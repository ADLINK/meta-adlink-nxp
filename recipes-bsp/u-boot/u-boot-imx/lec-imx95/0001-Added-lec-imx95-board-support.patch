From 3485a69b63fc47bedb54b62af47adb2240c56dec Mon Sep 17 00:00:00 2001
From: Dinesh kumar <dinesh.v@adlinktech.com>
Date: Mon, 11 Nov 2024 17:10:24 +0530
Subject: [PATCH] Added lec-imx95 board support

---
 arch/arm/mach-imx/imx9/Kconfig           |    5 +
 arch/arm/mach-imx/imx9/scmi/soc.c        |   40 +-
 board/adlink/common/Makefile             |   92 ++
 board/adlink/common/arm_sleep.c          |  130 +++
 board/adlink/common/cadmus.c             |   78 ++
 board/adlink/common/cadmus.h             |   37 +
 board/adlink/common/cds_pci_ft.c         |   18 +
 board/adlink/common/cds_via.c            |   96 ++
 board/adlink/common/cmd_esbc_validate.c  |   86 ++
 board/adlink/common/eeprom.h             |   33 +
 board/adlink/common/emc2305.c            |   62 ++
 board/adlink/common/emc2305.h            |   22 +
 board/adlink/common/epdc_setup.c         |  225 +++++
 board/adlink/common/fman.c               |   89 ++
 board/adlink/common/fman.h               |   14 +
 board/adlink/common/fsl_chain_of_trust.c |  160 ++++
 board/adlink/common/fsl_validate.c       |  975 ++++++++++++++++++++
 board/adlink/common/i2c_common.c         |   34 +
 board/adlink/common/i2c_common.h         |   30 +
 board/adlink/common/i2c_mux.c            |   62 ++
 board/adlink/common/i2c_mux.h            |   16 +
 board/adlink/common/ics307_clk.c         |  149 +++
 board/adlink/common/ics307_clk.h         |   14 +
 board/adlink/common/ls102xa_stream_id.c  |   35 +
 board/adlink/common/mc34vr500.c          |   95 ++
 board/adlink/common/mmc.c                |   49 +
 board/adlink/common/mpc85xx_sleep.c      |   97 ++
 board/adlink/common/ngpixis.c            |  248 +++++
 board/adlink/common/ngpixis.h            |   60 ++
 board/adlink/common/ns_access.c          |  241 +++++
 board/adlink/common/p_corenet/Makefile   |    7 +
 board/adlink/common/p_corenet/law.c      |   36 +
 board/adlink/common/p_corenet/tlb.c      |  160 ++++
 board/adlink/common/pfuze.c              |  173 ++++
 board/adlink/common/pfuze.h              |   17 +
 board/adlink/common/qixis.c              |  388 ++++++++
 board/adlink/common/qixis.h              |  190 ++++
 board/adlink/common/qsfp_eeprom.c        |   90 ++
 board/adlink/common/qsfp_eeprom.h        |   14 +
 board/adlink/common/qspi_header          |  128 +++
 board/adlink/common/recovery_keypad.c    |   60 ++
 board/adlink/common/recovery_keypad.h    |   13 +
 board/adlink/common/sdhc_boot.c          |   79 ++
 board/adlink/common/sgmii_riser.h        |   16 +
 board/adlink/common/sleep.h              |   20 +
 board/adlink/common/spl.h                |   12 +
 board/adlink/common/sys_eeprom.c         |  649 +++++++++++++
 board/adlink/common/tcpc.c               | 1069 ++++++++++++++++++++++
 board/adlink/common/tcpc.h               |  472 ++++++++++
 board/adlink/common/via.h                |   18 +
 board/adlink/common/vid.c                |  796 ++++++++++++++++
 board/adlink/common/vid.h                |   75 ++
 board/adlink/common/vsc3316_3308.h       |   23 +
 board/adlink/lec_imx95/Kconfig           |   12 +
 board/adlink/lec_imx95/Makefile          |   11 +
 board/adlink/lec_imx95/lec_imx95.c       |  610 ++++++++++++
 board/adlink/lec_imx95/spl.c             |  162 ++++
 drivers/usb/dwc3/gadget.c                |    8 +
 include/configs/lec_imx95.h              |  226 +++++
 59 files changed, 8822 insertions(+), 4 deletions(-)
 create mode 100644 board/adlink/common/Makefile
 create mode 100644 board/adlink/common/arm_sleep.c
 create mode 100644 board/adlink/common/cadmus.c
 create mode 100644 board/adlink/common/cadmus.h
 create mode 100644 board/adlink/common/cds_pci_ft.c
 create mode 100644 board/adlink/common/cds_via.c
 create mode 100644 board/adlink/common/cmd_esbc_validate.c
 create mode 100644 board/adlink/common/eeprom.h
 create mode 100644 board/adlink/common/emc2305.c
 create mode 100644 board/adlink/common/emc2305.h
 create mode 100644 board/adlink/common/epdc_setup.c
 create mode 100644 board/adlink/common/fman.c
 create mode 100644 board/adlink/common/fman.h
 create mode 100644 board/adlink/common/fsl_chain_of_trust.c
 create mode 100644 board/adlink/common/fsl_validate.c
 create mode 100644 board/adlink/common/i2c_common.c
 create mode 100644 board/adlink/common/i2c_common.h
 create mode 100644 board/adlink/common/i2c_mux.c
 create mode 100644 board/adlink/common/i2c_mux.h
 create mode 100644 board/adlink/common/ics307_clk.c
 create mode 100644 board/adlink/common/ics307_clk.h
 create mode 100644 board/adlink/common/ls102xa_stream_id.c
 create mode 100644 board/adlink/common/mc34vr500.c
 create mode 100644 board/adlink/common/mmc.c
 create mode 100644 board/adlink/common/mpc85xx_sleep.c
 create mode 100644 board/adlink/common/ngpixis.c
 create mode 100644 board/adlink/common/ngpixis.h
 create mode 100644 board/adlink/common/ns_access.c
 create mode 100644 board/adlink/common/p_corenet/Makefile
 create mode 100644 board/adlink/common/p_corenet/law.c
 create mode 100644 board/adlink/common/p_corenet/tlb.c
 create mode 100644 board/adlink/common/pfuze.c
 create mode 100644 board/adlink/common/pfuze.h
 create mode 100644 board/adlink/common/qixis.c
 create mode 100644 board/adlink/common/qixis.h
 create mode 100644 board/adlink/common/qsfp_eeprom.c
 create mode 100644 board/adlink/common/qsfp_eeprom.h
 create mode 100644 board/adlink/common/qspi_header
 create mode 100644 board/adlink/common/recovery_keypad.c
 create mode 100644 board/adlink/common/recovery_keypad.h
 create mode 100644 board/adlink/common/sdhc_boot.c
 create mode 100644 board/adlink/common/sgmii_riser.h
 create mode 100644 board/adlink/common/sleep.h
 create mode 100644 board/adlink/common/spl.h
 create mode 100644 board/adlink/common/sys_eeprom.c
 create mode 100644 board/adlink/common/tcpc.c
 create mode 100644 board/adlink/common/tcpc.h
 create mode 100644 board/adlink/common/via.h
 create mode 100644 board/adlink/common/vid.c
 create mode 100644 board/adlink/common/vid.h
 create mode 100644 board/adlink/common/vsc3316_3308.h
 create mode 100644 board/adlink/lec_imx95/Kconfig
 create mode 100644 board/adlink/lec_imx95/Makefile
 create mode 100644 board/adlink/lec_imx95/lec_imx95.c
 create mode 100644 board/adlink/lec_imx95/spl.c
 create mode 100755 include/configs/lec_imx95.h

diff --git a/arch/arm/mach-imx/imx9/Kconfig b/arch/arm/mach-imx/imx9/Kconfig
index 1f78b1b6a31..b51f22fbed2 100644
--- a/arch/arm/mach-imx/imx9/Kconfig
+++ b/arch/arm/mach-imx/imx9/Kconfig
@@ -72,6 +72,10 @@ config TARGET_IMX95_19X19_EVK
 	bool "imx95_19x19_evk"
 	select IMX95
 
+config TARGET_LEC_IMX95
+	bool "lec_imx95"
+	select IMX95
+
 config TARGET_VERDIN_IMX95_19X19
 	bool "imx95_verdin_evk"
 	select IMX95
@@ -89,6 +93,7 @@ source "board/phytec/phycore_imx93/Kconfig"
 source "board/variscite/imx93_var_som/Kconfig"
 source "board/freescale/imx93_qsb/Kconfig"
 source "board/freescale/imx95_evk/Kconfig"
+source "board/adlink/lec_imx95/Kconfig"
 source "board/toradex/verdin-imx95/Kconfig"
 
 endif
diff --git a/arch/arm/mach-imx/imx9/scmi/soc.c b/arch/arm/mach-imx/imx9/scmi/soc.c
index b16fb0e866f..a6a649a3a3b 100644
--- a/arch/arm/mach-imx/imx9/scmi/soc.c
+++ b/arch/arm/mach-imx/imx9/scmi/soc.c
@@ -49,6 +49,13 @@
 #include <mmc.h>
 #include <kaslr.h>
 
+#define PDIR (0x50)
+#define SKU_CFG_DDR_2G	0x01
+#define SKU_CFG_DDR_4G	0x02
+#define SKU_CFG_DDR_8G	0x03
+#define SKU_CFG_DDR_16G	0x04
+
+u64 phys_sdram_size=PHYS_SDRAM_SIZE,phys_sdram_2_size=PHYS_SDRAM_2_SIZE;
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -493,7 +500,7 @@ phys_size_t get_effective_memsize(void)
 
 		return sdram_b1_size;
 	} else {
-		return PHYS_SDRAM_SIZE;
+		return phys_sdram_size;
 	}
 }
 
@@ -1105,12 +1112,37 @@ ulong h_spl_load_read(struct spl_load_info *load, ulong off,
 	lbaint_t sector = off >> bd->log2blksz;
 	lbaint_t count = size >> bd->log2blksz;
 	ulong trampoline_sz = SZ_16M;
-	void *trampoline = (void *)((ulong)CFG_SYS_SDRAM_BASE + PHYS_SDRAM_SIZE - trampoline_sz);
-	ulong ns_ddr_end = CFG_SYS_SDRAM_BASE + PHYS_SDRAM_SIZE;
+	void *trampoline;
+	ulong ns_ddr_end;
 	ulong read_count, trampoline_cnt = trampoline_sz >> bd->log2blksz, actual, total;
+	ulong sku_cfg = ((readl(GPIO5_BASE_ADDR + PDIR) & 0x70)>>4); //GPIO5_IO_BIT(4~6)
+
+	if(sku_cfg==SKU_CFG_DDR_2G) //LEC-iMX95 2GB_MT62F1G16D1DS-023 2GB
+	{
+		phys_sdram_size = 0x70000000;		//2GB  - 256MB DDR 
+		phys_sdram_2_size = 0;		//0GB
+	}
+	else if(sku_cfg==SKU_CFG_DDR_4G) //LEC-iMX95 MT62F1G32D2DS-023 IT:C 4GB
+	{
+		phys_sdram_size = 0x70000000;		//2GB  - 256MB DDR 
+		phys_sdram_2_size = 0x80000000;		//2GB
+	}
+	else if(sku_cfg==SKU_CFG_DDR_8G) //LEC-iMX95 8GB_MT62F2G32D4DS-023 8GB
+	{
+		phys_sdram_size = 0x70000000;		//2GB  - 256MB DDR 
+		phys_sdram_2_size = 0x180000000;	//6GB
+	}
+	else if(sku_cfg==SKU_CFG_DDR_16G) //LEC-iMX95 16G_MT62F4G32D8DV-023 16GB
+	{
+		phys_sdram_size = 0x70000000;		//2GB  - 256MB DDR 
+		phys_sdram_2_size = 0x380000000;	//14GB
+	}
+
+	trampoline = (void *)((ulong)CFG_SYS_SDRAM_BASE + phys_sdram_size - trampoline_sz);
+	ns_ddr_end = CFG_SYS_SDRAM_BASE + phys_sdram_size;
 
 #ifdef PHYS_SDRAM_2_SIZE
-	ns_ddr_end += PHYS_SDRAM_2_SIZE;
+	ns_ddr_end += phys_sdram_2_size;
 #endif
 
 	/* Check if the buf is in non-secure world, otherwise copy from trampoline */
diff --git a/board/adlink/common/Makefile b/board/adlink/common/Makefile
new file mode 100644
index 00000000000..62e3abed4b0
--- /dev/null
+++ b/board/adlink/common/Makefile
@@ -0,0 +1,92 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+
+MINIMAL=
+
+ifdef CONFIG_SPL_BUILD
+ifndef CONFIG_TPL_BUILD
+ifdef CONFIG_SPL_INIT_MINIMAL
+MINIMAL=y
+endif
+endif
+endif
+
+ifdef MINIMAL
+# necessary to create built-in.o
+obj- := __dummy__.o
+else
+# include i2c_common.o once if either VID or FSL_USE_PCA9547_MUX
+I2C_COMMON=
+ifdef CONFIG_VID
+I2C_COMMON=y
+endif
+ifdef CONFIG_FSL_USE_PCA9547_MUX
+I2C_COMMON=y
+endif
+
+obj-$(CONFIG_FSL_CADMUS)	+= cadmus.o
+obj-$(CONFIG_FSL_VIA)		+= cds_via.o
+obj-$(CONFIG_FMAN_ENET)	+= fman.o
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_FSL_NGPIXIS)	+= ngpixis.o
+endif
+obj-$(I2C_COMMON)		+= i2c_common.o
+obj-$(CONFIG_FSL_USE_PCA9547_MUX)		+= i2c_mux.o
+obj-$(CONFIG_$(SPL_)VID)	+= vid.o
+obj-$(CONFIG_FSL_QIXIS)	+= qixis.o
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_ID_EEPROM)	+= sys_eeprom.o
+endif
+ifndef CONFIG_RAMBOOT_PBL
+obj-$(CONFIG_FSL_FIXED_MMC_LOCATION)	+= sdhc_boot.o
+endif
+
+ifdef CONFIG_ARM
+obj-$(CONFIG_DEEP_SLEEP)		+= arm_sleep.o
+else
+obj-$(CONFIG_DEEP_SLEEP)		+= mpc85xx_sleep.o
+endif
+
+obj-$(CONFIG_TARGET_MPC8548CDS)	+= cds_pci_ft.o
+
+obj-$(CONFIG_TARGET_P3041DS)		+= ics307_clk.o
+obj-$(CONFIG_TARGET_P4080DS)		+= ics307_clk.o
+obj-$(CONFIG_TARGET_P5040DS)		+= ics307_clk.o
+ifeq ($(CONFIG_$(SPL_)POWER_LEGACY),y)
+obj-$(CONFIG_POWER_PFUZE100)	+= pfuze.o
+endif
+obj-$(CONFIG_DM_PMIC_PFUZE100)	+= pfuze.o
+obj-$(CONFIG_POWER_MC34VR500)	+= mc34vr500.o
+ifneq (,$(filter $(SOC), mx6 mx7 mx7ulp imx8 imx8m imx8ulp imx9))
+obj-y				+= mmc.o
+endif
+obj-$(CONFIG_MXC_EPDC)		+= epdc_setup.o
+ifdef CONFIG_FSL_FASTBOOT
+obj-${CONFIG_ANDROID_RECOVERY} += recovery_keypad.o
+endif
+
+obj-$(CONFIG_LS102XA_STREAM_ID)	+= ls102xa_stream_id.o
+
+obj-$(CONFIG_EMC2305)              += emc2305.o
+obj-$(CONFIG_QSFP_EEPROM)	+= qsfp_eeprom.o
+
+# deal with common files for P-series corenet based devices
+obj-$(CONFIG_TARGET_P2041RDB)	+= p_corenet/
+obj-$(CONFIG_TARGET_P3041DS)	+= p_corenet/
+obj-$(CONFIG_TARGET_P4080DS)	+= p_corenet/
+obj-$(CONFIG_TARGET_P5040DS)	+= p_corenet/
+
+obj-$(CONFIG_LAYERSCAPE_NS_ACCESS)	+= ns_access.o
+
+ifdef CONFIG_NXP_ESBC
+obj-$(CONFIG_CMD_ESBC_VALIDATE) += fsl_validate.o cmd_esbc_validate.o
+endif
+obj-$(CONFIG_CHAIN_OF_TRUST) += fsl_chain_of_trust.o
+
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_USB_TCPC) += tcpc.o
+endif
+
+endif
diff --git a/board/adlink/common/arm_sleep.c b/board/adlink/common/arm_sleep.c
new file mode 100644
index 00000000000..228f07502f7
--- /dev/null
+++ b/board/adlink/common/arm_sleep.c
@@ -0,0 +1,130 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ */
+
+#include <log.h>
+#include <asm/global_data.h>
+#include <asm/io.h>
+#ifndef CONFIG_ARMV7_NONSEC
+#error " Deep sleep needs non-secure mode support. "
+#else
+#include <asm/secure.h>
+#endif
+#include <asm/armv7.h>
+
+#if defined(CONFIG_ARCH_LS1021A)
+#include <asm/arch/immap_ls102xa.h>
+#endif
+
+#include "sleep.h"
+#ifdef CONFIG_U_QE
+#include <fsl_qe.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void __weak board_mem_sleep_setup(void)
+{
+}
+
+void __weak board_sleep_prepare(void)
+{
+}
+
+bool is_warm_boot(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)CFG_SYS_FSL_GUTS_ADDR;
+
+	if (in_be32(&gur->crstsr) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_disable_console(void)
+{
+	gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+}
+
+/*
+ * When wakeup from deep sleep, the first 128 bytes space
+ * will be used to do DDR training which corrupts the data
+ * in there. This function will restore them.
+ */
+static void dp_ddr_restore(void)
+{
+	u64 *src, *dst;
+	int i;
+	struct ccsr_scfg __iomem *scfg = (void *)CFG_SYS_FSL_SCFG_ADDR;
+
+	/* get the address of ddr date from SPARECR3 */
+	src = (u64 *)in_le32(&scfg->sparecr[2]);
+	dst = (u64 *)CFG_SYS_SDRAM_BASE;
+
+	for (i = 0; i < DDR_BUFF_LEN / 8; i++)
+		*dst++ = *src++;
+}
+
+#if defined(CONFIG_ARMV7_PSCI) && defined(CONFIG_ARCH_LS1021A)
+void ls1_psci_resume_fixup(void)
+{
+	u32 tmp;
+	struct ccsr_scfg __iomem *scfg = (void *)CFG_SYS_FSL_SCFG_ADDR;
+
+#ifdef QIXIS_BASE
+	void *qixis_base = (void *)QIXIS_BASE;
+
+	/* Pull on PCIe RST# */
+	out_8(qixis_base + QIXIS_RST_FORCE_3, 0);
+
+	/* disable deep sleep signals in FPGA */
+	tmp = in_8(qixis_base + QIXIS_PWR_CTL2);
+	tmp &= ~QIXIS_PWR_CTL2_PCTL;
+	out_8(qixis_base + QIXIS_PWR_CTL2, tmp);
+#endif
+
+	/* Disable wakeup interrupt during deep sleep */
+	out_be32(&scfg->pmcintecr, 0);
+	/* Clear PMC interrupt status */
+	out_be32(&scfg->pmcintsr, 0xffffffff);
+
+	/* Disable Warm Device Reset */
+	tmp = in_be32(&scfg->dpslpcr);
+	tmp &= ~SCFG_DPSLPCR_WDRR_EN;
+	out_be32(&scfg->dpslpcr, tmp);
+}
+#endif
+
+static void dp_resume_prepare(void)
+{
+	dp_ddr_restore();
+	board_sleep_prepare();
+	armv7_init_nonsec();
+#ifdef CONFIG_U_QE
+	u_qe_resume();
+#endif
+#if defined(CONFIG_ARMV7_PSCI) && defined(CONFIG_ARCH_LS1021A)
+	ls1_psci_resume_fixup();
+#endif
+}
+
+int fsl_dp_resume(void)
+{
+	u32 start_addr;
+	void (*kernel_resume)(void);
+	struct ccsr_scfg __iomem *scfg = (void *)CFG_SYS_FSL_SCFG_ADDR;
+
+	if (!is_warm_boot())
+		return 0;
+
+	dp_resume_prepare();
+
+	/* Get the entry address and jump to kernel */
+	start_addr = in_le32(&scfg->sparecr[3]);
+	debug("Entry address is 0x%08x\n", start_addr);
+	kernel_resume = (void (*)(void))start_addr;
+	secure_ram_addr(_do_nonsec_entry)(kernel_resume, 0, 0, 0);
+
+	return 0;
+}
diff --git a/board/adlink/common/cadmus.c b/board/adlink/common/cadmus.c
new file mode 100644
index 00000000000..e7e07fff86c
--- /dev/null
+++ b/board/adlink/common/cadmus.c
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2004, 2011 Freescale Semiconductor.
+ */
+
+
+#include <common.h>
+#include <clock_legacy.h>
+
+/*
+ * CADMUS Board System Registers
+ */
+#ifndef CFG_SYS_CADMUS_BASE_REG
+#define CFG_SYS_CADMUS_BASE_REG	(CADMUS_BASE_ADDR + 0x4000)
+#endif
+
+typedef struct cadmus_reg {
+    u_char cm_ver;		/* Board version */
+    u_char cm_csr;		/* General control/status */
+    u_char cm_rst;		/* Reset control */
+    u_char cm_hsclk;		/* High speed clock */
+    u_char cm_hsxclk;		/* High speed clock extended */
+    u_char cm_led;		/* LED data */
+    u_char cm_pci;		/* PCI control/status */
+    u_char cm_dma;		/* DMA control */
+    u_char cm_reserved[248];	/* Total 256 bytes */
+} cadmus_reg_t;
+
+
+unsigned int
+get_board_version(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_SYS_CADMUS_BASE_REG;
+
+	return cadmus->cm_ver;
+}
+
+
+unsigned long
+get_board_sys_clk(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_SYS_CADMUS_BASE_REG;
+
+	uint pci1_speed = (cadmus->cm_pci >> 2) & 0x3; /* PSPEED in [4:5] */
+
+	if (pci1_speed == 0) {
+		return 33333333;
+	} else if (pci1_speed == 1) {
+		return 66666666;
+	} else {
+		/* Really, unknown. Be safe? */
+		return 33333333;
+	}
+}
+
+
+unsigned int
+get_pci_slot(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_SYS_CADMUS_BASE_REG;
+
+	/*
+	 * PCI slot in USER bits CSR[6:7] by convention.
+	 */
+	return ((cadmus->cm_csr >> 6) & 0x3) + 1;
+}
+
+
+unsigned int
+get_pci_dual(void)
+{
+	volatile cadmus_reg_t *cadmus = (cadmus_reg_t *)CFG_SYS_CADMUS_BASE_REG;
+
+	/*
+	 * PCI DUAL in CM_PCI[3]
+	 */
+	return cadmus->cm_pci & 0x10;
+}
diff --git a/board/adlink/common/cadmus.h b/board/adlink/common/cadmus.h
new file mode 100644
index 00000000000..fb74e8f6db5
--- /dev/null
+++ b/board/adlink/common/cadmus.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ */
+
+#ifndef __CADMUS_H_
+#define __CADMUS_H_
+
+
+/*
+ * CADMUS Board System Register interface.
+ */
+
+/*
+ * Returns board version register.
+ */
+extern unsigned int get_board_version(void);
+
+/*
+ * Returns either 33000000 or 66000000 as the SYS_CLK_FREQ.
+ */
+extern unsigned long get_board_sys_clk(void);
+
+
+/*
+ * Returns 1 - 4, as found in the USER CSR[6:7] bits.
+ */
+extern unsigned int get_pci_slot(void);
+
+
+/*
+ * Returns PCI DUAL as found in CM_PCI[3].
+ */
+extern unsigned int get_pci_dual(void);
+
+
+#endif	/* __CADMUS_H_ */
diff --git a/board/adlink/common/cds_pci_ft.c b/board/adlink/common/cds_pci_ft.c
new file mode 100644
index 00000000000..dc2d62850d1
--- /dev/null
+++ b/board/adlink/common/cds_pci_ft.c
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ */
+
+#include <common.h>
+#include <linux/libfdt.h>
+#include <fdt_support.h>
+#include "cadmus.h"
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	ft_cpu_setup(blob, bd);
+
+	return 0;
+}
+#endif
diff --git a/board/adlink/common/cds_via.c b/board/adlink/common/cds_via.c
new file mode 100644
index 00000000000..6184472b165
--- /dev/null
+++ b/board/adlink/common/cds_via.c
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2006 Freescale Semiconductor.
+ */
+
+#include <common.h>
+#include <pci.h>
+
+/* Config the VIA chip */
+void mpc85xx_config_via(struct pci_controller *hose,
+			pci_dev_t dev, struct pci_config_table *tab)
+{
+	pci_dev_t bridge;
+	unsigned int cmdstat;
+
+	/* Enable USB and IDE functions */
+	pci_hose_write_config_byte(hose, dev, 0x48, 0x08);
+
+	pci_hose_read_config_dword(hose, dev, PCI_COMMAND, &cmdstat);
+	cmdstat |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY| PCI_COMMAND_MASTER;
+	pci_hose_write_config_dword(hose, dev, PCI_COMMAND, cmdstat);
+	pci_hose_write_config_byte(hose, dev, PCI_CACHE_LINE_SIZE, 0x08);
+	pci_hose_write_config_byte(hose, dev, PCI_LATENCY_TIMER, 0x80);
+
+	/*
+	 * Force the backplane P2P bridge to have a window
+	 * open from 0x00000000-0x00001fff in PCI I/O space.
+	 * This allows legacy I/O (i8259, etc) on the VIA
+	 * southbridge to be accessed.
+	 */
+#ifdef CONFIG_TARGET_MPC8548CDS_LEGACY
+	bridge = PCI_BDF(0, 17, 0);
+#else
+	bridge = PCI_BDF(0, 28, 0);
+#endif
+	pci_hose_write_config_byte(hose, bridge, PCI_IO_BASE, 0);
+	pci_hose_write_config_word(hose, bridge, PCI_IO_BASE_UPPER16, 0);
+	pci_hose_write_config_byte(hose, bridge, PCI_IO_LIMIT, 0x10);
+	pci_hose_write_config_word(hose, bridge, PCI_IO_LIMIT_UPPER16, 0);
+}
+
+/* Function 1, IDE */
+void mpc85xx_config_via_usbide(struct pci_controller *hose,
+			       pci_dev_t dev, struct pci_config_table *tab)
+{
+	pciauto_config_device(hose, dev);
+	/*
+	 * Since the P2P window was forced to cover the fixed
+	 * legacy I/O addresses, it is necessary to manually
+	 * place the base addresses for the IDE and USB functions
+	 * within this window.
+	 */
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_0, 0x1ff8);
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_1, 0x1ff4);
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_2, 0x1fe8);
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_3, 0x1fe4);
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_4, 0x1fd0);
+}
+
+/* Function 2, USB ports 0-1 */
+void mpc85xx_config_via_usb(struct pci_controller *hose,
+			    pci_dev_t dev, struct pci_config_table *tab)
+{
+	pciauto_config_device(hose, dev);
+
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_4, 0x1fa0);
+}
+
+/* Function 3, USB ports 2-3 */
+void mpc85xx_config_via_usb2(struct pci_controller *hose,
+			     pci_dev_t dev, struct pci_config_table *tab)
+{
+	pciauto_config_device(hose, dev);
+
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_4, 0x1f80);
+}
+
+/* Function 5, Power Management */
+void mpc85xx_config_via_power(struct pci_controller *hose,
+			      pci_dev_t dev, struct pci_config_table *tab)
+{
+	pciauto_config_device(hose, dev);
+
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_0, 0x1e00);
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_1, 0x1dfc);
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_2, 0x1df8);
+}
+
+/* Function 6, AC97 Interface */
+void mpc85xx_config_via_ac97(struct pci_controller *hose,
+			     pci_dev_t dev, struct pci_config_table *tab)
+{
+	pciauto_config_device(hose, dev);
+
+	pci_hose_write_config_dword(hose, dev, PCI_BASE_ADDRESS_0, 0x1c00);
+}
diff --git a/board/adlink/common/cmd_esbc_validate.c b/board/adlink/common/cmd_esbc_validate.c
new file mode 100644
index 00000000000..6c096266b48
--- /dev/null
+++ b/board/adlink/common/cmd_esbc_validate.c
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <env.h>
+#include <fsl_validate.h>
+
+int do_esbc_halt(struct cmd_tbl *cmdtp, int flag, int argc,
+		 char *const argv[])
+{
+	if (fsl_check_boot_mode_secure() == 0) {
+		printf("Boot Mode is Non-Secure. Not entering spin loop.\n");
+		return 0;
+	}
+
+	printf("Core is entering spin loop.\n");
+loop:
+	goto loop;
+
+	return 0;
+}
+
+#ifndef CONFIG_SPL_BUILD
+static int do_esbc_validate(struct cmd_tbl *cmdtp, int flag, int argc,
+			    char *const argv[])
+{
+	char *hash_str = NULL;
+	uintptr_t haddr;
+	int ret;
+	uintptr_t img_addr = 0;
+	char buf[20];
+
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+	else if (argc > 2)
+		/* Second arg - Optional - Hash Str*/
+		hash_str = argv[2];
+
+	/* First argument - header address -32/64bit */
+	haddr = (uintptr_t)hextoul(argv[1], NULL);
+
+	/* With esbc_validate command, Image address must be
+	 * part of header. So, the function is called
+	 * by passing this argument as 0.
+	 */
+	ret = fsl_secboot_validate(haddr, hash_str, &img_addr);
+
+	/* Need to set "img_addr" even if validation failure.
+	 * Required when SB_EN in RCW set and non-fatal error
+	 * to continue U-Boot
+	 */
+	sprintf(buf, "%lx", img_addr);
+	env_set("img_addr", buf);
+
+	if (ret)
+		return 1;
+
+	printf("esbc_validate command successful\n");
+	return 0;
+}
+
+/***************************************************/
+static char esbc_validate_help_text[] =
+	"esbc_validate hdr_addr <hash_val> - Validates signature using\n"
+	"                          RSA verification\n"
+	"                          $hdr_addr Address of header of the image\n"
+	"                          to be validated.\n"
+	"                          $hash_val -Optional\n"
+	"                          It provides Hash of public/srk key to be\n"
+	"                          used to verify signature.\n";
+
+U_BOOT_CMD(
+	esbc_validate,	3,	0,	do_esbc_validate,
+	"Validates signature on a given image using RSA verification",
+	esbc_validate_help_text
+);
+
+U_BOOT_CMD(
+	esbc_halt,	1,	0,	do_esbc_halt,
+	"Put the core in spin loop (Secure Boot Only)",
+	""
+);
+#endif
diff --git a/board/adlink/common/eeprom.h b/board/adlink/common/eeprom.h
new file mode 100644
index 00000000000..328fd3974b1
--- /dev/null
+++ b/board/adlink/common/eeprom.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2004 Freescale Semiconductor.
+ */
+
+#ifndef __EEPROM_H_
+#define __EEPROM_H_
+
+
+/*
+ * EEPROM Board System Register interface.
+ */
+
+
+/*
+ * CPU Board Revision
+ */
+#define MPC85XX_CPU_BOARD_REV(maj, min)	((((maj)&0xff) << 8) | ((min) & 0xff))
+#define MPC85XX_CPU_BOARD_MAJOR(rev)	(((rev) >> 8) & 0xff)
+#define MPC85XX_CPU_BOARD_MINOR(rev)	((rev) & 0xff)
+
+#define MPC85XX_CPU_BOARD_REV_UNKNOWN	MPC85XX_CPU_BOARD_REV(0,0)
+#define MPC85XX_CPU_BOARD_REV_1_0	MPC85XX_CPU_BOARD_REV(1,0)
+#define MPC85XX_CPU_BOARD_REV_1_1	MPC85XX_CPU_BOARD_REV(1,1)
+
+/*
+ * Returns CPU board revision register as a 16-bit value with
+ * the Major in the high byte, and Minor in the low byte.
+ */
+extern unsigned int get_cpu_board_revision(void);
+
+
+#endif	/* __CADMUS_H_ */
diff --git a/board/adlink/common/emc2305.c b/board/adlink/common/emc2305.c
new file mode 100644
index 00000000000..9a75c5a09dd
--- /dev/null
+++ b/board/adlink/common/emc2305.c
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2018-2020 NXP.
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <asm/global_data.h>
+#include <asm/io.h>
+
+#include "emc2305.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void set_fan_speed(u8 data, int chip_addr)
+{
+	u8 index;
+	u8 Fan[NUM_OF_FANS] = {I2C_EMC2305_FAN1,
+			       I2C_EMC2305_FAN2,
+			       I2C_EMC2305_FAN3,
+			       I2C_EMC2305_FAN4,
+			       I2C_EMC2305_FAN5};
+
+	for (index = 0; index < NUM_OF_FANS; index++) {
+#if !CONFIG_IS_ENABLED(DM_I2C)
+		if (i2c_write(chip_addr, Fan[index], 1, &data, 1) != 0) {
+			printf("Error: failed to change fan speed @%x\n",
+			       Fan[index]);
+		}
+#else
+		struct udevice *dev;
+
+		if (i2c_get_chip_for_busnum(0, chip_addr, 1, &dev))
+			continue;
+
+		if (dm_i2c_write(dev, Fan[index], &data, 1) != 0) {
+			printf("Error: failed to change fan speed @%x\n",
+			       Fan[index]);
+		}
+#endif
+	}
+}
+
+void emc2305_init(int chip_addr)
+{
+	u8 data;
+
+	data = I2C_EMC2305_CMD;
+#if !CONFIG_IS_ENABLED(DM_I2C)
+	if (i2c_write(chip_addr, I2C_EMC2305_CONF, 1, &data, 1) != 0)
+		printf("Error: failed to configure EMC2305\n");
+#else
+	struct udevice *dev;
+
+	if (!i2c_get_chip_for_busnum(0, chip_addr, 1, &dev))
+		if (dm_i2c_write(dev, I2C_EMC2305_CONF, &data, 1))
+			printf("Error: failed to configure EMC2305\n");
+#endif
+
+}
diff --git a/board/adlink/common/emc2305.h b/board/adlink/common/emc2305.h
new file mode 100644
index 00000000000..24c5410d120
--- /dev/null
+++ b/board/adlink/common/emc2305.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2018-2020 NXP
+ *
+ */
+
+#ifndef __EMC2305_H_
+#define __EMC2305_H_
+
+#define I2C_EMC2305_CONF		0x20
+#define I2C_EMC2305_FAN1		0x30
+#define I2C_EMC2305_FAN2		0x40
+#define I2C_EMC2305_FAN3		0x50
+#define I2C_EMC2305_FAN4		0x60
+#define I2C_EMC2305_FAN5		0x70
+
+#define NUM_OF_FANS			5
+
+void emc2305_init(int chip_addr);
+void set_fan_speed(u8 data, int chip_addr);
+
+#endif  /* __EMC2305_H_ */
diff --git a/board/adlink/common/epdc_setup.c b/board/adlink/common/epdc_setup.c
new file mode 100644
index 00000000000..4126da729f2
--- /dev/null
+++ b/board/adlink/common/epdc_setup.c
@@ -0,0 +1,225 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Peng Fan <Peng.Fan@freescale.com>
+ */
+#include <common.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include <malloc.h>
+#include <mxc_epdc_fb.h>
+#include <fs.h>
+#include <cpu_func.h>
+#include <env.h>
+#include <asm/cache.h>
+
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
+__weak int mmc_get_env_devno(void)
+{
+	return 0;
+}
+__weak int check_mmc_autodetect(void)
+{
+	return 0;
+}
+
+int board_setup_waveform_file(ulong waveform_buf)
+{
+	char *fs_argv[5];
+	char addr[17];
+	ulong file_len, mmc_dev;
+
+	if (!check_mmc_autodetect())
+		mmc_dev = env_get_ulong("mmcdev", 10, 0);
+	else
+		mmc_dev = mmc_get_env_devno();
+
+	sprintf(addr, "%lx", (ulong)CONFIG_SYS_LOAD_ADDR);
+
+	fs_argv[0] = "fatload";
+	fs_argv[1] = "mmc";
+	fs_argv[2] = simple_itoa(mmc_dev);
+	fs_argv[3] = addr;
+	fs_argv[4] = env_get("epdc_waveform");
+
+	if (!fs_argv[4])
+		fs_argv[4] = "epdc_splash.bin";
+
+	if (do_fat_fsload(NULL, 0, 5, fs_argv)) {
+		printf("File %s not found on MMC Device %lu!\n", fs_argv[4], mmc_dev);
+		return -1;
+	}
+
+	file_len = env_get_hex("filesize", 0);
+	if (!file_len)
+		return -1;
+
+	memcpy((void *)waveform_buf, (const void *)CONFIG_SYS_LOAD_ADDR, file_len);
+
+	flush_cache(waveform_buf, roundup(file_len, ARCH_DMA_MINALIGN));
+
+	return 0;
+}
+
+int board_setup_logo_file(void *display_buf)
+{
+	int logo_width, logo_height;
+	char *fs_argv[5];
+	char addr[17];
+	int array[3];
+	ulong file_len, mmc_dev;
+	char *buf, *s;
+	int arg = 0, val = 0, pos = 0;
+	int i, j, max_check_length;
+	int row, col, row_end, col_end;
+
+	if (!display_buf)
+		return -EINVAL;
+
+	/* Assume PGM header not exceeds 128 bytes */
+	max_check_length = 128;
+
+	if (!check_mmc_autodetect())
+		mmc_dev = env_get_ulong("mmcdev", 10, 0);
+	else
+		mmc_dev = mmc_get_env_devno();
+
+	memset(display_buf, 0xFF, panel_info.vl_col * panel_info.vl_row);
+
+	fs_argv[0] = "fatsize";
+	fs_argv[1] = "mmc";
+	fs_argv[2] = simple_itoa(mmc_dev);
+	fs_argv[3] = env_get("epdc_logo");
+	if (!fs_argv[3])
+		fs_argv[3] = "epdc_logo.pgm";
+	if (do_fat_size(NULL, 0, 4, fs_argv)) {
+		debug("File %s not found on MMC Device %lu, use black border\n", fs_argv[3], mmc_dev);
+		/* Draw black border around framebuffer*/
+		memset(display_buf, 0x0, 24 * panel_info.vl_col);
+		for (i = 24; i < (panel_info.vl_row - 24); i++) {
+			memset((u8 *)display_buf + i * panel_info.vl_col,
+			       0x00, 24);
+			memset((u8 *)display_buf + i * panel_info.vl_col
+				+ panel_info.vl_col - 24, 0x00, 24);
+		}
+		memset((u8 *)display_buf +
+		       panel_info.vl_col * (panel_info.vl_row - 24),
+		       0x00, 24 * panel_info.vl_col);
+		return 0;
+	}
+
+	file_len = env_get_hex("filesize", 0);
+	if (!file_len)
+		return -EINVAL;
+
+	buf = memalign(ARCH_DMA_MINALIGN, file_len);
+	if (!buf)
+		return -ENOMEM;
+
+	sprintf(addr, "%lx", (ulong)CONFIG_SYS_LOAD_ADDR);
+
+	fs_argv[0] = "fatload";
+	fs_argv[1] = "mmc";
+	fs_argv[2] = simple_itoa(mmc_dev);
+	fs_argv[3] = addr;
+	fs_argv[4] = env_get("epdc_logo");
+
+	if (!fs_argv[4])
+		fs_argv[4] = "epdc_logo.pgm";
+
+	if (do_fat_fsload(NULL, 0, 5, fs_argv)) {
+		printf("File %s not found on MMC Device %lu!\n", fs_argv[4], mmc_dev);
+		free(buf);
+		return -1;
+	}
+
+	memcpy((void *)buf, (const void *)CONFIG_SYS_LOAD_ADDR, file_len);
+
+	if (strncmp(buf, "P5", 2)) {
+		printf("Wrong format for epdc logo, use PGM-P5 format.\n");
+		free(buf);
+		return -EINVAL;
+	}
+	/* Skip P5\n */
+	pos += 3;
+	arg = 0;
+	for (i = 3; i < max_check_length; ) {
+		/* skip \n \t and space */
+		if ((buf[i] == '\n') || (buf[i] == '\t') || (buf[i] == ' ')) {
+			i++;
+			continue;
+		}
+		/* skip comment */
+		if (buf[i] == '#') {
+			while (buf[i++] != '\n')
+				;
+			continue;
+		}
+
+		/* HEIGTH, WIDTH, MAX PIXEL VLAUE total 3 args */
+		if (arg > 2)
+			break;
+		val = 0;
+		while (is_digit(buf[i])) {
+			val = val * 10 + buf[i] - '0';
+			i++;
+		}
+		array[arg++] = val;
+
+		i++;
+	}
+
+	/* Point to data area */
+	pos = i;
+
+	logo_width = array[0];
+	logo_height = array[1];
+
+	if ((logo_width > panel_info.vl_col) ||
+	    (logo_height > panel_info.vl_row)) {
+		printf("Picture: too big\n");
+		free(buf);
+		return -EINVAL;
+	}
+
+	/* m,m means center of screen */
+	row = 0;
+	col = 0;
+	s = env_get("splashpos");
+	if (s) {
+		if (s[0] == 'm')
+			col = (panel_info.vl_col  - logo_width) >> 1;
+		else
+			col = simple_strtol(s, NULL, 0);
+		s = strchr(s + 1, ',');
+		if (s != NULL) {
+			if (s[1] == 'm')
+				row = (panel_info.vl_row  - logo_height) >> 1;
+			else
+				row = simple_strtol(s + 1, NULL, 0);
+		}
+	}
+	if ((col + logo_width > panel_info.vl_col) ||
+	    (row + logo_height > panel_info.vl_row)) {
+		printf("Incorrect pos, use (0, 0)\n");
+		row = 0;
+		col = 0;
+	}
+
+	/* Draw picture at the center of screen */
+	row_end = row + logo_height;
+	col_end = col + logo_width;
+	for (i = row; i < row_end; i++) {
+		for (j = col; j < col_end; j++) {
+			*((u8 *)display_buf + i * (panel_info.vl_col) + j) =
+				 buf[pos++];
+		}
+	}
+
+	free(buf);
+
+	flush_cache((ulong)display_buf, file_len - pos - 1);
+
+	return 0;
+}
diff --git a/board/adlink/common/fman.c b/board/adlink/common/fman.c
new file mode 100644
index 00000000000..358303108d8
--- /dev/null
+++ b/board/adlink/common/fman.c
@@ -0,0 +1,89 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2011-2015 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <linux/libfdt.h>
+#include <linux/libfdt_env.h>
+#include <fdt_support.h>
+
+#include <fm_eth.h>
+#ifdef CONFIG_FSL_LAYERSCAPE
+#include <asm/arch/fsl_serdes.h>
+#else
+#include <asm/fsl_serdes.h>
+#endif
+
+/*
+ * Given the following ...
+ *
+ * 1) A pointer to an Fman Ethernet node (as identified by the 'compat'
+ * compatible string and 'addr' physical address)
+ *
+ * 2) The name of an alias that points to the ethernet-phy node (usually inside
+ * a virtual MDIO node)
+ *
+ * ... update that Ethernet node's phy-handle property to point to the
+ * ethernet-phy node.  This is how we link an Ethernet node to its PHY, so each
+ * PHY in a virtual MDIO node must have an alias.
+ *
+ * Returns 0 on success, or a negative FDT error code on error.
+ */
+int fdt_set_phy_handle(void *fdt, char *compat, phys_addr_t addr,
+			const char *alias)
+{
+	int offset;
+	unsigned int ph;
+	const char *path;
+
+	/* Get a path to the node that 'alias' points to */
+	path = fdt_get_alias(fdt, alias);
+	if (!path)
+		return -FDT_ERR_BADPATH;
+
+	/* Get the offset of that node */
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		return offset;
+
+	ph = fdt_create_phandle(fdt, offset);
+	if (!ph)
+		return -FDT_ERR_BADPHANDLE;
+
+	ph = cpu_to_fdt32(ph);
+
+	offset = fdt_node_offset_by_compat_reg(fdt, compat, addr);
+	if (offset < 0)
+		return offset;
+
+	return fdt_setprop(fdt, offset, "phy-handle", &ph, sizeof(ph));
+}
+
+/*
+ * Return the SerDes device enum for a given Fman port
+ *
+ * This function just maps the fm_port namespace to the srds_prtcl namespace.
+ */
+enum srds_prtcl serdes_device_from_fm_port(enum fm_port port)
+{
+	static const enum srds_prtcl srds_table[] = {
+		[FM1_DTSEC1] = SGMII_FM1_DTSEC1,
+		[FM1_DTSEC2] = SGMII_FM1_DTSEC2,
+		[FM1_DTSEC3] = SGMII_FM1_DTSEC3,
+		[FM1_DTSEC4] = SGMII_FM1_DTSEC4,
+		[FM1_DTSEC5] = SGMII_FM1_DTSEC5,
+		[FM1_10GEC1] = XAUI_FM1,
+		[FM2_DTSEC1] = SGMII_FM2_DTSEC1,
+		[FM2_DTSEC2] = SGMII_FM2_DTSEC2,
+		[FM2_DTSEC3] = SGMII_FM2_DTSEC3,
+		[FM2_DTSEC4] = SGMII_FM2_DTSEC4,
+		[FM2_DTSEC5] = SGMII_FM2_DTSEC5,
+		[FM2_10GEC1] = XAUI_FM2,
+	};
+
+	if ((port < FM1_DTSEC1) || (port > FM2_10GEC1))
+		return NONE;
+	else
+		return srds_table[port];
+}
diff --git a/board/adlink/common/fman.h b/board/adlink/common/fman.h
new file mode 100644
index 00000000000..16afc34b03e
--- /dev/null
+++ b/board/adlink/common/fman.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __FMAN_BOARD_HELPER__
+#define __FMAN_BOARD_HELPER__
+
+int fdt_set_phy_handle(void *fdt, char *compat, phys_addr_t addr,
+			const char *alias);
+
+enum srds_prtcl serdes_device_from_fm_port(enum fm_port port);
+
+#endif
diff --git a/board/adlink/common/fsl_chain_of_trust.c b/board/adlink/common/fsl_chain_of_trust.c
new file mode 100644
index 00000000000..87ed814d6a2
--- /dev/null
+++ b/board/adlink/common/fsl_chain_of_trust.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ * Copyright 2022 NXP
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <env.h>
+#include <init.h>
+#include <fsl_validate.h>
+#include <fsl_secboot_err.h>
+#include <fsl_sfp.h>
+#include <log.h>
+#include <dm/root.h>
+#include <asm/fsl_secure_boot.h>
+
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_FRAMEWORK)
+#include <spl.h>
+#endif
+
+#ifdef CONFIG_FSL_CORENET
+#include <asm/fsl_pamu.h>
+#endif
+
+#ifdef CONFIG_ARCH_LS1021A
+#include <asm/arch/immap_ls102xa.h>
+#endif
+
+#if defined(CONFIG_MPC85xx)
+#define CFG_DCFG_ADDR	CFG_SYS_MPC85xx_GUTS_ADDR
+#else
+#define CFG_DCFG_ADDR	CFG_SYS_FSL_GUTS_ADDR
+#endif
+
+#ifdef CONFIG_SYS_FSL_CCSR_GUR_LE
+#define gur_in32(a)       in_le32(a)
+#else
+#define gur_in32(a)       in_be32(a)
+#endif
+
+/* Check the Boot Mode. If Secure, return 1 else return 0 */
+int fsl_check_boot_mode_secure(void)
+{
+	uint32_t val;
+	struct ccsr_sfp_regs *sfp_regs = (void *)(CFG_SYS_SFP_ADDR);
+	struct ccsr_gur __iomem *gur = (void *)(CFG_DCFG_ADDR);
+
+	val = sfp_in32(&sfp_regs->ospr) & ITS_MASK;
+	if (val == ITS_MASK)
+		return 1;
+
+#if defined(CONFIG_FSL_CORENET) || !defined(CONFIG_MPC85xx)
+	/* For PBL based platforms check the SB_EN bit in RCWSR */
+	val = gur_in32(&gur->rcwsr[RCW_SB_EN_REG_INDEX - 1]) & RCW_SB_EN_MASK;
+	if (val == RCW_SB_EN_MASK)
+		return 1;
+#endif
+
+#if defined(CONFIG_MPC85xx) && !defined(CONFIG_FSL_CORENET)
+	/* For Non-PBL Platforms, check the Device Status register 2*/
+	val = gur_in32(&gur->pordevsr2) & MPC85xx_PORDEVSR2_SBC_MASK;
+	if (val != MPC85xx_PORDEVSR2_SBC_MASK)
+		return 1;
+
+#endif
+	return 0;
+}
+
+#ifndef CONFIG_SPL_BUILD
+int fsl_setenv_chain_of_trust(void)
+{
+	/* Check Boot Mode
+	 * If Boot Mode is Non-Secure, no changes are required
+	 */
+	if (fsl_check_boot_mode_secure() == 0)
+		return 0;
+
+	/* If Boot mode is Secure, set the environment variables
+	 * bootdelay = 0 (To disable Boot Prompt)
+	 * bootcmd = CHAIN_BOOT_CMD (Validate and execute Boot script)
+	 */
+	env_set("bootdelay", "-2");
+
+#ifdef CONFIG_ARM
+	env_set("secureboot", "y");
+#else
+	env_set("bootcmd", CHAIN_BOOT_CMD);
+#endif
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+void spl_validate_uboot(uint32_t hdr_addr, uintptr_t img_addr)
+{
+	int res;
+
+	/*
+	 * Check Boot Mode
+	 * If Boot Mode is Non-Secure, skip validation
+	 */
+	if (fsl_check_boot_mode_secure() == 0)
+		return;
+
+	printf("SPL: Validating U-Boot image\n");
+
+#ifdef CONFIG_ADDR_MAP
+	init_addr_map();
+#endif
+
+#ifdef CONFIG_FSL_CORENET
+	if (pamu_init() < 0)
+		fsl_secboot_handle_error(ERROR_ESBC_PAMU_INIT);
+#endif
+
+/*
+ * dm_init_and_scan() is called as part of common SPL framework, so no
+ * need to call it again but in case of powerpc platforms which currently
+ * do not use common SPL framework, so need to call this function here.
+ */
+#if defined(CONFIG_SPL_DM) && (!defined(CONFIG_SPL_FRAMEWORK))
+	dm_init_and_scan(true);
+#endif
+	res = fsl_secboot_validate(hdr_addr, CONFIG_SPL_UBOOT_KEY_HASH,
+				   &img_addr);
+
+	if (res == 0)
+		printf("SPL: Validation of U-Boot successful\n");
+}
+
+#ifdef CONFIG_SPL_FRAMEWORK
+/* Override weak funtion defined in SPL framework to enable validation
+ * of main u-boot image before jumping to u-boot image.
+ */
+void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
+{
+	typedef void __noreturn (*image_entry_noargs_t)(void);
+	uint32_t hdr_addr;
+
+	image_entry_noargs_t image_entry =
+		(image_entry_noargs_t)(unsigned long)spl_image->entry_point;
+
+	hdr_addr = (spl_image->entry_point + spl_image->size -
+			FSL_U_BOOT_HDR_SIZE);
+	spl_validate_uboot(hdr_addr, (uintptr_t)spl_image->entry_point);
+	/*
+	 * In case of failure in validation, spl_validate_uboot would
+	 * not return back in case of Production environment with ITS=1.
+	 * Thus U-Boot will not start.
+	 * In Development environment (ITS=0 and SB_EN=1), the function
+	 * may return back in case of non-fatal failures.
+	 */
+
+	debug("image entry point: 0x%lX\n", spl_image->entry_point);
+	image_entry();
+}
+#endif /* ifdef CONFIG_SPL_FRAMEWORK */
+#endif /* ifdef CONFIG_SPL_BUILD */
diff --git a/board/adlink/common/fsl_validate.c b/board/adlink/common/fsl_validate.c
new file mode 100644
index 00000000000..bfe6357b0d6
--- /dev/null
+++ b/board/adlink/common/fsl_validate.c
@@ -0,0 +1,975 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ * Copyright 2021-2022 NXP
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <fsl_validate.h>
+#include <fsl_secboot_err.h>
+#include <fsl_sfp.h>
+#include <fsl_sec.h>
+#include <command.h>
+#include <log.h>
+#include <malloc.h>
+#include <u-boot/rsa-mod-exp.h>
+#include <hash.h>
+#include <fsl_secboot_err.h>
+#ifdef CONFIG_ARCH_LS1021A
+#include <asm/arch/immap_ls102xa.h>
+#endif
+#include <dm/lists.h>
+
+#define SHA256_BITS	256
+#define SHA256_BYTES	(256/8)
+#define SHA256_NIBBLES	(256/4)
+#define NUM_HEX_CHARS	(sizeof(ulong) * 2)
+
+#define CHECK_KEY_LEN(key_len)	(((key_len) == 2 * KEY_SIZE_BYTES / 4) || \
+				 ((key_len) == 2 * KEY_SIZE_BYTES / 2) || \
+				 ((key_len) == 2 * KEY_SIZE_BYTES))
+#if CONFIG_IS_ENABLED(FSL_ISBC_KEY_EXT)
+/* Global data structure */
+static struct fsl_secboot_glb glb;
+#endif
+
+/* This array contains DER value for SHA-256 */
+static const u8 hash_identifier[] = { 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60,
+		0x86, 0x48, 0x01, 0x65,	0x03, 0x04, 0x02, 0x01, 0x05, 0x00,
+		0x04, 0x20
+		};
+
+static u8 hash_val[SHA256_BYTES];
+
+#ifdef CONFIG_ESBC_HDR_LS
+/* New Barker Code for LS ESBC Header */
+static const u8 barker_code[ESBC_BARKER_LEN] = { 0x12, 0x19, 0x20, 0x01 };
+#else
+static const u8 barker_code[ESBC_BARKER_LEN] = { 0x68, 0x39, 0x27, 0x81 };
+#endif
+
+void branch_to_self(void) __attribute__ ((noreturn));
+
+/*
+ * This function will put core in infinite loop.
+ * This will be called when the ESBC can not proceed further due
+ * to some unknown errors.
+ */
+void branch_to_self(void)
+{
+	printf("Core is in infinite loop due to errors.\n");
+self:
+	goto self;
+}
+
+#if CONFIG_IS_ENABLED(FSL_ISBC_KEY_EXT)
+static u32 check_ie(struct fsl_secboot_img_priv *img)
+{
+	if (img->hdr.ie_flag & IE_FLAG_MASK)
+		return 1;
+
+	return 0;
+}
+
+/* This function returns the CSF Header Address of uboot
+ * For MPC85xx based platforms, the LAW mapping for NOR
+ * flash changes in uboot code. Hence the offset needs
+ * to be calculated and added to the new NOR flash base
+ * address
+ */
+#if defined(CONFIG_MPC85xx)
+#include <flash.h>
+
+int get_csf_base_addr(u32 *csf_addr, u32 *flash_base_addr)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CFG_SYS_MPC85xx_GUTS_ADDR);
+	u32 csf_hdr_addr = in_be32(&gur->scratchrw[0]);
+	u32 csf_flash_offset = csf_hdr_addr & ~(CFG_SYS_PBI_FLASH_BASE);
+	u32 flash_addr, addr;
+	int found = 0;
+	int i = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		flash_addr = flash_info[i].start[0];
+		addr = flash_info[i].start[0] + csf_flash_offset;
+		if (memcmp((u8 *)addr, barker_code, ESBC_BARKER_LEN) == 0) {
+			debug("Barker found on addr %x\n", addr);
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		return -1;
+
+	*csf_addr = addr;
+	*flash_base_addr = flash_addr;
+
+	return 0;
+}
+#else
+/* For platforms like LS1020, correct flash address is present in
+ * the header. So the function reqturns flash base address as 0
+ */
+int get_csf_base_addr(u32 *csf_addr, u32 *flash_base_addr)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CFG_SYS_FSL_GUTS_ADDR);
+	u32 csf_hdr_addr = in_be32(&gur->scratchrw[0]);
+
+	if (memcmp((u8 *)(uintptr_t)csf_hdr_addr,
+		   barker_code, ESBC_BARKER_LEN))
+		return -1;
+
+	*csf_addr = csf_hdr_addr;
+	*flash_base_addr = 0;
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_ESBC_HDR_LS)
+static int get_ie_info_addr(uintptr_t *ie_addr)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CFG_SYS_FSL_GUTS_ADDR);
+	/* For LS-CH3, the address of IE Table is
+	 * stated in Scratch13 and scratch14 of DCFG.
+	 * Bootrom validates this table while validating uboot.
+	 * DCFG is LE*/
+	*ie_addr = in_le32(&gur->scratchrw[SCRATCH_IE_HIGH_ADR - 1]);
+	*ie_addr = *ie_addr << 32;
+	*ie_addr |= in_le32(&gur->scratchrw[SCRATCH_IE_LOW_ADR - 1]);
+	return 0;
+}
+#else /* CONFIG_ESBC_HDR_LS */
+static int get_ie_info_addr(uintptr_t *ie_addr)
+{
+	struct fsl_secboot_img_hdr *hdr;
+	struct fsl_secboot_sg_table *sg_tbl;
+	u32 flash_base_addr, csf_addr;
+
+	if (get_csf_base_addr(&csf_addr, &flash_base_addr))
+		return -1;
+
+	hdr = (struct fsl_secboot_img_hdr *)(uintptr_t)csf_addr;
+
+	/* For SoC's with Trust Architecture v1 with corenet bus
+	 * the sg table field in CSF header has absolute address
+	 * for sg table in memory. In other Trust Architecture,
+	 * this field specifies the offset of sg table from the
+	 * base address of CSF Header
+	 */
+#if defined(CONFIG_FSL_TRUST_ARCH_v1) && defined(CONFIG_FSL_CORENET)
+	sg_tbl = (struct fsl_secboot_sg_table *)
+		 (((u32)hdr->psgtable & ~(CFG_SYS_PBI_FLASH_BASE)) +
+		  flash_base_addr);
+#else
+	sg_tbl = (struct fsl_secboot_sg_table *)(uintptr_t)(csf_addr +
+						 (u32)hdr->psgtable);
+#endif
+
+	/* IE Key Table is the first entry in the SG Table */
+#if defined(CONFIG_MPC85xx)
+	*ie_addr = (uintptr_t)((sg_tbl->src_addr &
+			~(CFG_SYS_PBI_FLASH_BASE)) +
+			flash_base_addr);
+#else
+	*ie_addr = (uintptr_t)sg_tbl->src_addr;
+#endif
+
+	debug("IE Table address is %lx\n", *ie_addr);
+	return 0;
+}
+#endif /* CONFIG_ESBC_HDR_LS */
+#endif
+
+#ifdef CONFIG_KEY_REVOCATION
+/* This function checks srk_table_flag in header and set/reset srk_flag.*/
+static u32 check_srk(struct fsl_secboot_img_priv *img)
+{
+#ifdef CONFIG_ESBC_HDR_LS
+	/* In LS, No SRK Flag as SRK is always present if IE not present*/
+#if CONFIG_IS_ENABLED(FSL_ISBC_KEY_EXT)
+	return !check_ie(img);
+#endif
+	return 1;
+#else
+	if (img->hdr.len_kr.srk_table_flag & SRK_FLAG)
+		return 1;
+
+	return 0;
+#endif
+}
+
+/* This function returns ospr's key_revoc values.*/
+static u32 get_key_revoc(void)
+{
+	struct ccsr_sfp_regs *sfp_regs = (void *)(CFG_SYS_SFP_ADDR);
+	return (sfp_in32(&sfp_regs->ospr) & OSPR_KEY_REVOC_MASK) >>
+		OSPR_KEY_REVOC_SHIFT;
+}
+
+/* This function checks if selected key is revoked or not.*/
+static u32 is_key_revoked(u32 keynum, u32 rev_flag)
+{
+	if (keynum == UNREVOCABLE_KEY)
+		return 0;
+
+	if ((u32)(1 << (ALIGN_REVOC_KEY - keynum)) & rev_flag)
+		return 1;
+
+	return 0;
+}
+
+/* It read validates srk_table key lengths.*/
+static u32 read_validate_srk_tbl(struct fsl_secboot_img_priv *img)
+{
+	int i = 0;
+	u32 ret, key_num, key_revoc_flag, size;
+	struct fsl_secboot_img_hdr *hdr = &img->hdr;
+	void *esbc = (u8 *)(uintptr_t)img->ehdrloc;
+
+	if ((hdr->len_kr.num_srk == 0) ||
+	    (hdr->len_kr.num_srk > MAX_KEY_ENTRIES))
+		return ERROR_ESBC_CLIENT_HEADER_INVALID_SRK_NUM_ENTRY;
+
+	key_num = hdr->len_kr.srk_sel;
+	if (key_num == 0 || key_num > hdr->len_kr.num_srk)
+		return ERROR_ESBC_CLIENT_HEADER_INVALID_KEY_NUM;
+
+	/* Get revoc key from sfp */
+	key_revoc_flag = get_key_revoc();
+	ret = is_key_revoked(key_num, key_revoc_flag);
+	if (ret)
+		return ERROR_ESBC_CLIENT_HEADER_KEY_REVOKED;
+
+	size = hdr->len_kr.num_srk * sizeof(struct srk_table);
+
+	memcpy(&img->srk_tbl, esbc + hdr->srk_tbl_off, size);
+
+	for (i = 0; i < hdr->len_kr.num_srk; i++) {
+		if (!CHECK_KEY_LEN(img->srk_tbl[i].key_len))
+			return ERROR_ESBC_CLIENT_HEADER_INV_SRK_ENTRY_KEYLEN;
+	}
+
+	img->key_len = img->srk_tbl[key_num - 1].key_len;
+
+	memcpy(&img->img_key, &(img->srk_tbl[key_num - 1].pkey),
+	       img->key_len);
+
+	return 0;
+}
+#endif
+
+#ifndef CONFIG_ESBC_HDR_LS
+static u32 read_validate_single_key(struct fsl_secboot_img_priv *img)
+{
+	struct fsl_secboot_img_hdr *hdr = &img->hdr;
+	void *esbc = (u8 *)(uintptr_t)img->ehdrloc;
+
+	/* check key length */
+	if (!CHECK_KEY_LEN(hdr->key_len))
+		return ERROR_ESBC_CLIENT_HEADER_KEY_LEN;
+
+	memcpy(&img->img_key, esbc + hdr->pkey, hdr->key_len);
+
+	img->key_len = hdr->key_len;
+
+	return 0;
+}
+#endif /* CONFIG_ESBC_HDR_LS */
+
+#if CONFIG_IS_ENABLED(FSL_ISBC_KEY_EXT)
+
+static void install_ie_tbl(uintptr_t ie_tbl_addr,
+		struct fsl_secboot_img_priv *img)
+{
+	/* Copy IE tbl to Global Data */
+	memcpy(&glb.ie_tbl, (u8 *)ie_tbl_addr, sizeof(struct ie_key_info));
+	img->ie_addr = (uintptr_t)&glb.ie_tbl;
+	glb.ie_addr = img->ie_addr;
+}
+
+static u32 read_validate_ie_tbl(struct fsl_secboot_img_priv *img)
+{
+	struct fsl_secboot_img_hdr *hdr = &img->hdr;
+	u32 ie_key_len, ie_revoc_flag, ie_num;
+	struct ie_key_info *ie_info;
+
+	if (!img->ie_addr) {
+		if (get_ie_info_addr(&img->ie_addr))
+			return ERROR_IE_TABLE_NOT_FOUND;
+		else
+			install_ie_tbl(img->ie_addr, img);
+		}
+
+	ie_info = (struct ie_key_info *)(uintptr_t)img->ie_addr;
+	if (ie_info->num_keys == 0 || ie_info->num_keys > 32)
+		return ERROR_ESBC_CLIENT_HEADER_INVALID_IE_NUM_ENTRY;
+
+	ie_num = hdr->ie_key_sel;
+	if (ie_num == 0 || ie_num > ie_info->num_keys)
+		return ERROR_ESBC_CLIENT_HEADER_INVALID_IE_KEY_NUM;
+
+	ie_revoc_flag = ie_info->key_revok;
+	if ((u32)(1 << (ie_num - 1)) & ie_revoc_flag)
+		return ERROR_ESBC_CLIENT_HEADER_IE_KEY_REVOKED;
+
+	ie_key_len = ie_info->ie_key_tbl[ie_num - 1].key_len;
+
+	if (!CHECK_KEY_LEN(ie_key_len))
+		return ERROR_ESBC_CLIENT_HEADER_INV_IE_ENTRY_KEYLEN;
+
+	memcpy(&img->img_key, &(ie_info->ie_key_tbl[ie_num - 1].pkey),
+	       ie_key_len);
+
+	img->key_len = ie_key_len;
+	return 0;
+}
+#endif
+
+
+/* This function return length of public key.*/
+static inline u32 get_key_len(struct fsl_secboot_img_priv *img)
+{
+	return img->key_len;
+}
+
+/*
+ * Handles the ESBC uboot client header verification failure.
+ * This  function  handles all the errors which might occur in the
+ * parsing and checking of ESBC uboot client header. It will also
+ * set the error bits in the SEC_MON.
+ */
+static void fsl_secboot_header_verification_failure(void)
+{
+	struct ccsr_sfp_regs *sfp_regs = (void *)(CFG_SYS_SFP_ADDR);
+
+	/* 29th bit of OSPR is ITS */
+	u32 its = sfp_in32(&sfp_regs->ospr) >> 2;
+
+	if (its == 1)
+		set_sec_mon_state(HPSR_SSM_ST_SOFT_FAIL);
+	else
+		set_sec_mon_state(HPSR_SSM_ST_NON_SECURE);
+
+	printf("Generating reset request\n");
+	do_reset(NULL, 0, 0, NULL);
+	/* If reset doesn't coocur, halt execution */
+	do_esbc_halt(NULL, 0, 0, NULL);
+}
+
+/*
+ * Handles the ESBC uboot client image verification failure.
+ * This  function  handles all the errors which might occur in the
+ * public key hash comparison and signature verification of
+ * ESBC uboot client image. It will also
+ * set the error bits in the SEC_MON.
+ */
+static void fsl_secboot_image_verification_failure(void)
+{
+	struct ccsr_sfp_regs *sfp_regs = (void *)(CFG_SYS_SFP_ADDR);
+
+	u32 its = (sfp_in32(&sfp_regs->ospr) & ITS_MASK) >> ITS_BIT;
+
+	if (its == 1) {
+		set_sec_mon_state(HPSR_SSM_ST_SOFT_FAIL);
+
+		printf("Generating reset request\n");
+		do_reset(NULL, 0, 0, NULL);
+		/* If reset doesn't coocur, halt execution */
+		do_esbc_halt(NULL, 0, 0, NULL);
+
+	} else {
+		set_sec_mon_state(HPSR_SSM_ST_NON_SECURE);
+	}
+}
+
+static void fsl_secboot_bootscript_parse_failure(void)
+{
+	fsl_secboot_header_verification_failure();
+}
+
+/*
+ * Handles the errors in esbc boot.
+ * This  function  handles all the errors which might occur in the
+ * esbc boot phase. It will call the appropriate api to log the
+ * errors and set the error bits in the SEC_MON.
+ */
+void fsl_secboot_handle_error(int error)
+{
+#ifndef CONFIG_SPL_BUILD
+	const struct fsl_secboot_errcode *e;
+
+	for (e = fsl_secboot_errcodes; e->errcode != ERROR_ESBC_CLIENT_MAX;
+		e++) {
+		if (e->errcode == error)
+			printf("ERROR :: %x :: %s\n", error, e->name);
+	}
+#else
+	printf("ERROR :: %x\n", error);
+#endif
+
+	/* If Boot Mode is secure, transition the SNVS state and issue
+	 * reset based on type of failure and ITS setting.
+	 * If Boot mode is non-secure, return from this function.
+	 */
+	if (fsl_check_boot_mode_secure() == 0)
+		return;
+
+	switch (error) {
+	case ERROR_ESBC_CLIENT_HEADER_BARKER:
+	case ERROR_ESBC_CLIENT_HEADER_IMG_SIZE:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_LEN:
+	case ERROR_ESBC_CLIENT_HEADER_SIG_LEN:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2:
+	case ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD:
+	case ERROR_ESBC_CLIENT_HEADER_SG_ESBC_EP:
+	case ERROR_ESBC_CLIENT_HEADER_SG_ENTIRES_BAD:
+	case ERROR_KEY_TABLE_NOT_FOUND:
+#ifdef CONFIG_KEY_REVOCATION
+	case ERROR_ESBC_CLIENT_HEADER_KEY_REVOKED:
+	case ERROR_ESBC_CLIENT_HEADER_INVALID_SRK_NUM_ENTRY:
+	case ERROR_ESBC_CLIENT_HEADER_INVALID_KEY_NUM:
+	case ERROR_ESBC_CLIENT_HEADER_INV_SRK_ENTRY_KEYLEN:
+#endif
+#if CONFIG_IS_ENABLED(FSL_ISBC_KEY_EXT)
+	/*@fallthrough@*/
+	case ERROR_ESBC_CLIENT_HEADER_IE_KEY_REVOKED:
+	case ERROR_ESBC_CLIENT_HEADER_INVALID_IE_NUM_ENTRY:
+	case ERROR_ESBC_CLIENT_HEADER_INVALID_IE_KEY_NUM:
+	case ERROR_ESBC_CLIENT_HEADER_INV_IE_ENTRY_KEYLEN:
+	case ERROR_IE_TABLE_NOT_FOUND:
+#endif
+		fsl_secboot_header_verification_failure();
+		break;
+	case ERROR_ESBC_SEC_RESET:
+	case ERROR_ESBC_SEC_DEQ:
+	case ERROR_ESBC_SEC_ENQ:
+	case ERROR_ESBC_SEC_DEQ_TO:
+	case ERROR_ESBC_SEC_JOBQ_STATUS:
+	case ERROR_ESBC_CLIENT_HASH_COMPARE_KEY:
+	case ERROR_ESBC_CLIENT_HASH_COMPARE_EM:
+		fsl_secboot_image_verification_failure();
+		break;
+	case ERROR_ESBC_MISSING_BOOTM:
+		fsl_secboot_bootscript_parse_failure();
+		break;
+	case ERROR_ESBC_WRONG_CMD:
+	default:
+		branch_to_self();
+		break;
+	}
+}
+
+static void fsl_secblk_handle_error(int error)
+{
+	switch (error) {
+	case ERROR_ESBC_SEC_ENQ:
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_ENQ);
+		break;
+	case ERROR_ESBC_SEC_DEQ:
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_DEQ);
+		break;
+	case ERROR_ESBC_SEC_DEQ_TO:
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_DEQ_TO);
+		break;
+	default:
+		printf("Job Queue Output status %x\n", error);
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_JOBQ_STATUS);
+		break;
+	}
+}
+
+/*
+ * Calculate hash of key obtained via offset present in ESBC uboot
+ * client hdr. This function calculates the hash of key which is obtained
+ * through offset present in ESBC uboot client header.
+ */
+static int calc_img_key_hash(struct fsl_secboot_img_priv *img)
+{
+	struct hash_algo *algo;
+	void *ctx;
+	int i, srk = 0;
+	int ret = 0;
+	const char *algo_name = "sha256";
+
+	/* Calculate hash of the esbc key */
+	ret = hash_progressive_lookup_algo(algo_name, &algo);
+	if (ret)
+		return ret;
+
+	ret = algo->hash_init(algo, &ctx);
+	if (ret)
+		return ret;
+	/* Update hash for ESBC key */
+#ifdef CONFIG_KEY_REVOCATION
+	if (check_srk(img)) {
+		ret = algo->hash_update(algo, ctx,
+		      (u8 *)(uintptr_t)(img->ehdrloc + img->hdr.srk_tbl_off),
+		      img->hdr.len_kr.num_srk * sizeof(struct srk_table), 1);
+		srk = 1;
+	}
+#endif
+	if (!srk)
+		ret = algo->hash_update(algo, ctx,
+			img->img_key, img->key_len, 1);
+	if (ret)
+		return ret;
+	/* Copy hash at destination buffer */
+	ret = algo->hash_finish(algo, ctx, hash_val, algo->digest_size);
+	if (ret) {
+		free(ctx);
+		return ret;
+	}
+	for (i = 0; i < SHA256_BYTES; i++)
+		img->img_key_hash[i] = hash_val[i];
+
+	return 0;
+}
+
+/*
+ * Calculate hash of ESBC hdr and ESBC. This function calculates the
+ * single hash of ESBC header and ESBC image. If SG flag is on, all
+ * SG entries are also hashed alongwith the complete SG table.
+ */
+static int calc_esbchdr_esbc_hash(struct fsl_secboot_img_priv *img)
+{
+	struct hash_algo *algo;
+	void *ctx;
+	int ret = 0;
+	int key_hash = 0;
+	const char *algo_name = "sha256";
+
+	/* Calculate the hash of the ESBC */
+	ret = hash_progressive_lookup_algo(algo_name, &algo);
+	if (ret)
+		return ret;
+
+	ret = algo->hash_init(algo, &ctx);
+	/* Copy hash at destination buffer */
+	if (ret)
+		return ret;
+
+	/* Update hash for CSF Header */
+	ret = algo->hash_update(algo, ctx,
+		(u8 *)&img->hdr, sizeof(struct fsl_secboot_img_hdr), 0);
+	if (ret)
+		return ret;
+
+	/* Update the hash with that of srk table if srk flag is 1
+	 * If IE Table is selected, key is not added in the hash
+	 * If neither srk table nor IE key table available, add key
+	 * from header in the hash calculation
+	 */
+#ifdef CONFIG_KEY_REVOCATION
+	if (check_srk(img)) {
+		ret = algo->hash_update(algo, ctx,
+		      (u8 *)(uintptr_t)(img->ehdrloc + img->hdr.srk_tbl_off),
+		      img->hdr.len_kr.num_srk * sizeof(struct srk_table), 0);
+		key_hash = 1;
+	}
+#endif
+#if CONFIG_IS_ENABLED(FSL_ISBC_KEY_EXT)
+	if (!key_hash && check_ie(img))
+		key_hash = 1;
+#endif
+#ifndef CONFIG_ESBC_HDR_LS
+/* No single key support in LS ESBC header */
+	if (!key_hash) {
+		ret = algo->hash_update(algo, ctx,
+			img->img_key, img->hdr.key_len, 0);
+		key_hash = 1;
+	}
+#endif
+	if (ret)
+		return ret;
+	if (!key_hash) {
+		free(ctx);
+		return ERROR_KEY_TABLE_NOT_FOUND;
+	}
+	/* Update hash for actual Image */
+	ret = algo->hash_update(algo, ctx,
+		(u8 *)(*(img->img_addr_ptr)), img->img_size, 1);
+	if (ret)
+		return ret;
+
+	/* Copy hash at destination buffer */
+	ret = algo->hash_finish(algo, ctx, hash_val, algo->digest_size);
+	if (ret) {
+		free(ctx);
+		return ret;
+	}
+	return 0;
+}
+
+/*
+ * Construct encoded hash EM' wrt PKCSv1.5. This function calculates the
+ * pointers for padding, DER value and hash. And finally, constructs EM'
+ * which includes hash of complete CSF header and ESBC image. If SG flag
+ * is on, hash of SG table and entries is also included.
+ */
+static void construct_img_encoded_hash_second(struct fsl_secboot_img_priv *img)
+{
+	/*
+	 * RSA PKCSv1.5 encoding format for encoded message is below
+	 * EM = 0x0 || 0x1 || PS || 0x0 || DER || Hash
+	 * PS is Padding String
+	 * DER is DER value for SHA-256
+	 * Hash is SHA-256 hash
+	 * *********************************************************
+	 * representative points to first byte of EM initially and is
+	 * filled with 0x0
+	 * representative is incremented by 1 and second byte is filled
+	 * with 0x1
+	 * padding points to third byte of EM
+	 * digest points to full length of EM - 32 bytes
+	 * hash_id (DER value) points to 19 bytes before pDigest
+	 * separator is one byte which separates padding and DER
+	 */
+
+	size_t len;
+	u8 *representative;
+	u8 *padding, *digest;
+	u8 *hash_id, *separator;
+	int i;
+
+	len = (get_key_len(img) / 2) - 1;
+	representative = img->img_encoded_hash_second;
+	representative[0] = 0;
+	representative[1] = 1;  /* block type 1 */
+
+	padding = &representative[2];
+	digest = &representative[1] + len - 32;
+	hash_id = digest - sizeof(hash_identifier);
+	separator = hash_id - 1;
+
+	/* fill padding area pointed by padding with 0xff */
+	memset(padding, 0xff, separator - padding);
+
+	/* fill byte pointed by separator */
+	*separator = 0;
+
+	/* fill SHA-256 DER value  pointed by HashId */
+	memcpy(hash_id, hash_identifier, sizeof(hash_identifier));
+
+	/* fill hash pointed by Digest */
+	for (i = 0; i < SHA256_BYTES; i++)
+		digest[i] = hash_val[i];
+}
+
+/*
+ * Reads and validates the ESBC client header.
+ * This function reads key and signature from the ESBC client header.
+ * If Scatter/Gather flag is on, lengths and offsets of images
+ * present as SG entries are also read. This function also checks
+ * whether the header is valid or not.
+ */
+static int read_validate_esbc_client_header(struct fsl_secboot_img_priv *img)
+{
+	struct fsl_secboot_img_hdr *hdr = &img->hdr;
+	void *esbc = (u8 *)(uintptr_t)img->ehdrloc;
+	u8 *k, *s;
+	u32 ret = 0;
+
+	int  key_found = 0;
+
+	/* check barker code */
+	if (memcmp(hdr->barker, barker_code, ESBC_BARKER_LEN))
+		return ERROR_ESBC_CLIENT_HEADER_BARKER;
+
+	/* If Image Address is not passed as argument to function,
+	 * then Address and Size must be read from the Header.
+	 */
+	if (*(img->img_addr_ptr) == 0) {
+	#ifdef CONFIG_ESBC_ADDR_64BIT
+		*(img->img_addr_ptr) = hdr->pimg64;
+	#else
+		*(img->img_addr_ptr) = hdr->pimg;
+	#endif
+	}
+
+	if (!hdr->img_size)
+		return ERROR_ESBC_CLIENT_HEADER_IMG_SIZE;
+
+	img->img_size = hdr->img_size;
+
+	/* Key checking*/
+#ifdef CONFIG_KEY_REVOCATION
+	if (check_srk(img)) {
+		ret = read_validate_srk_tbl(img);
+		if (ret != 0)
+			return ret;
+		key_found = 1;
+	}
+#endif
+
+#if CONFIG_IS_ENABLED(FSL_ISBC_KEY_EXT)
+	if (!key_found && check_ie(img)) {
+		ret = read_validate_ie_tbl(img);
+		if (ret != 0)
+			return ret;
+		key_found = 1;
+	}
+#endif
+#ifndef CONFIG_ESBC_HDR_LS
+/* Single Key Feature not available in LS ESBC Header */
+	if (key_found == 0) {
+		ret = read_validate_single_key(img);
+		if (ret != 0)
+			return ret;
+		key_found = 1;
+	}
+#endif
+	if (!key_found)
+		return ERROR_KEY_TABLE_NOT_FOUND;
+
+	/* check signaure */
+	if (get_key_len(img) == 2 * hdr->sign_len) {
+		/* check signature length */
+		if (!((hdr->sign_len == KEY_SIZE_BYTES / 4) ||
+		      (hdr->sign_len == KEY_SIZE_BYTES / 2) ||
+		      (hdr->sign_len == KEY_SIZE_BYTES)))
+			return ERROR_ESBC_CLIENT_HEADER_SIG_LEN;
+	} else {
+		return ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN;
+	}
+
+	memcpy(&img->img_sign, esbc + hdr->psign, hdr->sign_len);
+/* No SG support in LS-CH3 */
+#ifndef CONFIG_ESBC_HDR_LS
+	/* No SG support */
+	if (hdr->sg_flag)
+		return ERROR_ESBC_CLIENT_HEADER_SG;
+#endif
+
+	/* modulus most significant bit should be set */
+	k = (u8 *)&img->img_key;
+
+	if ((k[0] & 0x80) == 0)
+		return ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1;
+
+	/* modulus value should be odd */
+	if ((k[get_key_len(img) / 2 - 1] & 0x1) == 0)
+		return ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2;
+
+	/* Check signature value < modulus value */
+	s = (u8 *)&img->img_sign;
+
+	if (!(memcmp(s, k, hdr->sign_len) < 0))
+		return ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD;
+
+	return ESBC_VALID_HDR;
+}
+
+static inline int str2longbe(const char *p, ulong *num)
+{
+	char *endptr;
+	ulong tmp;
+
+	if (!p) {
+		return 0;
+	} else {
+		tmp = hextoul(p, &endptr);
+		if (sizeof(ulong) == 4)
+			*num = cpu_to_be32(tmp);
+		else
+			*num = cpu_to_be64(tmp);
+	}
+
+	return *p != '\0' && *endptr == '\0';
+}
+/* Function to calculate the ESBC Image Hash
+ * and hash from Digital signature.
+ * The Two hash's are compared to yield the
+ * result of signature validation.
+ */
+static int calculate_cmp_img_sig(struct fsl_secboot_img_priv *img)
+{
+	int ret;
+	uint32_t key_len;
+	struct key_prop prop;
+#if !defined(USE_HOSTCC)
+	struct udevice *mod_exp_dev;
+#endif
+	ret = calc_esbchdr_esbc_hash(img);
+	if (ret)
+		return ret;
+
+	/* Construct encoded hash EM' wrt PKCSv1.5 */
+	construct_img_encoded_hash_second(img);
+
+	/* Fill prop structure for public key */
+	memset(&prop, 0, sizeof(struct key_prop));
+	key_len = get_key_len(img) / 2;
+	prop.modulus = img->img_key;
+	prop.public_exponent = img->img_key + key_len;
+	prop.num_bits = key_len * 8;
+	prop.exp_len = key_len;
+
+#if defined(CONFIG_SPL_BUILD)
+	ret = device_bind_driver(NULL, "fsl_rsa_mod_exp", "fsl_rsa_mod_exp", NULL);
+	if (ret) {
+		printf("Couldn't bind fsl_rsa_mod_exp driver (%d)\n", ret);
+		return -EINVAL;
+	}
+#endif
+	ret = uclass_get_device(UCLASS_MOD_EXP, 0, &mod_exp_dev);
+	if (ret) {
+		printf("RSA: Can't find Modular Exp implementation\n");
+		return -EINVAL;
+	}
+
+	ret = rsa_mod_exp(mod_exp_dev, img->img_sign, img->hdr.sign_len,
+			  &prop, img->img_encoded_hash);
+	if (ret)
+		return ret;
+
+	/*
+	 * compare the encoded messages EM' and EM wrt RSA PKCSv1.5
+	 * memcmp returns zero on success
+	 * memcmp returns non-zero on failure
+	 */
+	ret = memcmp(&img->img_encoded_hash_second, &img->img_encoded_hash,
+		img->hdr.sign_len);
+
+	if (ret)
+		return ERROR_ESBC_CLIENT_HASH_COMPARE_EM;
+
+	return 0;
+}
+/* Function to initialize img priv and global data structure
+ */
+static int secboot_init(struct fsl_secboot_img_priv **img_ptr)
+{
+	*img_ptr = malloc(sizeof(struct fsl_secboot_img_priv));
+
+	struct fsl_secboot_img_priv *img = *img_ptr;
+
+	if (!img)
+		return -ENOMEM;
+	memset(img, 0, sizeof(struct fsl_secboot_img_priv));
+
+#if CONFIG_IS_ENABLED(FSL_ISBC_KEY_EXT)
+	if (glb.ie_addr)
+		img->ie_addr = glb.ie_addr;
+#endif
+	return 0;
+}
+
+
+/* haddr - Address of the header of image to be validated.
+ * arg_hash_str - Option hash string. If provided, this
+ * overrides the key hash in the SFP fuses.
+ * img_addr_ptr - Optional pointer to address of image to be validated.
+ * If non zero addr, this overrides the addr of image in header,
+ * otherwise updated to image addr in header.
+ * Acts as both input and output of function.
+ * This pointer shouldn't be NULL.
+ */
+int fsl_secboot_validate(uintptr_t haddr, char *arg_hash_str,
+			uintptr_t *img_addr_ptr)
+{
+	struct ccsr_sfp_regs *sfp_regs = (void *)(CFG_SYS_SFP_ADDR);
+	ulong hash[SHA256_BYTES/sizeof(ulong)];
+	char hash_str[NUM_HEX_CHARS + 1];
+	struct fsl_secboot_img_priv *img;
+	struct fsl_secboot_img_hdr *hdr;
+	void *esbc;
+	int ret, i, hash_cmd = 0;
+	u32 srk_hash[8];
+
+	if (strlen(arg_hash_str) != 0) {
+		const char *cp = arg_hash_str;
+		int i = 0;
+
+		if (*cp == '0' && *(cp + 1) == 'x')
+			cp += 2;
+
+		/* The input string expected is in hex, where
+		 * each 4 bits would be represented by a hex
+		 * sha256 hash is 256 bits long, which would mean
+		 * num of characters = 256 / 4
+		 */
+		if (strlen(cp) != SHA256_NIBBLES) {
+			printf("%s is not a 256 bits hex string as expected\n",
+			       arg_hash_str);
+			return -1;
+		}
+
+		for (i = 0; i < sizeof(hash)/sizeof(ulong); i++) {
+			strncpy(hash_str, cp + (i * NUM_HEX_CHARS),
+				NUM_HEX_CHARS);
+			hash_str[NUM_HEX_CHARS] = '\0';
+			if (!str2longbe(hash_str, &hash[i])) {
+				printf("%s is not a 256 bits hex string ",
+				       arg_hash_str);
+				return -1;
+			}
+		}
+
+		hash_cmd = 1;
+	}
+
+	ret = secboot_init(&img);
+	if (ret)
+		goto exit;
+
+	/* Update the information in Private Struct */
+	hdr = &img->hdr;
+	img->ehdrloc = haddr;
+	img->img_addr_ptr = img_addr_ptr;
+	esbc = (u8 *)img->ehdrloc;
+
+	memcpy(hdr, esbc, sizeof(struct fsl_secboot_img_hdr));
+
+	/* read and validate esbc header */
+	ret = read_validate_esbc_client_header(img);
+
+	if (ret != ESBC_VALID_HDR) {
+		fsl_secboot_handle_error(ret);
+		goto exit;
+	}
+
+	/* SRKH present in SFP */
+	for (i = 0; i < NUM_SRKH_REGS; i++)
+		srk_hash[i] = srk_in32(&sfp_regs->srk_hash[i]);
+
+	/*
+	 * Calculate hash of key obtained via offset present in
+	 * ESBC uboot client hdr
+	 */
+	ret = calc_img_key_hash(img);
+	if (ret) {
+		fsl_secblk_handle_error(ret);
+		goto exit;
+	}
+
+	/* Compare hash obtained above with SRK hash present in SFP */
+	if (hash_cmd)
+		ret = memcmp(&hash, &img->img_key_hash, SHA256_BYTES);
+	else
+		ret = memcmp(srk_hash, img->img_key_hash, SHA256_BYTES);
+
+#if CONFIG_IS_ENABLED(FSL_ISBC_KEY_EXT)
+	if (!hash_cmd && check_ie(img))
+		ret = 0;
+#endif
+
+	if (ret != 0) {
+		fsl_secboot_handle_error(ERROR_ESBC_CLIENT_HASH_COMPARE_KEY);
+		goto exit;
+	}
+
+	ret = calculate_cmp_img_sig(img);
+	if (ret) {
+		fsl_secboot_handle_error(ret);
+		goto exit;
+	}
+
+exit:
+	/* Free Img as it was malloc'ed*/
+	free(img);
+	return ret;
+}
diff --git a/board/adlink/common/i2c_common.c b/board/adlink/common/i2c_common.c
new file mode 100644
index 00000000000..119ed3c6171
--- /dev/null
+++ b/board/adlink/common/i2c_common.c
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Copyright 2020-21 NXP
+ * Copyright 2021 Microsoft Corporation
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include "i2c_common.h"
+
+#if CONFIG_IS_ENABLED(DM_I2C)
+
+/* If DM is in use, retrieve the chip for the specified bus number */
+int fsl_i2c_get_device(int address, int bus, DEVICE_HANDLE_T *dev)
+{
+	int ret = i2c_get_chip_for_busnum(bus, address, 1, dev);
+
+	if (ret)
+		printf("I2C: Bus %d has no device with address 0x%02X\n",
+		       bus, address);
+	return ret;
+}
+
+#else
+
+/* Handle is passed directly */
+int fsl_i2c_get_device(int address, int bus, DEVICE_HANDLE_T *dev)
+{
+	*dev = address;
+	return 0;
+}
+
+#endif
diff --git a/board/adlink/common/i2c_common.h b/board/adlink/common/i2c_common.h
new file mode 100644
index 00000000000..77a7b6aedd7
--- /dev/null
+++ b/board/adlink/common/i2c_common.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Copyright 2020-21 NXP
+ * Copyright 2021 Microsoft Corporation
+ */
+
+#ifndef __NXP_I2C_COMMON_H__
+#define __NXP_I2C_COMMON_H__
+
+/* Common functionality shared by the I2C drivers for VID and the mux. */
+#if CONFIG_IS_ENABLED(DM_I2C)
+#define DEVICE_HANDLE_T struct udevice *
+
+#define I2C_READ(dev, register, data, length) \
+	dm_i2c_read(dev, register, data, length)
+#define I2C_WRITE(dev, register, data, length) \
+	dm_i2c_write(dev, register, data, length)
+#else
+#define DEVICE_HANDLE_T int
+
+#define I2C_READ(dev, register, data, length) \
+	i2c_read(dev, register, 1, data, length)
+#define I2C_WRITE(dev, register, data, length) \
+	i2c_write(dev, register, 1, data, length)
+#endif
+
+int fsl_i2c_get_device(int address, int bus, DEVICE_HANDLE_T *dev);
+
+#endif
diff --git a/board/adlink/common/i2c_mux.c b/board/adlink/common/i2c_mux.c
new file mode 100644
index 00000000000..9523dd0942e
--- /dev/null
+++ b/board/adlink/common/i2c_mux.c
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Copyright 2020-2022 NXP
+ * Copyright 2021 Microsoft Corporation
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include "i2c_common.h"
+#include "i2c_mux.h"
+
+/*
+ * A new Kconfig option for something that used to always be built should be
+ * “default y”.
+ */
+#ifdef CONFIG_FSL_USE_PCA9547_MUX
+
+int select_i2c_ch_pca9547(u8 ch, int bus)
+{
+	int ret;
+	DEVICE_HANDLE_T dev;
+
+	/* Open device handle */
+	ret = fsl_i2c_get_device(I2C_MUX_PCA_ADDR_PRI, bus, &dev);
+	if (ret) {
+		printf("PCA: No PCA9547 device found\n");
+		return ret;
+	}
+
+	ret = I2C_WRITE(dev, 0, &ch, sizeof(ch));
+	if (ret) {
+		printf("PCA: Unable to select channel %d (%d)\n", (int)ch, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+#ifdef I2C_MUX_PCA_ADDR_SEC
+int select_i2c_ch_pca9547_sec(u8 ch, int bus)
+{
+	int ret;
+	DEVICE_HANDLE_T dev;
+
+	/* Open device handle */
+	ret = fsl_i2c_get_device(I2C_MUX_PCA_ADDR_SEC, bus, &dev);
+	if (ret) {
+		printf("PCA: No PCA9547 device found\n");
+		return ret;
+	}
+
+	ret = I2C_WRITE(dev, 0, &ch, sizeof(ch));
+	if (ret) {
+		printf("PCA: Unable to select channel %d (%d)\n", (int)ch, ret);
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+#endif
diff --git a/board/adlink/common/i2c_mux.h b/board/adlink/common/i2c_mux.h
new file mode 100644
index 00000000000..b58a284326e
--- /dev/null
+++ b/board/adlink/common/i2c_mux.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Copyright 2020-2022 NXP
+ * Copyright 2021 Microsoft Corporation
+ */
+
+#ifndef __NXP_I2C_MUX_H__
+#define __NXP_I2C_MUX_H__
+
+#ifdef CONFIG_FSL_USE_PCA9547_MUX
+int select_i2c_ch_pca9547(u8 ch, int bus);
+int select_i2c_ch_pca9547_sec(u8 ch, int bus);
+#endif
+
+#endif
diff --git a/board/adlink/common/ics307_clk.c b/board/adlink/common/ics307_clk.c
new file mode 100644
index 00000000000..5f95571d24c
--- /dev/null
+++ b/board/adlink/common/ics307_clk.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <clock_legacy.h>
+#include <log.h>
+#include <asm/io.h>
+
+#include "ics307_clk.h"
+
+#if defined(CONFIG_FSL_NGPIXIS)
+#include "ngpixis.h"
+#define fpga_reg pixis
+#elif defined(CONFIG_FSL_QIXIS)
+#include "qixis.h"
+#define fpga_reg ((struct qixis *)QIXIS_BASE)
+#else
+#include "pixis.h"
+#define fpga_reg pixis
+#endif
+
+/* define for SYS CLK or CLK1Frequency */
+#define TTL		1
+#define CLK2		0
+#define CRYSTAL		0
+#define MAX_VDW		(511 + 8)
+#define MAX_RDW		(127 + 2)
+#define MIN_VDW		(4 + 8)
+#define MIN_RDW		(1 + 2)
+#define NUM_OD_SETTING	8
+/*
+ * These defines cover the industrial temperature range part,
+ * for commercial, change below to 400000 and 55000, respectively
+ */
+#define MAX_VCO		360000
+#define MIN_VCO		60000
+
+/* decode S[0-2] to Output Divider (OD) */
+static u8 ics307_s_to_od[] = {
+	10, 2, 8, 4, 5, 7, 3, 6
+};
+
+/*
+ * Find one solution to generate required frequency for SYSCLK
+ * out_freq: KHz, required frequency to the SYSCLK
+ * the result will be retuned with component RDW, VDW, OD, TTL,
+ * CLK2 and crystal
+ */
+unsigned long ics307_sysclk_calculator(unsigned long out_freq)
+{
+	const unsigned long input_freq = CFG_ICS307_REFCLK_HZ;
+	unsigned long vdw, rdw, odp, s_vdw = 0, s_rdw = 0, s_odp = 0, od;
+	unsigned long tmp_out, diff, result = 0;
+	int found = 0;
+
+	for (odp = 0; odp < NUM_OD_SETTING; odp++) {
+		od = ics307_s_to_od[odp];
+		if (od * out_freq < MIN_VCO || od * out_freq > MAX_VCO)
+			continue;
+		for (rdw = MIN_RDW; rdw <= MAX_RDW; rdw++) {
+			/* Calculate the VDW */
+			vdw = out_freq * 1000 * od * rdw / (input_freq * 2);
+			if (vdw > MAX_VDW)
+				vdw = MAX_VDW;
+			if (vdw < MIN_VDW)
+				continue;
+			/* Calculate the temp out frequency */
+			tmp_out = input_freq * 2 * vdw / (rdw * od * 1000);
+			diff = max(out_freq, tmp_out) - min(out_freq, tmp_out);
+			/*
+			 * calculate the percent, the precision is 1/1000
+			 * If greater than 1/1000, continue
+			 * otherwise, we think the solution is we required
+			 */
+			if (diff * 1000 / out_freq > 1)
+				continue;
+			else {
+				s_vdw = vdw;
+				s_rdw = rdw;
+				s_odp = odp;
+				found = 1;
+				break;
+			}
+		}
+	}
+
+	if (found)
+		result = (s_rdw - 2) | (s_vdw - 8) << 7 | s_odp << 16 |
+			CLK2 << 19 | TTL << 21 | CRYSTAL << 22;
+
+	debug("ICS307-02: RDW: %ld, VDW: %ld, OD: %d\n", s_rdw - 2, s_vdw - 8,
+			ics307_s_to_od[s_odp]);
+	return result;
+}
+
+/*
+ * Calculate frequency being generated by ICS307-02 clock chip based upon
+ * the control bytes being programmed into it.
+ */
+static unsigned long ics307_clk_freq(u8 cw0, u8 cw1, u8 cw2)
+{
+	const unsigned long input_freq = CFG_ICS307_REFCLK_HZ;
+	unsigned long vdw = ((cw1 << 1) & 0x1FE) + ((cw2 >> 7) & 1);
+	unsigned long rdw = cw2 & 0x7F;
+	unsigned long od = ics307_s_to_od[cw0 & 0x7];
+	unsigned long freq;
+
+	/*
+	 * CLK1 Freq = Input Frequency * 2 * (VDW + 8) / ((RDW + 2) * OD)
+	 *
+	 * cw0:  C1 C0 TTL F1 F0 S2 S1 S0
+	 * cw1:  V8 V7 V6 V5 V4 V3 V2 V1
+	 * cw2:  V0 R6 R5 R4 R3 R2 R1 R0
+	 *
+	 * R6:R0 = Reference Divider Word (RDW)
+	 * V8:V0 = VCO Divider Word (VDW)
+	 * S2:S0 = Output Divider Select (OD)
+	 * F1:F0 = Function of CLK2 Output
+	 * TTL = duty cycle
+	 * C1:C0 = internal load capacitance for cyrstal
+	 *
+	 */
+
+	freq = input_freq * 2 * (vdw + 8) / ((rdw + 2) * od);
+
+	debug("ICS307: CW[0-2]: %02X %02X %02X => %lu Hz\n", cw0, cw1, cw2,
+			freq);
+	return freq;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	return ics307_clk_freq(
+			in_8(&fpga_reg->sclk[0]),
+			in_8(&fpga_reg->sclk[1]),
+			in_8(&fpga_reg->sclk[2]));
+}
+
+#ifdef CONFIG_DYNAMIC_DDR_CLK_FREQ
+unsigned long get_board_ddr_clk(void)
+{
+	return ics307_clk_freq(
+			in_8(&fpga_reg->dclk[0]),
+			in_8(&fpga_reg->dclk[1]),
+			in_8(&fpga_reg->dclk[2]));
+}
+#endif
diff --git a/board/adlink/common/ics307_clk.h b/board/adlink/common/ics307_clk.h
new file mode 100644
index 00000000000..163496930c8
--- /dev/null
+++ b/board/adlink/common/ics307_clk.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ */
+#ifndef __ICS_CLK_H_
+#define __ICS_CLK_H_	1
+
+#ifndef __ASSEMBLY__
+
+extern unsigned long get_board_sys_clk(void);
+extern unsigned long ics307_sysclk_calculator(unsigned long out_freq);
+#endif
+
+#endif	/* __ICS_CLK_H_ */
diff --git a/board/adlink/common/ls102xa_stream_id.c b/board/adlink/common/ls102xa_stream_id.c
new file mode 100644
index 00000000000..f754cf42fd3
--- /dev/null
+++ b/board/adlink/common/ls102xa_stream_id.c
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2014 Freescale Semiconductor
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/ls102xa_stream_id.h>
+
+void ls102xa_config_smmu_stream_id(struct smmu_stream_id *id, uint32_t num)
+{
+	void *scfg = (void *)CFG_SYS_FSL_SCFG_ADDR;
+	int i;
+	u32 icid;
+
+	for (i = 0; i < num; i++) {
+		icid = (id[i].stream_id & 0xff) << 24;
+		out_be32((u32 *)(scfg + id[i].offset), icid);
+	}
+}
+
+void ls1021x_config_caam_stream_id(struct liodn_id_table *tbl, int size)
+{
+	int i;
+	u32 liodn;
+
+	for (i = 0; i < size; i++) {
+		if (tbl[i].num_ids == 2)
+			liodn = (tbl[i].id[0] << 16) | tbl[i].id[1];
+		else
+			liodn = tbl[i].id[0];
+
+		out_le32((u32 *)(tbl[i].reg_offset), liodn);
+	}
+}
diff --git a/board/adlink/common/mc34vr500.c b/board/adlink/common/mc34vr500.c
new file mode 100644
index 00000000000..d6b4c65a3c0
--- /dev/null
+++ b/board/adlink/common/mc34vr500.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ * Hou Zhiqiang <Zhiqiang.Hou@freescale.com>
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <i2c.h>
+#include <log.h>
+#include <power/pmic.h>
+#include <power/mc34vr500_pmic.h>
+
+static uint8_t swxvolt_addr[4] = { MC34VR500_SW1VOLT,
+				   MC34VR500_SW2VOLT,
+				   MC34VR500_SW3VOLT,
+				   MC34VR500_SW4VOLT };
+
+static uint8_t swx_set_point_base[4] = { 13, 9, 9, 9 };
+
+int mc34vr500_get_sw_volt(uint8_t sw)
+{
+	struct pmic *p;
+	u32 swxvolt;
+	uint8_t spb;
+	int sw_volt;
+	int ret;
+
+	debug("%s: Get SW%u volt from swxvolt_addr = 0x%x\n",
+	      __func__, sw + 1, swxvolt_addr[sw]);
+	if (sw > SW4) {
+		printf("%s: Unsupported SW(sw%d)\n", __func__, sw + 1);
+		return -EINVAL;
+	}
+
+	p = pmic_get("MC34VR500");
+	if (!p) {
+		printf("%s: Did NOT find PMIC MC34VR500\n", __func__);
+		return -ENODEV;
+	}
+
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	ret = pmic_reg_read(p, swxvolt_addr[sw], &swxvolt);
+	if (ret) {
+		printf("%s: Failed to get SW%u volt\n", __func__, sw + 1);
+		return ret;
+	}
+
+	debug("%s: SW%d step point swxvolt = %u\n", __func__, sw + 1, swxvolt);
+	spb = swx_set_point_base[sw];
+	/* The base of SW volt is 625mV and increase by step 25mV */
+	sw_volt = 625 + (swxvolt - spb) * 25;
+
+	debug("%s: SW%u volt = %dmV\n", __func__, sw + 1, sw_volt);
+	return sw_volt;
+}
+
+int mc34vr500_set_sw_volt(uint8_t sw, int sw_volt)
+{
+	struct pmic *p;
+	u32 swxvolt;
+	uint8_t spb;
+	int ret;
+
+	debug("%s: Set SW%u volt to %dmV\n", __func__, sw + 1, sw_volt);
+	/* The least SW volt is 625mV, and only 4 SW outputs */
+	if (sw > SW4 || sw_volt < 625)
+		return -EINVAL;
+
+	p = pmic_get("MC34VR500");
+	if (!p) {
+		printf("%s: Did NOT find PMIC MC34VR500\n", __func__);
+		return -ENODEV;
+	}
+
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	spb = swx_set_point_base[sw];
+	/* The base of SW volt is 625mV and increase by step 25mV */
+	swxvolt = (sw_volt - 625) / 25 + spb;
+	debug("%s: SW%d step point swxvolt = %u\n", __func__, sw + 1, swxvolt);
+	if (swxvolt > 63)
+		return -EINVAL;
+
+	ret = pmic_reg_write(p, swxvolt_addr[sw], swxvolt);
+	if (ret)
+		return ret;
+
+	return 0;
+}
diff --git a/board/adlink/common/mmc.c b/board/adlink/common/mmc.c
new file mode 100644
index 00000000000..8cd5079f962
--- /dev/null
+++ b/board/adlink/common/mmc.c
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ * Copyright 2018-2022 NXP
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/sys_proto.h>
+#include <linux/errno.h>
+#include <asm/io.h>
+#include <stdbool.h>
+#include <mmc.h>
+#include <env.h>
+
+static int check_mmc_autodetect(void)
+{
+	char *autodetect_str = env_get("mmcautodetect");
+
+	if (autodetect_str && !strcmp(autodetect_str, "yes"))
+		return 1;
+
+	return 0;
+}
+
+/* This should be defined for each board */
+__weak int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_dev();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	env_set_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw", mmc_map_to_kernel_blk(dev_no));
+	env_set("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
diff --git a/board/adlink/common/mpc85xx_sleep.c b/board/adlink/common/mpc85xx_sleep.c
new file mode 100644
index 00000000000..d4ca278e883
--- /dev/null
+++ b/board/adlink/common/mpc85xx_sleep.c
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ */
+
+#include <log.h>
+#include <asm/cache.h>
+#include <asm/global_data.h>
+#include <asm/immap_85xx.h>
+#include "sleep.h"
+#ifdef CONFIG_U_QE
+#include <fsl_qe.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void __weak board_mem_sleep_setup(void)
+{
+}
+
+void __weak board_sleep_prepare(void)
+{
+}
+
+bool is_warm_boot(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)CFG_SYS_MPC85xx_GUTS_ADDR;
+
+	if (in_be32(&gur->scrtsr[0]) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_disable_console(void)
+{
+	gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+}
+
+/*
+ * When wakeup from deep sleep, the first 128 bytes space
+ * will be used to do DDR training which corrupts the data
+ * in there. This function will restore them.
+ */
+static void dp_ddr_restore(void)
+{
+	u64 *src, *dst;
+	int i;
+	struct ccsr_scfg __iomem *scfg = (void *)CFG_SYS_MPC85xx_SCFG;
+
+	/* get the address of ddr date from SPARECR3 */
+	src = (u64 *)(in_be32(&scfg->sparecr[2]) + DDR_BUFF_LEN - 8);
+	dst = (u64 *)(CFG_SYS_SDRAM_BASE + DDR_BUFF_LEN - 8);
+
+	for (i = 0; i < DDR_BUFF_LEN / 8; i++)
+		*dst-- = *src--;
+
+	flush_dcache();
+}
+
+static void dp_resume_prepare(void)
+{
+	dp_ddr_restore();
+
+	board_sleep_prepare();
+
+	l2cache_init();
+#if defined(CONFIG_RAMBOOT_PBL)
+	disable_cpc_sram();
+#endif
+	enable_cpc();
+
+#ifdef CONFIG_U_QE
+	u_qe_resume();
+#endif
+
+}
+
+int fsl_dp_resume(void)
+{
+	u32 start_addr;
+	void (*kernel_resume)(void);
+	struct ccsr_scfg __iomem *scfg = (void *)CFG_SYS_MPC85xx_SCFG;
+
+	if (!is_warm_boot())
+		return 0;
+
+	dp_resume_prepare();
+
+	/* Get the entry address and jump to kernel */
+	start_addr = in_be32(&scfg->sparecr[1]);
+	debug("Entry address is 0x%08x\n", start_addr);
+	kernel_resume = (void (*)(void))start_addr;
+	kernel_resume();
+
+	return 0;
+}
diff --git a/board/adlink/common/ngpixis.c b/board/adlink/common/ngpixis.c
new file mode 100644
index 00000000000..7be1ccee638
--- /dev/null
+++ b/board/adlink/common/ngpixis.c
@@ -0,0 +1,248 @@
+// SPDX-License-Identifier: GPL-2.0+
+/**
+ * Copyright 2010-2011 Freescale Semiconductor
+ * Author: Timur Tabi <timur@freescale.com>
+ *
+ * This file provides support for the ngPIXIS, a board-specific FPGA used on
+ * some Freescale reference boards.
+ *
+ * A "switch" is black rectangular block on the motherboard.  It contains
+ * eight "bits".  The ngPIXIS has a set of memory-mapped registers (SWx) that
+ * shadow the actual physical switches.  There is also another set of
+ * registers (ENx) that tell the ngPIXIS which bits of SWx should actually be
+ * used to override the values of the bits in the physical switches.
+ *
+ * The following macros need to be defined:
+ *
+ * PIXIS_BASE - The virtual address of the base of the PIXIS register map
+ *
+ * PIXIS_LBMAP_SWITCH - The switch number (i.e. the "x" in "SWx"). This value
+ *    is used in the PIXIS_SW() macro to determine which offset in
+ *    the PIXIS register map corresponds to the physical switch that controls
+ *    the boot bank.
+ *
+ * PIXIS_LBMAP_MASK - A bit mask the defines which bits in SWx to use.
+ *
+ * PIXIS_LBMAP_SHIFT - The shift value that corresponds to PIXIS_LBMAP_MASK.
+ *
+ * PIXIS_LBMAP_ALTBANK - The value to program into SWx to tell the ngPIXIS to
+ *    boot from the alternate bank.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+
+#include "ngpixis.h"
+
+static u8 __pixis_read(unsigned int reg)
+{
+	void *p = (void *)PIXIS_BASE;
+
+	return in_8(p + reg);
+}
+u8 pixis_read(unsigned int reg) __attribute__((weak, alias("__pixis_read")));
+
+static void __pixis_write(unsigned int reg, u8 value)
+{
+	void *p = (void *)PIXIS_BASE;
+
+	out_8(p + reg, value);
+}
+void pixis_write(unsigned int reg, u8 value)
+	__attribute__((weak, alias("__pixis_write")));
+
+/*
+ * Reset the board. This ignores the ENx registers.
+ */
+void __pixis_reset(void)
+{
+	PIXIS_WRITE(rst, 0);
+
+	while (1);
+}
+void pixis_reset(void) __attribute__((weak, alias("__pixis_reset")));
+
+/*
+ * Reset the board.  Like pixis_reset(), but it honors the ENx registers.
+ */
+void __pixis_bank_reset(void)
+{
+	PIXIS_WRITE(vctl, 0);
+	PIXIS_WRITE(vctl, 1);
+
+	while (1);
+}
+void pixis_bank_reset(void) __attribute__((weak, alias("__pixis_bank_reset")));
+
+/**
+ * Set the boot bank to the power-on default bank
+ */
+void __clear_altbank(void)
+{
+	u8 reg;
+
+	/* Tell the ngPIXIS to use this the bits in the physical switch for the
+	 * boot bank value, instead of the SWx register.  We need to be careful
+	 * only to set the bits in SWx that correspond to the boot bank.
+	 */
+	reg = PIXIS_READ(s[PIXIS_LBMAP_SWITCH - 1].en);
+	reg &= ~PIXIS_LBMAP_MASK;
+	PIXIS_WRITE(s[PIXIS_LBMAP_SWITCH - 1].en, reg);
+}
+void clear_altbank(void) __attribute__((weak, alias("__clear_altbank")));
+
+/**
+ * Set the boot bank to the alternate bank
+ */
+void __set_altbank(void)
+{
+	u8 reg;
+
+	/* Program the alternate bank number into the SWx register.
+	 */
+	reg = PIXIS_READ(s[PIXIS_LBMAP_SWITCH - 1].sw);
+	reg = (reg & ~PIXIS_LBMAP_MASK) | PIXIS_LBMAP_ALTBANK;
+	PIXIS_WRITE(s[PIXIS_LBMAP_SWITCH - 1].sw, reg);
+
+	/* Tell the ngPIXIS to use this the bits in the SWx register for the
+	 * boot bank value, instead of the physical switch.  We need to be
+	 * careful only to set the bits in SWx that correspond to the boot bank.
+	 */
+	reg = PIXIS_READ(s[PIXIS_LBMAP_SWITCH - 1].en);
+	reg |= PIXIS_LBMAP_MASK;
+	PIXIS_WRITE(s[PIXIS_LBMAP_SWITCH - 1].en, reg);
+}
+void set_altbank(void) __attribute__((weak, alias("__set_altbank")));
+
+#ifdef DEBUG
+static void pixis_dump_regs(void)
+{
+	unsigned int i;
+
+	printf("id=%02x\n", PIXIS_READ(id));
+	printf("arch=%02x\n", PIXIS_READ(arch));
+	printf("scver=%02x\n", PIXIS_READ(scver));
+	printf("csr=%02x\n", PIXIS_READ(csr));
+	printf("rst=%02x\n", PIXIS_READ(rst));
+	printf("aux=%02x\n", PIXIS_READ(aux));
+	printf("spd=%02x\n", PIXIS_READ(spd));
+	printf("brdcfg0=%02x\n", PIXIS_READ(brdcfg0));
+	printf("brdcfg1=%02x\n", PIXIS_READ(brdcfg1));
+	printf("addr=%02x\n", PIXIS_READ(addr));
+	printf("data=%02x\n", PIXIS_READ(data));
+	printf("led=%02x\n", PIXIS_READ(led));
+	printf("vctl=%02x\n", PIXIS_READ(vctl));
+	printf("vstat=%02x\n", PIXIS_READ(vstat));
+	printf("vcfgen0=%02x\n", PIXIS_READ(vcfgen0));
+	printf("ocmcsr=%02x\n", PIXIS_READ(ocmcsr));
+	printf("ocmmsg=%02x\n", PIXIS_READ(ocmmsg));
+	printf("gmdbg=%02x\n", PIXIS_READ(gmdbg));
+	printf("sclk=%02x%02x%02x\n",
+	       PIXIS_READ(sclk[0]), PIXIS_READ(sclk[1]), PIXIS_READ(sclk[2]));
+	printf("dclk=%02x%02x%02x\n",
+	       PIXIS_READ(dclk[0]), PIXIS_READ(dclk[1]), PIXIS_READ(dclk[2]));
+	printf("watch=%02x\n", PIXIS_READ(watch));
+
+	for (i = 0; i < 8; i++) {
+		printf("SW%u=%02x/%02x ", i + 1,
+			PIXIS_READ(s[i].sw), PIXIS_READ(s[i].en));
+	}
+	putc('\n');
+}
+#endif
+
+void pixis_sysclk_set(unsigned long sysclk)
+{
+	unsigned long freq_word;
+	u8 sclk0, sclk1, sclk2;
+
+	freq_word = ics307_sysclk_calculator(sysclk);
+	sclk2 = freq_word & 0xff;
+	sclk1 = (freq_word >> 8) & 0xff;
+	sclk0 = (freq_word >> 16) & 0xff;
+
+	/* set SYSCLK enable bit */
+	PIXIS_WRITE(vcfgen0, 0x01);
+
+	/* SYSCLK to required frequency */
+	PIXIS_WRITE(sclk[0], sclk0);
+	PIXIS_WRITE(sclk[1], sclk1);
+	PIXIS_WRITE(sclk[2], sclk2);
+}
+
+int pixis_reset_cmd(struct cmd_tbl *cmdtp, int flag, int argc,
+		    char *const argv[])
+{
+	unsigned int i;
+	unsigned long sysclk;
+	char *p_altbank = NULL;
+#ifdef DEBUG
+	char *p_dump = NULL;
+#endif
+	char *unknown_param = NULL;
+
+	/* No args is a simple reset request.
+	 */
+	if (argc <= 1)
+		pixis_reset();
+
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "altbank") == 0) {
+			p_altbank = argv[i];
+			continue;
+		}
+
+#ifdef DEBUG
+		if (strcmp(argv[i], "dump") == 0) {
+			p_dump = argv[i];
+			continue;
+		}
+#endif
+		if (strcmp(argv[i], "sysclk") == 0) {
+			sysclk = simple_strtoul(argv[i + 1], NULL, 0);
+			i += 1;
+			pixis_sysclk_set(sysclk);
+			continue;
+		}
+
+		unknown_param = argv[i];
+	}
+
+	if (unknown_param) {
+		printf("Invalid option: %s\n", unknown_param);
+		return 1;
+	}
+
+#ifdef DEBUG
+	if (p_dump) {
+		pixis_dump_regs();
+
+		/* 'dump' ignores other commands */
+		return 0;
+	}
+#endif
+
+	if (p_altbank)
+		set_altbank();
+	else
+		clear_altbank();
+
+	pixis_bank_reset();
+
+	/* Shouldn't be reached. */
+	return 0;
+}
+
+U_BOOT_LONGHELP(pixis,
+	"- hard reset to default bank\n"
+	"pixis_reset altbank - reset to alternate bank\n"
+#ifdef DEBUG
+	"pixis_reset dump - display the PIXIS registers\n"
+#endif
+	"pixis_reset sysclk <SYSCLK_freq> - reset with SYSCLK frequency(KHz)\n");
+
+U_BOOT_CMD(
+	pixis_reset, CONFIG_SYS_MAXARGS, 1, pixis_reset_cmd,
+	"Reset the board using the FPGA sequencer", pixis_help_text
+	);
diff --git a/board/adlink/common/ngpixis.h b/board/adlink/common/ngpixis.h
new file mode 100644
index 00000000000..7a20ee015fa
--- /dev/null
+++ b/board/adlink/common/ngpixis.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/**
+ * Copyright 2010-2011 Freescale Semiconductor
+ * Author: Timur Tabi <timur@freescale.com>
+ *
+ * This file provides support for the ngPIXIS, a board-specific FPGA used on
+ * some Freescale reference boards.
+ */
+
+/* ngPIXIS register set. Hopefully, this won't change too much over time.
+ * Feel free to add board-specific #ifdefs where necessary.
+ */
+typedef struct ngpixis {
+	u8 id;
+	u8 arch;
+	u8 scver;
+	u8 csr;
+	u8 rst;
+	u8 serclk;
+	u8 aux;
+	u8 spd;
+	u8 brdcfg0;
+	u8 brdcfg1;	/* On some boards, this register is called 'dma' */
+	u8 addr;
+	u8 brdcfg2;
+	u8 gpiodir;
+	u8 data;
+	u8 led;
+	u8 tag;
+	u8 vctl;
+	u8 vstat;
+	u8 vcfgen0;
+	u8 res4;
+	u8 ocmcsr;
+	u8 ocmmsg;
+	u8 gmdbg;
+	u8 res5[2];
+	u8 sclk[3];
+	u8 dclk[3];
+	u8 watch;
+	struct {
+		u8 sw;
+		u8 en;
+	} s[9];		/* s[0]..s[7] is SW1..SW8, and s[8] is SW11 */
+} __attribute__ ((packed)) ngpixis_t;
+
+/* Pointer to the PIXIS register set */
+#define pixis ((ngpixis_t *)PIXIS_BASE)
+
+/* The PIXIS SW register that corresponds to board switch X, where x >= 1 */
+#define PIXIS_SW(x)		(pixis->s[(x) - 1].sw)
+
+/* The PIXIS EN register that corresponds to board switch X, where x >= 1 */
+#define PIXIS_EN(x)		(pixis->s[(x) - 1].en)
+
+u8 pixis_read(unsigned int reg);
+void pixis_write(unsigned int reg, u8 value);
+
+#define PIXIS_READ(reg) pixis_read(offsetof(ngpixis_t, reg))
+#define PIXIS_WRITE(reg, value) pixis_write(offsetof(ngpixis_t, reg), value)
diff --git a/board/adlink/common/ns_access.c b/board/adlink/common/ns_access.c
new file mode 100644
index 00000000000..a95d15c1ef3
--- /dev/null
+++ b/board/adlink/common/ns_access.c
@@ -0,0 +1,241 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2014 Freescale Semiconductor
+ */
+
+#include <common.h>
+#include <log.h>
+#include <asm/cache.h>
+#include <asm/io.h>
+#include <fsl_csu.h>
+#include <asm/arch/ns_access.h>
+#include <asm/arch/fsl_serdes.h>
+
+#ifdef CONFIG_ARCH_LS1021A
+static struct csu_ns_dev ns_dev[] = {
+	{ CSU_CSLX_PCIE2_IO, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1_IO, CSU_ALL_RW },
+	{ CSU_CSLX_MG2TPR_IP, CSU_ALL_RW },
+	{ CSU_CSLX_IFC_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM, CSU_ALL_RW },
+	{ CSU_CSLX_GIC, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM2, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE2, CSU_ALL_RW },
+	{ CSU_CSLX_SATA, CSU_ALL_RW },
+	{ CSU_CSLX_USB3, CSU_ALL_RW },
+	{ CSU_CSLX_SERDES, CSU_ALL_RW },
+	{ CSU_CSLX_QDMA, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART2, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART1, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART4, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART3, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART6, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART5, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI2, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI1, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI, CSU_ALL_RW },
+	{ CSU_CSLX_ESDHC, CSU_ALL_RW },
+	{ CSU_CSLX_2D_ACE, CSU_ALL_RW },
+	{ CSU_CSLX_IFC, CSU_ALL_RW },
+	{ CSU_CSLX_I2C1, CSU_ALL_RW },
+	{ CSU_CSLX_USB2, CSU_ALL_RW },
+	{ CSU_CSLX_I2C3, CSU_ALL_RW },
+	{ CSU_CSLX_I2C2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART1, CSU_ALL_RW },
+	{ CSU_CSLX_WDT2, CSU_ALL_RW },
+	{ CSU_CSLX_WDT1, CSU_ALL_RW },
+	{ CSU_CSLX_EDMA, CSU_ALL_RW },
+	{ CSU_CSLX_SYS_CNT, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX2, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX1, CSU_ALL_RW },
+	{ CSU_CSLX_DDR, CSU_ALL_RW },
+	{ CSU_CSLX_QUICC, CSU_ALL_RW },
+	{ CSU_CSLX_DCFG_CCU_RCPM, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_BOOTROM, CSU_ALL_RW },
+	{ CSU_CSLX_SFP, CSU_ALL_RW },
+	{ CSU_CSLX_TMU, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_MONITOR, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED0, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC1, CSU_ALL_RW },
+	{ CSU_CSLX_SEC5_5, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC3, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO1, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO4, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO3, CSU_ALL_RW },
+	{ CSU_CSLX_PLATFORM_CONT, CSU_ALL_RW },
+	{ CSU_CSLX_CSU, CSU_ALL_RW },
+	{ CSU_CSLX_ASRC, CSU_ALL_RW },
+	{ CSU_CSLX_SPDIF, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN2, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN1, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN4, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN3, CSU_ALL_RW },
+	{ CSU_CSLX_SAI2, CSU_ALL_RW },
+	{ CSU_CSLX_SAI1, CSU_ALL_RW },
+	{ CSU_CSLX_SAI4, CSU_ALL_RW },
+	{ CSU_CSLX_SAI3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM2, CSU_ALL_RW },
+	{ CSU_CSLX_FTM1, CSU_ALL_RW },
+	{ CSU_CSLX_FTM4, CSU_ALL_RW },
+	{ CSU_CSLX_FTM3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM6, CSU_ALL_RW },
+	{ CSU_CSLX_FTM5, CSU_ALL_RW },
+	{ CSU_CSLX_FTM8, CSU_ALL_RW },
+	{ CSU_CSLX_FTM7, CSU_ALL_RW },
+	{ CSU_CSLX_COP_DCSR, CSU_ALL_RW },
+	{ CSU_CSLX_EPU, CSU_ALL_RW },
+	{ CSU_CSLX_GDI, CSU_ALL_RW },
+	{ CSU_CSLX_DDI, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED1, CSU_ALL_RW },
+	{ CSU_CSLX_USB3_PHY, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED2, CSU_ALL_RW },
+};
+
+#else
+static struct csu_ns_dev ns_dev[] = {
+	 {CSU_CSLX_PCIE2_IO, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE1_IO, CSU_ALL_RW},
+	 {CSU_CSLX_MG2TPR_IP, CSU_ALL_RW},
+	 {CSU_CSLX_IFC_MEM, CSU_ALL_RW},
+	 {CSU_CSLX_OCRAM, CSU_ALL_RW},
+	 {CSU_CSLX_GIC, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE1, CSU_ALL_RW},
+	 {CSU_CSLX_OCRAM2, CSU_ALL_RW},
+	 {CSU_CSLX_QSPI_MEM, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE2, CSU_ALL_RW},
+	 {CSU_CSLX_SATA, CSU_ALL_RW},
+	 {CSU_CSLX_USB1, CSU_ALL_RW},
+	 {CSU_CSLX_QM_BM_SWPORTAL, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE3, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE3_IO, CSU_ALL_RW},
+	 {CSU_CSLX_USB3, CSU_ALL_RW},
+	 {CSU_CSLX_USB2, CSU_ALL_RW},
+	 {CSU_CSLX_PFE, CSU_ALL_RW},
+	 {CSU_CSLX_SERDES, CSU_ALL_RW},
+	 {CSU_CSLX_QDMA, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART2, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART1, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART4, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART3, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART6, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART5, CSU_ALL_RW},
+	 {CSU_CSLX_DSPI1, CSU_ALL_RW},
+	 {CSU_CSLX_QSPI, CSU_ALL_RW},
+	 {CSU_CSLX_ESDHC, CSU_ALL_RW},
+	 {CSU_CSLX_IFC, CSU_ALL_RW},
+	 {CSU_CSLX_I2C1, CSU_ALL_RW},
+	 {CSU_CSLX_I2C3, CSU_ALL_RW},
+	 {CSU_CSLX_I2C2, CSU_ALL_RW},
+	 {CSU_CSLX_DUART2, CSU_ALL_RW},
+	 {CSU_CSLX_DUART1, CSU_ALL_RW},
+	 {CSU_CSLX_WDT2, CSU_ALL_RW},
+	 {CSU_CSLX_WDT1, CSU_ALL_RW},
+	 {CSU_CSLX_EDMA, CSU_ALL_RW},
+	 {CSU_CSLX_SYS_CNT, CSU_ALL_RW},
+	 {CSU_CSLX_DMA_MUX2, CSU_ALL_RW},
+	 {CSU_CSLX_DMA_MUX1, CSU_ALL_RW},
+	 {CSU_CSLX_DDR, CSU_ALL_RW},
+	 {CSU_CSLX_QUICC, CSU_ALL_RW},
+	 {CSU_CSLX_DCFG_CCU_RCPM, CSU_ALL_RW},
+	 {CSU_CSLX_SECURE_BOOTROM, CSU_ALL_RW},
+	 {CSU_CSLX_SFP, CSU_ALL_RW},
+	 {CSU_CSLX_TMU, CSU_ALL_RW},
+	 {CSU_CSLX_SECURE_MONITOR, CSU_ALL_RW},
+	 {CSU_CSLX_SCFG, CSU_ALL_RW},
+	 {CSU_CSLX_FM, CSU_ALL_RW},
+	 {CSU_CSLX_SEC5_5, CSU_ALL_RW},
+	 {CSU_CSLX_BM, CSU_ALL_RW},
+	 {CSU_CSLX_QM, CSU_ALL_RW},
+	 {CSU_CSLX_GPIO2, CSU_ALL_RW},
+	 {CSU_CSLX_GPIO1, CSU_ALL_RW},
+	 {CSU_CSLX_GPIO4, CSU_ALL_RW},
+	 {CSU_CSLX_GPIO3, CSU_ALL_RW},
+	 {CSU_CSLX_PLATFORM_CONT, CSU_ALL_RW},
+	 {CSU_CSLX_CSU, CSU_ALL_RW},
+	 {CSU_CSLX_IIC4, CSU_ALL_RW},
+	 {CSU_CSLX_WDT4, CSU_ALL_RW},
+	 {CSU_CSLX_WDT3, CSU_ALL_RW},
+	 {CSU_CSLX_ESDHC2, CSU_ALL_RW},
+	 {CSU_CSLX_WDT5, CSU_ALL_RW},
+	 {CSU_CSLX_SAI2, CSU_ALL_RW},
+	 {CSU_CSLX_SAI1, CSU_ALL_RW},
+	 {CSU_CSLX_SAI4, CSU_ALL_RW},
+	 {CSU_CSLX_SAI3, CSU_ALL_RW},
+	 {CSU_CSLX_FTM2, CSU_ALL_RW},
+	 {CSU_CSLX_FTM1, CSU_ALL_RW},
+	 {CSU_CSLX_FTM4, CSU_ALL_RW},
+	 {CSU_CSLX_FTM3, CSU_ALL_RW},
+	 {CSU_CSLX_FTM6, CSU_ALL_RW},
+	 {CSU_CSLX_FTM5, CSU_ALL_RW},
+	 {CSU_CSLX_FTM8, CSU_ALL_RW},
+	 {CSU_CSLX_FTM7, CSU_ALL_RW},
+	 {CSU_CSLX_DSCR, CSU_ALL_RW},
+};
+#endif
+
+void set_devices_ns_access(unsigned long index, u16 val)
+{
+	u32 *base = (u32 *)CFG_SYS_FSL_CSU_ADDR;
+	u32 *reg;
+	uint32_t tmp;
+
+	reg = base + index / 2;
+	tmp = in_be32(reg);
+	if (index % 2 == 0) {
+		tmp &= 0x0000ffff;
+		tmp |= val << 16;
+	} else {
+		tmp &= 0xffff0000;
+		tmp |= val;
+	}
+
+	out_be32(reg, tmp);
+}
+
+static void enable_devices_ns_access(struct csu_ns_dev *ns_dev, uint32_t num)
+{
+	int i;
+
+	for (i = 0; i < num; i++)
+		set_devices_ns_access(ns_dev[i].ind, ns_dev[i].val);
+}
+
+void enable_layerscape_ns_access(void)
+{
+#ifdef CONFIG_ARM64
+	if (current_el() == 3)
+#endif
+		enable_devices_ns_access(ns_dev, ARRAY_SIZE(ns_dev));
+}
+
+void set_pcie_ns_access(int pcie, u16 val)
+{
+	switch (pcie) {
+#ifdef CONFIG_PCIE1
+	case PCIE1:
+		set_devices_ns_access(CSU_CSLX_PCIE1, val);
+		set_devices_ns_access(CSU_CSLX_PCIE1_IO, val);
+		return;
+#endif
+#ifdef CONFIG_PCIE2
+	case PCIE2:
+		set_devices_ns_access(CSU_CSLX_PCIE2, val);
+		set_devices_ns_access(CSU_CSLX_PCIE2_IO, val);
+		return;
+#endif
+#ifdef CONFIG_PCIE3
+	case PCIE3:
+		set_devices_ns_access(CSU_CSLX_PCIE3, val);
+		set_devices_ns_access(CSU_CSLX_PCIE3_IO, val);
+		return;
+#endif
+	default:
+		debug("The PCIE%d doesn't exist!\n", pcie);
+		return;
+	}
+}
diff --git a/board/adlink/common/p_corenet/Makefile b/board/adlink/common/p_corenet/Makefile
new file mode 100644
index 00000000000..ce156018a06
--- /dev/null
+++ b/board/adlink/common/p_corenet/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# (C) Copyright 2002-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+
+obj-y			+= law.o
+obj-y			+= tlb.o
diff --git a/board/adlink/common/p_corenet/law.c b/board/adlink/common/p_corenet/law.c
new file mode 100644
index 00000000000..1a1e9343d23
--- /dev/null
+++ b/board/adlink/common/p_corenet/law.c
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CFG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
+#ifdef CFG_SYS_BMAN_MEM_PHYS
+	SET_LAW(CFG_SYS_BMAN_MEM_PHYS, LAW_SIZE_2M, LAW_TRGT_IF_BMAN),
+#endif
+#ifdef CFG_SYS_QMAN_MEM_PHYS
+	SET_LAW(CFG_SYS_QMAN_MEM_PHYS, LAW_SIZE_2M, LAW_TRGT_IF_QMAN),
+#endif
+#ifdef PIXIS_BASE_PHYS
+	SET_LAW(PIXIS_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_LBC),
+#endif
+#ifdef CPLD_BASE_PHYS
+	SET_LAW(CPLD_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_LBC),
+#endif
+#ifdef CFG_SYS_DCSRBAR_PHYS
+	/* Limit DCSR to 32M to access NPC Trace Buffer */
+	SET_LAW(CFG_SYS_DCSRBAR_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_DCSR),
+#endif
+#ifdef CFG_SYS_NAND_BASE_PHYS
+	SET_LAW(CFG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_LBC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/adlink/common/p_corenet/tlb.c b/board/adlink/common/p_corenet/tlb.c
new file mode 100644
index 00000000000..1a2d9cbfc0c
--- /dev/null
+++ b/board/adlink/common/p_corenet/tlb.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CFG_SYS_INIT_RAM_ADDR,
+		      CFG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CFG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CFG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CFG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CFG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CFG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CFG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+#ifdef CPLD_BASE
+	SET_TLB_ENTRY(0, CPLD_BASE, CPLD_BASE_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+#endif
+
+#ifdef PIXIS_BASE
+	SET_TLB_ENTRY(0, PIXIS_BASE, PIXIS_BASE_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+#endif
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CFG_SYS_INIT_L3_ADDR)
+
+#if !defined(CONFIG_NXP_ESBC)
+	/*
+	 * *I*G - L3SRAM. When L3 is used as 1M SRAM, the address of the
+	 * SRAM is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CFG_SYS_INIT_L3_ADDR, CFG_SYS_INIT_L3_ADDR,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_1M, 1),
+#else
+	/*
+	 * *I*G - L3SRAM. When L3 is used as 1M SRAM, in case of Secure Boot
+	 * the physical address of the SRAM is at CFG_SYS_INIT_L3_ADDR,
+	 * and virtual address is CONFIG_SYS_MONITOR_BASE
+	 */
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_MONITOR_BASE & 0xfff00000,
+			CFG_SYS_INIT_L3_ADDR & 0xfff00000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_1M, 1),
+#endif
+
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. When slave boot, the address of the
+	 * space is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CFG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR,
+			CFG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_W|MAS2_G,
+			0, 0, BOOKE_PAGESZ_1M, 1),
+#else
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#endif
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CFG_SYS_CCSRBAR, CFG_SYS_CCSRBAR_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_16M, 1),
+
+	/* *I*G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CFG_SYS_FLASH_BASE, CFG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CFG_SYS_PCIE1_MEM_VIRT, CFG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CFG_SYS_PCIE1_MEM_VIRT + 0x40000000,
+		      CFG_SYS_PCIE1_MEM_PHYS + 0x40000000,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256M, 1),
+
+	SET_TLB_ENTRY(1, CFG_SYS_PCIE1_MEM_VIRT + 0x50000000,
+		      CFG_SYS_PCIE1_MEM_PHYS + 0x50000000,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 5, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CFG_SYS_PCIE1_IO_VIRT, CFG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_256K, 1),
+
+	/* Bman/Qman */
+#ifdef CFG_SYS_BMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CFG_SYS_BMAN_MEM_BASE, CFG_SYS_BMAN_MEM_PHYS,
+		      MAS3_SW|MAS3_SR, 0,
+		      0, 9, BOOKE_PAGESZ_1M, 1),
+	SET_TLB_ENTRY(1, CFG_SYS_BMAN_MEM_BASE + 0x00100000,
+		      CFG_SYS_BMAN_MEM_PHYS + 0x00100000,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_1M, 1),
+#endif
+#ifdef CFG_SYS_QMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CFG_SYS_QMAN_MEM_BASE, CFG_SYS_QMAN_MEM_PHYS,
+		      MAS3_SW|MAS3_SR, 0,
+		      0, 11, BOOKE_PAGESZ_1M, 1),
+	SET_TLB_ENTRY(1, CFG_SYS_QMAN_MEM_BASE + 0x00100000,
+		      CFG_SYS_QMAN_MEM_PHYS + 0x00100000,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 12, BOOKE_PAGESZ_1M, 1),
+#endif
+#ifdef CFG_SYS_DCSRBAR_PHYS
+	SET_TLB_ENTRY(1, CFG_SYS_DCSRBAR, CFG_SYS_DCSRBAR_PHYS,
+		      MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 13, BOOKE_PAGESZ_4M, 1),
+#endif
+#ifdef CFG_SYS_NAND_BASE
+	/*
+	 * *I*G - NAND
+	 * entry 14 and 15 has been used hard coded, they will be disabled
+	 * in cpu_init_f, so we use entry 16 for nand.
+	 */
+	SET_TLB_ENTRY(1, CFG_SYS_NAND_BASE, CFG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 16, BOOKE_PAGESZ_1M, 1),
+#endif
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. 1M space from 0xffe00000 for
+	 * fetching ucode and ENV from master
+	 */
+	SET_TLB_ENTRY(1, CFG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR,
+		CFG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS,
+		MAS3_SX|MAS3_SW|MAS3_SR, MAS2_G,
+		0, 17, BOOKE_PAGESZ_1M, 1),
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/adlink/common/pfuze.c b/board/adlink/common/pfuze.c
new file mode 100644
index 00000000000..a9288820b2e
--- /dev/null
+++ b/board/adlink/common/pfuze.c
@@ -0,0 +1,173 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+
+#ifndef CONFIG_DM_PMIC_PFUZE100
+int pfuze_mode_init(struct pmic *p, u32 mode)
+{
+	unsigned char offset, i, switch_num;
+	u32 id;
+	int ret;
+
+	pmic_reg_read(p, PFUZE100_DEVICEID, &id);
+	id = id & 0xf;
+
+	if (id == 0) {
+		switch_num = 6;
+		offset = PFUZE100_SW1CMODE;
+	} else if (id == 1) {
+		switch_num = 4;
+		offset = PFUZE100_SW2MODE;
+	} else {
+		printf("Not supported, id=%d\n", id);
+		return -EINVAL;
+	}
+
+	ret = pmic_reg_write(p, PFUZE100_SW1ABMODE, mode);
+	if (ret < 0) {
+		printf("Set SW1AB mode error!\n");
+		return ret;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		ret = pmic_reg_write(p, offset + i * SWITCH_SIZE, mode);
+		if (ret < 0) {
+			printf("Set switch 0x%x mode error!\n",
+			       offset + i * SWITCH_SIZE);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+struct pmic *pfuze_common_init(unsigned char i2cbus)
+{
+	struct pmic *p;
+	int ret;
+	unsigned int reg;
+
+	ret = power_pfuze100_init(i2cbus);
+	if (ret)
+		return NULL;
+
+	p = pmic_get("PFUZE100");
+	ret = pmic_probe(p);
+	if (ret)
+		return NULL;
+
+	pmic_reg_read(p, PFUZE100_DEVICEID, &reg);
+	printf("PMIC:  PFUZE100 ID=0x%02x\n", reg);
+
+	/* Set SW1AB stanby volage to 0.975V */
+	pmic_reg_read(p, PFUZE100_SW1ABSTBY, &reg);
+	reg &= ~SW1x_STBY_MASK;
+	reg |= SW1x_0_975V;
+	pmic_reg_write(p, PFUZE100_SW1ABSTBY, reg);
+
+	/* Set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(p, PFUZE100_SW1ABCONF, &reg);
+	reg &= ~SW1xCONF_DVSSPEED_MASK;
+	reg |= SW1xCONF_DVSSPEED_4US;
+	pmic_reg_write(p, PFUZE100_SW1ABCONF, reg);
+
+	/* Set SW1C standby voltage to 0.975V */
+	pmic_reg_read(p, PFUZE100_SW1CSTBY, &reg);
+	reg &= ~SW1x_STBY_MASK;
+	reg |= SW1x_0_975V;
+	pmic_reg_write(p, PFUZE100_SW1CSTBY, reg);
+
+	/* Set SW1C/VDDSOC step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(p, PFUZE100_SW1CCONF, &reg);
+	reg &= ~SW1xCONF_DVSSPEED_MASK;
+	reg |= SW1xCONF_DVSSPEED_4US;
+	pmic_reg_write(p, PFUZE100_SW1CCONF, reg);
+
+	return p;
+}
+#elif defined(CONFIG_DM_PMIC)
+int pfuze_mode_init(struct udevice *dev, u32 mode)
+{
+	unsigned char offset, i, switch_num;
+	u32 id;
+	int ret;
+
+	id = pmic_reg_read(dev, PFUZE100_DEVICEID);
+	id = id & 0xf;
+
+	if (id == 0) {
+		switch_num = 6;
+		offset = PFUZE100_SW1CMODE;
+	} else if (id == 1) {
+		switch_num = 4;
+		offset = PFUZE100_SW2MODE;
+	} else {
+		printf("Not supported, id=%d\n", id);
+		return -EINVAL;
+	}
+
+	ret = pmic_reg_write(dev, PFUZE100_SW1ABMODE, mode);
+	if (ret < 0) {
+		printf("Set SW1AB mode error!\n");
+		return ret;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		ret = pmic_reg_write(dev, offset + i * SWITCH_SIZE, mode);
+		if (ret < 0) {
+			printf("Set switch 0x%x mode error!\n",
+			       offset + i * SWITCH_SIZE);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+struct udevice *pfuze_common_init(void)
+{
+	struct udevice *dev;
+	int ret;
+	unsigned int reg, dev_id, rev_id;
+
+	ret = pmic_get("pfuze100@8", &dev);
+	if (ret == -ENODEV)
+		return NULL;
+
+	dev_id = pmic_reg_read(dev, PFUZE100_DEVICEID);
+	rev_id = pmic_reg_read(dev, PFUZE100_REVID);
+	printf("PMIC: PFUZE100! DEV_ID=0x%x REV_ID=0x%x\n", dev_id, rev_id);
+
+	/* Set SW1AB stanby volage to 0.975V */
+	reg = pmic_reg_read(dev, PFUZE100_SW1ABSTBY);
+	reg &= ~SW1x_STBY_MASK;
+	reg |= SW1x_0_975V;
+	pmic_reg_write(dev, PFUZE100_SW1ABSTBY, reg);
+
+	/* Set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	reg = pmic_reg_read(dev, PFUZE100_SW1ABCONF);
+	reg &= ~SW1xCONF_DVSSPEED_MASK;
+	reg |= SW1xCONF_DVSSPEED_4US;
+	pmic_reg_write(dev, PFUZE100_SW1ABCONF, reg);
+
+	/* Set SW1C standby voltage to 0.975V */
+	reg = pmic_reg_read(dev, PFUZE100_SW1CSTBY);
+	reg &= ~SW1x_STBY_MASK;
+	reg |= SW1x_0_975V;
+	pmic_reg_write(dev, PFUZE100_SW1CSTBY, reg);
+
+	/* Set SW1C/VDDSOC step ramp up time from 16us to 4us/25mV */
+	reg = pmic_reg_read(dev, PFUZE100_SW1CCONF);
+	reg &= ~SW1xCONF_DVSSPEED_MASK;
+	reg |= SW1xCONF_DVSSPEED_4US;
+	pmic_reg_write(dev, PFUZE100_SW1CCONF, reg);
+
+	return dev;
+}
+#endif
diff --git a/board/adlink/common/pfuze.h b/board/adlink/common/pfuze.h
new file mode 100644
index 00000000000..45b49afaeb7
--- /dev/null
+++ b/board/adlink/common/pfuze.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __PFUZE_BOARD_HELPER__
+#define __PFUZE_BOARD_HELPER__
+
+#ifdef CONFIG_DM_PMIC_PFUZE100
+struct udevice *pfuze_common_init(void);
+int pfuze_mode_init(struct udevice *dev, u32 mode);
+#else
+struct pmic *pfuze_common_init(unsigned char i2cbus);
+int pfuze_mode_init(struct pmic *p, u32 mode);
+#endif
+
+#endif
diff --git a/board/adlink/common/qixis.c b/board/adlink/common/qixis.c
new file mode 100644
index 00000000000..da2c1de078b
--- /dev/null
+++ b/board/adlink/common/qixis.c
@@ -0,0 +1,388 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2011 Freescale Semiconductor
+ * Copyright 2020 NXP
+ * Author: Shengzhou Liu <Shengzhou.Liu@freescale.com>
+ *
+ * This file provides support for the QIXIS of some Freescale reference boards.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/time.h>
+#include <i2c.h>
+#include "qixis.h"
+
+#ifndef QIXIS_LBMAP_BRDCFG_REG
+/*
+ * For consistency with existing platforms
+ */
+#define QIXIS_LBMAP_BRDCFG_REG 0x00
+#endif
+
+#ifndef QIXIS_RCFG_CTL_RECONFIG_IDLE
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE 0x20
+#endif
+#ifndef QIXIS_RCFG_CTL_RECONFIG_START
+#define QIXIS_RCFG_CTL_RECONFIG_START 0x21
+#endif
+
+#ifdef CFG_SYS_I2C_FPGA_ADDR
+u8 qixis_read_i2c(unsigned int reg)
+{
+#if !CONFIG_IS_ENABLED(DM_I2C)
+	return i2c_reg_read(CFG_SYS_I2C_FPGA_ADDR, reg);
+#else
+	struct udevice *dev;
+
+	if (i2c_get_chip_for_busnum(0, CFG_SYS_I2C_FPGA_ADDR, 1, &dev))
+		return 0xff;
+
+	return dm_i2c_reg_read(dev, reg);
+#endif
+}
+
+void qixis_write_i2c(unsigned int reg, u8 value)
+{
+	u8 val = value;
+#if !CONFIG_IS_ENABLED(DM_I2C)
+	i2c_reg_write(CFG_SYS_I2C_FPGA_ADDR, reg, val);
+#else
+	struct udevice *dev;
+
+	if (!i2c_get_chip_for_busnum(0, CFG_SYS_I2C_FPGA_ADDR, 1, &dev))
+		dm_i2c_reg_write(dev, reg, val);
+#endif
+
+}
+#endif
+
+#ifdef QIXIS_BASE
+u8 qixis_read(unsigned int reg)
+{
+	void *p = (void *)QIXIS_BASE;
+
+	return in_8(p + reg);
+}
+
+void qixis_write(unsigned int reg, u8 value)
+{
+	void *p = (void *)QIXIS_BASE;
+
+	out_8(p + reg, value);
+}
+#endif
+
+u16 qixis_read_minor(void)
+{
+	u16 minor;
+
+	/* this data is in little endian */
+	QIXIS_WRITE(tagdata, 5);
+	minor = QIXIS_READ(tagdata);
+	QIXIS_WRITE(tagdata, 6);
+	minor += QIXIS_READ(tagdata) << 8;
+
+	return minor;
+}
+
+char *qixis_read_time(char *result)
+{
+	time_t time = 0;
+	int i;
+
+	/* timestamp is in 32-bit big endian */
+	for (i = 8; i <= 11; i++) {
+		QIXIS_WRITE(tagdata, i);
+		time =  (time << 8) + QIXIS_READ(tagdata);
+	}
+
+	return ctime_r(&time, result);
+}
+
+char *qixis_read_tag(char *buf)
+{
+	int i;
+	char tag, *ptr = buf;
+
+	for (i = 16; i <= 63; i++) {
+		QIXIS_WRITE(tagdata, i);
+		tag = QIXIS_READ(tagdata);
+		*(ptr++) = tag;
+		if (!tag)
+			break;
+	}
+	if (i > 63)
+		*ptr = '\0';
+
+	return buf;
+}
+
+/*
+ * return the string of binary of u8 in the format of
+ * 1010 10_0. The masked bit is filled as underscore.
+ */
+const char *byte_to_binary_mask(u8 val, u8 mask, char *buf)
+{
+	char *ptr;
+	int i;
+
+	ptr = buf;
+	for (i = 0x80; i > 0x08 ; i >>= 1, ptr++)
+		*ptr = (val & i) ? '1' : ((mask & i) ? '_' : '0');
+	*(ptr++) = ' ';
+	for (i = 0x08; i > 0 ; i >>= 1, ptr++)
+		*ptr = (val & i) ? '1' : ((mask & i) ? '_' : '0');
+
+	*ptr = '\0';
+
+	return buf;
+}
+
+#ifdef QIXIS_RST_FORCE_MEM
+void board_assert_mem_reset(void)
+{
+	u8 rst;
+
+	rst = QIXIS_READ(rst_frc[0]);
+	if (!(rst & QIXIS_RST_FORCE_MEM))
+		QIXIS_WRITE(rst_frc[0], rst | QIXIS_RST_FORCE_MEM);
+}
+
+void board_deassert_mem_reset(void)
+{
+	u8 rst;
+
+	rst = QIXIS_READ(rst_frc[0]);
+	if (rst & QIXIS_RST_FORCE_MEM)
+		QIXIS_WRITE(rst_frc[0], rst & ~QIXIS_RST_FORCE_MEM);
+}
+#endif
+
+#ifndef CONFIG_SPL_BUILD
+static void qixis_reset(void)
+{
+	QIXIS_WRITE(rst_ctl, QIXIS_RST_CTL_RESET);
+}
+
+#ifdef QIXIS_LBMAP_ALTBANK
+static void qixis_bank_reset(void)
+{
+	QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_IDLE);
+	QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_START);
+}
+#endif
+
+static void __maybe_unused set_lbmap(int lbmap)
+{
+	u8 reg;
+
+	reg = QIXIS_READ(brdcfg[QIXIS_LBMAP_BRDCFG_REG]);
+	reg = (reg & ~QIXIS_LBMAP_MASK) | lbmap;
+	QIXIS_WRITE(brdcfg[QIXIS_LBMAP_BRDCFG_REG], reg);
+}
+
+static void __maybe_unused set_rcw_src(int rcw_src)
+{
+#ifdef CONFIG_NXP_LSCH3_2
+	QIXIS_WRITE(dutcfg[0], (rcw_src & 0xff));
+#else
+	u8 reg;
+
+	reg = QIXIS_READ(dutcfg[1]);
+	reg = (reg & ~1) | (rcw_src & 1);
+	QIXIS_WRITE(dutcfg[1], reg);
+	QIXIS_WRITE(dutcfg[0], (rcw_src >> 1) & 0xff);
+#endif
+}
+
+static void qixis_dump_regs(void)
+{
+	int i;
+
+	printf("id	= %02x\n", QIXIS_READ(id));
+	printf("arch	= %02x\n", QIXIS_READ(arch));
+	printf("scver	= %02x\n", QIXIS_READ(scver));
+	printf("model	= %02x\n", QIXIS_READ(model));
+	printf("rst_ctl	= %02x\n", QIXIS_READ(rst_ctl));
+	printf("aux	= %02x\n", QIXIS_READ(aux));
+	for (i = 0; i < 16; i++)
+		printf("brdcfg%02d = %02x\n", i, QIXIS_READ(brdcfg[i]));
+	for (i = 0; i < 16; i++)
+		printf("dutcfg%02d = %02x\n", i, QIXIS_READ(dutcfg[i]));
+	printf("sclk	= %02x%02x%02x\n", QIXIS_READ(sclk[0]),
+		QIXIS_READ(sclk[1]), QIXIS_READ(sclk[2]));
+	printf("dclk	= %02x%02x%02x\n", QIXIS_READ(dclk[0]),
+		QIXIS_READ(dclk[1]), QIXIS_READ(dclk[2]));
+	printf("aux     = %02x\n", QIXIS_READ(aux));
+	printf("watch	= %02x\n", QIXIS_READ(watch));
+	printf("ctl_sys	= %02x\n", QIXIS_READ(ctl_sys));
+	printf("rcw_ctl = %02x\n", QIXIS_READ(rcw_ctl));
+	printf("present = %02x\n", QIXIS_READ(present));
+	printf("present2 = %02x\n", QIXIS_READ(present2));
+	printf("clk_spd = %02x\n", QIXIS_READ(clk_spd));
+	printf("stat_dut = %02x\n", QIXIS_READ(stat_dut));
+	printf("stat_sys = %02x\n", QIXIS_READ(stat_sys));
+	printf("stat_alrm = %02x\n", QIXIS_READ(stat_alrm));
+}
+
+void __weak qixis_dump_switch(void)
+{
+	puts("Reverse engineering switch is not implemented for this board\n");
+}
+
+static int qixis_reset_cmd(struct cmd_tbl *cmdtp, int flag, int argc,
+			   char *const argv[])
+{
+	int i;
+
+	if (argc <= 1) {
+		set_lbmap(QIXIS_LBMAP_DFLTBANK);
+		qixis_reset();
+	} else if (strcmp(argv[1], "altbank") == 0) {
+#ifdef QIXIS_LBMAP_ALTBANK
+		set_lbmap(QIXIS_LBMAP_ALTBANK);
+		qixis_bank_reset();
+#else
+		printf("No Altbank!\n");
+#endif
+	} else if (strcmp(argv[1], "nand") == 0) {
+#ifdef QIXIS_LBMAP_NAND
+		QIXIS_WRITE(rst_ctl, 0x30);
+		QIXIS_WRITE(rcfg_ctl, 0);
+		set_lbmap(QIXIS_LBMAP_NAND);
+		set_rcw_src(QIXIS_RCW_SRC_NAND);
+		QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_IDLE);
+		QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_START);
+#else
+		printf("Not implemented\n");
+#endif
+	} else if (strcmp(argv[1], "sd") == 0) {
+#ifdef QIXIS_LBMAP_SD
+		QIXIS_WRITE(rst_ctl, 0x30);
+		QIXIS_WRITE(rcfg_ctl, 0);
+#ifdef NON_EXTENDED_DUTCFG
+		QIXIS_WRITE(dutcfg[0], QIXIS_RCW_SRC_SD);
+#else
+		set_lbmap(QIXIS_LBMAP_SD);
+		set_rcw_src(QIXIS_RCW_SRC_SD);
+#endif
+		QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_IDLE);
+		QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_START);
+#else
+		printf("Not implemented\n");
+#endif
+	} else if (strcmp(argv[1], "ifc") == 0) {
+#ifdef QIXIS_LBMAP_IFC
+		QIXIS_WRITE(rst_ctl, 0x30);
+		QIXIS_WRITE(rcfg_ctl, 0);
+		set_lbmap(QIXIS_LBMAP_IFC);
+		set_rcw_src(QIXIS_RCW_SRC_IFC);
+		QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_IDLE);
+		QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_START);
+#else
+		printf("Not implemented\n");
+#endif
+	} else if (strcmp(argv[1], "emmc") == 0) {
+#ifdef QIXIS_LBMAP_EMMC
+		QIXIS_WRITE(rst_ctl, 0x30);
+		QIXIS_WRITE(rcfg_ctl, 0);
+#ifndef NON_EXTENDED_DUTCFG
+		set_lbmap(QIXIS_LBMAP_EMMC);
+#endif
+		set_rcw_src(QIXIS_RCW_SRC_EMMC);
+		QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_IDLE);
+		QIXIS_WRITE(rcfg_ctl, QIXIS_RCFG_CTL_RECONFIG_START);
+#else
+		printf("Not implemented\n");
+#endif
+	} else if (strcmp(argv[1], "sd_qspi") == 0) {
+#ifdef QIXIS_LBMAP_SD_QSPI
+		QIXIS_WRITE(rst_ctl, 0x30);
+		QIXIS_WRITE(rcfg_ctl, 0);
+		set_lbmap(QIXIS_LBMAP_SD_QSPI);
+		set_rcw_src(QIXIS_RCW_SRC_SD);
+		qixis_write_i2c(offsetof(struct qixis, rcfg_ctl),
+				QIXIS_RCFG_CTL_RECONFIG_IDLE);
+		qixis_write_i2c(offsetof(struct qixis, rcfg_ctl),
+				QIXIS_RCFG_CTL_RECONFIG_START);
+#else
+		printf("Not implemented\n");
+#endif
+	} else if (strcmp(argv[1], "qspi") == 0) {
+#ifdef QIXIS_LBMAP_QSPI
+		QIXIS_WRITE(rst_ctl, 0x30);
+		QIXIS_WRITE(rcfg_ctl, 0);
+		set_lbmap(QIXIS_LBMAP_QSPI);
+		set_rcw_src(QIXIS_RCW_SRC_QSPI);
+		qixis_write_i2c(offsetof(struct qixis, rcfg_ctl),
+				QIXIS_RCFG_CTL_RECONFIG_IDLE);
+		qixis_write_i2c(offsetof(struct qixis, rcfg_ctl),
+				QIXIS_RCFG_CTL_RECONFIG_START);
+#else
+		printf("Not implemented\n");
+#endif
+	} else if (strcmp(argv[1], "xspi") == 0) {
+#ifdef QIXIS_LBMAP_XSPI
+		QIXIS_WRITE(rst_ctl, 0x30);
+		QIXIS_WRITE(rcfg_ctl, 0);
+		set_lbmap(QIXIS_LBMAP_XSPI);
+		set_rcw_src(QIXIS_RCW_SRC_XSPI);
+		qixis_write_i2c(offsetof(struct qixis, rcfg_ctl),
+				QIXIS_RCFG_CTL_RECONFIG_IDLE);
+		qixis_write_i2c(offsetof(struct qixis, rcfg_ctl),
+				QIXIS_RCFG_CTL_RECONFIG_START);
+#else
+		printf("Not implemented\n");
+#endif
+	} else if (strcmp(argv[1], "watchdog") == 0) {
+		static char *period[9] = {"2s", "4s", "8s", "16s", "32s",
+					  "1min", "2min", "4min", "8min"};
+		u8 rcfg = QIXIS_READ(rcfg_ctl);
+
+		if (argv[2] == NULL) {
+			printf("qixis watchdog <watchdog_period>\n");
+			return 0;
+		}
+		for (i = 0; i < ARRAY_SIZE(period); i++) {
+			if (strcmp(argv[2], period[i]) == 0) {
+				/* disable watchdog */
+				QIXIS_WRITE(rcfg_ctl,
+					rcfg & ~QIXIS_RCFG_CTL_WATCHDOG_ENBLE);
+				QIXIS_WRITE(watch, ((i<<2) - 1));
+				QIXIS_WRITE(rcfg_ctl, rcfg);
+				return 0;
+			}
+		}
+	} else if (strcmp(argv[1], "dump") == 0) {
+		qixis_dump_regs();
+		return 0;
+	} else if (strcmp(argv[1], "switch") == 0) {
+		qixis_dump_switch();
+		return 0;
+	} else {
+		printf("Invalid option: %s\n", argv[1]);
+		return 1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	qixis_reset, CONFIG_SYS_MAXARGS, 1, qixis_reset_cmd,
+	"Reset the board using the FPGA sequencer",
+	"- hard reset to default bank\n"
+	"qixis_reset altbank - reset to alternate bank\n"
+	"qixis_reset nand - reset to nand\n"
+	"qixis_reset sd - reset to sd\n"
+	"qixis_reset sd_qspi - reset to sd with qspi support\n"
+	"qixis_reset qspi - reset to qspi\n"
+	"qixis watchdog <watchdog_period> - set the watchdog period\n"
+	"	period: 1s 2s 4s 8s 16s 32s 1min 2min 4min 8min\n"
+	"qixis_reset dump - display the QIXIS registers\n"
+	"qixis_reset emmc - reset to emmc\n"
+	"qixis_reset switch - display switch\n"
+	);
+#endif
diff --git a/board/adlink/common/qixis.h b/board/adlink/common/qixis.h
new file mode 100644
index 00000000000..784046ac4e0
--- /dev/null
+++ b/board/adlink/common/qixis.h
@@ -0,0 +1,190 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2011 Freescale Semiconductor
+ * Copyright 2020 NXP
+ * Author: Shengzhou Liu <Shengzhou.Liu@freescale.com>
+ *
+ * This file provides support for the QIXIS of some Freescale reference boards.
+ */
+
+#ifndef __QIXIS_H_
+#define __QIXIS_H_
+
+struct qixis {
+	u8 id;      /* ID value uniquely identifying each QDS board type */
+	u8 arch;    /* Board version information */
+	u8 scver;   /* QIXIS Version Register */
+	u8 model;   /* Information of software programming model version */
+	u8 tagdata;
+	u8 ctl_sys;
+	u8 aux;         /* Auxiliary Register,0x06 */
+	u8 clk_spd;
+	u8 stat_dut;
+	u8 stat_sys;
+	u8 stat_alrm;
+	u8 present;
+	u8 present2;    /* Presence Status Register 2,0x0c */
+	u8 rcw_ctl;
+	u8 ctl_led;
+	u8 i2cblk;
+	u8 rcfg_ctl;    /* Reconfig Control Register,0x10 */
+	u8 rcfg_st;
+	u8 dcm_ad;
+	u8 dcm_da;
+	u8 dcmd;
+	u8 dmsg;
+	u8 gdc;
+	u8 gdd;         /* DCM Debug Data Register,0x17 */
+	u8 dmack;
+	u8 res1;
+	u8 sdhc1;
+	u8 sdhc2;
+	u8 stat_pres3;
+	u8 los_stat;
+	u8 usb_ctl;
+	u8 watch;       /* Watchdog Register,0x1F */
+	u8 pwr_ctl[2];  /* Power Control Register,0x20 */
+	u8 res2[2];
+	u8 pwr_stat[4]; /* Power Status Register,0x24 */
+	u8 res3[8];
+	u8 clk_spd2[2];  /* SYSCLK clock Speed Register,0x30 */
+	u8 res4[2];
+	u8 sclk[3];  /* Clock Configuration Registers,0x34 */
+	u8 res5;
+	u8 dclk[3];
+	u8 res6;
+	u8 clk_dspd[3];
+	u8 res7;
+	u8 rst_ctl;     /* Reset Control Register,0x40 */
+	u8 rst_stat;    /* Reset Status Register */
+	u8 rst_rsn;     /* Reset Reason Register */
+	u8 rst_frc[2];  /* Reset Force Registers,0x43 */
+	u8 res8[11];
+	u8 brdcfg[16];  /* Board Configuration Register,0x50 */
+	u8 dutcfg[16];
+	u8 rcw_ad[2];   /* RCW SRAM Address Registers,0x70 */
+	u8 rcw_data;
+	u8 res9[5];
+	u8 post_ctl;
+	u8 post_stat;
+	u8 post_dat[2];
+	u8 pi_d[4];
+	u8 gpio_io[4];
+	u8 gpio_dir[4];
+	u8 res10[20];
+	u8 rjtag_ctl;
+	u8 rjtag_dat;
+	u8 res11[2];
+	u8 trig_src[4];
+	u8 trig_dst[4];
+	u8 trig_stat;
+	u8 res12[3];
+	u8 trig_ctr[4];
+	u8 res13[16];
+	u8 clk_freq[6];	/* Clock Measurement Registers */
+	u8 res_c6[8];
+	u8 clk_base[2];	/* Clock Frequency Base Reg */
+	u8 res_d0[8];
+	u8 cms[2];	/* Core Management Space Address Register, 0xD8 */
+	u8 res_c0[6];
+	u8 aux2[4];	/* Auxiliary Registers,0xE0 */
+	u8 res14[10];
+	u8 aux_ad;
+	u8 aux_da;
+	u8 res15[16];
+};
+
+u8 qixis_read(unsigned int reg);
+void qixis_write(unsigned int reg, u8 value);
+u16 qixis_read_minor(void);
+char *qixis_read_time(char *result);
+char *qixis_read_tag(char *buf);
+const char *byte_to_binary_mask(u8 val, u8 mask, char *buf);
+#ifdef CFG_SYS_I2C_FPGA_ADDR
+u8 qixis_read_i2c(unsigned int reg);
+void qixis_write_i2c(unsigned int reg, u8 value);
+#endif
+
+#if defined(CONFIG_QIXIS_I2C_ACCESS) && defined(CFG_SYS_I2C_FPGA_ADDR)
+#define QIXIS_READ(reg) qixis_read_i2c(offsetof(struct qixis, reg))
+#define QIXIS_WRITE(reg, value) \
+	qixis_write_i2c(offsetof(struct qixis, reg), value)
+#else
+#define QIXIS_READ(reg) qixis_read(offsetof(struct qixis, reg))
+#define QIXIS_WRITE(reg, value) qixis_write(offsetof(struct qixis, reg), value)
+#endif
+
+#ifdef CFG_SYS_I2C_FPGA_ADDR
+#define QIXIS_READ_I2C(reg) qixis_read_i2c(offsetof(struct qixis, reg))
+#define QIXIS_WRITE_I2C(reg, value) \
+			qixis_write_i2c(offsetof(struct qixis, reg), value)
+#endif
+
+/* Use for SDHC adapter card type identification and operation */
+#define QIXIS_SDID_MASK                         0x07
+
+#define QIXIS_ESDHC_ADAPTER_TYPE_EMMC45         0x1	/* eMMC Card Rev4.5 */
+#define QIXIS_ESDHC_ADAPTER_TYPE_SDMMC_LEGACY   0x2	/* SD/MMC Legacy Card */
+#define QIXIS_ESDHC_ADAPTER_TYPE_EMMC44         0x3	/* eMMC Card Rev4.4 */
+#define QIXIS_ESDHC_ADAPTER_TYPE_RSV            0x4	/* Reserved */
+#define QIXIS_ESDHC_ADAPTER_TYPE_MMC            0x5	/* MMC Card */
+#define QIXIS_ESDHC_ADAPTER_TYPE_SD             0x6	/* SD Card Rev2.0 3.0 */
+#define QIXIS_ESDHC_NO_ADAPTER                  0x7	/* No Card is Present*/
+
+#define QIXIS_SDHC1_S1V3	0x80	/* SDHC1: SDHC1 3.3V power control */
+#define QIXIS_SDHC1_VS		0x30	/* BRDCFG11: route to SDHC1_VS */
+
+#define QIXIS_SDCLKIN		0x08
+#define QIXIS_SDCLKOUT		0x02
+#define QIXIS_DAT5_6_7		0X02
+#define QIXIS_DAT4		0X01
+
+#define QIXIS_EVDD_BY_SDHC_VS	0x0c
+
+#if defined(CONFIG_TARGET_LX2160AQDS) || defined(CONFIG_TARGET_LX2162AQDS) || \
+defined(CONFIG_TARGET_LX2160ARDB)
+#define QIXIS_XMAP_MASK			0x07
+#define QIXIS_RST_CTL_RESET_EN		0x30
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x20
+#define QIXIS_LBMAP_QSPI		0x00
+#define QIXIS_RCW_SRC_QSPI		0xff
+#define QIXIS_RST_CTL_RESET		0x31
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SD
+#define QIXIS_LBMAP_EMMC
+#define QIXIS_RCW_SRC_SD		0x08
+#define QIXIS_RCW_SRC_EMMC         0x09
+#define NON_EXTENDED_DUTCFG
+#endif
+
+#if defined(CONFIG_TARGET_LX2160AQDS) || defined(CONFIG_TARGET_LX2162AQDS)
+#define QIXIS_SDID_MASK			0x07
+#define QIXIS_ESDHC_NO_ADAPTER		0x7
+#endif
+
+/*
+ * implementation of CONFIG_ESDHC_DETECT_QUIRK Macro.
+ */
+static inline u8 qixis_esdhc_detect_quirk(void)
+{
+	/*
+	 * SDHC1 Card ID:
+	 * Specifies the type of card installed in the SDHC1 adapter slot.
+	 * 000= (reserved)
+	 * 001= eMMC V4.5 adapter is installed.
+	 * 010= SD/MMC 3.3V adapter is installed.
+	 * 011= eMMC V4.4 adapter is installed.
+	 * 100= eMMC V5.0 adapter is installed.
+	 * 101= MMC card/Legacy (3.3V) adapter is installed.
+	 * 110= SDCard V2/V3 adapter installed.
+	 * 111= no adapter is installed.
+	 */
+	return ((QIXIS_READ(sdhc1) & QIXIS_SDID_MASK) !=
+		 QIXIS_ESDHC_NO_ADAPTER);
+}
+
+#endif
diff --git a/board/adlink/common/qsfp_eeprom.c b/board/adlink/common/qsfp_eeprom.c
new file mode 100644
index 00000000000..d57a10d663a
--- /dev/null
+++ b/board/adlink/common/qsfp_eeprom.c
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019-2022 NXP
+ */
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <linux/ctype.h>
+
+#define DEV_ID_QSFP		0x0c
+#define DEV_ID_QSFP_PLUS	0x0d
+
+static struct __attribute__ ((__packed__)) qsfp_eeprom_map {
+	struct __attribute__ ((__packed__)) qsfp_low_mem {
+	/*	field			byte address */
+	u8	identifier;		/* 0 */
+	u16	status;			/* 1-2 */
+	u8	reserved[124];		/* 3-126 */
+	u8	page_select;		/* 127 */
+	} base;
+
+	struct __attribute__ ((__packed__)) qsfp_page00_mem {
+	/*	field			byte address */
+	u8	identifier;		/* 128 */
+	u8	ext_identifier;		/* 129 */
+	u8	connector;		/* 130 */
+	u8	compat[8];		/* 131-138 */
+	u8	reserved[3];		/* 139-142 */
+	u8	length_fiber[4];
+	u8	length_copper;		/* 146 */
+	u8	tech;			/* 147 */
+	u8	vendor_name[16];	/* 148-163 */
+	u8	reserved2;		/* 164 */
+	u8	oui[3];			/* 165-167 */
+	u8	pn[16];			/* 168-183 */
+	u8	rev[2];			/* 184-185 */
+	u8	reserved3[10];		/* 186-195 */
+	u8	serial[16];		/* 196-211 */
+	u8	date[8];		/* 212-219 */
+	u8	reserved4[35];		/* 220-255 */
+	} page0;
+} qsfp;
+
+unsigned char get_qsfp_compat0(void)
+{
+	int ret;
+	char vendor[20] = {0};
+	char serial[20] = {0};
+	char pname[20] = {0};
+	char mfgdt[20] = {0};
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
+
+	memset(&qsfp, 0, sizeof(qsfp));
+#ifndef CONFIG_DM_I2C
+	ret = i2c_read(I2C_SFP_EEPROM_ADDR,
+		       0,
+		       I2C_SFP_EEPROM_ADDR_LEN,
+		       (void *)&qsfp,
+		       sizeof(qsfp));
+#else
+	ret = i2c_get_chip_for_busnum(0, I2C_SFP_EEPROM_ADDR, 1, &dev);
+	if (!ret)
+		ret = dm_i2c_read(dev, 0, (void *)&qsfp, sizeof(qsfp));
+#endif
+
+	if (ret != 0) {
+		debug("\nQSFP: no module detected\n");
+		return 0;
+	}
+	/* check if QSFP type */
+	if (qsfp.base.identifier != DEV_ID_QSFP_PLUS) {
+		debug("\nQSFP: unrecognized module\n");
+		return 0;
+	}
+
+	/* copy fields and trim the whitespaces and dump on screen */
+	snprintf(vendor, sizeof(vendor), "%.16s", qsfp.page0.vendor_name);
+	snprintf(serial, sizeof(serial), "%.16s", qsfp.page0.serial);
+	snprintf(pname, sizeof(pname), "%.16s", qsfp.page0.pn);
+	snprintf(mfgdt, sizeof(mfgdt), "%.2s/%.2s/%.2s",
+		 &qsfp.page0.date[0], &qsfp.page0.date[2], &qsfp.page0.date[4]);
+
+	printf("QSFP: detected %s %s s/n: %s mfgdt: %s\n",
+	       strim(vendor), strim(pname), strim(serial), strim(mfgdt));
+
+	/* return ethernet compatibility code*/
+	return qsfp.page0.compat[0];
+}
diff --git a/board/adlink/common/qsfp_eeprom.h b/board/adlink/common/qsfp_eeprom.h
new file mode 100644
index 00000000000..4aab21997fd
--- /dev/null
+++ b/board/adlink/common/qsfp_eeprom.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2019-2022 NXP
+ */
+
+#ifndef __QSFP_EEPROM_H_
+#define __QSFP_EEPROM_H_
+/*
+ * QSFP eeprom reader external API interface.
+ */
+
+/* return the ethernet compatibility field 0 */
+unsigned char get_qsfp_compat0(void);
+#endif  /* __QSFP_EEPROM_H_ */
diff --git a/board/adlink/common/qspi_header b/board/adlink/common/qspi_header
new file mode 100644
index 00000000000..d4f3c12d418
--- /dev/null
+++ b/board/adlink/common/qspi_header
@@ -0,0 +1,128 @@
+0			/*dqs_loopback=0 or 1*/
+0			/*hold_delay=0 to 3*/
+0			/*hsphs=0 (Half Speed Phase sampling at non-inverted clock) or 1 (sampling at inverted clock)*/
+0			/*hsdly=0 (Half Speed Delay one clk delay) or 1 (two clk cycle delay)*/
+0			/*device_quad_mode_en=1 to enable sending command to SPI device*/
+0			/*device_cmd=command to device for enableing Quad I/O mode*/
+0			/*write_cmd_ipcr=hex value to be written to IPCR register for write cmd of device*/
+2000000			/*write_enable_ipcr=hex value to be written to IPCR register for write enable of device*/
+3			/*cs_hold_time=0 to 0xF*/
+3			/*cs_setup_time=0 to 0xF*/
+8000000		/*sflash_A1_size=size in byte(hex)*/
+0		/*sflash_A2_size=size in byte(hex)*/
+8000000		/*sflash_B1_size=size in byte(hex)*/
+0		/*sflash_B2_size=size in byte(hex)*/
+0			/*sclk_freq=0 to 6*/
+0			/*busy_bit_offset=bit position of device BUSY in device status register*/
+1			/*sflash_type=1 (Single), 2 (Dual), 4 (Quad mode of operation)*/
+0			/*sflash_port=0 or 1 (Port B used)*/
+0			/*ddr_mode_enable=0 or 1*/
+0			/*dqs_enable=0 or 1*/
+0			/*parallel_mode_enable=0 or 1*/
+0			/*portA_cs1=0 or 1*/
+0			/*portB_cs1=0 or 1*/
+0			/*fsphs=0 (Full Speed Phase sampling at non-inverted clock) or 1 (sampling at inverted clock)*/
+0			/*fsdly=0 (Full Speed Delay One clk delay) or 1 (two clk cycle delay)*/
+0			/*ddrsmp=0 to 7 (sampling point for incoming data in DDR mode)*/
+08180403		/*lut[0] command sequence*/
+24001c00		/*lut[1] command sequence*/
+0			/*lut[2] command sequence*/
+0			/*lut[3] command sequence*/
+0			/*lut[4] command sequence*/
+0			/*lut[5] command sequence*/
+0			/*lut[6] command sequence*/
+0			/*lut[7] command sequence*/
+0			/*lut[8] command sequence*/
+0			/*lut[9] command sequence*/
+0			/*lut[10] command sequence*/
+0			/*lut[11] command sequence*/
+0			/*lut[12] command sequence*/
+0			/*lut[13] command sequence*/
+0			/*lut[14] command sequence*/
+0			/*lut[15] command sequence*/
+0			/*lut[16] command sequence*/
+0			/*lut[17] command sequence*/
+0			/*lut[18] command sequence*/
+0			/*lut[19] command sequence*/
+0			/*lut[20] command sequence*/
+0			/*lut[21] command sequence*/
+0			/*lut[22] command sequence*/
+0			/*lut[23] command sequence*/
+0			/*lut[24] command sequence*/
+0			/*lut[25] command sequence*/
+0			/*lut[26] command sequence*/
+0			/*lut[27] command sequence*/
+0			/*lut[28] command sequence*/
+0			/*lut[29] command sequence*/
+0			/*lut[30] command sequence*/
+0			/*lut[31] command sequence*/
+0			/*lut[32] command sequence*/
+0			/*lut[33] command sequence*/
+0			/*lut[34] command sequence*/
+0			/*lut[35] command sequence*/
+0			/*lut[36] command sequence*/
+0			/*lut[37] command sequence*/
+0			/*lut[38] command sequence*/
+0			/*lut[39] command sequence*/
+0			/*lut[40] command sequence*/
+0			/*lut[41] command sequence*/
+0			/*lut[42] command sequence*/
+0			/*lut[43] command sequence*/
+0			/*lut[44] command sequence*/
+0			/*lut[45] command sequence*/
+0			/*lut[46] command sequence*/
+0			/*lut[47] command sequence*/
+0			/*lut[48] command sequence*/
+0			/*lut[49] command sequence*/
+0			/*lut[50] command sequence*/
+0			/*lut[51] command sequence*/
+0			/*lut[52] command sequence*/
+0			/*lut[53] command sequence*/
+0			/*lut[54] command sequence*/
+0			/*lut[55] command sequence*/
+0			/*lut[56] command sequence*/
+0			/*lut[57] command sequence*/
+0			/*lut[58] command sequence*/
+0			/*lut[59] command sequence*/
+0			/*lut[60] command sequence*/
+0			/*lut[61] command sequence*/
+0			/*lut[62] command sequence*/
+0			/*lut[63] command sequence*/
+1000001			/*read_status_ipcr=hex value to be written to IPCR register for reading status reg of device*/
+0			/*enable_dqs_phase=0 or 1*/
+0			/*config_cmds_en, enable config command*/
+0			/*config_cmds[0]*/
+0			/*config_cmds[1]*/
+0			/*config_cmds[2]*/
+0			/*config_cmds[3]*/
+0			/*config_cmds_args[0]*/
+0			/*config_cmds_args[1]*/
+0			/*config_cmds_args[2]*/
+0			/*config_cmds_args[3]*/
+0			/*io_pad_override_setting QSPI pins override setting*/
+0			/*reserve[0], 25 byte reserved area*/
+0			/*reserve[1], 25 byte reserved area*/
+0			/*reserve[2], 25 byte reserved area*/
+0			/*reserve[3], 25 byte reserved area*/
+0			/*reserve[4], 25 byte reserved area*/
+0			/*reserve[5], 25 byte reserved area*/
+0			/*reserve[6], 25 byte reserved area*/
+0			/*reserve[7], 25 byte reserved area*/
+0			/*reserve[8], 25 byte reserved area*/
+0			/*reserve[9], 25 byte reserved area*/
+0			/*reserve[10], 25 byte reserved area*/
+0			/*reserve[11], 25 byte reserved area*/
+0			/*reserve[12], 25 byte reserved area*/
+0			/*reserve[13], 25 byte reserved area*/
+0			/*reserve[14], 25 byte reserved area*/
+0			/*reserve[15], 25 byte reserved area*/
+0			/*reserve[16], 25 byte reserved area*/
+0			/*reserve[17], 25 byte reserved area*/
+0			/*reserve[18], 25 byte reserved area*/
+0			/*reserve[19], 25 byte reserved area*/
+0			/*reserve[20], 25 byte reserved area*/
+0			/*reserve[21], 25 byte reserved area*/
+0			/*reserve[22], 25 byte reserved area*/
+0			/*reserve[23], 25 byte reserved area*/
+0			/*reserve[24], 25 byte reserved area*/
+c0ffee01	/*tag, QSPI configuration tag, should be 0xc0ffee01*/
diff --git a/board/adlink/common/recovery_keypad.c b/board/adlink/common/recovery_keypad.c
new file mode 100644
index 00000000000..2f5a58a92d8
--- /dev/null
+++ b/board/adlink/common/recovery_keypad.c
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier:	GPL-2.0+
+/*
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2017 NXP
+ *
+ */
+#include <common.h>
+#include <malloc.h>
+#include <recovery.h>
+#ifdef CONFIG_MXC_KPD
+#include <mxc_keyb.h>
+#endif
+#include <asm/mach-imx/boot_mode.h>
+
+#ifdef CONFIG_MXC_KPD
+#define PRESSED_VOL_DOWN	0x01
+#define PRESSED_POWER	    0x02
+#define RECOVERY_KEY_MASK (PRESSED_VOL_DOWN | PRESSED_POWER)
+
+inline int test_key(int value, struct kpp_key_info *ki)
+{
+	return (ki->val == value) && (ki->evt == KDepress);
+}
+
+int is_recovery_keypad_pressing(void)
+{
+	struct kpp_key_info *key_info = NULL;
+	int state = 0, keys, i;
+
+	int ret = 0;
+
+	mxc_kpp_init();
+	/* due to glitch suppression circuit,
+	   wait sometime to let all keys scanned. */
+	udelay(1000);
+	keys = mxc_kpp_getc(&key_info);
+
+	printf("Detecting VOL_DOWN+POWER key for recovery(%d:%d) ...\n",
+		keys, keys ? key_info->val : 0);
+	if (keys > 1) {
+		for (i = 0; i < keys; i++) {
+			if (test_key(CONFIG_POWER_KEY, &key_info[i]))
+				state |= PRESSED_POWER;
+			else if (test_key(CONFIG_VOL_DOWN_KEY, &key_info[i]))
+				state |= PRESSED_VOL_DOWN;
+		}
+	}
+	if ((state & RECOVERY_KEY_MASK) == RECOVERY_KEY_MASK)
+		ret = 1;
+	if (key_info)
+		free(key_info);
+	return ret;
+}
+#else
+/* If not using mxc keypad, currently we will detect power key on board */
+int is_recovery_keypad_pressing(void)
+{
+	return 0;
+}
+#endif
diff --git a/board/adlink/common/recovery_keypad.h b/board/adlink/common/recovery_keypad.h
new file mode 100644
index 00000000000..9adf2243e88
--- /dev/null
+++ b/board/adlink/common/recovery_keypad.h
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier:	GPL-2.0+
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2017 NXP
+ *
+ */
+
+#ifndef __RECOVERY_KEYPAD_H_
+#define __RECOVERY_KEYPAD_H_
+
+int is_recovery_keypad_pressing(void);
+
+#endif
diff --git a/board/adlink/common/sdhc_boot.c b/board/adlink/common/sdhc_boot.c
new file mode 100644
index 00000000000..a1c7a94a90e
--- /dev/null
+++ b/board/adlink/common/sdhc_boot.c
@@ -0,0 +1,79 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <mmc.h>
+#include <malloc.h>
+
+/*
+ * The environment variables are written to just after the u-boot image
+ * on SDCard, so we must read the MBR to get the start address and code
+ * length of the u-boot image, then calculate the address of the env.
+ */
+#define ESDHC_BOOT_IMAGE_SIZE	0x48
+#define ESDHC_BOOT_IMAGE_ADDR	0x50
+
+#define ESDHC_DEFAULT_ENVADDR	0x400
+
+int mmc_get_env_addr(struct mmc *mmc, int copy, u32 *env_addr)
+{
+	u8 *tmp_buf;
+	u32 blklen, code_offset, code_len, n;
+
+	blklen = mmc->read_bl_len;
+	tmp_buf = malloc(blklen);
+	if (!tmp_buf)
+		return 1;
+
+	/* read out the first block, get the config data information */
+#ifdef CONFIG_BLK
+	n = blk_dread(mmc_get_blk_desc(mmc), 0, 1, tmp_buf);
+#else
+	n = mmc->block_dev.block_read(&mmc->block_dev, 0, 1, tmp_buf);
+#endif
+	if (!n) {
+		free(tmp_buf);
+		return 1;
+	}
+
+	/* Get the Source Address, from offset 0x50 */
+	code_offset = *(u32 *)(tmp_buf + ESDHC_BOOT_IMAGE_ADDR);
+
+	/* Get the code size from offset 0x48 */
+	code_len = *(u32 *)(tmp_buf + ESDHC_BOOT_IMAGE_SIZE);
+
+#ifdef CONFIG_ESDHC_HC_BLK_ADDR
+	/*
+	 * On soc BSC9131, BSC9132:
+	 * In High Capacity SD Cards (> 2 GBytes), the 32-bit source address and
+	 * code length of these soc specify the memory address in block address
+	 * format. Block length is fixed to 512 bytes as per the SD High
+	 * Capacity specification.
+	 */
+	u64 tmp;
+
+	if (mmc->high_capacity) {
+		tmp = (u64)code_offset * blklen;
+		tmp += code_len * blklen;
+	} else
+		tmp = code_offset + code_len;
+
+	if ((tmp + CONFIG_ENV_SIZE > mmc->capacity) ||
+			(tmp > 0xFFFFFFFFU))
+		*env_addr = ESDHC_DEFAULT_ENVADDR;
+	else
+		*env_addr = tmp;
+
+	free(tmp_buf);
+
+	return 0;
+#endif
+
+	*env_addr = code_offset + code_len;
+
+	free(tmp_buf);
+
+	return 0;
+}
diff --git a/board/adlink/common/sgmii_riser.h b/board/adlink/common/sgmii_riser.h
new file mode 100644
index 00000000000..e1fcc858f3f
--- /dev/null
+++ b/board/adlink/common/sgmii_riser.h
@@ -0,0 +1,16 @@
+/*
+ * Freescale SGMII Riser Card
+ *
+ * This driver supports the SGMII Riser card found on the
+ * "DS" style of development board from Freescale.
+ *
+ * This software may be used and distributed according to the
+ * terms of the GNU Public License, Version 2, incorporated
+ * herein by reference.
+ *
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ *
+ */
+
+void fsl_sgmii_riser_init(struct tsec_info_struct *tsec_info, int num);
+void fsl_sgmii_riser_fdt_fixup(void *fdt);
diff --git a/board/adlink/common/sleep.h b/board/adlink/common/sleep.h
new file mode 100644
index 00000000000..1450baa0725
--- /dev/null
+++ b/board/adlink/common/sleep.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __SLEEP_H
+#define __SLEEP_H
+
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+#define DDR_BUFF_LEN			128
+
+/* determine if it is a wakeup from deep sleep */
+bool is_warm_boot(void);
+
+/* disable console output */
+void fsl_dp_disable_console(void);
+
+/* clean up everything and jump to kernel */
+int fsl_dp_resume(void);
+#endif
diff --git a/board/adlink/common/spl.h b/board/adlink/common/spl.h
new file mode 100644
index 00000000000..d4689d3d726
--- /dev/null
+++ b/board/adlink/common/spl.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2016 Google, Inc
+ */
+
+#ifndef __FREESCALE_BOARD_SPL_H
+#define __FREESCALE_BOARD_SPL_H
+
+void fsl_spi_spl_load_image(uint32_t offs, unsigned int size, void *vdst);
+void fsl_spi_boot(void) __noreturn;
+
+#endif
diff --git a/board/adlink/common/sys_eeprom.c b/board/adlink/common/sys_eeprom.c
new file mode 100644
index 00000000000..64139d4659f
--- /dev/null
+++ b/board/adlink/common/sys_eeprom.c
@@ -0,0 +1,649 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2006, 2008-2009, 2011 Freescale Semiconductor
+ * York Sun (yorksun@freescale.com)
+ * Haiying Wang (haiying.wang@freescale.com)
+ * Timur Tabi (timur@freescale.com)
+ */
+
+#include <common.h>
+#include <command.h>
+#include <env.h>
+#include <i2c.h>
+#include <init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <u-boot/crc.h>
+
+#ifdef CONFIG_SYS_I2C_EEPROM_CCID
+#include "../common/eeprom.h"
+#define MAX_NUM_PORTS	8
+#endif
+
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+/* some boards with non-256-bytes EEPROM have special define */
+/* for MAX_NUM_PORTS in board-specific file */
+#ifndef MAX_NUM_PORTS
+#define MAX_NUM_PORTS	16
+#endif
+#define NXID_VERSION	1
+#endif
+
+/**
+ * static eeprom: EEPROM layout for CCID or NXID formats
+ *
+ * See application note AN3638 for details.
+ */
+static struct __attribute__ ((__packed__)) eeprom {
+#ifdef CONFIG_SYS_I2C_EEPROM_CCID
+	u8 id[4];         /* 0x00 - 0x03 EEPROM Tag 'CCID' */
+	u8 major;         /* 0x04        Board revision, major */
+	u8 minor;         /* 0x05        Board revision, minor */
+	u8 sn[10];        /* 0x06 - 0x0F Serial Number*/
+	u8 errata[2];     /* 0x10 - 0x11 Errata Level */
+	u8 date[6];       /* 0x12 - 0x17 Build Date */
+	u8 res_0[40];     /* 0x18 - 0x3f Reserved */
+	u8 mac_count;     /* 0x40        Number of MAC addresses */
+	u8 mac_flag;      /* 0x41        MAC table flags */
+	u8 mac[MAX_NUM_PORTS][6];     /* 0x42 - 0x71 MAC addresses */
+	u32 crc;          /* 0x72        CRC32 checksum */
+#endif
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+	u8 id[4];         /* 0x00 - 0x03 EEPROM Tag 'NXID' */
+	u8 sn[12];        /* 0x04 - 0x0F Serial Number */
+	u8 errata[5];     /* 0x10 - 0x14 Errata Level */
+	u8 date[6];       /* 0x15 - 0x1a Build Date */
+	u8 res_0;         /* 0x1b        Reserved */
+	u32 version;      /* 0x1c - 0x1f NXID Version */
+	u8 tempcal[8];    /* 0x20 - 0x27 Temperature Calibration Factors */
+	u8 tempcalsys[2]; /* 0x28 - 0x29 System Temperature Calibration Factors */
+	u8 tempcalflags;  /* 0x2a        Temperature Calibration Flags */
+	u8 res_1[21];     /* 0x2b - 0x3f Reserved */
+	u8 mac_count;     /* 0x40        Number of MAC addresses */
+	u8 mac_flag;      /* 0x41        MAC table flags */
+	u8 mac[MAX_NUM_PORTS][6];     /* 0x42 - 0xa1 MAC addresses */
+	u8 res_2[90];     /* 0xa2 - 0xfb Reserved */
+	u32 crc;          /* 0xfc - 0xff CRC32 checksum */
+#endif
+} e;
+
+/* Set to 1 if we've read EEPROM into memory */
+static int has_been_read = 0;
+
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+/* Is this a valid NXID EEPROM? */
+#define is_valid ((e.id[0] == 'N') || (e.id[1] == 'X') || \
+		  (e.id[2] == 'I') || (e.id[3] == 'D'))
+#endif
+
+#ifdef CONFIG_SYS_I2C_EEPROM_CCID
+/* Is this a valid CCID EEPROM? */
+#define is_valid ((e.id[0] == 'C') || (e.id[1] == 'C') || \
+		  (e.id[2] == 'I') || (e.id[3] == 'D'))
+#endif
+
+/**
+ * show_eeprom - display the contents of the EEPROM
+ */
+static void show_eeprom(void)
+{
+	int i;
+	unsigned int crc;
+
+	/* EEPROM tag ID, either CCID or NXID */
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+	printf("ID: %c%c%c%c v%u\n", e.id[0], e.id[1], e.id[2], e.id[3],
+	       be32_to_cpu(e.version));
+#else
+	printf("ID: %c%c%c%c\n", e.id[0], e.id[1], e.id[2], e.id[3]);
+#endif
+
+	/* Serial number */
+	printf("SN: %s\n", e.sn);
+
+	/* Errata level. */
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+	printf("Errata: %s\n", e.errata);
+#else
+	printf("Errata: %c%c\n",
+		e.errata[0] ? e.errata[0] : '.',
+		e.errata[1] ? e.errata[1] : '.');
+#endif
+
+	/* Build date, BCD date values, as YYMMDDhhmmss */
+	printf("Build date: 20%02x/%02x/%02x %02x:%02x:%02x %s\n",
+		e.date[0], e.date[1], e.date[2],
+		e.date[3] & 0x7F, e.date[4], e.date[5],
+		e.date[3] & 0x80 ? "PM" : "");
+
+	/* Show MAC addresses  */
+	for (i = 0; i < min(e.mac_count, (u8)MAX_NUM_PORTS); i++) {
+
+		u8 *p = e.mac[i];
+
+		printf("Eth%u: %02x:%02x:%02x:%02x:%02x:%02x\n", i,
+			p[0], p[1], p[2], p[3],	p[4], p[5]);
+	}
+
+	crc = crc32(0, (void *)&e, sizeof(e) - 4);
+
+	if (crc == be32_to_cpu(e.crc))
+		printf("CRC: %08x\n", be32_to_cpu(e.crc));
+	else
+		printf("CRC: %08x (should be %08x)\n",
+			be32_to_cpu(e.crc), crc);
+
+#ifdef DEBUG
+	printf("EEPROM dump: (0x%x bytes)\n", sizeof(e));
+	for (i = 0; i < sizeof(e); i++) {
+		if ((i % 16) == 0)
+			printf("%02X: ", i);
+		printf("%02X ", ((u8 *)&e)[i]);
+		if (((i % 16) == 15) || (i == sizeof(e) - 1))
+			printf("\n");
+	}
+#endif
+}
+
+/**
+ * read_eeprom - read the EEPROM into memory
+ */
+static int read_eeprom(void)
+{
+	int ret;
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+#if !CONFIG_IS_ENABLED(DM_I2C)
+	unsigned int bus;
+#endif
+#endif
+
+	if (has_been_read)
+		return 0;
+
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+#if !CONFIG_IS_ENABLED(DM_I2C)
+	bus = i2c_get_bus_num();
+	i2c_set_bus_num(CONFIG_SYS_EEPROM_BUS_NUM);
+#endif
+#endif
+
+#if !CONFIG_IS_ENABLED(DM_I2C)
+	ret = i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0,
+		       CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+		       (void *)&e, sizeof(e));
+#else
+	struct udevice *dev;
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+	ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
+				      CONFIG_SYS_I2C_EEPROM_ADDR,
+				      CONFIG_SYS_I2C_EEPROM_ADDR_LEN, &dev);
+#else
+	ret = i2c_get_chip_for_busnum(0, CONFIG_SYS_I2C_EEPROM_ADDR,
+				      CONFIG_SYS_I2C_EEPROM_ADDR_LEN, &dev);
+#endif
+	if (!ret)
+		ret = dm_i2c_read(dev, 0, (void *)&e, sizeof(e));
+#endif
+
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+#if !CONFIG_IS_ENABLED(DM_I2C)
+	i2c_set_bus_num(bus);
+#endif
+#endif
+
+#ifdef DEBUG
+	show_eeprom();
+#endif
+
+	has_been_read = (ret == 0) ? 1 : 0;
+
+	return ret;
+}
+
+/**
+ *  update_crc - update the CRC
+ *
+ *  This function should be called after each update to the EEPROM structure,
+ *  to make sure the CRC is always correct.
+ */
+static void update_crc(void)
+{
+	u32 crc;
+
+	crc = crc32(0, (void *)&e, sizeof(e) - 4);
+	e.crc = cpu_to_be32(crc);
+}
+
+/**
+ * prog_eeprom - write the EEPROM from memory
+ */
+static int prog_eeprom(void)
+{
+	int ret = 0;
+	int i;
+	void *p;
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+#if !CONFIG_IS_ENABLED(DM_I2C)
+	unsigned int bus;
+#endif
+#endif
+
+	/* Set the reserved values to 0xFF   */
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+	e.res_0 = 0xFF;
+	memset(e.res_1, 0xFF, sizeof(e.res_1));
+#else
+	memset(e.res_0, 0xFF, sizeof(e.res_0));
+#endif
+	update_crc();
+
+#if !CONFIG_IS_ENABLED(DM_I2C)
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+	bus = i2c_get_bus_num();
+	i2c_set_bus_num(CONFIG_SYS_EEPROM_BUS_NUM);
+#endif
+#endif
+
+	/*
+	 * The AT24C02 datasheet says that data can only be written in page
+	 * mode, which means 8 bytes at a time, and it takes up to 5ms to
+	 * complete a given write.
+	 */
+	for (i = 0, p = &e; i < sizeof(e); i += 8, p += 8) {
+#if !CONFIG_IS_ENABLED(DM_I2C)
+		ret = i2c_write(CONFIG_SYS_I2C_EEPROM_ADDR, i,
+				CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+				p, min((int)(sizeof(e) - i), 8));
+#else
+		struct udevice *dev;
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+		ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
+					      CONFIG_SYS_I2C_EEPROM_ADDR,
+					      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+					      &dev);
+#else
+		ret = i2c_get_chip_for_busnum(0, CONFIG_SYS_I2C_EEPROM_ADDR,
+					      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+					      &dev);
+#endif
+		if (!ret)
+			ret = dm_i2c_write(dev, i, p, min((int)(sizeof(e) - i),
+							  8));
+#endif
+		if (ret)
+			break;
+		udelay(5000);	/* 5ms write cycle timing */
+	}
+
+	if (!ret) {
+		/* Verify the write by reading back the EEPROM and comparing */
+		struct eeprom e2;
+
+#if !CONFIG_IS_ENABLED(DM_I2C)
+		ret = i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0,
+			       CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+			       (void *)&e2, sizeof(e2));
+#else
+		struct udevice *dev;
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+		ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
+					      CONFIG_SYS_I2C_EEPROM_ADDR,
+					      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+					      &dev);
+#else
+		ret = i2c_get_chip_for_busnum(0, CONFIG_SYS_I2C_EEPROM_ADDR,
+					      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+					      &dev);
+#endif
+		if (!ret)
+			ret = dm_i2c_read(dev, 0, (void *)&e2, sizeof(e2));
+#endif
+		if (!ret && memcmp(&e, &e2, sizeof(e)))
+			ret = -1;
+	}
+
+#if !CONFIG_IS_ENABLED(DM_I2C)
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+	i2c_set_bus_num(bus);
+#endif
+#endif
+
+	if (ret) {
+		printf("Programming failed.\n");
+		has_been_read = 0;
+		return -1;
+	}
+
+	printf("Programming passed.\n");
+	return 0;
+}
+
+/**
+ * h2i - converts hex character into a number
+ *
+ * This function takes a hexadecimal character (e.g. '7' or 'C') and returns
+ * the integer equivalent.
+ */
+static inline u8 h2i(char p)
+{
+	if ((p >= '0') && (p <= '9'))
+		return p - '0';
+
+	if ((p >= 'A') && (p <= 'F'))
+		return (p - 'A') + 10;
+
+	if ((p >= 'a') && (p <= 'f'))
+		return (p - 'a') + 10;
+
+	return 0;
+}
+
+/**
+ * set_date - stores the build date into the EEPROM
+ *
+ * This function takes a pointer to a string in the format "YYMMDDhhmmss"
+ * (2-digit year, 2-digit month, etc), converts it to a 6-byte BCD string,
+ * and stores it in the build date field of the EEPROM local copy.
+ */
+static void set_date(const char *string)
+{
+	unsigned int i;
+
+	if (strlen(string) != 12) {
+		printf("Usage: mac date YYMMDDhhmmss\n");
+		return;
+	}
+
+	for (i = 0; i < 6; i++)
+		e.date[i] = h2i(string[2 * i]) << 4 | h2i(string[2 * i + 1]);
+
+	update_crc();
+}
+
+/**
+ * set_mac_address - stores a MAC address into the EEPROM
+ *
+ * This function takes a pointer to MAC address string
+ * (i.e."XX:XX:XX:XX:XX:XX", where "XX" is a two-digit hex number) and
+ * stores it in one of the MAC address fields of the EEPROM local copy.
+ */
+static void set_mac_address(unsigned int index, const char *string)
+{
+	char *p = (char *) string;
+	unsigned int i;
+
+	if ((index >= MAX_NUM_PORTS) || !string) {
+		printf("Usage: mac <n> XX:XX:XX:XX:XX:XX\n");
+		return;
+	}
+
+	for (i = 0; *p && (i < 6); i++) {
+		e.mac[index][i] = hextoul(p, &p);
+		if (*p == ':')
+			p++;
+	}
+
+	update_crc();
+}
+
+int do_mac(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	char cmd;
+
+	if (argc == 1) {
+		show_eeprom();
+		return 0;
+	}
+
+	cmd = argv[1][0];
+
+	if (cmd == 'r') {
+		read_eeprom();
+		return 0;
+	}
+
+	if (cmd == 'i') {
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+		memcpy(e.id, "NXID", sizeof(e.id));
+		e.version = cpu_to_be32(NXID_VERSION);
+#else
+		memcpy(e.id, "CCID", sizeof(e.id));
+#endif
+		update_crc();
+		return 0;
+	}
+
+	if (!is_valid) {
+		printf("Please read the EEPROM ('r') and/or set the ID ('i') first.\n");
+		return 0;
+	}
+
+	if (argc == 2) {
+		switch (cmd) {
+		case 's':	/* save */
+			prog_eeprom();
+			break;
+		default:
+			return CMD_RET_USAGE;
+		}
+
+		return 0;
+	}
+
+	/* We know we have at least one parameter  */
+
+	switch (cmd) {
+	case 'n':	/* serial number */
+		memset(e.sn, 0, sizeof(e.sn));
+		strncpy((char *)e.sn, argv[2], sizeof(e.sn) - 1);
+		update_crc();
+		break;
+	case 'e':	/* errata */
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+		memset(e.errata, 0, 5);
+		strncpy((char *)e.errata, argv[2], 4);
+#else
+		e.errata[0] = argv[2][0];
+		e.errata[1] = argv[2][1];
+#endif
+		update_crc();
+		break;
+	case 'd':	/* date BCD format YYMMDDhhmmss */
+		set_date(argv[2]);
+		break;
+	case 'p':	/* MAC table size */
+		e.mac_count = hextoul(argv[2], NULL);
+		update_crc();
+		break;
+	case '0' ... '9':	/* "mac 0" through "mac 22" */
+		set_mac_address(dectoul(argv[1], NULL), argv[2]);
+		break;
+	case 'h':	/* help */
+	default:
+		return cmd_usage(cmdtp);
+	}
+
+	return 0;
+}
+
+/**
+ * mac_read_from_eeprom - read the MAC addresses from EEPROM
+ *
+ * This function reads the MAC addresses from EEPROM and sets the
+ * appropriate environment variables for each one read.
+ *
+ * The environment variables are only set if they haven't been set already.
+ * This ensures that any user-saved variables are never overwritten.
+ *
+ * This function must be called after relocation.
+ *
+ * For NXID v1 EEPROMs, we support loading and up-converting the older NXID v0
+ * format.  In a v0 EEPROM, there are only eight MAC addresses and the CRC is
+ * located at a different offset.
+ */
+int mac_read_from_eeprom(void)
+{
+	unsigned int i;
+	u32 crc, crc_offset = offsetof(struct eeprom, crc);
+	u32 *crcp; /* Pointer to the CRC in the data read from the EEPROM */
+
+	puts("EEPROM: ");
+
+	if (read_eeprom()) {
+		printf("Read failed.\n");
+		return 0;
+	}
+
+	if (!is_valid) {
+		printf("Invalid ID (%02x %02x %02x %02x)\n",
+		       e.id[0], e.id[1], e.id[2], e.id[3]);
+		return 0;
+	}
+
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+	/*
+	 * If we've read an NXID v0 EEPROM, then we need to set the CRC offset
+	 * to where it is in v0.
+	 */
+	if (e.version == 0)
+		crc_offset = 0x72;
+#endif
+
+	crc = crc32(0, (void *)&e, crc_offset);
+	crcp = (void *)&e + crc_offset;
+	if (crc != be32_to_cpu(*crcp)) {
+		printf("CRC mismatch (%08x != %08x)\n", crc, be32_to_cpu(e.crc));
+		return 0;
+	}
+
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+	/*
+	 * MAC address #9 in v1 occupies the same position as the CRC in v0.
+	 * Erase it so that it's not mistaken for a MAC address.  We'll
+	 * update the CRC later.
+	 */
+	if (e.version == 0)
+		memset(e.mac[8], 0xff, 6);
+#endif
+
+	for (i = 0; i < min(e.mac_count, (u8)MAX_NUM_PORTS); i++) {
+		if (memcmp(&e.mac[i], "\0\0\0\0\0\0", 6) &&
+		    memcmp(&e.mac[i], "\xFF\xFF\xFF\xFF\xFF\xFF", 6)) {
+			char ethaddr[18];
+			char enetvar[9];
+
+			sprintf(ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
+				e.mac[i][0],
+				e.mac[i][1],
+				e.mac[i][2],
+				e.mac[i][3],
+				e.mac[i][4],
+				e.mac[i][5]);
+			sprintf(enetvar, i ? "eth%daddr" : "ethaddr", i);
+			/* Only initialize environment variables that are blank
+			 * (i.e. have not yet been set)
+			 */
+			if (!env_get(enetvar))
+				env_set(enetvar, ethaddr);
+		}
+	}
+
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+	printf("%c%c%c%c v%u\n", e.id[0], e.id[1], e.id[2], e.id[3],
+	       be32_to_cpu(e.version));
+#else
+	printf("%c%c%c%c\n", e.id[0], e.id[1], e.id[2], e.id[3]);
+#endif
+
+#ifdef CONFIG_SYS_I2C_EEPROM_NXID
+	/*
+	 * Now we need to upconvert the data into v1 format.  We do this last so
+	 * that at boot time, U-Boot will still say "NXID v0".
+	 */
+	if (e.version == 0) {
+		e.version = cpu_to_be32(NXID_VERSION);
+		update_crc();
+	}
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_SYS_I2C_EEPROM_CCID
+
+/**
+ * get_cpu_board_revision - get the CPU board revision on 85xx boards
+ *
+ * Read the EEPROM to determine the board revision.
+ *
+ * This function is called before relocation, so we need to read a private
+ * copy of the EEPROM into a local variable on the stack.
+ *
+ * Also, we assume that CONFIG_SYS_EEPROM_BUS_NUM == CONFIG_SYS_SPD_BUS_NUM.  The global
+ * variable i2c_bus_num must be compile-time initialized to CONFIG_SYS_SPD_BUS_NUM,
+ * so that the SPD code will work.  This means that all pre-relocation I2C
+ * operations can only occur on the CONFIG_SYS_SPD_BUS_NUM bus.  So if
+ * CONFIG_SYS_EEPROM_BUS_NUM != CONFIG_SYS_SPD_BUS_NUM, then we can't read the EEPROM when
+ * this function is called.  Oh well.
+ */
+unsigned int get_cpu_board_revision(void)
+{
+	struct board_eeprom {
+		u32 id;           /* 0x00 - 0x03 EEPROM Tag 'CCID' */
+		u8 major;         /* 0x04        Board revision, major */
+		u8 minor;         /* 0x05        Board revision, minor */
+	} be;
+
+#if !CONFIG_IS_ENABLED(DM_I2C)
+	i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+		(void *)&be, sizeof(be));
+#else
+	struct udevice *dev;
+	int ret;
+#ifdef CONFIG_SYS_EEPROM_BUS_NUM
+	ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
+				      CONFIG_SYS_I2C_EEPROM_ADDR,
+				      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+				      &dev);
+#else
+	ret = i2c_get_chip_for_busnum(0, CONFIG_SYS_I2C_EEPROM_ADDR,
+				      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+				      &dev);
+#endif
+	if (!ret)
+		dm_i2c_read(dev, 0, (void *)&be, sizeof(be));
+#endif
+
+	if (be.id != (('C' << 24) | ('C' << 16) | ('I' << 8) | 'D'))
+		return MPC85XX_CPU_BOARD_REV(0, 0);
+
+	if ((be.major == 0xff) && (be.minor == 0xff))
+		return MPC85XX_CPU_BOARD_REV(0, 0);
+
+	return MPC85XX_CPU_BOARD_REV(be.major, be.minor);
+}
+#endif
+
+U_BOOT_LONGHELP(mac,
+	"[read|save|id|num|errata|date|ports|port_number]\n"
+	"mac read\n"
+	"    - read EEPROM content into memory data structure\n"
+	"mac save\n"
+	"    - save memory data structure to the EEPROM\n"
+	"mac id\n"
+	"    - program system id per hard coded value\n"
+	"mac num string\n"
+	"    - program system serial number to value string\n"
+	"mac errata string\n"
+	"    - program errata data to value string\n"
+	"mac date YYMMDDhhmmss\n"
+	"    - program date to string value YYMMDDhhmmss\n"
+	"mac ports N\n"
+	"    - program the number of network ports to integer N\n"
+	"mac X string\n"
+	"    - program MAC addr for port X [X=0,1..] to colon separated string");
+
+U_BOOT_CMD(
+	mac, 3, 1,  do_mac,
+	"display and program the system ID and MAC addresses in EEPROM",
+	mac_help_text);
diff --git a/board/adlink/common/tcpc.c b/board/adlink/common/tcpc.c
new file mode 100644
index 00000000000..a12c10fbe92
--- /dev/null
+++ b/board/adlink/common/tcpc.c
@@ -0,0 +1,1069 @@
+/*
+ * Copyright 2017,2019 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <i2c.h>
+#include <time.h>
+#include <linux/delay.h>
+#include "tcpc.h"
+
+#ifdef DEBUG
+#define tcpc_debug_log(port, fmt, args...) tcpc_log(port, fmt, ##args)
+#else
+#define tcpc_debug_log(port, fmt, args...)
+#endif
+
+static int tcpc_log(struct tcpc_port *port, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i = vscnprintf(port->log_p, port->log_size, fmt, args);
+	va_end(args);
+
+	port->log_size -= i;
+	port->log_p += i;
+
+	return i;
+}
+
+int tcpc_set_cc_to_source(struct tcpc_port *port)
+{
+	uint8_t valb;
+	int err;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	valb = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |
+			(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |
+			(TCPC_ROLE_CTRL_RP_VAL_DEF <<
+			 TCPC_ROLE_CTRL_RP_VAL_SHIFT) | TCPC_ROLE_CTRL_DRP;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_ROLE_CTRL, &valb, 1);
+	if (err)
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+	return err;
+}
+
+int tcpc_set_cc_to_sink(struct tcpc_port *port)
+{
+	uint8_t valb;
+	int err;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	valb = (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT) |
+			(TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT) | TCPC_ROLE_CTRL_DRP;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_ROLE_CTRL, &valb, 1);
+	if (err)
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+	return err;
+}
+
+
+int tcpc_set_plug_orientation(struct tcpc_port *port, enum typec_cc_polarity polarity)
+{
+	uint8_t valb;
+	int err;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_read(port->i2c_dev, TCPC_TCPC_CTRL, &valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	if (polarity == TYPEC_POLARITY_CC2)
+		valb |= TCPC_TCPC_CTRL_ORIENTATION;
+	else
+		valb &= ~TCPC_TCPC_CTRL_ORIENTATION;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_TCPC_CTRL, &valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int tcpc_get_cc_status(struct tcpc_port *port, enum typec_cc_polarity *polarity, enum typec_cc_state *state)
+{
+
+	uint8_t valb_cc, cc2, cc1;
+	int err;
+
+	if (port == NULL || port->i2c_dev == NULL || polarity == NULL || state == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_read(port->i2c_dev, TCPC_CC_STATUS, (uint8_t *)&valb_cc, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	tcpc_debug_log(port, "cc status 0x%x\n", valb_cc);
+
+	cc2 = (valb_cc >> TCPC_CC_STATUS_CC2_SHIFT) & TCPC_CC_STATUS_CC2_MASK;
+	cc1 = (valb_cc >> TCPC_CC_STATUS_CC1_SHIFT) & TCPC_CC_STATUS_CC1_MASK;
+
+	if (valb_cc & TCPC_CC_STATUS_LOOK4CONN)
+		return -EFAULT;
+
+	*state = TYPEC_STATE_OPEN;
+
+	if (valb_cc & TCPC_CC_STATUS_TERM) {
+		if (cc2) {
+			*polarity = TYPEC_POLARITY_CC2;
+
+			switch (cc2) {
+			case 0x1:
+				*state = TYPEC_STATE_SNK_DEFAULT;
+				tcpc_log(port, "SNK.Default on CC2\n");
+				break;
+			case 0x2:
+				*state = TYPEC_STATE_SNK_POWER15;
+				tcpc_log(port, "SNK.Power1.5 on CC2\n");
+				break;
+			case 0x3:
+				*state = TYPEC_STATE_SNK_POWER30;
+				tcpc_log(port, "SNK.Power3.0 on CC2\n");
+				break;
+			}
+		} else if (cc1) {
+			*polarity = TYPEC_POLARITY_CC1;
+
+			switch (cc1) {
+			case 0x1:
+				*state = TYPEC_STATE_SNK_DEFAULT;
+				tcpc_log(port, "SNK.Default on CC1\n");
+				break;
+			case 0x2:
+				*state = TYPEC_STATE_SNK_POWER15;
+				tcpc_log(port, "SNK.Power1.5 on CC1\n");
+				break;
+			case 0x3:
+				*state = TYPEC_STATE_SNK_POWER30;
+				tcpc_log(port, "SNK.Power3.0 on CC1\n");
+				break;
+			}
+		} else {
+			*state = TYPEC_STATE_OPEN;
+			return -EPERM;
+		}
+
+	} else {
+		if (cc2) {
+			*polarity = TYPEC_POLARITY_CC2;
+
+			switch (cc2) {
+			case 0x1:
+				if (cc1 == 0x1) {
+					*state = TYPEC_STATE_SRC_BOTH_RA;
+					tcpc_log(port, "SRC.Ra on both CC1 and CC2\n");
+				} else if (cc1 == 0x2) {
+					*state = TYPEC_STATE_SRC_RD_RA;
+					tcpc_log(port, "SRC.Ra on CC2, SRC.Rd on CC1\n");
+				} else if (cc1 == 0x0) {
+					tcpc_log(port, "SRC.Ra only on CC2\n");
+					return -EFAULT;
+				} else
+					return -EFAULT;
+				break;
+			case 0x2:
+				if (cc1 == 0x1) {
+					*state = TYPEC_STATE_SRC_RD_RA;
+					tcpc_log(port, "SRC.Ra on CC1, SRC.Rd on CC2\n");
+				} else if (cc1 == 0x0) {
+					*state = TYPEC_STATE_SRC_RD;
+					tcpc_log(port, "SRC.Rd on CC2\n");
+				} else
+					return -EFAULT;
+				break;
+			case 0x3:
+				*state = TYPEC_STATE_SRC_RESERVED;
+				return -EFAULT;
+			}
+		} else if (cc1) {
+			*polarity = TYPEC_POLARITY_CC1;
+
+			switch (cc1) {
+			case 0x1:
+				tcpc_log(port, "SRC.Ra only on CC1\n");
+				return -EFAULT;
+			case 0x2:
+				*state = TYPEC_STATE_SRC_RD;
+				tcpc_log(port, "SRC.Rd on CC1\n");
+				break;
+			case 0x3:
+				*state = TYPEC_STATE_SRC_RESERVED;
+				return -EFAULT;
+			}
+		} else {
+			*state = TYPEC_STATE_OPEN;
+			return -EPERM;
+		}
+	}
+
+	return 0;
+}
+
+int tcpc_alert_mask(struct tcpc_port *port, uint16_t alert_mask)
+{
+	int err = 0;
+
+	if (!port || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_ALERT_MASK, (const uint8_t *)&alert_mask, 2);
+	if (err)
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+
+	return err;
+}
+
+int tcpc_clear_alert(struct tcpc_port *port, uint16_t clear_mask)
+{
+	int err;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_ALERT, (const uint8_t *)&clear_mask, 2);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int tcpc_fault_status_mask(struct tcpc_port *port, uint8_t fault_mask)
+{
+	int err = 0;
+
+	if (!port || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_FAULT_STATUS_MASK, &fault_mask, 1);
+	if (err)
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+
+	return err;
+}
+
+int tcpc_send_command(struct tcpc_port *port, uint8_t command)
+{
+	int err;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_COMMAND, (const uint8_t *)&command, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int tcpc_polling_reg(struct tcpc_port *port, uint8_t reg,
+	uint8_t reg_width, uint16_t mask, uint16_t value, ulong timeout_ms)
+{
+	uint16_t val = 0;
+	int err;
+	ulong start;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	tcpc_debug_log(port, "%s reg 0x%x, mask 0x%x, value 0x%x\n", __func__, reg, mask, value);
+
+	/* TCPC registers is 8 bits or 16 bits */
+	if (reg_width != 1 && reg_width != 2)
+		return -EINVAL;
+
+	start = get_timer(0);	/* Get current timestamp */
+	do {
+		err = dm_i2c_read(port->i2c_dev, reg, (uint8_t *)&val, reg_width);
+		if (err)
+			return -EIO;
+
+		if ((val & mask) == value)
+			return 0;
+	} while (get_timer(0) < (start + timeout_ms));
+
+	return -ETIME;
+}
+
+void tcpc_print_log(struct tcpc_port *port)
+{
+	if (port == NULL)
+		return;
+
+	if (port->log_print == port->log_p) /*nothing to output*/
+		return;
+
+	printf("%s", port->log_print);
+
+	port->log_print = port->log_p;
+}
+
+int tcpc_setup_dfp_mode(struct tcpc_port *port)
+{
+	enum typec_cc_polarity pol;
+	enum typec_cc_state state;
+	int ret;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	if (tcpc_pd_sink_check_charging(port)) {
+		tcpc_log(port, "%s: Can't apply DFP mode when PD is charging\n",
+			__func__);
+		return -EPERM;
+	}
+
+	tcpc_set_cc_to_source(port);
+
+	ret = tcpc_send_command(port, TCPC_CMD_LOOK4CONNECTION);
+	if (ret)
+		return ret;
+
+	/* At least wait tCcStatusDelay + tTCPCFilter + tCcTCPCSampleRate (max) = 200us + 500us + ?ms
+	 * PTN5110 datasheet does not contain the sample rate value, according other productions,
+	 * the sample rate is at ms level, about 2 ms -10ms. So wait 100ms should be enough.
+	 */
+	mdelay(100);
+
+	ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_CC_STATUS, TCPC_ALERT_CC_STATUS, 100);
+	if (ret) {
+		tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_CC_STATUS bit failed, ret = %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	ret = tcpc_get_cc_status(port, &pol, &state);
+	tcpc_clear_alert(port, TCPC_ALERT_CC_STATUS);
+
+	if (!ret) {
+		/* If presenting as Rd/audio mode/open, return */
+		if (state != TYPEC_STATE_SRC_RD_RA && state != TYPEC_STATE_SRC_RD)
+			return -EPERM;
+
+		if (pol == TYPEC_POLARITY_CC1)
+			tcpc_debug_log(port, "polarity cc1\n");
+		else
+			tcpc_debug_log(port, "polarity cc2\n");
+
+		if (port->ss_sel_func)
+			port->ss_sel_func(pol);
+
+		ret = tcpc_set_plug_orientation(port, pol);
+		if (ret)
+			return ret;
+
+		/* Enable source vbus default voltage */
+		ret = tcpc_send_command(port, TCPC_CMD_SRC_VBUS_DEFAULT);
+		if (ret)
+			return ret;
+
+		/* The max vbus on time is 200ms, we add margin 100ms */
+		mdelay(300);
+
+	}
+
+	return 0;
+}
+
+int tcpc_setup_ufp_mode(struct tcpc_port *port)
+{
+	enum typec_cc_polarity pol;
+	enum typec_cc_state state;
+	int ret;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	/* Check if the PD charge is working. If not, need to configure CC role for UFP */
+	if (!tcpc_pd_sink_check_charging(port)) {
+
+		/* Disable the source vbus once it is enabled by DFP mode */
+		tcpc_disable_src_vbus(port);
+
+		tcpc_set_cc_to_sink(port);
+
+		ret = tcpc_send_command(port, TCPC_CMD_LOOK4CONNECTION);
+		if (ret)
+			return ret;
+
+		/* At least wait tCcStatusDelay + tTCPCFilter + tCcTCPCSampleRate (max) = 200us + 500us + ?ms
+		 * PTN5110 datasheet does not contain the sample rate value, according other productions,
+		 * the sample rate is at ms level, about 2 ms -10ms. So wait 100ms should be enough.
+		 */
+		mdelay(100);
+
+		ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_CC_STATUS, TCPC_ALERT_CC_STATUS, 100);
+		if (ret) {
+			tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_CC_STATUS bit failed, ret = %d\n",
+				__func__, ret);
+			return ret;
+		}
+
+		ret = tcpc_get_cc_status(port, &pol, &state);
+		tcpc_clear_alert(port, TCPC_ALERT_CC_STATUS);
+
+	} else {
+		ret = tcpc_get_cc_status(port, &pol, &state);
+	}
+
+	if (!ret) {
+		/* If presenting not as sink, then return */
+		if (state != TYPEC_STATE_SNK_DEFAULT && state != TYPEC_STATE_SNK_POWER15 &&
+			state != TYPEC_STATE_SNK_POWER30)
+			return -EPERM;
+
+		if (pol == TYPEC_POLARITY_CC1)
+			tcpc_debug_log(port, "polarity cc1\n");
+		else
+			tcpc_debug_log(port, "polarity cc2\n");
+
+		if (port->ss_sel_func)
+			port->ss_sel_func(pol);
+
+		ret = tcpc_set_plug_orientation(port, pol);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int tcpc_disable_src_vbus(struct tcpc_port *port)
+{
+	int ret;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	/* Disable VBUS*/
+	ret = tcpc_send_command(port, TCPC_CMD_DISABLE_SRC_VBUS);
+	if (ret)
+		return ret;
+
+	/* The max vbus off time is 0.5ms, we add margin 0.5 ms */
+	mdelay(1);
+
+	return 0;
+}
+
+int tcpc_disable_sink_vbus(struct tcpc_port *port)
+{
+	int ret;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	/* Disable SINK VBUS*/
+	ret = tcpc_send_command(port, TCPC_CMD_DISABLE_SINK_VBUS);
+	if (ret)
+		return ret;
+
+	/* The max vbus off time is 0.5ms, we add margin 0.5 ms */
+	mdelay(1);
+
+	return 0;
+}
+
+
+static int tcpc_pd_receive_message(struct tcpc_port *port, struct pd_message *msg)
+{
+	int ret;
+	uint8_t cnt;
+	uint16_t val;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	/* Generally the max tSenderResponse is 30ms, max tTypeCSendSourceCap is 200ms, we set the timeout to 500ms */
+	ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_RX_STATUS, TCPC_ALERT_RX_STATUS, 500);
+	if (ret) {
+		tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_RX_STATUS bit failed, ret = %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	cnt = 0;
+	ret = dm_i2c_read(port->i2c_dev, TCPC_RX_BYTE_CNT, (uint8_t *)&cnt, 1);
+	if (ret)
+		return -EIO;
+
+	if (cnt > 0) {
+		ret = dm_i2c_read(port->i2c_dev, TCPC_RX_BUF_FRAME_TYPE, (uint8_t *)msg, cnt);
+		if (ret)
+			return -EIO;
+
+		/* Clear RX status alert bit */
+		val = TCPC_ALERT_RX_STATUS;
+		ret = dm_i2c_write(port->i2c_dev, TCPC_ALERT, (const uint8_t *)&val, 2);
+		if (ret)
+			return -EIO;
+	}
+
+	return cnt;
+}
+
+static int tcpc_pd_transmit_message(struct tcpc_port *port, struct pd_message *msg_p, uint8_t bytes)
+{
+	int ret;
+	uint8_t valb;
+	uint16_t val = 0;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	if (msg_p == NULL || bytes <= 0)
+		return -EINVAL;
+
+	ret = dm_i2c_write(port->i2c_dev, TCPC_TX_BYTE_CNT, (const uint8_t *)&bytes, 1);
+	if (ret)
+		return -EIO;
+
+	ret = dm_i2c_write(port->i2c_dev, TCPC_TX_HDR, (const uint8_t *)&(msg_p->header), bytes);
+	if (ret)
+		return -EIO;
+
+	valb = (3 << TCPC_TRANSMIT_RETRY_SHIFT) | (TCPC_TX_SOP << TCPC_TRANSMIT_TYPE_SHIFT);
+	ret = dm_i2c_write(port->i2c_dev, TCPC_TRANSMIT, (const uint8_t *)&valb, 1);
+	if (ret)
+		return -EIO;
+
+	/* Max tReceive is 1.1ms, we set to 5ms timeout */
+	ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_TX_SUCCESS, TCPC_ALERT_TX_SUCCESS, 5);
+	if (ret) {
+		if (ret == -ETIME) {
+			ret = dm_i2c_read(port->i2c_dev, TCPC_ALERT, (uint8_t *)&val, 2);
+			if (ret)
+				return -EIO;
+
+			if (val & TCPC_ALERT_TX_FAILED)
+				tcpc_log(port, "%s: PD TX FAILED, ALERT = 0x%x\n", __func__, val);
+
+			if (val & TCPC_ALERT_TX_DISCARDED)
+				tcpc_log(port, "%s: PD TX DISCARDED, ALERT = 0x%x\n", __func__, val);
+
+		} else {
+			tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_TX_SUCCESS bit failed, ret = %d\n",
+				__func__, ret);
+		}
+	} else {
+		port->tx_msg_id = (port->tx_msg_id + 1) & PD_HEADER_ID_MASK;
+	}
+
+	/* Clear ALERT status */
+	val &= (TCPC_ALERT_TX_FAILED | TCPC_ALERT_TX_DISCARDED | TCPC_ALERT_TX_SUCCESS);
+	ret = dm_i2c_write(port->i2c_dev, TCPC_ALERT, (const uint8_t *)&val, 2);
+	if (ret)
+		return -EIO;
+
+	return ret;
+}
+
+static void tcpc_log_source_caps(struct tcpc_port *port, struct pd_message *msg, unsigned int capcount)
+{
+	int i;
+
+	for (i = 0; i < capcount; i++) {
+		u32 pdo = msg->payload[i];
+		enum pd_pdo_type type = pdo_type(pdo);
+
+		tcpc_log(port, "PDO %d: type %d, ",
+			 i, type);
+
+		switch (type) {
+		case PDO_TYPE_FIXED:
+			tcpc_log(port, "%u mV, %u mA [%s%s%s%s%s%s]\n",
+				  pdo_fixed_voltage(pdo),
+				  pdo_max_current(pdo),
+				  (pdo & PDO_FIXED_DUAL_ROLE) ?
+							"R" : "",
+				  (pdo & PDO_FIXED_SUSPEND) ?
+							"S" : "",
+				  (pdo & PDO_FIXED_HIGHER_CAP) ?
+							"H" : "",
+				  (pdo & PDO_FIXED_USB_COMM) ?
+							"U" : "",
+				  (pdo & PDO_FIXED_DATA_SWAP) ?
+							"D" : "",
+				  (pdo & PDO_FIXED_EXTPOWER) ?
+							"E" : "");
+			break;
+		case PDO_TYPE_VAR:
+			tcpc_log(port, "%u-%u mV, %u mA\n",
+				  pdo_min_voltage(pdo),
+				  pdo_max_voltage(pdo),
+				  pdo_max_current(pdo));
+			break;
+		case PDO_TYPE_BATT:
+			tcpc_log(port, "%u-%u mV, %u mW\n",
+				  pdo_min_voltage(pdo),
+				  pdo_max_voltage(pdo),
+				  pdo_max_power(pdo));
+			break;
+		default:
+			tcpc_log(port, "undefined\n");
+			break;
+		}
+	}
+}
+
+static int tcpc_pd_select_pdo(struct pd_message *msg, uint32_t capcount, uint32_t max_snk_mv, uint32_t max_snk_ma)
+{
+	unsigned int i, max_mw = 0, max_mv = 0;
+	int ret = -EINVAL;
+
+	/*
+	 * Select the source PDO providing the most power while staying within
+	 * the board's voltage limits. Prefer PDO providing exp
+	 */
+	for (i = 0; i < capcount; i++) {
+		u32 pdo = msg->payload[i];
+		enum pd_pdo_type type = pdo_type(pdo);
+		unsigned int mv, ma, mw;
+
+		if (type == PDO_TYPE_FIXED)
+			mv = pdo_fixed_voltage(pdo);
+		else
+			mv = pdo_min_voltage(pdo);
+
+		if (type == PDO_TYPE_BATT) {
+			mw = pdo_max_power(pdo);
+		} else {
+			ma = min(pdo_max_current(pdo),
+				 max_snk_ma);
+			mw = ma * mv / 1000;
+		}
+
+		/* Perfer higher voltages if available */
+		if ((mw > max_mw || (mw == max_mw && mv > max_mv)) &&
+		    mv <= max_snk_mv) {
+			ret = i;
+			max_mw = mw;
+			max_mv = mv;
+		}
+	}
+
+	return ret;
+}
+
+static int tcpc_pd_build_request(struct tcpc_port *port,
+										struct pd_message *msg,
+										uint32_t capcount,
+										uint32_t max_snk_mv,
+										uint32_t max_snk_ma,
+										uint32_t max_snk_mw,
+										uint32_t operating_snk_mw,
+										uint32_t *rdo)
+{
+	unsigned int mv, ma, mw, flags;
+	unsigned int max_ma, max_mw;
+	enum pd_pdo_type type;
+	int index;
+	u32 pdo;
+
+	index = tcpc_pd_select_pdo(msg, capcount, max_snk_mv, max_snk_ma);
+	if (index < 0)
+		return -EINVAL;
+
+	pdo = msg->payload[index];
+	type = pdo_type(pdo);
+
+	if (type == PDO_TYPE_FIXED)
+		mv = pdo_fixed_voltage(pdo);
+	else
+		mv = pdo_min_voltage(pdo);
+
+	/* Select maximum available current within the board's power limit */
+	if (type == PDO_TYPE_BATT) {
+		mw = pdo_max_power(pdo);
+		ma = 1000 * min(mw, max_snk_mw) / mv;
+	} else {
+		ma = min(pdo_max_current(pdo),
+			 1000 * max_snk_mw / mv);
+	}
+	ma = min(ma, max_snk_ma);
+
+	/* XXX: Any other flags need to be set? */
+	flags = 0;
+
+	/* Set mismatch bit if offered power is less than operating power */
+	mw = ma * mv / 1000;
+	max_ma = ma;
+	max_mw = mw;
+	if (mw < operating_snk_mw) {
+		flags |= RDO_CAP_MISMATCH;
+		max_mw = operating_snk_mw;
+		max_ma = max_mw * 1000 / mv;
+	}
+
+	if (type == PDO_TYPE_BATT) {
+		*rdo = RDO_BATT(index + 1, mw, max_mw, flags);
+
+		tcpc_log(port, "Requesting PDO %d: %u mV, %u mW%s\n",
+			 index, mv, mw,
+			 flags & RDO_CAP_MISMATCH ? " [mismatch]" : "");
+	} else {
+		*rdo = RDO_FIXED(index + 1, ma, max_ma, flags);
+
+		tcpc_log(port, "Requesting PDO %d: %u mV, %u mA%s\n",
+			 index, mv, ma,
+			 flags & RDO_CAP_MISMATCH ? " [mismatch]" : "");
+	}
+
+	return 0;
+}
+
+static void tcpc_pd_sink_process(struct tcpc_port *port)
+{
+	int ret;
+	uint8_t msgtype;
+	uint32_t objcnt;
+	struct pd_message msg;
+	enum pd_sink_state pd_state = WAIT_SOURCE_CAP;
+
+	while (tcpc_pd_receive_message(port, &msg) > 0) {
+
+		msgtype = pd_header_type(msg.header);
+		objcnt = pd_header_cnt_le(msg.header);
+
+		tcpc_debug_log(port, "get msg, type %d, cnt %d\n", msgtype, objcnt);
+
+		switch (pd_state) {
+		case WAIT_SOURCE_CAP:
+		case SINK_READY:
+			if (msgtype != PD_DATA_SOURCE_CAP)
+				continue;
+
+			uint32_t rdo = 0;
+
+			tcpc_log_source_caps(port, &msg, objcnt);
+
+			tcpc_pd_build_request(port, &msg, objcnt,
+				port->cfg.max_snk_mv, port->cfg.max_snk_ma,
+				port->cfg.max_snk_mw, port->cfg.op_snk_mv,
+				&rdo);
+
+			memset(&msg, 0, sizeof(msg));
+			msg.header = PD_HEADER(PD_DATA_REQUEST, 0, 0, port->tx_msg_id, 1);  /* power sink, data device, id 0, len 1 */
+			msg.payload[0] = rdo;
+
+			ret = tcpc_pd_transmit_message(port, &msg, 6);
+			if (ret)
+				tcpc_log(port, "send request failed\n");
+			else
+				pd_state = WAIT_SOURCE_ACCEPT;
+
+			break;
+		case WAIT_SOURCE_ACCEPT:
+			if (objcnt > 0) /* Should be ctrl message */
+				continue;
+
+			if (msgtype == PD_CTRL_ACCEPT) {
+				pd_state = WAIT_SOURCE_READY;
+				tcpc_log(port, "Source accept request\n");
+			} else if (msgtype == PD_CTRL_REJECT) {
+				tcpc_log(port, "Source reject request\n");
+				return;
+			}
+
+			break;
+		case WAIT_SOURCE_READY:
+			if (objcnt > 0) /* Should be ctrl message */
+				continue;
+
+			if (msgtype == PD_CTRL_PS_RDY) {
+				tcpc_log(port, "PD source ready!\n");
+				pd_state = SINK_READY;
+			}
+
+			break;
+		default:
+			tcpc_log(port, "unexpect status: %u\n", pd_state);
+			break;
+		}
+	}
+}
+
+bool tcpc_pd_sink_check_charging(struct tcpc_port *port)
+{
+	uint8_t valb;
+	int err;
+	enum typec_cc_polarity pol;
+	enum typec_cc_state state;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return false;
+
+	/* Check the CC status, must be sink */
+	err = tcpc_get_cc_status(port, &pol, &state);
+	if (err || (state != TYPEC_STATE_SNK_POWER15
+		&& state != TYPEC_STATE_SNK_POWER30
+		&& state != TYPEC_STATE_SNK_DEFAULT)) {
+		tcpc_debug_log(port, "TCPC wrong state for PD charging, err = %d, CC = 0x%x\n",
+			err, state);
+		return false;
+	}
+
+	/* Check the VBUS PRES and SINK VBUS for dead battery */
+	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
+	if (err) {
+		tcpc_debug_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return false;
+	}
+
+	if (!(valb & TCPC_POWER_STATUS_VBUS_PRES)) {
+		tcpc_debug_log(port, "VBUS NOT PRES \n");
+		return false;
+	}
+
+	if (!(valb & TCPC_POWER_STATUS_SINKING_VBUS)) {
+		tcpc_debug_log(port, "SINK VBUS is not enabled for dead battery\n");
+		return false;
+	}
+
+	return true;
+}
+
+static int tcpc_pd_sink_disable(struct tcpc_port *port)
+{
+	uint8_t valb;
+	int err;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	port->pd_state = UNATTACH;
+
+	/* Check the VBUS PRES and SINK VBUS for dead battery */
+	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	if ((valb & TCPC_POWER_STATUS_VBUS_PRES) && (valb & TCPC_POWER_STATUS_SINKING_VBUS)) {
+		err = dm_i2c_read(port->i2c_dev, TCPC_POWER_CTRL, (uint8_t *)&valb, 1);
+		if (err) {
+			tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+			return -EIO;
+		}
+
+		valb &= ~TCPC_POWER_CTRL_AUTO_DISCH_DISCO; /* disable AutoDischargeDisconnect */
+		err = dm_i2c_write(port->i2c_dev, TCPC_POWER_CTRL, (const uint8_t *)&valb, 1);
+		if (err) {
+			tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+			return -EIO;
+		}
+
+		tcpc_disable_sink_vbus(port);
+	}
+
+	if (port->cfg.switch_setup_func)
+		port->cfg.switch_setup_func(port);
+
+	return 0;
+}
+
+static int tcpc_pd_sink_init(struct tcpc_port *port)
+{
+	uint8_t valb;
+	uint16_t val;
+	int err;
+	enum typec_cc_polarity pol;
+	enum typec_cc_state state;
+
+	if (port == NULL || port->i2c_dev == NULL)
+		return -EINVAL;
+
+	port->pd_state = UNATTACH;
+
+	/* Check the VBUS PRES and SINK VBUS for dead battery */
+	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	if (!(valb & TCPC_POWER_STATUS_VBUS_PRES)) {
+		tcpc_debug_log(port, "VBUS NOT PRES \n");
+		return -EPERM;
+	}
+
+	if (!(valb & TCPC_POWER_STATUS_SINKING_VBUS)) {
+		tcpc_debug_log(port, "SINK VBUS is not enabled for dead battery\n");
+		return -EPERM;
+	}
+
+	err = dm_i2c_read(port->i2c_dev, TCPC_ALERT, (uint8_t *)&val, 2);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	if (!(val & TCPC_ALERT_CC_STATUS)) {
+		tcpc_debug_log(port, "CC STATUS not detected for dead battery\n");
+		return -EPERM;
+	}
+
+	err = tcpc_get_cc_status(port, &pol, &state);
+	if (err || (state != TYPEC_STATE_SNK_POWER15
+		&& state != TYPEC_STATE_SNK_POWER30
+		&& state != TYPEC_STATE_SNK_DEFAULT)) {
+		tcpc_log(port, "TCPC wrong state for dead battery, err = %d, CC = 0x%x\n",
+			err, state);
+		return -EPERM;
+	} else {
+		err = tcpc_set_plug_orientation(port, pol);
+		if (err) {
+			tcpc_log(port, "TCPC set plug orientation failed, err = %d\n", err);
+			return err;
+		}
+		port->pd_state = ATTACHED;
+	}
+
+	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_CTRL, (uint8_t *)&valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	valb &= ~TCPC_POWER_CTRL_AUTO_DISCH_DISCO; /* disable AutoDischargeDisconnect */
+	err = dm_i2c_write(port->i2c_dev, TCPC_POWER_CTRL, (const uint8_t *)&valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	if (port->cfg.switch_setup_func)
+		port->cfg.switch_setup_func(port);
+
+	/* As sink role */
+	valb = 0x00;
+	err = dm_i2c_write(port->i2c_dev, TCPC_MSG_HDR_INFO, (const uint8_t *)&valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	/* Enable rx */
+	valb = TCPC_RX_DETECT_SOP | TCPC_RX_DETECT_HARD_RESET;
+	err = dm_i2c_write(port->i2c_dev, TCPC_RX_DETECT, (const uint8_t *)&valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	tcpc_pd_sink_process(port);
+
+	return 0;
+}
+
+int tcpc_init(struct tcpc_port *port, struct tcpc_port_config config, ss_mux_sel ss_sel_func)
+{
+	int ret;
+	uint8_t valb;
+	uint16_t vid, pid;
+	struct udevice *bus;
+	struct udevice *i2c_dev = NULL;
+
+	memset(port, 0, sizeof(struct tcpc_port));
+
+	if (port == NULL)
+		return -EINVAL;
+
+	port->cfg = config;
+	port->tx_msg_id = 0;
+	port->ss_sel_func = ss_sel_func;
+	port->log_p = (char *)&(port->logbuffer);
+	port->log_size = TCPC_LOG_BUFFER_SIZE;
+	port->log_print = port->log_p;
+	memset(&(port->logbuffer), 0, TCPC_LOG_BUFFER_SIZE);
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, port->cfg.i2c_bus, &bus);
+	if (ret) {
+		printf("%s: Can't find bus\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = dm_i2c_probe(bus, port->cfg.addr, 0, &i2c_dev);
+	if (ret) {
+		printf("%s: Can't find device id=0x%x\n",
+			__func__, config.addr);
+		return -ENODEV;
+	}
+
+	port->i2c_dev = i2c_dev;
+
+	/* Check the Initialization Status bit in 1s */
+	ret = tcpc_polling_reg(port, TCPC_POWER_STATUS, 1, TCPC_POWER_STATUS_UNINIT, 0, 1000);
+	if (ret) {
+		tcpc_log(port, "%s: Polling TCPC POWER STATUS Initialization Status bit failed, ret = %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
+	tcpc_debug_log(port, "POWER STATUS: 0x%x\n", valb);
+
+	/* Clear AllRegistersResetToDefault */
+	valb = 0x80;
+	ret = dm_i2c_write(port->i2c_dev, TCPC_FAULT_STATUS, (const uint8_t *)&valb, 1);
+	if (ret) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, ret);
+		return -EIO;
+	}
+
+	/* Read Vendor ID and Product ID */
+	ret = dm_i2c_read(port->i2c_dev, TCPC_VENDOR_ID, (uint8_t *)&vid, 2);
+	if (ret) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, ret);
+		return -EIO;
+	}
+
+	ret = dm_i2c_read(port->i2c_dev, TCPC_PRODUCT_ID, (uint8_t *)&pid, 2);
+	if (ret) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, ret);
+		return -EIO;
+	}
+
+	tcpc_log(port, "TCPC:  Vendor ID [0x%x], Product ID [0x%x], Addr [I2C%u 0x%x]\n",
+		vid, pid, port->cfg.i2c_bus, port->cfg.addr);
+
+	if (!port->cfg.disable_pd) {
+		if  (port->cfg.port_type == TYPEC_PORT_UFP
+			|| port->cfg.port_type == TYPEC_PORT_DRP)
+			tcpc_pd_sink_init(port);
+	} else {
+		tcpc_pd_sink_disable(port);
+	}
+
+	/* Mask all alert status */
+	tcpc_alert_mask(port, 0);
+	/* Mask all fault status */
+	tcpc_fault_status_mask(port, 0);
+
+	tcpc_clear_alert(port, 0xffff);
+
+	tcpc_print_log(port);
+
+	return 0;
+}
diff --git a/board/adlink/common/tcpc.h b/board/adlink/common/tcpc.h
new file mode 100644
index 00000000000..87d9a228fff
--- /dev/null
+++ b/board/adlink/common/tcpc.h
@@ -0,0 +1,472 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __TCPCI_H
+#define __TCPCI_H
+
+#include <dm.h>
+
+#define TCPC_VENDOR_ID			0x0
+#define TCPC_PRODUCT_ID			0x2
+
+#define TCPC_ALERT					0x10
+#define TCPC_ALERT_VBUS_DISCNCT		BIT(11)
+#define TCPC_ALERT_RX_BUF_OVF		BIT(10)
+#define TCPC_ALERT_FAULT			BIT(9)
+#define TCPC_ALERT_V_ALARM_LO		BIT(8)
+#define TCPC_ALERT_V_ALARM_HI		BIT(7)
+#define TCPC_ALERT_TX_SUCCESS		BIT(6)
+#define TCPC_ALERT_TX_DISCARDED		BIT(5)
+#define TCPC_ALERT_TX_FAILED		BIT(4)
+#define TCPC_ALERT_RX_HARD_RST		BIT(3)
+#define TCPC_ALERT_RX_STATUS		BIT(2)
+#define TCPC_ALERT_POWER_STATUS		BIT(1)
+#define TCPC_ALERT_CC_STATUS		BIT(0)
+
+#define TCPC_ALERT_MASK			0x12
+#define TCPC_FAULT_STATUS_MASK		0x15
+
+#define TCPC_TCPC_CTRL				0x19
+#define TCPC_TCPC_CTRL_BIST_MODE	BIT(1)
+#define TCPC_TCPC_CTRL_ORIENTATION	BIT(0)
+
+#define TCPC_ROLE_CTRL				0x1a
+#define TCPC_ROLE_CTRL_DRP			BIT(6)
+#define TCPC_ROLE_CTRL_RP_VAL_SHIFT	4
+#define TCPC_ROLE_CTRL_RP_VAL_MASK	0x3
+#define TCPC_ROLE_CTRL_RP_VAL_DEF	0x0
+#define TCPC_ROLE_CTRL_RP_VAL_1_5	0x1
+#define TCPC_ROLE_CTRL_RP_VAL_3_0	0x2
+#define TCPC_ROLE_CTRL_CC2_SHIFT	2
+#define TCPC_ROLE_CTRL_CC2_MASK		0x3
+#define TCPC_ROLE_CTRL_CC1_SHIFT	0
+#define TCPC_ROLE_CTRL_CC1_MASK		0x3
+#define TCPC_ROLE_CTRL_CC_RA		0x0
+#define TCPC_ROLE_CTRL_CC_RP		0x1
+#define TCPC_ROLE_CTRL_CC_RD		0x2
+#define TCPC_ROLE_CTRL_CC_OPEN		0x3
+
+#define TCPC_POWER_CTRL						0x1c
+#define TCPC_POWER_CTRL_EN_VCONN			BIT(0)
+#define TCPC_POWER_CTRL_VCONN_POWER			BIT(1)
+#define TCPC_POWER_CTRL_FORCE_DISCH			BIT(2)
+#define TCPC_POWER_CTRL_EN_BLEED_CH			BIT(3)
+#define TCPC_POWER_CTRL_AUTO_DISCH_DISCO	BIT(4)
+#define TCPC_POWER_CTRL_DIS_V_ALARMS		BIT(5)
+#define TCPC_POWER_CTRL_VBUS_V_MONITOR		BIT(6)
+
+#define TCPC_CC_STATUS					0x1d
+#define TCPC_CC_STATUS_LOOK4CONN		BIT(5)
+#define TCPC_CC_STATUS_TERM				BIT(4)
+#define TCPC_CC_STATUS_CC2_SHIFT		2
+#define TCPC_CC_STATUS_CC2_MASK			0x3
+#define TCPC_CC_STATUS_CC1_SHIFT		0
+#define TCPC_CC_STATUS_CC1_MASK			0x3
+
+#define TCPC_POWER_STATUS				0x1e
+#define TCPC_POWER_STATUS_UNINIT		BIT(6)
+#define TCPC_POWER_STATUS_VBUS_DET		BIT(3)
+#define TCPC_POWER_STATUS_VBUS_PRES		BIT(2)
+#define TCPC_POWER_STATUS_SINKING_VBUS	BIT(0)
+
+#define TCPC_FAULT_STATUS               0x1f
+
+#define TCPC_COMMAND					0x23
+#define TCPC_CMD_WAKE_I2C				0x11
+#define TCPC_CMD_DISABLE_VBUS_DETECT	0x22
+#define TCPC_CMD_ENABLE_VBUS_DETECT		0x33
+#define TCPC_CMD_DISABLE_SINK_VBUS		0x44
+#define TCPC_CMD_SINK_VBUS				0x55
+#define TCPC_CMD_DISABLE_SRC_VBUS		0x66
+#define TCPC_CMD_SRC_VBUS_DEFAULT		0x77
+#define TCPC_CMD_SRC_VBUS_HIGH			0x88
+#define TCPC_CMD_LOOK4CONNECTION		0x99
+#define TCPC_CMD_RXONEMORE				0xAA
+#define TCPC_CMD_I2C_IDLE				0xFF
+
+#define TCPC_DEV_CAP_1					0x24
+#define TCPC_DEV_CAP_2					0x26
+#define TCPC_STD_INPUT_CAP				0x28
+#define TCPC_STD_OUTPUT_CAP				0x29
+
+#define TCPC_MSG_HDR_INFO				0x2e
+#define TCPC_MSG_HDR_INFO_DATA_ROLE		BIT(3)
+#define TCPC_MSG_HDR_INFO_PWR_ROLE		BIT(0)
+#define TCPC_MSG_HDR_INFO_REV_SHIFT		1
+#define TCPC_MSG_HDR_INFO_REV_MASK		0x3
+
+#define TCPC_RX_DETECT					0x2f
+#define TCPC_RX_DETECT_HARD_RESET		BIT(5)
+#define TCPC_RX_DETECT_SOP				BIT(0)
+
+#define TCPC_RX_BYTE_CNT				0x30
+#define TCPC_RX_BUF_FRAME_TYPE			0x31
+#define TCPC_RX_HDR						0x32
+#define TCPC_RX_DATA					0x34 /* through 0x4f */
+
+#define TCPC_TRANSMIT					0x50
+#define TCPC_TRANSMIT_RETRY_SHIFT		4
+#define TCPC_TRANSMIT_RETRY_MASK		0x3
+#define TCPC_TRANSMIT_TYPE_SHIFT		0
+#define TCPC_TRANSMIT_TYPE_MASK			0x7
+
+#define TCPC_TX_BYTE_CNT				0x51
+#define TCPC_TX_HDR						0x52
+#define TCPC_TX_DATA					0x54 /* through 0x6f */
+
+#define TCPC_VBUS_VOLTAGE					0x70
+#define TCPC_VBUS_VOL_MASK					0x3ff
+#define TCPC_VBUS_VOL_SCALE_FACTOR_MASK		0xc00
+#define TCPC_VBUS_VOL_SCALE_FACTOR_SHIFT	10
+#define TCPC_VBUS_VOL_MV_UNIT				25
+
+#define TCPC_VBUS_SINK_DISCONNECT_THRESH	0x72
+#define TCPC_VBUS_STOP_DISCHARGE_THRESH		0x74
+#define TCPC_VBUS_VOLTAGE_ALARM_HI_CFG		0x76
+#define TCPC_VBUS_VOLTAGE_ALARM_LO_CFG		0x78
+
+enum typec_role {
+	TYPEC_SINK,
+	TYPEC_SOURCE,
+	TYPEC_ROLE_UNKNOWN,
+};
+
+enum typec_data_role {
+	TYPEC_DEVICE,
+	TYPEC_HOST,
+};
+
+enum typec_cc_polarity {
+	TYPEC_POLARITY_CC1,
+	TYPEC_POLARITY_CC2,
+};
+
+enum typec_cc_state {
+	TYPEC_STATE_OPEN,
+	TYPEC_STATE_SRC_BOTH_RA,
+	TYPEC_STATE_SRC_RD_RA,
+	TYPEC_STATE_SRC_RD,
+	TYPEC_STATE_SRC_RESERVED,
+	TYPEC_STATE_SNK_DEFAULT,
+	TYPEC_STATE_SNK_POWER15,
+	TYPEC_STATE_SNK_POWER30,
+};
+
+
+/* USB PD Messages */
+enum pd_ctrl_msg_type {
+	/* 0 Reserved */
+	PD_CTRL_GOOD_CRC = 1,
+	PD_CTRL_GOTO_MIN = 2,
+	PD_CTRL_ACCEPT = 3,
+	PD_CTRL_REJECT = 4,
+	PD_CTRL_PING = 5,
+	PD_CTRL_PS_RDY = 6,
+	PD_CTRL_GET_SOURCE_CAP = 7,
+	PD_CTRL_GET_SINK_CAP = 8,
+	PD_CTRL_DR_SWAP = 9,
+	PD_CTRL_PR_SWAP = 10,
+	PD_CTRL_VCONN_SWAP = 11,
+	PD_CTRL_WAIT = 12,
+	PD_CTRL_SOFT_RESET = 13,
+	/* 14-15 Reserved */
+};
+
+enum pd_data_msg_type {
+	/* 0 Reserved */
+	PD_DATA_SOURCE_CAP = 1,
+	PD_DATA_REQUEST = 2,
+	PD_DATA_BIST = 3,
+	PD_DATA_SINK_CAP = 4,
+	/* 5-14 Reserved */
+	PD_DATA_VENDOR_DEF = 15,
+};
+
+enum tcpc_transmit_type {
+	TCPC_TX_SOP = 0,
+	TCPC_TX_SOP_PRIME = 1,
+	TCPC_TX_SOP_PRIME_PRIME = 2,
+	TCPC_TX_SOP_DEBUG_PRIME = 3,
+	TCPC_TX_SOP_DEBUG_PRIME_PRIME = 4,
+	TCPC_TX_HARD_RESET = 5,
+	TCPC_TX_CABLE_RESET = 6,
+	TCPC_TX_BIST_MODE_2 = 7
+};
+
+enum pd_sink_state{
+	UNATTACH = 0,
+	ATTACHED,
+	WAIT_SOURCE_CAP,
+	WAIT_SOURCE_ACCEPT,
+	WAIT_SOURCE_READY,
+	SINK_READY,
+};
+
+
+#define PD_REV10        0x0
+#define PD_REV20        0x1
+
+#define PD_HEADER_CNT_SHIFT     12
+#define PD_HEADER_CNT_MASK      0x7
+#define PD_HEADER_ID_SHIFT      9
+#define PD_HEADER_ID_MASK       0x7
+#define PD_HEADER_PWR_ROLE      BIT(8)
+#define PD_HEADER_REV_SHIFT     6
+#define PD_HEADER_REV_MASK      0x3
+#define PD_HEADER_DATA_ROLE     BIT(5)
+#define PD_HEADER_TYPE_SHIFT    0
+#define PD_HEADER_TYPE_MASK     0xf
+
+#define PD_HEADER(type, pwr, data, id, cnt)                             \
+	((((type) & PD_HEADER_TYPE_MASK) << PD_HEADER_TYPE_SHIFT) |     \
+	 ((pwr) == TYPEC_SOURCE ? PD_HEADER_PWR_ROLE : 0) |             \
+	 ((data) == TYPEC_HOST ? PD_HEADER_DATA_ROLE : 0) |             \
+	 (PD_REV20 << PD_HEADER_REV_SHIFT) |                            \
+	 (((id) & PD_HEADER_ID_MASK) << PD_HEADER_ID_SHIFT) |           \
+	 (((cnt) & PD_HEADER_CNT_MASK) << PD_HEADER_CNT_SHIFT))
+
+
+static inline unsigned int pd_header_cnt(uint16_t header)
+{
+	return (header >> PD_HEADER_CNT_SHIFT) & PD_HEADER_CNT_MASK;
+}
+
+static inline unsigned int pd_header_cnt_le(__le16 header)
+{
+	return pd_header_cnt(le16_to_cpu(header));
+}
+
+static inline unsigned int pd_header_type(uint16_t header)
+{
+	return (header >> PD_HEADER_TYPE_SHIFT) & PD_HEADER_TYPE_MASK;
+}
+
+static inline unsigned int pd_header_type_le(__le16 header)
+{
+	return pd_header_type(le16_to_cpu(header));
+}
+
+#define PD_MAX_PAYLOAD          7
+
+struct pd_message {
+	uint8_t   frametype;
+	uint16_t  header;
+	uint32_t  payload[PD_MAX_PAYLOAD];
+} __packed;
+
+enum pd_pdo_type {
+	PDO_TYPE_FIXED = 0,
+	PDO_TYPE_BATT = 1,
+	PDO_TYPE_VAR = 2,
+};
+
+
+#define PDO_TYPE_SHIFT          30
+#define PDO_TYPE_MASK           0x3
+
+#define PDO_TYPE(t)     ((t) << PDO_TYPE_SHIFT)
+
+#define PDO_VOLT_MASK           0x3ff
+#define PDO_CURR_MASK           0x3ff
+#define PDO_PWR_MASK            0x3ff
+
+#define PDO_FIXED_DUAL_ROLE     BIT(29) /* Power role swap supported */
+#define PDO_FIXED_SUSPEND       BIT(28) /* USB Suspend supported (Source) */
+#define PDO_FIXED_HIGHER_CAP    BIT(28) /* Requires more than vSafe5V (Sink) */
+#define PDO_FIXED_EXTPOWER      BIT(27) /* Externally powered */
+#define PDO_FIXED_USB_COMM      BIT(26) /* USB communications capable */
+#define PDO_FIXED_DATA_SWAP     BIT(25) /* Data role swap supported */
+#define PDO_FIXED_VOLT_SHIFT    10      /* 50mV units */
+#define PDO_FIXED_CURR_SHIFT    0       /* 10mA units */
+
+#define PDO_FIXED_VOLT(mv)      ((((mv) / 50) & PDO_VOLT_MASK) << PDO_FIXED_VOLT_SHIFT)
+#define PDO_FIXED_CURR(ma)      ((((ma) / 10) & PDO_CURR_MASK) << PDO_FIXED_CURR_SHIFT)
+
+#define PDO_FIXED(mv, ma, flags)                        \
+	(PDO_TYPE(PDO_TYPE_FIXED) | (flags) |           \
+	 PDO_FIXED_VOLT(mv) | PDO_FIXED_CURR(ma))
+
+#define PDO_BATT_MAX_VOLT_SHIFT 20      /* 50mV units */
+#define PDO_BATT_MIN_VOLT_SHIFT 10      /* 50mV units */
+#define PDO_BATT_MAX_PWR_SHIFT  0       /* 250mW units */
+
+#define PDO_BATT_MIN_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_BATT_MIN_VOLT_SHIFT)
+#define PDO_BATT_MAX_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_BATT_MAX_VOLT_SHIFT)
+#define PDO_BATT_MAX_POWER(mw) ((((mw) / 250) & PDO_PWR_MASK) << PDO_BATT_MAX_PWR_SHIFT)
+
+#define PDO_BATT(min_mv, max_mv, max_mw)                        \
+	(PDO_TYPE(PDO_TYPE_BATT) | PDO_BATT_MIN_VOLT(min_mv) |  \
+	 PDO_BATT_MAX_VOLT(max_mv) | PDO_BATT_MAX_POWER(max_mw))
+
+#define PDO_VAR_MAX_VOLT_SHIFT  20      /* 50mV units */
+#define PDO_VAR_MIN_VOLT_SHIFT  10      /* 50mV units */
+#define PDO_VAR_MAX_CURR_SHIFT  0       /* 10mA units */
+
+#define PDO_VAR_MIN_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_VAR_MIN_VOLT_SHIFT)
+#define PDO_VAR_MAX_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_VAR_MAX_VOLT_SHIFT)
+#define PDO_VAR_MAX_CURR(ma) ((((ma) / 10) & PDO_CURR_MASK) << PDO_VAR_MAX_CURR_SHIFT)
+
+#define PDO_VAR(min_mv, max_mv, max_ma)                         \
+	(PDO_TYPE(PDO_TYPE_VAR) | PDO_VAR_MIN_VOLT(min_mv) |    \
+	 PDO_VAR_MAX_VOLT(max_mv) | PDO_VAR_MAX_CURR(max_ma))
+
+static inline enum pd_pdo_type pdo_type(uint32_t pdo)
+{
+	return (pdo >> PDO_TYPE_SHIFT) & PDO_TYPE_MASK;
+}
+
+static inline unsigned int pdo_fixed_voltage(uint32_t pdo)
+{
+	return ((pdo >> PDO_FIXED_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;
+}
+
+static inline unsigned int pdo_min_voltage(uint32_t pdo)
+{
+	return ((pdo >> PDO_VAR_MIN_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;
+}
+
+static inline unsigned int pdo_max_voltage(uint32_t pdo)
+{
+	return ((pdo >> PDO_VAR_MAX_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;
+}
+
+static inline unsigned int pdo_max_current(uint32_t pdo)
+{
+	return ((pdo >> PDO_VAR_MAX_CURR_SHIFT) & PDO_CURR_MASK) * 10;
+}
+
+static inline unsigned int pdo_max_power(uint32_t pdo)
+{
+	return ((pdo >> PDO_BATT_MAX_PWR_SHIFT) & PDO_PWR_MASK) * 250;
+}
+
+/* RDO: Request Data Object */
+#define RDO_OBJ_POS_SHIFT       28
+#define RDO_OBJ_POS_MASK        0x7
+#define RDO_GIVE_BACK           BIT(27) /* Supports reduced operating current */
+#define RDO_CAP_MISMATCH        BIT(26) /* Not satisfied by source caps */
+#define RDO_USB_COMM            BIT(25) /* USB communications capable */
+#define RDO_NO_SUSPEND          BIT(24) /* USB Suspend not supported */
+
+#define RDO_PWR_MASK                    0x3ff
+#define RDO_CURR_MASK                   0x3ff
+
+#define RDO_FIXED_OP_CURR_SHIFT         10
+#define RDO_FIXED_MAX_CURR_SHIFT        0
+
+#define RDO_OBJ(idx) (((idx) & RDO_OBJ_POS_MASK) << RDO_OBJ_POS_SHIFT)
+
+#define PDO_FIXED_OP_CURR(ma) ((((ma) / 10) & RDO_CURR_MASK) << RDO_FIXED_OP_CURR_SHIFT)
+#define PDO_FIXED_MAX_CURR(ma) ((((ma) / 10) & RDO_CURR_MASK) << RDO_FIXED_MAX_CURR_SHIFT)
+
+#define RDO_FIXED(idx, op_ma, max_ma, flags)                    \
+	(RDO_OBJ(idx) | (flags) |                               \
+	 PDO_FIXED_OP_CURR(op_ma) | PDO_FIXED_MAX_CURR(max_ma))
+
+#define RDO_BATT_OP_PWR_SHIFT           10      /* 250mW units */
+#define RDO_BATT_MAX_PWR_SHIFT          0       /* 250mW units */
+
+#define RDO_BATT_OP_PWR(mw) ((((mw) / 250) & RDO_PWR_MASK) << RDO_BATT_OP_PWR_SHIFT)
+#define RDO_BATT_MAX_PWR(mw) ((((mw) / 250) & RDO_PWR_MASK) << RDO_BATT_MAX_PWR_SHIFT)
+
+#define RDO_BATT(idx, op_mw, max_mw, flags)                     \
+	(RDO_OBJ(idx) | (flags) |                               \
+	 RDO_BATT_OP_PWR(op_mw) | RDO_BATT_MAX_PWR(max_mw))
+
+static inline unsigned int rdo_index(u32 rdo)
+{
+	return (rdo >> RDO_OBJ_POS_SHIFT) & RDO_OBJ_POS_MASK;
+}
+
+static inline unsigned int rdo_op_current(u32 rdo)
+{
+	return ((rdo >> RDO_FIXED_OP_CURR_SHIFT) & RDO_CURR_MASK) * 10;
+}
+
+static inline unsigned int rdo_max_current(u32 rdo)
+{
+	return ((rdo >> RDO_FIXED_MAX_CURR_SHIFT) &
+			RDO_CURR_MASK) * 10;
+}
+
+static inline unsigned int rdo_op_power(u32 rdo)
+{
+	return ((rdo >> RDO_BATT_OP_PWR_SHIFT) & RDO_PWR_MASK) * 250;
+}
+
+static inline unsigned int rdo_max_power(u32 rdo)
+{
+	return ((rdo >> RDO_BATT_MAX_PWR_SHIFT) & RDO_PWR_MASK) * 250;
+}
+
+#define TCPC_LOG_BUFFER_SIZE 1024
+
+struct tcpc_port;
+
+typedef void (*ss_mux_sel)(enum typec_cc_polarity pol);
+typedef int (*ext_pd_switch_setup)(struct tcpc_port *port_p);
+
+enum tcpc_port_type {
+	TYPEC_PORT_DFP,
+	TYPEC_PORT_UFP,
+	TYPEC_PORT_DRP,
+};
+
+struct tcpc_port_config {
+	uint8_t i2c_bus;
+	uint8_t addr;
+	enum tcpc_port_type port_type;
+	uint32_t max_snk_mv;
+	uint32_t max_snk_ma;
+	uint32_t max_snk_mw;
+	uint32_t op_snk_mv;
+	bool disable_pd;
+	ext_pd_switch_setup switch_setup_func;
+};
+
+struct tcpc_port {
+	struct tcpc_port_config cfg;
+	struct udevice *i2c_dev;
+	ss_mux_sel ss_sel_func;
+	enum pd_sink_state pd_state;
+	uint32_t tx_msg_id;
+	uint32_t log_size;
+	char logbuffer[TCPC_LOG_BUFFER_SIZE];
+	char *log_p;
+	char *log_print;
+};
+
+int tcpc_set_cc_to_source(struct tcpc_port *port);
+int tcpc_set_cc_to_sink(struct tcpc_port *port);
+int tcpc_set_plug_orientation(struct tcpc_port *port, enum typec_cc_polarity polarity);
+int tcpc_get_cc_status(struct tcpc_port *port, enum typec_cc_polarity *polarity, enum typec_cc_state *state);
+int tcpc_clear_alert(struct tcpc_port *port, uint16_t clear_mask);
+int tcpc_send_command(struct tcpc_port *port, uint8_t command);
+int tcpc_polling_reg(struct tcpc_port *port, uint8_t reg,
+	uint8_t reg_width, uint16_t mask, uint16_t value, ulong timeout_ms);
+int tcpc_setup_dfp_mode(struct tcpc_port *port);
+int tcpc_setup_ufp_mode(struct tcpc_port *port);
+int tcpc_disable_src_vbus(struct tcpc_port *port);
+int tcpc_init(struct tcpc_port *port, struct tcpc_port_config config, ss_mux_sel ss_sel_func);
+bool tcpc_pd_sink_check_charging(struct tcpc_port *port);
+void tcpc_print_log(struct tcpc_port *port);
+
+#ifdef CONFIG_SPL_BUILD
+int tcpc_setup_ufp_mode(struct tcpc_port *port)
+{
+	return 0;
+}
+int tcpc_setup_dfp_mode(struct tcpc_port *port)
+{
+	return 0;
+}
+
+int tcpc_disable_src_vbus(struct tcpc_port *port)
+{
+	return 0;
+}
+#endif
+#endif /* __TCPCI_H */
diff --git a/board/adlink/common/via.h b/board/adlink/common/via.h
new file mode 100644
index 00000000000..77cfacc5261
--- /dev/null
+++ b/board/adlink/common/via.h
@@ -0,0 +1,18 @@
+#ifndef _MPC85xx_VIA_H
+void mpc85xx_config_via(struct pci_controller* hose, pci_dev_t dev, struct pci_config_table *tab);
+
+/* Function 1, IDE */
+void mpc85xx_config_via_usbide(struct pci_controller* hose, pci_dev_t dev, struct pci_config_table *tab);
+
+/* Function 2, USB ports 0-1 */
+void mpc85xx_config_via_usb(struct pci_controller* hose, pci_dev_t dev, struct pci_config_table *tab);
+
+/* Function 3, USB ports 2-3 */
+void mpc85xx_config_via_usb2(struct pci_controller* hose, pci_dev_t dev, struct pci_config_table *tab);
+
+/* Function 5, Power Management */
+void mpc85xx_config_via_power(struct pci_controller* hose, pci_dev_t dev, struct pci_config_table *tab);
+
+/* Function 6, AC97 Interface */
+void mpc85xx_config_via_ac97(struct pci_controller* hose, pci_dev_t dev, struct pci_config_table *tab);
+#endif /* _MPC85xx_VIA_H */
diff --git a/board/adlink/common/vid.c b/board/adlink/common/vid.c
new file mode 100644
index 00000000000..fc5d400cfe1
--- /dev/null
+++ b/board/adlink/common/vid.c
@@ -0,0 +1,796 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Copyright 2020-21 NXP
+ * Copyright 2020 Stephen Carlson <stcarlso@linux.microsoft.com>
+ */
+
+#include <common.h>
+#include <command.h>
+#include <env.h>
+#include <i2c.h>
+#include <irq_func.h>
+#include <log.h>
+#include <asm/io.h>
+#ifdef CONFIG_FSL_LSCH2
+#include <asm/arch/immap_lsch2.h>
+#elif defined(CONFIG_FSL_LSCH3)
+#include <asm/arch/immap_lsch3.h>
+#else
+#include <asm/immap_85xx.h>
+#endif
+#include <linux/delay.h>
+#include "i2c_common.h"
+#include "vid.h"
+
+#ifndef I2C_VOL_MONITOR_BUS
+#define I2C_VOL_MONITOR_BUS                    0
+#endif
+
+/* Voltages are generally handled in mV to keep them as integers */
+#define MV_PER_V 1000
+
+/*
+ * Select the channel on the I2C mux (on some NXP boards) that contains
+ * the voltage regulator to use for VID. Return 0 for success or nonzero
+ * for failure.
+ */
+int __weak i2c_multiplexer_select_vid_channel(u8 channel)
+{
+	return 0;
+}
+
+/*
+ * Compensate for a board specific voltage drop between regulator and SoC.
+ * Returns the voltage offset in mV.
+ */
+int __weak board_vdd_drop_compensation(void)
+{
+	return 0;
+}
+
+/*
+ * Performs any board specific adjustments after the VID voltage has been
+ * set. Return 0 for success or nonzero for failure.
+ */
+int __weak board_adjust_vdd(int vdd)
+{
+	return 0;
+}
+
+/*
+ * Processor specific method of converting the fuse value read from VID
+ * registers into the core voltage to supply. Return the voltage in mV.
+ */
+u16 __weak soc_get_fuse_vid(int vid_index)
+{
+	/* Default VDD for Layerscape Chassis 1 devices */
+	static const u16 vdd[32] = {
+		0,      /* unused */
+		9875,   /* 0.9875V */
+		9750,
+		9625,
+		9500,
+		9375,
+		9250,
+		9125,
+		9000,
+		8875,
+		8750,
+		8625,
+		8500,
+		8375,
+		8250,
+		8125,
+		10000,  /* 1.0000V */
+		10125,
+		10250,
+		10375,
+		10500,
+		10625,
+		10750,
+		10875,
+		11000,
+		0,      /* reserved */
+	};
+	return vdd[vid_index];
+}
+
+#ifndef I2C_VOL_MONITOR_ADDR
+#define I2C_VOL_MONITOR_ADDR                    0
+#endif
+
+#if defined(CONFIG_VOL_MONITOR_IR36021_SET) || \
+	defined(CONFIG_VOL_MONITOR_IR36021_READ)
+/*
+ * Get the i2c address configuration for the IR regulator chip
+ *
+ * There are some variance in the RDB HW regarding the I2C address configuration
+ * for the IR regulator chip, which is likely a problem of external resistor
+ * accuracy. So we just check each address in a hopefully non-intrusive mode
+ * and use the first one that seems to work
+ *
+ * The IR chip can show up under the following addresses:
+ * 0x08 (Verified on T1040RDB-PA,T4240RDB-PB,X-T4240RDB-16GPA)
+ * 0x09 (Verified on T1040RDB-PA)
+ * 0x38 (Verified on T2080QDS, T2081QDS, T4240RDB)
+ */
+static int find_ir_chip_on_i2c(void)
+{
+	int i2caddress, ret, i;
+	u8 mfrID;
+	const int ir_i2c_addr[] = {0x38, 0x08, 0x09};
+	DEVICE_HANDLE_T dev;
+
+	/* Check all the address */
+	for (i = 0; i < (sizeof(ir_i2c_addr)/sizeof(ir_i2c_addr[0])); i++) {
+		i2caddress = ir_i2c_addr[i];
+		ret = fsl_i2c_get_device(i2caddress, I2C_VOL_MONITOR_BUS, &dev);
+		if (!ret) {
+			ret = I2C_READ(dev, IR36021_MFR_ID_OFFSET,
+				       (void *)&mfrID, sizeof(mfrID));
+			/* If manufacturer ID matches the IR36021 */
+			if (!ret && mfrID == IR36021_MFR_ID)
+				return i2caddress;
+		}
+	}
+	return -1;
+}
+#endif
+
+/* Maximum loop count waiting for new voltage to take effect */
+#define MAX_LOOP_WAIT_NEW_VOL		100
+/* Maximum loop count waiting for the voltage to be stable */
+#define MAX_LOOP_WAIT_VOL_STABLE	100
+/*
+ * read_voltage from sensor on I2C bus
+ * We use average of 4 readings, waiting for WAIT_FOR_ADC before
+ * another reading
+ */
+#define NUM_READINGS    4       /* prefer to be power of 2 for efficiency */
+
+/* If an INA220 chip is available, we can use it to read back the voltage
+ * as it may have a higher accuracy than the IR chip for the same purpose
+ */
+#ifdef CONFIG_VOL_MONITOR_INA220
+#define WAIT_FOR_ADC	532	/* wait for 532 microseconds for ADC */
+#define ADC_MIN_ACCURACY	4
+#else
+#define WAIT_FOR_ADC	138	/* wait for 138 microseconds for ADC */
+#define ADC_MIN_ACCURACY	4
+#endif
+
+#ifdef CONFIG_VOL_MONITOR_INA220
+static int read_voltage_from_INA220(int i2caddress)
+{
+	int i, ret, voltage_read = 0;
+	u16 vol_mon;
+	u8 buf[2];
+	DEVICE_HANDLE_T dev;
+
+	/* Open device handle */
+	ret = fsl_i2c_get_device(i2caddress, I2C_VOL_MONITOR_BUS, &dev);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < NUM_READINGS; i++) {
+		ret = I2C_READ(dev, I2C_VOL_MONITOR_BUS_V_OFFSET,
+			       (void *)&buf[0], sizeof(buf));
+		if (ret) {
+			printf("VID: failed to read core voltage\n");
+			return ret;
+		}
+
+		vol_mon = (buf[0] << 8) | buf[1];
+		if (vol_mon & I2C_VOL_MONITOR_BUS_V_OVF) {
+			printf("VID: Core voltage sensor error\n");
+			return -1;
+		}
+
+		debug("VID: bus voltage reads 0x%04x\n", vol_mon);
+		/* LSB = 4mv */
+		voltage_read += (vol_mon >> I2C_VOL_MONITOR_BUS_V_SHIFT) * 4;
+		udelay(WAIT_FOR_ADC);
+	}
+
+	/* calculate the average */
+	voltage_read /= NUM_READINGS;
+
+	return voltage_read;
+}
+#endif
+
+#ifdef CONFIG_VOL_MONITOR_IR36021_READ
+/* read voltage from IR */
+static int read_voltage_from_IR(int i2caddress)
+{
+	int i, ret, voltage_read = 0;
+	u16 vol_mon;
+	u8 buf;
+	DEVICE_HANDLE_T dev;
+
+	/* Open device handle */
+	ret = fsl_i2c_get_device(i2caddress, I2C_VOL_MONITOR_BUS, &dev);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < NUM_READINGS; i++) {
+		ret = I2C_READ(dev, IR36021_LOOP1_VOUT_OFFSET, (void *)&buf,
+			       sizeof(buf));
+		if (ret) {
+			printf("VID: failed to read core voltage\n");
+			return ret;
+		}
+		vol_mon = buf;
+		if (!vol_mon) {
+			printf("VID: Core voltage sensor error\n");
+			return -1;
+		}
+		debug("VID: bus voltage reads 0x%02x\n", vol_mon);
+		/* Resolution is 1/128V. We scale up here to get 1/128mV
+		 * and divide at the end
+		 */
+		voltage_read += vol_mon * MV_PER_V;
+		udelay(WAIT_FOR_ADC);
+	}
+	/* Scale down to the real mV as IR resolution is 1/128V, rounding up */
+	voltage_read = DIV_ROUND_UP(voltage_read, 128);
+
+	/* calculate the average */
+	voltage_read /= NUM_READINGS;
+
+	/* Compensate for a board specific voltage drop between regulator and
+	 * SoC before converting into an IR VID value
+	 */
+	voltage_read -= board_vdd_drop_compensation();
+
+	return voltage_read;
+}
+#endif
+
+#if defined(CONFIG_VOL_MONITOR_ISL68233_READ) || \
+	defined(CONFIG_VOL_MONITOR_LTC3882_READ) || \
+	defined(CONFIG_VOL_MONITOR_ISL68233_SET) || \
+	defined(CONFIG_VOL_MONITOR_LTC3882_SET)
+
+/*
+ * The message displayed if the VOUT exponent causes a resolution
+ * worse than 1.0 V (if exponent is >= 0).
+ */
+#define VOUT_WARNING "VID: VOUT_MODE exponent has resolution worse than 1 V!\n"
+
+/* Checks the PMBus voltage monitor for the format used for voltage values */
+static int get_pmbus_multiplier(DEVICE_HANDLE_T dev)
+{
+	u8 mode;
+	int exponent, multiplier, ret;
+
+	ret = I2C_READ(dev, PMBUS_CMD_VOUT_MODE, &mode, sizeof(mode));
+	if (ret) {
+		printf("VID: unable to determine voltage multiplier\n");
+		return 1;
+	}
+
+	/* Upper 3 bits is mode, lower 5 bits is exponent */
+	exponent = (int)mode & 0x1F;
+	mode >>= 5;
+	switch (mode) {
+	case 0:
+		/* Linear, 5 bit twos component exponent */
+		if (exponent & 0x10) {
+			multiplier = 1 << (16 - (exponent & 0xF));
+		} else {
+			/* If exponent is >= 0, then resolution is 1 V! */
+			printf(VOUT_WARNING);
+			multiplier = 1;
+		}
+		break;
+	case 1:
+		/* VID code identifier */
+		printf("VID: custom VID codes are not supported\n");
+		multiplier = MV_PER_V;
+		break;
+	default:
+		/* Direct, in mV */
+		multiplier = MV_PER_V;
+		break;
+	}
+
+	debug("VID: calculated multiplier is %d\n", multiplier);
+	return multiplier;
+}
+#endif
+
+#if defined(CONFIG_VOL_MONITOR_ISL68233_READ) || \
+	defined(CONFIG_VOL_MONITOR_LTC3882_READ)
+static int read_voltage_from_pmbus(int i2caddress)
+{
+	int ret, multiplier, vout;
+	u8 channel = PWM_CHANNEL0;
+	u16 vcode;
+	DEVICE_HANDLE_T dev;
+
+	/* Open device handle */
+	ret = fsl_i2c_get_device(i2caddress, I2C_VOL_MONITOR_BUS, &dev);
+	if (ret)
+		return ret;
+
+	/* Select the right page */
+	ret = I2C_WRITE(dev, PMBUS_CMD_PAGE, &channel, sizeof(channel));
+	if (ret) {
+		printf("VID: failed to select VDD page %d\n", channel);
+		return ret;
+	}
+
+	/* VOUT is little endian */
+	ret = I2C_READ(dev, PMBUS_CMD_READ_VOUT, (void *)&vcode, sizeof(vcode));
+	if (ret) {
+		printf("VID: failed to read core voltage\n");
+		return ret;
+	}
+
+	/* Scale down to the real mV */
+	multiplier = get_pmbus_multiplier(dev);
+	vout = (int)vcode;
+	/* Multiplier 1000 (direct mode) requires no change to convert */
+	if (multiplier != MV_PER_V)
+		vout = DIV_ROUND_UP(vout * MV_PER_V, multiplier);
+	return vout - board_vdd_drop_compensation();
+}
+#endif
+
+static int read_voltage(int i2caddress)
+{
+	int voltage_read;
+#ifdef CONFIG_VOL_MONITOR_INA220
+	voltage_read = read_voltage_from_INA220(I2C_VOL_MONITOR_ADDR);
+#elif defined CONFIG_VOL_MONITOR_IR36021_READ
+	voltage_read = read_voltage_from_IR(i2caddress);
+#elif defined(CONFIG_VOL_MONITOR_ISL68233_READ) || \
+	  defined(CONFIG_VOL_MONITOR_LTC3882_READ)
+	voltage_read = read_voltage_from_pmbus(i2caddress);
+#else
+	voltage_read = -1;
+#endif
+	return voltage_read;
+}
+
+#ifdef CONFIG_VOL_MONITOR_IR36021_SET
+/*
+ * We need to calculate how long before the voltage stops to drop
+ * or increase. It returns with the loop count. Each loop takes
+ * several readings (WAIT_FOR_ADC)
+ */
+static int wait_for_new_voltage(int vdd, int i2caddress)
+{
+	int timeout, vdd_current;
+
+	vdd_current = read_voltage(i2caddress);
+	/* wait until voltage starts to reach the target. Voltage slew
+	 * rates by typical regulators will always lead to stable readings
+	 * within each fairly long ADC interval in comparison to the
+	 * intended voltage delta change until the target voltage is
+	 * reached. The fairly small voltage delta change to any target
+	 * VID voltage also means that this function will always complete
+	 * within few iterations. If the timeout was ever reached, it would
+	 * point to a serious failure in the regulator system.
+	 */
+	for (timeout = 0;
+	     abs(vdd - vdd_current) > (IR_VDD_STEP_UP + IR_VDD_STEP_DOWN) &&
+	     timeout < MAX_LOOP_WAIT_NEW_VOL; timeout++) {
+		vdd_current = read_voltage(i2caddress);
+	}
+	if (timeout >= MAX_LOOP_WAIT_NEW_VOL) {
+		printf("VID: Voltage adjustment timeout\n");
+		return -1;
+	}
+	return timeout;
+}
+
+/*
+ * Blocks and reads the VID voltage until it stabilizes, or the
+ * timeout expires
+ */
+static int wait_for_voltage_stable(int i2caddress)
+{
+	int timeout, vdd_current, vdd;
+
+	vdd = read_voltage(i2caddress);
+	udelay(NUM_READINGS * WAIT_FOR_ADC);
+
+	vdd_current = read_voltage(i2caddress);
+	/*
+	 * The maximum timeout is
+	 * MAX_LOOP_WAIT_VOL_STABLE * NUM_READINGS * WAIT_FOR_ADC
+	 */
+	for (timeout = MAX_LOOP_WAIT_VOL_STABLE;
+	     abs(vdd - vdd_current) > ADC_MIN_ACCURACY &&
+	     timeout > 0; timeout--) {
+		vdd = vdd_current;
+		udelay(NUM_READINGS * WAIT_FOR_ADC);
+		vdd_current = read_voltage(i2caddress);
+	}
+	if (timeout == 0)
+		return -1;
+	return vdd_current;
+}
+
+/* Sets the VID voltage using the IR36021 */
+static int set_voltage_to_IR(int i2caddress, int vdd)
+{
+	int wait, vdd_last;
+	int ret;
+	u8 vid;
+	DEVICE_HANDLE_T dev;
+
+	/* Open device handle */
+	ret = fsl_i2c_get_device(i2caddress, I2C_VOL_MONITOR_BUS, &dev);
+	if (ret)
+		return ret;
+
+	/* Compensate for a board specific voltage drop between regulator and
+	 * SoC before converting into an IR VID value
+	 */
+	vdd += board_vdd_drop_compensation();
+#ifdef CONFIG_FSL_LSCH2
+	vid = DIV_ROUND_UP(vdd - 265, 5);
+#else
+	vid = DIV_ROUND_UP(vdd - 245, 5);
+#endif
+
+	ret = I2C_WRITE(dev, IR36021_LOOP1_MANUAL_ID_OFFSET, (void *)&vid,
+			sizeof(vid));
+	if (ret) {
+		printf("VID: failed to write new voltage\n");
+		return -1;
+	}
+	wait = wait_for_new_voltage(vdd, i2caddress);
+	if (wait < 0)
+		return -1;
+	debug("VID: Waited %d us\n", wait * NUM_READINGS * WAIT_FOR_ADC);
+
+	vdd_last = wait_for_voltage_stable(i2caddress);
+	if (vdd_last < 0)
+		return -1;
+	debug("VID: Current voltage is %d mV\n", vdd_last);
+	return vdd_last;
+}
+#endif
+
+#if defined(CONFIG_VOL_MONITOR_ISL68233_SET) || \
+	defined(CONFIG_VOL_MONITOR_LTC3882_SET)
+static int set_voltage_to_pmbus(int i2caddress, int vdd)
+{
+	int ret, vdd_last, vdd_target = vdd;
+	int count = MAX_LOOP_WAIT_NEW_VOL, temp = 0, multiplier;
+	unsigned char value;
+
+	/* The data to be sent with the PMBus command PAGE_PLUS_WRITE */
+	u8 buffer[5] = { 0x04, PWM_CHANNEL0, PMBUS_CMD_VOUT_COMMAND, 0, 0 };
+	DEVICE_HANDLE_T dev;
+
+	/* Open device handle */
+	ret = fsl_i2c_get_device(i2caddress, I2C_VOL_MONITOR_BUS, &dev);
+	if (ret)
+		return ret;
+
+	/* Scale up to the proper value for the VOUT command, little endian */
+	multiplier = get_pmbus_multiplier(dev);
+	vdd += board_vdd_drop_compensation();
+	if (multiplier != MV_PER_V)
+		vdd = DIV_ROUND_UP(vdd * multiplier, MV_PER_V);
+	buffer[3] = vdd & 0xFF;
+	buffer[4] = (vdd & 0xFF00) >> 8;
+
+	/* Check write protect state */
+	ret = I2C_READ(dev, PMBUS_CMD_WRITE_PROTECT, (void *)&value,
+		       sizeof(value));
+	if (ret)
+		goto exit;
+
+	if (value != EN_WRITE_ALL_CMD) {
+		value = EN_WRITE_ALL_CMD;
+		ret = I2C_WRITE(dev, PMBUS_CMD_WRITE_PROTECT,
+				(void *)&value, sizeof(value));
+		if (ret)
+			goto exit;
+	}
+
+	/* Write the desired voltage code to the regulator */
+	ret = I2C_WRITE(dev, PMBUS_CMD_PAGE_PLUS_WRITE, (void *)&buffer[0],
+			sizeof(buffer));
+	if (ret) {
+		printf("VID: I2C failed to write to the voltage regulator\n");
+		return -1;
+	}
+
+exit:
+	/* Wait for the voltage to get to the desired value */
+	do {
+		vdd_last = read_voltage_from_pmbus(i2caddress);
+		if (vdd_last < 0) {
+			printf("VID: Couldn't read sensor abort VID adjust\n");
+			return -1;
+		}
+		count--;
+		temp = vdd_last - vdd_target;
+	} while ((abs(temp) > 2)  && (count > 0));
+
+	return vdd_last;
+}
+#endif
+
+static int set_voltage(int i2caddress, int vdd)
+{
+	int vdd_last = -1;
+
+#ifdef CONFIG_VOL_MONITOR_IR36021_SET
+	vdd_last = set_voltage_to_IR(i2caddress, vdd);
+#elif defined(CONFIG_VOL_MONITOR_ISL68233_SET) || \
+	  defined(CONFIG_VOL_MONITOR_LTC3882_SET)
+	vdd_last = set_voltage_to_pmbus(i2caddress, vdd);
+#else
+	#error Specific voltage monitor must be defined
+#endif
+	return vdd_last;
+}
+
+int adjust_vdd(ulong vdd_override)
+{
+	int re_enable = disable_interrupts();
+#if defined(CONFIG_FSL_LSCH2) || defined(CONFIG_FSL_LSCH3)
+	struct ccsr_gur *gur = (void *)(CFG_SYS_FSL_GUTS_ADDR);
+#else
+	ccsr_gur_t __iomem *gur =
+		(void __iomem *)(CFG_SYS_MPC85xx_GUTS_ADDR);
+#endif
+	u8 vid;
+	u32 fusesr;
+	int vdd_current, vdd_last, vdd_target;
+	int ret, i2caddress = I2C_VOL_MONITOR_ADDR;
+	unsigned long vdd_string_override;
+	char *vdd_string;
+
+#if defined(CONFIG_VOL_MONITOR_IR36021_SET) || \
+	defined(CONFIG_VOL_MONITOR_IR36021_READ)
+	u8 buf;
+	DEVICE_HANDLE_T dev;
+#endif
+
+	/*
+	 * VID is used according to the table below
+	 *                ---------------------------------------
+	 *                |                DA_V                 |
+	 *                |-------------------------------------|
+	 *                | 5b00000 | 5b00001-5b11110 | 5b11111 |
+	 * ---------------+---------+-----------------+---------|
+	 * | D | 5b00000  | NO VID  | VID = DA_V      | NO VID  |
+	 * | A |----------+---------+-----------------+---------|
+	 * | _ | 5b00001  |VID =    | VID =           |VID =    |
+	 * | V |   ~      | DA_V_ALT|   DA_V_ALT      | DA_A_VLT|
+	 * | _ | 5b11110  |         |                 |         |
+	 * | A |----------+---------+-----------------+---------|
+	 * | L | 5b11111  | No VID  | VID = DA_V      | NO VID  |
+	 * | T |          |         |                 |         |
+	 * ------------------------------------------------------
+	 */
+#if defined(CONFIG_FSL_LSCH3)
+	fusesr = in_le32(&gur->dcfg_fusesr);
+	vid = (fusesr >> FSL_CHASSIS3_DCFG_FUSESR_ALTVID_SHIFT) &
+	       FSL_CHASSIS3_DCFG_FUSESR_ALTVID_MASK;
+	if (vid == 0 || vid == FSL_CHASSIS3_DCFG_FUSESR_ALTVID_MASK) {
+		vid = (fusesr >> FSL_CHASSIS3_DCFG_FUSESR_VID_SHIFT) &
+		       FSL_CHASSIS3_DCFG_FUSESR_VID_MASK;
+	}
+#elif defined(CONFIG_FSL_LSCH2)
+	fusesr = in_be32(&gur->dcfg_fusesr);
+	vid = (fusesr >> FSL_CHASSIS2_DCFG_FUSESR_ALTVID_SHIFT) &
+	       FSL_CHASSIS2_DCFG_FUSESR_ALTVID_MASK;
+	if (vid == 0 || vid == FSL_CHASSIS2_DCFG_FUSESR_ALTVID_MASK) {
+		vid = (fusesr >> FSL_CHASSIS2_DCFG_FUSESR_VID_SHIFT) &
+		       FSL_CHASSIS2_DCFG_FUSESR_VID_MASK;
+	}
+#else
+	fusesr = in_be32(&gur->dcfg_fusesr);
+	vid = (fusesr >> FSL_CORENET_DCFG_FUSESR_ALTVID_SHIFT) &
+	       FSL_CORENET_DCFG_FUSESR_ALTVID_MASK;
+	if (vid == 0 || vid == FSL_CORENET_DCFG_FUSESR_ALTVID_MASK) {
+		vid = (fusesr >> FSL_CORENET_DCFG_FUSESR_VID_SHIFT) &
+		       FSL_CORENET_DCFG_FUSESR_VID_MASK;
+	}
+#endif
+	vdd_target = soc_get_fuse_vid((int)vid);
+
+	ret = i2c_multiplexer_select_vid_channel(I2C_MUX_CH_VOL_MONITOR);
+	if (ret) {
+		debug("VID: I2C failed to switch channel\n");
+		ret = -1;
+		goto exit;
+	}
+
+#if defined(CONFIG_VOL_MONITOR_IR36021_SET) || \
+	defined(CONFIG_VOL_MONITOR_IR36021_READ)
+	ret = find_ir_chip_on_i2c();
+	if (ret < 0) {
+		printf("VID: Could not find voltage regulator on I2C.\n");
+		ret = -1;
+		goto exit;
+	} else {
+		i2caddress = ret;
+		debug("VID: IR Chip found on I2C address 0x%02x\n", i2caddress);
+	}
+
+	ret = fsl_i2c_get_device(i2caddress, I2C_VOL_MONITOR_BUS, &dev);
+	if (ret)
+		return ret;
+
+	/* check IR chip work on Intel mode */
+	ret = I2C_READ(dev, IR36021_INTEL_MODE_OFFSET, (void *)&buf,
+		       sizeof(buf));
+	if (ret) {
+		printf("VID: failed to read IR chip mode.\n");
+		ret = -1;
+		goto exit;
+	}
+	if ((buf & IR36021_MODE_MASK) != IR36021_INTEL_MODE) {
+		printf("VID: IR Chip is not used in Intel mode.\n");
+		ret = -1;
+		goto exit;
+	}
+#endif
+
+	/* check override variable for overriding VDD */
+	vdd_string = env_get(CONFIG_VID_FLS_ENV);
+	debug("VID: Initial VDD value is %d mV\n",
+	      DIV_ROUND_UP(vdd_target, 10));
+	if (vdd_override == 0 && vdd_string &&
+	    !strict_strtoul(vdd_string, 10, &vdd_string_override))
+		vdd_override = vdd_string_override;
+	if (vdd_override >= VDD_MV_MIN && vdd_override <= VDD_MV_MAX) {
+		vdd_target = vdd_override * 10; /* convert to 1/10 mV */
+		debug("VID: VDD override is %lu\n", vdd_override);
+	} else if (vdd_override != 0) {
+		printf("VID: Invalid VDD value.\n");
+	}
+	if (vdd_target == 0) {
+		debug("VID: VID not used\n");
+		ret = 0;
+		goto exit;
+	} else {
+		/* divide and round up by 10 to get a value in mV */
+		vdd_target = DIV_ROUND_UP(vdd_target, 10);
+		debug("VID: vid = %d mV\n", vdd_target);
+	}
+
+	/*
+	 * Read voltage monitor to check real voltage.
+	 */
+	vdd_last = read_voltage(i2caddress);
+	if (vdd_last < 0) {
+		printf("VID: Couldn't read sensor abort VID adjustment\n");
+		ret = -1;
+		goto exit;
+	}
+	vdd_current = vdd_last;
+	debug("VID: Core voltage is currently at %d mV\n", vdd_last);
+
+#if defined(CONFIG_VOL_MONITOR_LTC3882_SET) || \
+	defined(CONFIG_VOL_MONITOR_ISL68233_SET)
+	/* Set the target voltage */
+	vdd_current = set_voltage(i2caddress, vdd_target);
+	vdd_last = vdd_current;
+#else
+	/*
+	  * Adjust voltage to at or one step above target.
+	  * As measurements are less precise than setting the values
+	  * we may run through dummy steps that cancel each other
+	  * when stepping up and then down.
+	  */
+	while (vdd_last > 0 &&
+	       vdd_last < vdd_target) {
+		vdd_current += IR_VDD_STEP_UP;
+		vdd_last = set_voltage(i2caddress, vdd_current);
+	}
+	while (vdd_last > 0 &&
+	       vdd_last > vdd_target + (IR_VDD_STEP_DOWN - 1)) {
+		vdd_current -= IR_VDD_STEP_DOWN;
+		vdd_last = set_voltage(i2caddress, vdd_current);
+	}
+#endif
+
+	/* Board specific adjustments */
+	if (board_adjust_vdd(vdd_target) < 0) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (vdd_last > 0)
+		printf("VID: Core voltage after adjustment is at %d mV\n",
+		       vdd_last);
+	else
+		ret = -1;
+exit:
+	if (re_enable)
+		enable_interrupts();
+
+	i2c_multiplexer_select_vid_channel(I2C_MUX_CH_DEFAULT);
+
+	return ret;
+}
+
+static int print_vdd(void)
+{
+	int vdd_last, ret, i2caddress = I2C_VOL_MONITOR_ADDR;
+
+	ret = i2c_multiplexer_select_vid_channel(I2C_MUX_CH_VOL_MONITOR);
+	if (ret) {
+		debug("VID : I2c failed to switch channel\n");
+		return -1;
+	}
+#if defined(CONFIG_VOL_MONITOR_IR36021_SET) || \
+	defined(CONFIG_VOL_MONITOR_IR36021_READ)
+	ret = find_ir_chip_on_i2c();
+	if (ret < 0) {
+		printf("VID: Could not find voltage regulator on I2C.\n");
+		goto exit;
+	} else {
+		i2caddress = ret;
+		debug("VID: IR Chip found on I2C address 0x%02x\n", i2caddress);
+	}
+#endif
+
+	/*
+	 * Read voltage monitor to check real voltage.
+	 */
+	vdd_last = read_voltage(i2caddress);
+	if (vdd_last < 0) {
+		printf("VID: Couldn't read sensor abort VID adjustment\n");
+		goto exit;
+	}
+	printf("VID: Core voltage is at %d mV\n", vdd_last);
+exit:
+	i2c_multiplexer_select_vid_channel(I2C_MUX_CH_DEFAULT);
+
+	return ret < 0 ? -1 : 0;
+}
+
+static int do_vdd_override(struct cmd_tbl *cmdtp,
+			   int flag, int argc,
+			   char *const argv[])
+{
+	ulong override;
+	int ret = 0;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	if (!strict_strtoul(argv[1], 10, &override)) {
+		ret = adjust_vdd(override);
+		if (ret < 0)
+			return CMD_RET_FAILURE;
+	} else
+		return CMD_RET_USAGE;
+	return 0;
+}
+
+static int do_vdd_read(struct cmd_tbl *cmdtp, int flag, int argc,
+		       char *const argv[])
+{
+	if (argc < 1)
+		return CMD_RET_USAGE;
+	print_vdd();
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	vdd_override, 2, 0, do_vdd_override,
+	"override VDD",
+	" - override with the voltage specified in mV, eg. 1050"
+);
+
+U_BOOT_CMD(
+	vdd_read, 1, 0, do_vdd_read,
+	"read VDD",
+	" - Read the voltage specified in mV"
+);
diff --git a/board/adlink/common/vid.h b/board/adlink/common/vid.h
new file mode 100644
index 00000000000..b34c080b4ba
--- /dev/null
+++ b/board/adlink/common/vid.h
@@ -0,0 +1,75 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Copyright 2020 NXP
+ */
+
+#ifndef __VID_H_
+#define __VID_H_
+
+/* IR36021 command codes */
+#define IR36021_LOOP1_MANUAL_ID_OFFSET	0x6A
+#define IR36021_LOOP1_VOUT_OFFSET	0x9A
+#define IR36021_MFR_ID_OFFSET		0x92
+#define IR36021_MFR_ID			0x43
+#define IR36021_INTEL_MODE_OFFSET	0x14
+#define IR36021_MODE_MASK		0x20
+#define IR36021_INTEL_MODE		0x00
+#define IR36021_AMD_MODE		0x20
+
+/* Step the IR regulator in 5mV increments */
+#define IR_VDD_STEP_DOWN		5
+#define IR_VDD_STEP_UP			5
+
+/* LTC3882 */
+#define PMBUS_CMD_WRITE_PROTECT         0x10
+/*
+ * WRITE_PROTECT command supported values
+ * 0x80: Disable all writes except WRITE_PROTECT, PAGE,
+ *       STORE_USER_ALL and MFR_EE_UNLOCK commands.
+ * 0x40: Disable all writes except WRITE_PROTECT, PAGE, STORE_USER_ALL,
+ *       MFR_EE_UNLOCK, OPERATION, CLEAR_PEAKS and CLEAR_FAULTS commands.
+ *       Individual faults can also be cleared by writing a 1 to the
+ *       respective status bit.
+ * 0x20: Disable all writes except WRITE_PROTECT, PAGE, STORE_USER_ ALL,
+ *       MFR_EE_UNLOCK, OPERATION, CLEAR_PEAKS, CLEAR_FAULTS, ON_OFF_CONFIG
+ *       and VOUT_COMMAND commands. Individual faults can be cleared by
+ *       writing a 1 to the respective status bit.
+ * 0x00: Enables write to all commands
+ */
+#define EN_WRITE_ALL_CMD (0)
+
+#ifdef CONFIG_TARGET_LX2160ARDB
+/* The lowest and highest voltage allowed*/
+#define VDD_MV_MIN			775
+#define VDD_MV_MAX			855
+#endif
+
+#if defined(CONFIG_TARGET_LX2160AQDS) || defined(CONFIG_TARGET_LX2162AQDS)
+/* The lowest and highest voltage allowed*/
+#define VDD_MV_MIN			775
+#define VDD_MV_MAX			925
+#endif
+
+/* PM Bus commands code for LTC3882*/
+#define PWM_CHANNEL0                    0x0
+#define PMBUS_CMD_PAGE                  0x0
+#define PMBUS_CMD_READ_VOUT             0x8B
+#define PMBUS_CMD_VOUT_MODE			0x20
+#define PMBUS_CMD_VOUT_COMMAND          0x21
+#define PMBUS_CMD_PAGE_PLUS_WRITE       0x05
+
+#if defined(CONFIG_TARGET_LX2160AQDS) || defined(CONFIG_TARGET_LX2162AQDS) || \
+defined(CONFIG_TARGET_LX2160ARDB)
+/* Voltage monitor on channel 2*/
+#define I2C_VOL_MONITOR_BUS_V_OFFSET	0x2
+#define I2C_VOL_MONITOR_BUS_V_OVF	0x1
+#define I2C_VOL_MONITOR_BUS_V_SHIFT	3
+#define I2C_VOL_MONITOR_ADDR            0x63
+#define I2C_MUX_CH_VOL_MONITOR		0xA
+#endif
+
+int adjust_vdd(ulong vdd_override);
+u16 soc_get_fuse_vid(int vid_index);
+
+#endif  /* __VID_H_ */
diff --git a/board/adlink/common/vsc3316_3308.h b/board/adlink/common/vsc3316_3308.h
new file mode 100644
index 00000000000..9725d6d9e39
--- /dev/null
+++ b/board/adlink/common/vsc3316_3308.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __VSC_CROSSBAR_H_
+#define __VSC_CROSSBAR_H_
+
+#include <i2c.h>
+#include <errno.h>
+
+int vsc_if_enable(unsigned int vsc_addr);
+int vsc3316_config(unsigned int vsc_addr, int8_t con_arr[][2],
+		unsigned int num_con);
+#ifdef CONFIG_SYS_FSL_B4860QDS_XFI_ERR
+int vsc3308_config_adjust(unsigned int vsc_addr, const int8_t con_arr[][2],
+		unsigned int num_con);
+#endif
+int vsc3308_config(unsigned int vsc_addr, const int8_t con_arr[][2],
+		unsigned int num_con);
+void vsc_wp_config(unsigned int vsc_addr);
+
+#endif	/* __VSC_CROSSBAR_H_ */
diff --git a/board/adlink/lec_imx95/Kconfig b/board/adlink/lec_imx95/Kconfig
new file mode 100644
index 00000000000..ba564180a6e
--- /dev/null
+++ b/board/adlink/lec_imx95/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_LEC_IMX95
+
+config SYS_BOARD
+	default "lec_imx95"
+
+config SYS_VENDOR
+	default "adlink"
+
+config SYS_CONFIG_NAME
+	default "lec_imx95"
+
+endif
diff --git a/board/adlink/lec_imx95/Makefile b/board/adlink/lec_imx95/Makefile
new file mode 100644
index 00000000000..cc60dcc67be
--- /dev/null
+++ b/board/adlink/lec_imx95/Makefile
@@ -0,0 +1,11 @@
+#
+# Copyright 2023 NXP
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y += lec_imx95.o
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+endif
diff --git a/board/adlink/lec_imx95/lec_imx95.c b/board/adlink/lec_imx95/lec_imx95.c
new file mode 100644
index 00000000000..e29a0d85b67
--- /dev/null
+++ b/board/adlink/lec_imx95/lec_imx95.c
@@ -0,0 +1,610 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2023-2024 NXP
+ */
+
+#include <common.h>
+#include <env.h>
+#include <init.h>
+#include <asm/global_data.h>
+#include <asm/arch-imx9/ccm_regs.h>
+#include <asm/arch/clock.h>
+#include <fdt_support.h>
+#include <usb.h>
+#include "../common/tcpc.h"
+#include <dwc3-uboot.h>
+#include <asm/io.h>
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/gpio.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <dm/uclass.h>
+#include <dm/uclass-internal.h>
+
+#ifdef CONFIG_SCMI_FIRMWARE
+#include <scmi_agent.h>
+#include <scmi_protocols.h>
+#include <dt-bindings/clock/fsl,imx95-clock.h>
+#include <dt-bindings/power/fsl,imx95-power.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_early_init_f(void)
+{
+	/* UART1: A55, UART2: M33, UART3: M7 */
+	init_uart_clk(0);
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_TCPC
+struct tcpc_port port;
+#ifdef CONFIG_TARGET_IMX95_15X15_EVK
+struct tcpc_port portpd;
+struct tcpc_port_config port_config = {
+	.i2c_bus = 2, /* i2c3 */
+	.addr = 0x50,
+	.port_type = TYPEC_PORT_DRP,
+	.disable_pd = true,
+};
+
+struct tcpc_port_config portpd_config = {
+	.i2c_bus = 2, /*i2c3*/
+	.addr = 0x52,
+	.port_type = TYPEC_PORT_UFP,
+	.max_snk_mv = 20000,
+	.max_snk_ma = 3000,
+	.max_snk_mw = 15000,
+	.op_snk_mv = 9000,
+};
+#else
+struct tcpc_port_config port_config = {
+	.i2c_bus = 6, /* i2c7 */
+	.addr = 0x50,
+	.port_type = TYPEC_PORT_DRP,
+	.disable_pd = true,
+};
+#endif
+
+ulong tca_base;
+
+void tca_mux_select(enum typec_cc_polarity pol)
+{
+	u32 val;
+
+	if (!tca_base)
+		return;
+
+	/* reset XBar block */
+	setbits_le32(tca_base, BIT(9));
+
+	/* Set OP mode to System configure Mode */
+	clrbits_le32(tca_base + 0x10, 0x3);
+
+	val = readl(tca_base + 0x30);
+
+	WARN_ON((val & GENMASK(1, 0)) != 0x3);
+	WARN_ON((val & BIT(2)) != 0);
+	WARN_ON((val & BIT(3)) != 0);
+	WARN_ON((val & BIT(4)) != 0);
+
+	printf("tca pstate 0x%x\n", val);
+
+	setbits_le32(tca_base + 0x18, BIT(3));
+	udelay(1);
+
+	if (pol == TYPEC_POLARITY_CC1)
+		clrbits_le32(tca_base + 0x18, BIT(2));
+	else
+		setbits_le32(tca_base + 0x18, BIT(2));
+
+	udelay(1);
+
+	clrbits_le32(tca_base + 0x18, BIT(3));
+}
+
+static void setup_typec(void)
+{
+	int ret;
+
+	tca_base = USB1_BASE_ADDR + 0xfc000;
+
+#ifdef CONFIG_TARGET_IMX95_15X15_EVK
+	struct gpio_desc ext_12v_desc;
+
+	ret = tcpc_init(&portpd, portpd_config, NULL);
+	if (ret) {
+		printf("%s: tcpc portpd init failed, err=%d\n",
+		       __func__, ret);
+	} else if (tcpc_pd_sink_check_charging(&portpd)) {
+		printf("Power supply on USB PD\n");
+
+		/* Enable EXT 12V */
+		ret = dm_gpio_lookup_name("gpio@22_1", &ext_12v_desc);
+		if (ret) {
+			printf("%s lookup gpio@22_1 failed ret = %d\n", __func__, ret);
+			return;
+		}
+
+		ret = dm_gpio_request(&ext_12v_desc, "ext_12v_en");
+		if (ret) {
+			printf("%s request ext_12v_en failed ret = %d\n", __func__, ret);
+			return;
+		}
+
+		/* Enable PER 12V regulator */
+		dm_gpio_set_dir_flags(&ext_12v_desc, GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	}
+#endif
+
+	ret = tcpc_init(&port, port_config, &tca_mux_select);
+	if (ret) {
+		printf("%s: tcpc init failed, err=%d\n", __func__, ret);
+		return;
+	}
+}
+#endif
+
+#ifdef CONFIG_USB_DWC3
+
+#define PHY_CTRL0			0xF0040
+#define PHY_CTRL0_REF_SSP_EN		BIT(2)
+#define PHY_CTRL0_FSEL_MASK		GENMASK(10, 5)
+#define PHY_CTRL0_FSEL_24M		0x2a
+#define PHY_CTRL0_FSEL_100M		0x27
+#define PHY_CTRL0_SSC_RANGE_MASK	GENMASK(23, 21)
+#define PHY_CTRL0_SSC_RANGE_4003PPM	(0x2 << 21)
+
+#define PHY_CTRL1			0xF0044
+#define PHY_CTRL1_RESET			BIT(0)
+#define PHY_CTRL1_COMMONONN		BIT(1)
+#define PHY_CTRL1_ATERESET		BIT(3)
+#define PHY_CTRL1_DCDENB		BIT(17)
+#define PHY_CTRL1_CHRGSEL		BIT(18)
+#define PHY_CTRL1_VDATSRCENB0		BIT(19)
+#define PHY_CTRL1_VDATDETENB0		BIT(20)
+
+#define PHY_CTRL2			0xF0048
+#define PHY_CTRL2_TXENABLEN0		BIT(8)
+#define PHY_CTRL2_OTG_DISABLE		BIT(9)
+
+#define PHY_CTRL6			0xF0058
+#define PHY_CTRL6_RXTERM_OVERRIDE_SEL	BIT(29)
+#define PHY_CTRL6_ALT_CLK_EN		BIT(1)
+#define PHY_CTRL6_ALT_CLK_SEL		BIT(0)
+
+#define PDIR (0x50)
+extern u64 phys_sdram_size,phys_sdram_2_size;
+
+static struct dwc3_device dwc3_device_data = {
+#ifdef CONFIG_SPL_BUILD
+	.maximum_speed = USB_SPEED_HIGH,
+#else
+	.maximum_speed = USB_SPEED_SUPER,
+#endif
+	.base = USB1_BASE_ADDR,
+	.dr_mode = USB_DR_MODE_PERIPHERAL,
+	.index = 0,
+	.power_down_scale = 2,
+};
+
+int dm_usb_gadget_handle_interrupts(struct udevice *dev)
+{
+	dwc3_uboot_handle_interrupt(dev);
+	return 0;
+}
+
+static void dwc3_nxp_usb_phy_init(struct dwc3_device *dwc3)
+{
+	u32 value;
+
+	/* USB3.0 PHY signal fsel for 24M ref */
+	value = readl(dwc3->base + PHY_CTRL0);
+	value &= ~PHY_CTRL0_FSEL_MASK;
+	value |= FIELD_PREP(PHY_CTRL0_FSEL_MASK, PHY_CTRL0_FSEL_24M);
+	writel(value, dwc3->base + PHY_CTRL0);
+
+	/* Disable alt_clk_en and use internal MPLL clocks */
+	value = readl(dwc3->base + PHY_CTRL6);
+	value &= ~(PHY_CTRL6_ALT_CLK_SEL | PHY_CTRL6_ALT_CLK_EN);
+	writel(value, dwc3->base + PHY_CTRL6);
+
+	value = readl(dwc3->base + PHY_CTRL1);
+	value &= ~(PHY_CTRL1_VDATSRCENB0 | PHY_CTRL1_VDATDETENB0);
+	value |= PHY_CTRL1_RESET | PHY_CTRL1_ATERESET;
+	writel(value, dwc3->base + PHY_CTRL1);
+
+	value = readl(dwc3->base + PHY_CTRL0);
+	value |= PHY_CTRL0_REF_SSP_EN;
+	writel(value, dwc3->base + PHY_CTRL0);
+
+	value = readl(dwc3->base + PHY_CTRL2);
+	value |= PHY_CTRL2_TXENABLEN0 | PHY_CTRL2_OTG_DISABLE;
+	writel(value, dwc3->base + PHY_CTRL2);
+
+	udelay(10);
+
+	value = readl(dwc3->base + PHY_CTRL1);
+	value &= ~(PHY_CTRL1_RESET | PHY_CTRL1_ATERESET);
+	writel(value, dwc3->base + PHY_CTRL1);
+}
+#endif
+
+static int imx9_scmi_power_domain_enable(u32 domain, bool enable)
+{
+	return scmi_pwd_state_set(gd->arch.scmi_dev, 0, domain, enable ? 0 : BIT(30));
+}
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	int ret = 0;
+
+	if (index == 0 && init == USB_INIT_DEVICE) {
+		ret = imx9_scmi_power_domain_enable(IMX95_PD_HSIO_TOP, true);
+		if (ret) {
+			printf("SCMI_POWWER_STATE_SET Failed for USB\n");
+			return ret;
+		}
+
+#ifdef CONFIG_USB_DWC3
+		dwc3_nxp_usb_phy_init(&dwc3_device_data);
+#endif
+#ifdef CONFIG_USB_TCPC
+		ret = tcpc_setup_ufp_mode(&port);
+		if (ret)
+			return ret;
+#endif
+#ifdef CONFIG_USB_DWC3
+		return dwc3_uboot_init(&dwc3_device_data);
+#endif
+	} else if (index == 0 && init == USB_INIT_HOST) {
+#ifdef CONFIG_USB_TCPC
+		ret = tcpc_setup_dfp_mode(&port);
+#endif
+		return ret;
+	}
+
+	return 0;
+}
+
+int board_usb_cleanup(int index, enum usb_init_type init)
+{
+	int ret = 0;
+	if (index == 0 && init == USB_INIT_DEVICE) {
+#ifdef CONFIG_USB_DWC3
+		dwc3_uboot_exit(index);
+#endif
+	} else if (index == 0 && init == USB_INIT_HOST) {
+#ifdef CONFIG_USB_TCPC
+		ret = tcpc_disable_src_vbus(&port);
+#endif
+	}
+
+	return ret;
+}
+
+static void netc_phy_rst(const char *gpio_name, const char *label)
+{
+	int ret;
+	struct gpio_desc desc;
+
+	/* ENET_RST_B */
+	ret = dm_gpio_lookup_name(gpio_name, &desc);
+	if (ret) {
+		printf("%s lookup %s failed ret = %d\n", __func__, gpio_name, ret);
+		return;
+	}
+
+	ret = dm_gpio_request(&desc, label);
+	if (ret) {
+		printf("%s request %s failed ret = %d\n", __func__, label, ret);
+		return;
+	}
+
+	/* assert the ENET_RST_B */
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE | GPIOD_ACTIVE_LOW);
+	udelay(10000);
+	dm_gpio_set_value(&desc, 0); /* deassert the ENET_RST_B */
+	udelay(80000);
+
+}
+
+void netc_init(void)
+{
+	int ret;
+
+	/* Power up the NETC MIX. */
+	ret = imx9_scmi_power_domain_enable(IMX95_PD_NETC, true);
+	if (ret) {
+		printf("SCMI_POWWER_STATE_SET Failed for NETC MIX\n");
+		return;
+	}
+
+	set_clk_netc(ENET_125MHZ);
+
+#ifdef CONFIG_TARGET_IMX95_15X15_EVK
+	netc_phy_rst("gpio@22_4", "ENET1_RST_B");
+	netc_phy_rst("gpio@22_5", "ENET2_RST_B");
+#else
+	netc_phy_rst("i2c5_io@21_2", "ENET1_RST_B");
+#endif
+	pci_init();
+}
+
+static void flexspi_nor_steup(void)
+{
+	struct gpio_desc desc;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_TARGET_IMX95_15X15_EVK))
+		return;
+
+	/* Power cycle the M2 3V3 */
+	ret = dm_gpio_lookup_name("gpio@22_10", &desc);
+	if (ret)
+		return;
+
+	ret = dm_gpio_request(&desc, "M2_PWREN");
+	if (ret)
+		return;
+
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT);
+	dm_gpio_set_value(&desc, 0);
+	udelay(100000);
+	dm_gpio_set_value(&desc, 1);
+
+	/* Enable 1.8V LDO */
+	ret = dm_gpio_lookup_name("gpio@22_11", &desc);
+	if (ret)
+		return;
+
+	ret = dm_gpio_request(&desc, "M2_DIS1");
+	if (ret)
+		return;
+
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT);
+	dm_gpio_set_value(&desc, 1);
+
+	/* Deassert M2_SD3_nRST */
+	ret = dm_gpio_lookup_name("GPIO5_9", &desc);
+	if (ret)
+		return;
+
+	ret = dm_gpio_request(&desc, "M2_SD3_nRST");
+	if (ret)
+		return;
+
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT);
+	dm_gpio_set_value(&desc, 1);
+}
+
+#if CONFIG_IS_ENABLED(NET)
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	int ret;
+	ret = imx9_scmi_power_domain_enable(IMX95_PD_HSIO_TOP, true);
+	if (ret) {
+		printf("SCMI_POWWER_STATE_SET Failed for USB\n");
+		return ret;
+	}
+
+	imx9_scmi_power_domain_enable(IMX95_PD_DISPLAY, false);
+	imx9_scmi_power_domain_enable(IMX95_PD_CAMERA, false);
+
+#if defined(CONFIG_USB_TCPC)
+	setup_typec();
+#endif
+
+	netc_init();
+
+	flexspi_nor_steup();
+
+	power_on_m7("mx95alt");
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	env_set("sec_boot", "no");
+#ifdef CONFIG_AHAB_BOOT
+	env_set("sec_boot", "yes");
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	return 0;
+}
+#endif
+
+int board_phys_sdram_size(phys_size_t *size)
+{
+	ulong sku_cfg = ((readl(GPIO5_BASE_ADDR + PDIR) & 0x70)>>4); //GPIO5_IO_BIT(4~6)
+
+	if(sku_cfg==0x2) //LEC-iMX95 MT62F2G32D4DS-023 IT:C 4GB
+	{
+		phys_sdram_size = 0x70000000;		//2GB  - 256MB DDR
+		phys_sdram_2_size = 0x80000000;		//2GB
+	}
+
+	*size = phys_sdram_size + phys_sdram_2_size;
+
+	return 0;
+}
+
+void board_quiesce_devices(void)
+{
+	int ret;
+	struct uclass *uc_dev;
+
+	ret = imx9_scmi_power_domain_enable(IMX95_PD_HSIO_TOP, false);
+	if (ret) {
+		printf("%s: Failed for HSIO MIX: %d\n", __func__, ret);
+		return;
+	}
+
+	ret = imx9_scmi_power_domain_enable(IMX95_PD_NETC, false);
+	if (ret) {
+		printf("%s: Failed for NETC MIX: %d\n", __func__, ret);
+		return;
+	}
+
+	ret = uclass_get(UCLASS_SPI_FLASH, &uc_dev);
+	if (uc_dev)
+		ret = uclass_destroy(uc_dev);
+	if (ret)
+		printf("couldn't remove SPI FLASH devices\n");
+}
+
+#if IS_ENABLED(CONFIG_OF_BOARD_FIXUP)
+
+#if IS_ENABLED(CONFIG_TARGET_IMX95_15X15_EVK)
+static void change_fdt_mido_pins(void *fdt)
+{
+	int nodeoff, ret;
+	u32 enet1_pins[12] = { 0x00B8, 0x02BC, 0x0424, 0x00, 0x00, 0x57e,
+		0x00BC, 0x02C0, 0x0428, 0x00, 0x00, 0x97e};
+
+	nodeoff = fdt_path_offset(fdt, "/firmware/scmi/protocol@19/emdiogrp");
+	if (nodeoff > 0) {
+
+		int i;
+		for (i = 0; i < 12; i++) {
+			enet1_pins[i] = cpu_to_fdt32(enet1_pins[i]);
+		}
+
+		ret = fdt_setprop(fdt, nodeoff, "fsl,pins", enet1_pins, 12 * sizeof(u32));
+		if (ret)
+			printf("fdt_setprop fsl,pins error %d\n", ret);
+		else
+			debug("Update MDIO pins ok\n");
+	}
+}
+
+static int board_fix_15x15_evk(void *fdt)
+{
+	int ret;
+	struct udevice *bus;
+	struct udevice *i2c_dev = NULL;
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, 2, &bus);
+	if (ret) {
+		printf("%s: Can't find I2C bus 2\n", __func__);
+		return 0;
+	}
+
+	ret = dm_i2c_probe(bus, 0x50, 0, &i2c_dev);
+	if (ret) {
+		ret = dm_i2c_probe(bus, 0x20, 0, &i2c_dev);
+		if (!ret) {
+			debug("Find Audio board\n");
+			change_fdt_mido_pins(fdt);
+		}
+	}
+
+	return 0;
+}
+
+#else
+
+static int imx9_scmi_misc_cfginfo(u32 *msel, char *cfgname)
+{
+	struct scmi_cfg_info_out out;
+	struct scmi_msg msg = SCMI_MSG(SCMI_PROTOCOL_ID_MISC, SCMI_MISC_CFG_INFO, out);
+	int ret;
+
+	ret = devm_scmi_process_msg(gd->arch.scmi_dev, &msg);
+	if(ret == 0 && out.status == 0) {
+		strcpy(cfgname, (const char *)out.cfgname);
+	} else {
+		printf("Failed to get cfg name, scmi_err = %d\n",
+		       out.status);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void disable_fdt_resources(void *fdt)
+{
+	int i = 0;
+	int nodeoff, ret;
+	const char *status = "disabled";
+	static const char * const dsi_nodes[] = {
+		"/soc@0/bus@42000000/i2c@426b0000",
+		"/soc@0/bus@42000000/i2c@426d0000",
+		"/pcie@4ca00000",
+		"/pcie@4cb00000"
+	};
+
+	for (i = 0; i < ARRAY_SIZE(dsi_nodes); i++) {
+		nodeoff = fdt_path_offset(fdt, dsi_nodes[i]);
+		if (nodeoff > 0) {
+set_status:
+			ret = fdt_setprop(fdt, nodeoff, "status", status,
+					  strlen(status) + 1);
+			if (ret == -FDT_ERR_NOSPACE) {
+				ret = fdt_increase_size(fdt, 512);
+				if (!ret)
+					goto set_status;
+			}
+		}
+	}
+}
+
+static int board_fix_19x19_evk(void *fdt)
+{
+	char cfgname[SCMI_MISC_MAX_CFGNAME];
+	u32 msel;
+	int ret;
+	const char *netcfg = "mx95netc";
+
+	ret = imx9_scmi_misc_cfginfo(&msel, cfgname);
+	if (!ret) {
+		debug("SM: %s\n", cfgname);
+		if (!strcmp(netcfg, cfgname))
+			disable_fdt_resources(fdt);
+	}
+
+	return 0;
+}
+#endif
+
+int board_fix_fdt(void *fdt)
+{
+#if IS_ENABLED(CONFIG_TARGET_IMX95_15X15_EVK)
+	return board_fix_15x15_evk(fdt);
+#else
+	return board_fix_19x19_evk(fdt);
+#endif
+}
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+#ifdef CONFIG_ANDROID_RECOVERY
+int is_recovery_key_pressing(void)
+{
+	return 0;
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+#endif /*CONFIG_FSL_FASTBOOT*/
diff --git a/board/adlink/lec_imx95/spl.c b/board/adlink/lec_imx95/spl.c
new file mode 100644
index 00000000000..6b688186b0c
--- /dev/null
+++ b/board/adlink/lec_imx95/spl.c
@@ -0,0 +1,162 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2023 NXP
+ */
+
+#include <common.h>
+#include <command.h>
+#include <cpu_func.h>
+#include <clk.h>
+#include <hang.h>
+#include <image.h>
+#include <init.h>
+#include <log.h>
+#include <spl.h>
+#include <asm/global_data.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/mach-imx/syscounter.h>
+#include <asm/mach-imx/ele_api.h>
+#include <asm/sections.h>
+#include <dm/uclass.h>
+#include <dm/device.h>
+#include <dm/uclass-internal.h>
+#include <dm/device-internal.h>
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/ccm_regs.h>
+#include <asm/gpio.h>
+#ifdef CONFIG_SCMI_FIRMWARE
+#include <scmi_agent.h>
+#include <scmi_protocols.h>
+#include <dt-bindings/clock/fsl,imx95-clock.h>
+#include <dt-bindings/power/fsl,imx95-power.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct udevice *scmi_dev __maybe_unused;
+
+int spl_board_boot_device(enum boot_device boot_dev_spl)
+{
+	switch (boot_dev_spl) {
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		return BOOT_DEVICE_MMC1;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		return BOOT_DEVICE_MMC2;
+	case USB_BOOT:
+		return BOOT_DEVICE_BOARD;
+	case QSPI_BOOT:
+		return BOOT_DEVICE_SPI;
+	default:
+		return BOOT_DEVICE_NONE;
+	}
+}
+
+void spl_board_init(void)
+{
+	int ret;
+
+	puts("Normal Boot\n");
+
+	ret = ele_start_rng();
+	if (ret)
+		printf("Fail to start RNG: %d\n", ret);
+}
+
+static void flexspi_nor_reset(void)
+{
+	int ret;
+	struct gpio_desc desc;
+
+	/* 15x15 EVK use M.2 QSPI card, not support booting */
+	if (IS_ENABLED(CONFIG_TARGET_IMX95_15X15_EVK))
+		return;
+
+	ret = dm_gpio_lookup_name("GPIO5_11", &desc);
+	if (ret) {
+		printf("%s lookup GPIO5_11 failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	ret = dm_gpio_request(&desc, "XSPI_RST_B");
+	if (ret) {
+		printf("%s request XSPI_RST_B failed ret = %d\n", __func__, ret);
+		return;
+	}
+
+	/* assert the XSPI_RST_B */
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE | GPIOD_ACTIVE_LOW);
+	udelay(200); /* 50 ns at least, so use 200ns */
+	dm_gpio_set_value(&desc, 0); /* deassert the XSPI_RST_B */
+}
+
+extern int imx9_probe_mu(void);
+
+void board_init_f(ulong dummy)
+{
+	int ret;
+	bool ddrmix_power = false;
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+#ifdef CONFIG_SPL_RECOVER_DATA_SECTION
+	if (IS_ENABLED(CONFIG_SPL_BUILD)) {
+		spl_save_restore_data();
+	}
+#endif
+
+	timer_init();
+
+	/* Need dm_init() to run before any SCMI calls can be made. */
+	spl_early_init();
+
+	/* Need enable SCMI drivers and ELE driver before enabling console */
+	ret = imx9_probe_mu();
+	if (ret)
+		hang(); /* if MU not probed, nothing can output, just hang here */
+
+	arch_cpu_init();
+
+	board_early_init_f();
+
+	preloader_console_init();
+
+	printf("SOC: 0x%x\n", gd->arch.soc_rev);
+	printf("LC: 0x%x\n", gd->arch.lifecycle);
+
+	get_reset_reason(true, false);
+
+	/* Will set ARM freq to max rate */
+	clock_init_late();
+
+	/* Check is DDR MIX is already powered up. */
+	u32 state = 0;
+	ret = scmi_pwd_state_get(gd->arch.scmi_dev, IMX95_PD_DDR, &state);
+	if (ret) {
+		printf("scmi_pwd_state_get Failed %d for DDRMIX\n", ret);
+	} else {
+		if (state == BIT(30)) {
+			panic("DDRMIX is powered OFF, Please initialize DDR with OEI \n");
+		} else {
+			printf("DDRMIX is powered UP \n");
+			ddrmix_power = true;
+		}
+	}
+
+	flexspi_nor_reset();
+
+	board_init_r(NULL, 0);
+}
+
+#ifdef CONFIG_ANDROID_SUPPORT
+int board_get_emmc_id(void) {
+	return 0;
+}
+#endif
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index 442ca739d28..42513c40cdf 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -1455,6 +1455,7 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 	unsigned long		flags;
 	int			ret = 0;
 	u32			reg;
+	int			wait_cnt=0;
 
 	spin_lock_irqsave(&dwc->lock, flags);
 
@@ -1471,6 +1472,13 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 	reg = dwc3_readl(dwc->regs, DWC3_DCFG);
 	reg &= ~(DWC3_DCFG_SPEED_MASK);
 
+	while(DWC3_DSTS_USBLNKST(dwc3_readl(dwc->regs, DWC3_DSTS)) == DWC3_LINK_STATE_SS_DIS)
+	{
+		if(wait_cnt++ > 30 )
+			break;
+		mdelay(1);
+	}
+	
 	/**
 	 * WORKAROUND: DWC3 revision < 2.20a have an issue
 	 * which would cause metastability state on Run/Stop
diff --git a/include/configs/lec_imx95.h b/include/configs/lec_imx95.h
new file mode 100755
index 00000000000..4dfc1db5133
--- /dev/null
+++ b/include/configs/lec_imx95.h
@@ -0,0 +1,226 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2023 NXP
+ */
+
+#ifndef __IMX95_EVK_H
+#define __IMX95_EVK_H
+
+#include <linux/sizes.h>
+#include <linux/stringify.h>
+#include <asm/arch/imx-regs.h>
+#include "imx_env.h"
+
+#define CFG_SYS_UBOOT_BASE	\
+	(QSPI0_AMBA_BASE + CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR * 512)
+
+#ifdef CONFIG_AHAB_BOOT
+#define AHAB_ENV "sec_boot=yes\0"
+#else
+#define AHAB_ENV "sec_boot=no\0"
+#endif
+
+#ifdef CONFIG_DISTRO_DEFAULTS
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 0) \
+	func(MMC, mmc, 1) \
+	func(USB, usb, 0)
+
+#include <config_distro_bootcmd.h>
+#else
+#define BOOTENV
+#endif
+
+#ifdef CONFIG_TARGET_IMX95_15X15_EVK
+#define JH_ROOT_DTB "imx95-15x15-evk-root.dtb"
+#else
+#define JH_ROOT_DTB "imx95-19x19-evk-root.dtb"
+#endif
+
+#define JAILHOUSE_ENV \
+	"jh_root_dtb=" JH_ROOT_DTB "\0" \
+	"jh_mmcboot=setenv fdtfile ${jh_root_dtb}; " \
+		    "setenv jh_clk cpuidle.off=1 clk_ignore_unused mem=1408MB kvm-arm.mode=nvhe; " \
+		    "if run loadimage; then run mmcboot;" \
+		    "else run jh_netboot; fi; \0" \
+	"jh_netboot=setenv fdtfile ${jh_root_dtb}; " \
+		    "setenv jh_clk cpuidle.off=1 clk_ignore_unused mem=1408MB kvm-arm.mode=nvhe; run netboot; \0 "
+
+#define CFG_MFG_ENV_SETTINGS \
+	CFG_MFG_ENV_SETTINGS_DEFAULT \
+	"initrd_addr=0x93800000\0" \
+	"initrd_high=0xffffffffffffffff\0" \
+	"emmc_dev=0\0"\
+	"sd_dev=1\0" \
+
+#define XEN_BOOT_ENV \
+	    "domu-android-auto=no\0" \
+            "xenhyper_bootargs=console=dtuart dom0_mem=4096M dom0_max_vcpus=2 pci-passthrough=on\0" \
+            "xenlinux_bootargs= \0" \
+            "xenlinux_console=hvc0 earlycon=xen\0" \
+            "xenlinux_addr=0x9c000000\0" \
+            "dom0fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+            "xenboot_common=" \
+                "${get_cmd} ${loadaddr} xen;" \
+                "${get_cmd} ${fdt_addr} ${dom0fdt_file};" \
+                "${get_cmd} ${xenlinux_addr} ${image};" \
+                "fdt addr ${fdt_addr};" \
+                "fdt resize 256;" \
+                "fdt set /chosen/module@0 reg <0x00000000 ${xenlinux_addr} 0x00000000 0x${filesize}>;" \
+                "fdt set /chosen/module@0 bootargs \"${bootargs} ${xenlinux_bootargs}\"; " \
+                "fdt set /soc/bus@49000000/iommu@490d0000 status disabled;" \
+                "setenv bootargs ${xenhyper_bootargs};" \
+                "booti ${loadaddr} - ${fdt_addr};" \
+            "\0" \
+            "xennetboot=" \
+                "setenv get_cmd dhcp;" \
+                "setenv console ${xenlinux_console};" \
+		"setenv jh_clk clk_ignore_unused;" \
+                "run netargs;" \
+                "run xenboot_common;" \
+            "\0" \
+            "xenmmcboot=" \
+                "setenv get_cmd \"fatload mmc ${mmcdev}:${mmcpart}\";" \
+                "setenv console ${xenlinux_console};" \
+		"setenv jh_clk clk_ignore_unused;" \
+                "run mmcargs;" \
+                "run xenboot_common;" \
+            "\0" \
+/* Initial environment variables */
+#define CFG_EXTRA_ENV_SETTINGS		\
+	JAILHOUSE_ENV \
+	CFG_MFG_ENV_SETTINGS \
+	XEN_BOOT_ENV \
+	BOOTENV \
+	AHAB_ENV \
+	"prepare_mcore=setenv mcore_args pd_ignore_unused;\0" \
+	"cpuidle= \0" \
+	"scriptaddr=0x93500000\0" \
+	"kernel_addr_r=" __stringify(CONFIG_SYS_LOAD_ADDR) "\0" \
+	"image=Image\0" \
+	"splashimage=0xA0000000\0" \
+	"console=ttyLP0,115200 earlycon\0" \
+	"fdt_addr_r=0x93000000\0"			\
+	"fdt_addr=0x93000000\0"			\
+	"fdt_high=0xffffffffffffffff\0"		\
+	"cntr_addr=0xA8000000\0"			\
+	"cntr_file=os_cntr_signed.bin\0" \
+	"boot_fit=no\0" \
+	"fdtfile=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"bootm_size=0x10000000\0" \
+	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcroot=/dev/mmcblk1p2 rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs ${cpuidle} ${jh_clk} ${mcore_args} console=${console} root=${mmcroot}\0 " \
+	"loadbootscript=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr_r} ${fdtfile}\0" \
+	"loadcntr=fatload mmc ${mmcdev}:${mmcpart} ${cntr_addr} ${cntr_file}\0" \
+	"auth_os=auth_cntr ${cntr_addr}\0" \
+	"boot_os=booti ${loadaddr} - ${fdt_addr_r};\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${sec_boot} = yes; then " \
+			"if run auth_os; then " \
+				"run boot_os; " \
+			"else " \
+				"echo ERR: failed to authenticate; " \
+			"fi; " \
+		"else " \
+			"if test ${boot_fit} = yes || test ${boot_fit} = try; then " \
+				"bootm ${loadaddr}; " \
+			"else " \
+				"if run loadfdt; then " \
+					"run boot_os; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi;" \
+		"fi;\0" \
+	"netargs=setenv bootargs ${cpuidle} ${jh_clk} ${mcore_args} console=${console} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs;  " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if test ${sec_boot} = yes; then " \
+			"${get_cmd} ${cntr_addr} ${cntr_file}; " \
+			"if run auth_os; then " \
+				"run boot_os; " \
+			"else " \
+				"echo ERR: failed to authenticate; " \
+			"fi; " \
+		"else " \
+			"${get_cmd} ${loadaddr} ${image}; " \
+			"if test ${boot_fit} = yes || test ${boot_fit} = try; then " \
+				"bootm ${loadaddr}; " \
+			"else " \
+				"if ${get_cmd} ${fdt_addr_r} ${fdtfile}; then " \
+					"run boot_os; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi;" \
+		"fi;\0" \
+	"bsp_bootcmd=echo Running BSP bootcmd ...; " \
+		"mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if test ${sec_boot} = yes; then " \
+				   "if run loadcntr; then " \
+					   "run mmcboot; " \
+				   "else run netboot; " \
+				   "fi; " \
+			    "else " \
+				   "if run loadimage; then " \
+					   "run mmcboot; " \
+					"else " \
+						"setenv mmcdev 0; mmc dev ${mmcdev}; " \
+						"if run loadimage; then " \
+							"run mmcboot; " \
+						"else run netboot; " \
+						"fi; " \
+				   "fi; " \
+				"fi; " \
+		   "fi; " \
+	   "fi;"
+
+/* Link Definitions */
+
+#define CFG_SYS_INIT_RAM_ADDR        0x90000000
+#define CFG_SYS_INIT_RAM_SIZE        0x200000
+
+#define CFG_SYS_SDRAM_BASE           0x90000000
+#define PHYS_SDRAM                      0x90000000
+/* Totally 16GB */
+#define PHYS_SDRAM_SIZE			0x70000000UL /* 2GB  - 256MB DDR */
+#ifdef CONFIG_TARGET_IMX95_15X15_EVK
+#define PHYS_SDRAM_2_SIZE 		0x180000000UL /* 4GB temp workaround, should be 8GB */
+#else
+#define PHYS_SDRAM_2_SIZE 		0x380000000UL /* 14GB */
+#endif
+
+#define CFG_SYS_FSL_USDHC_NUM	2
+
+/* Using ULP WDOG for reset */
+#define WDOG_BASE_ADDR          WDG3_BASE_ADDR
+
+/* USB configs */
+#if defined(CONFIG_CMD_NET)
+#define PHY_ANEG_TIMEOUT 20000
+/* Number of Rx BD rings: 8 per ENETC instance */
+#endif
+
+#ifdef CONFIG_ANDROID_SUPPORT
+#include "imx95_evk_android.h"
+#endif
+
+#endif
-- 
2.25.1

