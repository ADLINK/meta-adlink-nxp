From b17376bb55ea717c79b8aab9030adc409c4f07ba Mon Sep 17 00:00:00 2001
From: "po.cheng" <po.cheng@adlinktech.com>
Date: Tue, 6 May 2025 16:14:51 +0800
Subject: [PATCH 1/2] vvcam: imx678: beautify kernel logs and codes

Signed-off-by: po.cheng <po.cheng@adlinktech.com>
---
 vvcam/v4l2/sensor/imx678/imx678_mipi.c | 525 +++++++++++++------------
 1 file changed, 275 insertions(+), 250 deletions(-)

diff --git a/vvcam/v4l2/sensor/imx678/imx678_mipi.c b/vvcam/v4l2/sensor/imx678/imx678_mipi.c
index 7479557..cdc03ed 100644
--- a/vvcam/v4l2/sensor/imx678/imx678_mipi.c
+++ b/vvcam/v4l2/sensor/imx678/imx678_mipi.c
@@ -86,7 +86,7 @@ const char * const data_rate_menu[] = {
 };
 
 static const char * const test_pattern_menu[] = {
-	[0] = "No pattern",
+    [0] = "No pattern",
     [1] = "000h Pattern",
     [2] = "3FF(FFFh) Pattern",
     [3] = "155(555h) Pattern",
@@ -135,7 +135,7 @@ static const u32 gain_reg2times[IMX678_GAIN_REG_LEN] = {
     3430046, 3550585, 3675361, 3804521, 3938220, 4076617};
 
 const char * const sync_mode_menu[] = {
-	[NO_SYNC] 		= "No sync",
+    [NO_SYNC] 		= "No sync",
     [INTERNAL_SYNC] = "Internal sync",
     [EXTERNAL_SYNC] = "External sync",
 };
@@ -177,7 +177,6 @@ static struct v4l2_ctrl_config imx678_ctrl_framerate[] = {
 		.step = 1,
 	},
 };
-
 struct imx678_ctrls {
 	struct v4l2_ctrl_handler handler;
 	struct v4l2_ctrl *exposure;
@@ -220,8 +219,7 @@ static inline struct imx678 *to_imx678_dev(struct v4l2_subdev *sd)
 
 static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
 {
-	return &container_of(ctrl->handler, struct imx678,
-			     ctrls.handler)->sd;
+	return &container_of(ctrl->handler, struct imx678, ctrls.handler)->sd;
 }
 
 static struct vvcam_mode_info_s pimx678_mode_info[] = {
@@ -439,12 +437,13 @@ static int imx678_write_reg_arry(struct imx678 *sensor,
 	u8 send_buf_len = 0;
 	const u8 max_send_buff = 8;
 	struct i2c_client *i2c_client = sensor->i2c_client;
+	struct device *dev = &sensor->i2c_client->dev;
 	int i = 0;
 	int ret = 0;
 
 	send_buf = (u8 *)kmalloc(size + 2, GFP_KERNEL);
 	if (!send_buf) {
-		pr_err("enter %s failed to allocate memory for send_buffer\n", __func__);
+		dev_err(dev, "%s: failed to allocate memory for send_buffer\n", __func__);
 		return -ENOMEM;
 	}
 
@@ -488,11 +487,12 @@ static int imx678_write_reg_arry(struct imx678 *sensor,
 static int imx678_power_on(struct imx678 *sensor)
 {
 	int ret;
+	struct device *dev = &sensor->i2c_client->dev;
 
-	pr_info("enter %s\n", __func__);
+	dev_info(dev, "%s\n", __func__);
 
 	if (!gpio_is_valid(sensor->rst_gpio)) {
-		pr_err("%s:reset pin is not valid\n", __func__);
+		dev_err(dev, "%s: reset pin is not valid\n", __func__);
 		return -1;
 	}
 
@@ -500,7 +500,7 @@ static int imx678_power_on(struct imx678 *sensor)
 
 	ret = clk_prepare_enable(sensor->sensor_clk);
 	if (ret < 0)
-		pr_err("%s: enable sensor clk fail\n", __func__);
+		dev_err(dev, "%s: enable sensor clk fail\n", __func__);
 
 	sensor->powered_on = 1;
 	msleep(35);
@@ -511,15 +511,17 @@ static int imx678_power_on(struct imx678 *sensor)
 static int imx678_power_off(struct imx678 *sensor)
 {
 	int err = 0;
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s\n", __func__);
 
 	err = imx678_write_reg(sensor, XVS_XHS_DRV, 0xF);
 	if (err < 0) {
-		pr_err("%s: failed to set XVS XHS to Hi-Z\n", __func__);
+		dev_err(dev, "%s: failed to set XVS XHS to Hi-Z\n", __func__);
 	}
 
 	if (!gpio_is_valid(sensor->rst_gpio)) {
-		pr_err("%s:reset pin is not valid\n", __func__);
+		dev_err(dev, "%s:reset pin is not valid\n", __func__);
 		return -1;
 	}
 
@@ -536,9 +538,10 @@ static int imx678_s_power(struct v4l2_subdev *sd, int on)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct imx678 *sensor = client_to_imx678(client);
+	struct device *dev = &sensor->i2c_client->dev;
 	int ret = 0;
 
-	pr_info("enter %s\n", __func__);
+	dev_info(dev, "%s: %s\n", __func__, on ? "on" : "off");
 	if (on)
 		ret = imx678_power_on(sensor);
 	else
@@ -569,13 +572,15 @@ static int imx678_query_supports(struct imx678 *sensor, void* parry)
 	int ret = 0;
 	struct vvcam_mode_info_array_s *psensor_mode_arry = parry;
 	uint32_t support_counts = ARRAY_SIZE(pimx678_mode_info);
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s: mode counts: %u\n", __func__, support_counts);
 
 	ret = copy_to_user(&psensor_mode_arry->count, &support_counts, sizeof(support_counts));
 	ret |= copy_to_user(&psensor_mode_arry->modes, pimx678_mode_info,
 			   sizeof(pimx678_mode_info));
 	if (ret != 0) {
-		pr_err("enter %s failed to allocate memory \n", __func__);
+		dev_err(dev, "%s: failed to allocate memory \n", __func__);
 		ret = -ENOMEM;
 	}
 	return ret;
@@ -586,7 +591,9 @@ static int imx678_get_sensor_id(struct imx678 *sensor, void* pchip_id)
 {
 	int ret = 0;
 	u16 chip_id = 678;
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s: chip_id: %d\n", __func__, chip_id);
 	ret = copy_to_user(pchip_id, &chip_id, sizeof(u16));
 	if (ret != 0)
 		ret = -ENOMEM;
@@ -597,7 +604,9 @@ static int imx678_get_reserve_id(struct imx678 *sensor, void* preserve_id)
 {
 	int ret = 0;
 	u16 reserve_id = 678;
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s: reserve_id: %u\n", __func__, reserve_id);
 	ret = copy_to_user(preserve_id, &reserve_id, sizeof(u16));
 	if (ret != 0)
 		ret = -ENOMEM;
@@ -607,12 +616,14 @@ static int imx678_get_reserve_id(struct imx678 *sensor, void* preserve_id)
 static int imx678_get_sensor_mode(struct imx678 *sensor, void* pmode)
 {
 	int ret = 0;
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s: cur_mode: %d\n", __func__, sensor->cur_mode.index);
 	ret = copy_to_user(pmode, &sensor->cur_mode,
 		sizeof(struct vvcam_mode_info_s));
 	if (ret != 0) {
 		ret = -ENOMEM;
-		pr_warn("error getting sensor mode %s\n", __func__);
+		dev_err(dev, "%s: error getting sensor mode\n", __func__);
 	}
 	return ret;
 }
@@ -622,22 +633,25 @@ static int imx678_set_sensor_mode(struct imx678 *sensor, void* pmode)
 	int ret = 0;
 	int i = 0;
 	struct vvcam_mode_info_s sensor_mode;
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s\n", __func__);
 	ret = copy_from_user(&sensor_mode, pmode,
 		sizeof(struct vvcam_mode_info_s));
 	if (ret != 0) {
-		pr_err("enter %s: Failed to get sensor mode \n", __func__);
+		dev_err(dev, "%s: Failed to get sensor mode \n", __func__);
 		return -ENOMEM;
 	}
 	for (i = 0; i < ARRAY_SIZE(pimx678_mode_info); i++) {
 		if (pimx678_mode_info[i].index == sensor_mode.index) {
+			dev_info(dev, "%s: sensor mode index: %d\n", __func__, sensor_mode.index);
 			memcpy(&sensor->cur_mode, &pimx678_mode_info[i],
 				sizeof(struct vvcam_mode_info_s));
 			return 0;
 		}
 	}
 
-	pr_err("enter %s: Failed to set current sensor mode \n", __func__);
+	dev_err(dev, "%s: Failed to set current sensor mode \n", __func__);
 	return -ENXIO;
 }
 
@@ -646,157 +660,154 @@ static int imx678_set_sensor_mode(struct imx678 *sensor, void* pmode)
  */
 static int imx678_adjust_hmax_register(struct imx678 *sensor)
 {
-    int err = 0;
-    u32 hmax = 628;
+	int err = 0;
+	u32 hmax = 628;
 	u8 data_rate, current_binning_mode;
-
-    pr_debug("%s:++\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
 
 	err = imx678_read_reg(sensor, DATARATE_SEL, &data_rate);
-
 	err |= imx678_read_reg(sensor, ADDMODE, &current_binning_mode);
 
-    switch (data_rate) {
-    case IMX678_1440_MBPS:
+	switch (data_rate) {
+	case IMX678_1440_MBPS:
 		if (current_binning_mode) {
 			hmax = 550;
 		} else {
 			hmax = (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) ? 550 : 660;
 		}
 		break;
-    case IMX678_1188_MBPS:
+	case IMX678_1188_MBPS:
 		hmax = 1100;
-        break;
-    case IMX678_891_MBPS:
-        hmax = (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) ? 1100 : 1320;
-        break;
-    case IMX678_720_MBPS:
-        if (current_binning_mode) {
+		break;
+	case IMX678_891_MBPS:
+		hmax = (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) ? 1100 : 1320;
+		break;
+	case IMX678_720_MBPS:
+		if (current_binning_mode) {
 			hmax = 1100;
 		} else {
 			hmax = 1320;
 		}
 		break;
-    default:
+	default:
 		// this should never happen
-        pr_err("%s: data rate not supported\n", __func__);
-        return -1;
-    }
+		dev_err(dev, "%s: data rate not supported\n", __func__);
+		return -1;
+	}
 
 	err = imx678_write_reg(sensor, REGHOLD, 1);
 	err |= imx678_write_reg(sensor, HMAX_HIGH, (hmax >> 8) & 0xff);
 	err |= imx678_write_reg(sensor, HMAX_LOW, hmax & 0xff);
 	err |= imx678_write_reg(sensor, REGHOLD, 0);
-    if (err) {
-        pr_err("%s: failed to set HMAX register\n", __func__);
-        return err;
-    }
+	if (err) {
+		dev_err(dev, "%s: failed to set HMAX register\n", __func__);
+		return err;
+	}
 
 	sensor->cur_mode.ae_info.one_line_exp_time_ns = (hmax*IMX678_G_FACTOR) / IMX678_1ST_INCK;
+	dev_info(dev, "%s: HMAX: %u\n", __func__, hmax);
 
-    pr_debug("%s:  HMAX: %u\n", __func__, hmax);
-
-    return 0;
+	return 0;
 }
 
 static int imx678_change_data_rate(struct imx678 *sensor, u32 data_rate)
 {
 	int ret = 0;
 	struct device *dev = &sensor->i2c_client->dev;
-    u8 current_lane_mode, current_binning_mode;
-    pr_info("%s++\n", __func__);
+	u8 current_lane_mode, current_binning_mode;
 
 	ret = imx678_read_reg(sensor, LANEMODE, &current_lane_mode);
-
 	if (current_lane_mode == IMX678_TWO_LANE_MODE)
-    {
-        pr_info("%s: 2 lane mode is not supported, switching to 4 lane mode \n",__func__);
-        imx678_write_reg(sensor, LANEMODE, IMX678_FOUR_LANE_MODE);
-    }
+	{
+		dev_info(dev, "%s: 2 lane mode is not supported, switching to 4 lane mode \n",__func__);
+		imx678_write_reg(sensor, LANEMODE, IMX678_FOUR_LANE_MODE);
+	}
 
 	ret |= imx678_read_reg(sensor, ADDMODE, &current_binning_mode);
 	if (ret < 0) {
-		pr_err("%s: Could not read ADDMODE \n",__func__);
+		dev_err(dev, "%s: Could not read ADDMODE \n",__func__);
 		return ret;
 	}
-    if (current_binning_mode) {
-        switch (data_rate) {
-            case IMX678_2376_MBPS:
-            case IMX678_2079_MBPS:
+	if (current_binning_mode) {
+		switch (data_rate) {
+			case IMX678_2376_MBPS:
+			case IMX678_2079_MBPS:
 			case IMX678_1782_MBPS:
 			case IMX678_1440_MBPS:
-            case IMX678_1188_MBPS:
-            case IMX678_891_MBPS:
+			case IMX678_1188_MBPS:
+			case IMX678_891_MBPS:
 			case IMX678_594_MBPS:
-                dev_warn(dev, "%s: Selected data rate is not supported in 4 lane binning mode, switching to 720 binning mode!\n", __func__);
-                data_rate = IMX678_720_MBPS;
-                break;
-            default:
-                break;
-        }
-    }
-    else {
-        switch(data_rate) {
+				dev_warn(dev, "%s: Selected data rate is not supported in 4 lane binning mode, switching to 720 binning mode!\n", __func__);
+				data_rate = IMX678_720_MBPS;
+				break;
+			default:
+				break;
+		}
+	}
+	else {
+		switch(data_rate) {
 			case IMX678_2376_MBPS:
-            case IMX678_2079_MBPS:
-            case IMX678_1782_MBPS:
+			case IMX678_2079_MBPS:
+			case IMX678_1782_MBPS:
 			case IMX678_1440_MBPS:
-            case IMX678_594_MBPS:
-                dev_warn(dev, "%s: Selected data rate is not supported in 4 CSI lane non binning mode, switching to default 891 mode!\n", __func__);
-                data_rate = IMX678_891_MBPS;
-                break;
-            case IMX678_720_MBPS:
-                if (sensor->format.code == MEDIA_BUS_FMT_SRGGB12_1X12) {
-                    dev_warn(dev, "%s: Selected data rate is not supported with 12 bit mode, switching to 1188 mode!\n", __func__);
-                    data_rate = IMX678_1188_MBPS;
-                }
-                break;
-            case IMX678_1188_MBPS:
-                if (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) {
-                    dev_warn(dev, "%s: Selected data rate is not supported with 10 bit mode, switching to 891 mode!\n", __func__);
-                    data_rate = IMX678_891_MBPS;
-                }
-                break;
-        }
-    }
-
-    dev_warn(dev, "%s: Setting data rate to value: %u\n", __func__, data_rate);
+			case IMX678_594_MBPS:
+				dev_warn(dev, "%s: Selected data rate is not supported in 4 CSI lane non binning mode, switching to default 891 mode!\n", __func__);
+				data_rate = IMX678_891_MBPS;
+				break;
+			case IMX678_720_MBPS:
+				if (sensor->format.code == MEDIA_BUS_FMT_SRGGB12_1X12) {
+					dev_warn(dev, "%s: Selected data rate is not supported with 12 bit mode, switching to 1188 mode!\n", __func__);
+					data_rate = IMX678_1188_MBPS;
+				}
+				break;
+			case IMX678_1188_MBPS:
+				if (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) {
+					dev_warn(dev, "%s: Selected data rate is not supported with 10 bit mode, switching to 891 mode!\n", __func__);
+					data_rate = IMX678_891_MBPS;
+				}
+				break;
+		}
+	}
+
+	dev_warn(dev, "%s: Setting data rate to value: %u\n", __func__, data_rate);
 	ret = imx678_write_reg(sensor, DATARATE_SEL, data_rate);
-    return 0;
+	return 0;
 }
 
 static int imx678_set_data_rate(struct imx678 *sensor, u32 data_rate)
 {
 	int ret = 0;
+	struct device *dev = &sensor->i2c_client->dev;
 
-	pr_info("enter %s data rate received: %u\n", __func__, data_rate);
+	dev_info(dev, "%s: data rate received: %u\n", __func__, data_rate);
 
-    ret = imx678_change_data_rate(sensor, data_rate);
-    if (ret) {
-        goto fail;
+	ret = imx678_change_data_rate(sensor, data_rate);
+	if (ret) {
+		goto fail;
 	}
 
 	ret = imx678_adjust_hmax_register(sensor);
-    if (ret) {
-        pr_err("%s: unable to adjust hmax\n", __func__);
-        return ret;
-    }
+	if (ret) {
+		dev_err(dev, "%s: unable to adjust hmax\n", __func__);
+		return ret;
+	}
 
 	ret = imx678_write_reg(sensor, INCK_SEL, sensor->inck);
 	if (ret < 0) {
-		pr_err("%s: unable to set inck\n", __func__);
+		dev_err(dev, "%s: unable to set inck\n", __func__);
 		return ret;
 	}
 
 	ret = clk_set_rate(sensor->sensor_clk, sensor->mclk);
-        if (ret < 0)
-                pr_debug("set rate filed, rate=%d\n", sensor->mclk);
+	if (ret < 0) {
+		dev_dbg(dev, "%s: set rate failed, rate=%d\n", __func__, sensor->mclk);
+	}
 
 	return ret;
 
 fail:
-    pr_info("%s: unable to set data rate\n", __func__);
-    return ret;
+	dev_err(dev, "%s: unable to set data rate\n", __func__);
+	return ret;
 }
 
 /**
@@ -811,38 +822,39 @@ fail:
  */
 static int imx678_configure_triggering_pins(struct imx678 *sensor)
 {
-    int err = 0;
+	int err = 0;
 	u8 extmode;
-    u8  xvs_xhs_drv = 0xF;
-	pr_info("enter %s\n", __func__);
+	u8  xvs_xhs_drv = 0xF;
+	struct device *dev = &sensor->i2c_client->dev;
 
-	err = imx678_read_reg(sensor, EXTMODE, &extmode);
+	dev_dbg(dev, "%s\n", __func__);
 
+	err = imx678_read_reg(sensor, EXTMODE, &extmode);
 	if (extmode == INTERNAL_SYNC) {
-	    /* XVS - output, XHS - output */
-	    xvs_xhs_drv = 0x0;
-	    pr_debug("%s: Sensor is in - Internal sync Master mode\n", __func__);
+		/* XVS - output, XHS - output */
+		xvs_xhs_drv = 0x0;
+		dev_dbg(dev, "%s: Sensor is in - Internal sync Master mode\n", __func__);
 	}
 	else if (extmode == EXTERNAL_SYNC) {
-	    /* XVS - hi-z, XHS - output */
-	    xvs_xhs_drv = 0x3;
-	    pr_debug("%s: Sensor is in - External sync Master mode\n", __func__);
+		/* XVS - hi-z, XHS - output */
+		xvs_xhs_drv = 0x3;
+		dev_dbg(dev, "%s: Sensor is in - External sync Master mode\n", __func__);
 	}
 	else {
-	    /* XVS - hi-z, XHS - hi-z */
-	    xvs_xhs_drv = 0xF;
-	    pr_debug("%s: Sensor is in - No sync Master mode\n", __func__);
+		/* XVS - hi-z, XHS - hi-z */
+		xvs_xhs_drv = 0xF;
+		dev_dbg(dev, "%s: Sensor is in - No sync Master mode\n", __func__);
 	}
 
-    err = imx678_write_reg(sensor, XVS_XHS_DRV, xvs_xhs_drv);
-    if (err) {
-        pr_err("%s: error setting triggering pins\n", __func__);
-        return err;
-    }
+	err = imx678_write_reg(sensor, XVS_XHS_DRV, xvs_xhs_drv);
+	if (err) {
+		dev_err(dev, "%s: error setting triggering pins\n", __func__);
+		return err;
+	}
 
-    pr_debug("%s: XVS_XHS driver register: %x\n", __func__, xvs_xhs_drv);
+	dev_info(dev, "%s: XVS_XHS driver register: %x\n", __func__, xvs_xhs_drv);
 
-    return 0;
+	return 0;
 }
 
 /**
@@ -851,28 +863,30 @@ static int imx678_configure_triggering_pins(struct imx678 *sensor)
  */
 static int imx678_set_sync_mode(struct imx678 *sensor, u32 val)
 {
-    int err = 0;
-    u8 extmode = 0;
-	pr_info("enter %s sync mode %u\n", __func__, val);
+	int err = 0;
+	u8 extmode = 0;
+	struct device *dev = &sensor->i2c_client->dev;
 
-    if (val == EXTERNAL_SYNC)
-        extmode = 1;
-    else
-        extmode = 0;
+	dev_info(dev, "%s sync mode %u\n", __func__, val);
 
-    if (sensor->powered_on == 1) {
-        err = imx678_write_reg(sensor, EXTMODE, extmode);
-        if (err < 0)
-            pr_err("%s: error setting sync mode\n", __func__);
-    }
+	if (val == EXTERNAL_SYNC)
+		extmode = 1;
+	else
+		extmode = 0;
+
+	if (sensor->powered_on == 1) {
+		err = imx678_write_reg(sensor, EXTMODE, extmode);
+		if (err < 0)
+			dev_err(dev, "%s: error setting sync mode\n", __func__);
+	}
 
 	err = imx678_configure_triggering_pins(sensor);
 	if (err < 0) {
-		pr_err("%s:unable to configure XVS/XHS pins\n",__func__);
+		dev_err(dev, "%s: unable to configure XVS/XHS pins\n",__func__);
 		return -EINVAL;
 	}
 
-    return err;
+	return err;
 }
 
 static int imx678_set_exp(struct imx678 *sensor, u32 exp, unsigned int which_control)
@@ -881,32 +895,33 @@ static int imx678_set_exp(struct imx678 *sensor, u32 exp, unsigned int which_con
 	u32 integration_time_line;
 	u32 reg_shr0 = 0;
 	u32 frame_length;
+	struct device *dev = &sensor->i2c_client->dev;
 
 	frame_length = sensor->cur_mode.ae_info.curr_frm_len_lines;
 
 	// from ISP driver
 	if (which_control == 0) {
-		pr_info("enter %s exposure received: %u\n", __func__, exp >>10);
-		integration_time_line = ((exp >> 10)
-	           * IMX678_K_FACTOR) / sensor->cur_mode.ae_info.one_line_exp_time_ns;
+		dev_info(dev, "%s: exposure received: %u\n", __func__, exp >>10);
+		integration_time_line = ((exp >> 10) * IMX678_K_FACTOR) / sensor->cur_mode.ae_info.one_line_exp_time_ns;
 	}
 	// from V4L2 control
 	else {
-		pr_info("enter %s exposure received: %u\n", __func__, exp);
+		dev_info(dev, "%s: exposure received: %u\n", __func__, exp);
 		integration_time_line = exp * IMX678_K_FACTOR / sensor->cur_mode.ae_info.one_line_exp_time_ns;
 	}
 
 	reg_shr0 = frame_length - integration_time_line;
 
 	/* Value must be multiple of 2 */
-    reg_shr0 = (reg_shr0 % 2) ? reg_shr0 + 1 : reg_shr0;
+	reg_shr0 = (reg_shr0 % 2) ? reg_shr0 + 1 : reg_shr0;
 
-    if (reg_shr0 < IMX678_MIN_SHR0_LENGTH)
-        reg_shr0 = IMX678_MIN_SHR0_LENGTH;
-	else if (reg_shr0 > (frame_length - IMX678_MIN_INTEGRATION_LINES))
+	if (reg_shr0 < IMX678_MIN_SHR0_LENGTH) {
+		reg_shr0 = IMX678_MIN_SHR0_LENGTH;
+	} else if (reg_shr0 > (frame_length - IMX678_MIN_INTEGRATION_LINES)) {
 		reg_shr0 = frame_length - IMX678_MIN_INTEGRATION_LINES;
+	}
 
-	pr_info("enter %s exposure register: %u integration_time_line: %u\n", __func__, reg_shr0, integration_time_line);
+	dev_info(dev, "%s: exposure register: %u integration_time_line: %u\n", __func__, reg_shr0, integration_time_line);
 	ret = imx678_write_reg(sensor, REGHOLD, 1);
 	ret |= imx678_write_reg(sensor, SHR0_HIGH, (reg_shr0 >> 16) & 0xff);
 	ret |= imx678_write_reg(sensor, SHR0_MID, (reg_shr0 >> 8) & 0xff);
@@ -914,7 +929,7 @@ static int imx678_set_exp(struct imx678 *sensor, u32 exp, unsigned int which_con
 	ret |= imx678_write_reg(sensor, REGHOLD, 0);
 
 	if (ret < 0) {
-		pr_err("%s Failed to set exposure exp: %u, shr register:  %u\n", __func__, exp, reg_shr0);
+		dev_err(dev, "%s: Failed to set exposure exp: %u, shr register:  %u\n", __func__, exp, reg_shr0);
 	}
 	return ret;
 }
@@ -969,16 +984,17 @@ static int imx678_set_gain(struct imx678 *sensor, u32 gain, unsigned int which_c
 {
 	int ret = 0;
 	u32 gain_reg = 0;
-	pr_info("enter %s: gain received: %u control: %u\n", __func__, gain, which_control);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s: gain received: %u control: %u\n", __func__, gain, which_control);
 
 	if (which_control == 0) { // from isp
 		gain_reg = imx678_get_gain_reg(gain);
 	} else { // from v4l2 control
-		gain_reg = gain * IMX678_MAX_GAIN_DEC /
-                 (IMX678_MAX_GAIN_DB * 10);
+		gain_reg = gain * IMX678_MAX_GAIN_DEC / (IMX678_MAX_GAIN_DB * 10);
 	}
 
-    pr_info("%s: gain register: %u\n", __func__, gain_reg);
+	dev_info(dev, "%s: gain register: %u\n", __func__, gain_reg);
 	ret = imx678_write_reg(sensor, REGHOLD, 1);
 	ret |= imx678_write_reg(sensor, GAIN_0_HIGH, (gain_reg>>8) & 0xff);
 	ret |= imx678_write_reg(sensor, GAIN_0_LOW, gain_reg & 0xff);
@@ -991,11 +1007,13 @@ static int imx678_set_black_level(struct imx678 *sensor, s64 val, u32 which_cont
 {
 	int ret = 0;
 	s64 black_level_reg;
-	pr_info("enter %s black level: %lld\n",  __func__, val);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s: black level: %lld\n",  __func__, val);
 
 	if (sensor->format.code == MEDIA_BUS_FMT_SRGGB10_1X10) {
 		black_level_reg = val;
-    } else {
+	} else {
 		black_level_reg = val >> 2;
 	}
 
@@ -1003,10 +1021,10 @@ static int imx678_set_black_level(struct imx678 *sensor, s64 val, u32 which_cont
 	ret |= imx678_write_reg(sensor, BLKLEVEL_HIGH, (black_level_reg>>8) & 0xff);
 	ret |= imx678_write_reg(sensor, BLKLEVEL_LOW, black_level_reg & 0xff);
 	ret |= imx678_write_reg(sensor, REGHOLD, 0);
-	if (ret){
-	    pr_info("%s: BLACK LEVEL control error\n", __func__);
-	    return ret;
-    }
+	if (ret) {
+		dev_info(dev, "%s: BLACK LEVEL control error\n", __func__);
+		return ret;
+	}
 
 	return 0;
 }
@@ -1015,8 +1033,10 @@ static int imx678_set_fps(struct imx678 *sensor, u32 fps, u32 which_control)
 {
 	u32 fps_reg;
 	u32 line_time;
+	struct device *dev = &sensor->i2c_client->dev;
 	int ret = 0;
-	pr_info("enter %s fps received: %u\n", __func__, fps);
+
+	dev_info(dev, "%s: fps received: %u\n", __func__, fps);
 	if (which_control == 1) {
 		fps = fps << 10;
 	}
@@ -1030,7 +1050,7 @@ static int imx678_set_fps(struct imx678 *sensor, u32 fps, u32 which_control)
 		fps = sensor->cur_mode.ae_info.min_fps;
 	}
 	fps_reg = IMX678_G_FACTOR / ((fps >> 10) * line_time);
-	pr_info("enter %s vmax register: %u\n", __func__, fps_reg);
+	dev_info(dev, "%s: vmax register: %u\n", __func__, fps_reg);
 	ret = imx678_write_reg(sensor, REGHOLD, 1);
 	ret |= imx678_write_reg(sensor, VMAX_HIGH, (u8)(fps_reg >> 16) & 0xff);
 	ret |= imx678_write_reg(sensor, VMAX_MID, (u8)(fps_reg >> 8) & 0xff);
@@ -1042,8 +1062,7 @@ static int imx678_set_fps(struct imx678 *sensor, u32 fps, u32 which_control)
 	if (sensor->cur_mode.hdr_mode == SENSOR_MODE_LINEAR) {
 		sensor->cur_mode.ae_info.max_integration_line = fps_reg - 4;
 	} else {
-		if (sensor->cur_mode.stitching_mode ==
-		    SENSOR_STITCHING_DUAL_DCG){
+		if (sensor->cur_mode.stitching_mode == SENSOR_STITCHING_DUAL_DCG) {
 			sensor->cur_mode.ae_info.max_vsintegration_line = 44;
 			sensor->cur_mode.ae_info.max_integration_line = fps_reg -
 				4 - sensor->cur_mode.ae_info.max_vsintegration_line;
@@ -1057,7 +1076,9 @@ static int imx678_set_fps(struct imx678 *sensor, u32 fps, u32 which_control)
 
 static int imx678_get_fps(struct imx678 *sensor, u32 *pfps)
 {
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s: fps: %u\n", __func__, sensor->cur_mode.ae_info.cur_fps);
 	*pfps = sensor->cur_mode.ae_info.cur_fps;
 	return 0;
 }
@@ -1065,13 +1086,15 @@ static int imx678_get_fps(struct imx678 *sensor, u32 *pfps)
 static int imx678_set_test_pattern(struct imx678 *sensor, u32 pattern)
 {
 	int ret;
-	pr_info("enter %s, pattern = %u\n", __func__, pattern);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s: pattern = %u\n", __func__, pattern);
 	if (pattern > 0 && pattern < ARRAY_SIZE(test_pattern_menu)) {
 		ret = imx678_write_reg_arry(sensor,
 			(struct vvcam_sccb_data_s *)mode_enable_pattern_generator,
 			ARRAY_SIZE(mode_enable_pattern_generator));
 		if (ret < 0) {
-			pr_err("%s:imx678_write_reg_arry error\n",__func__);
+			dev_err(dev, "%s: imx678_write_reg_arry error\n", __func__);
 			return -EINVAL;
 		}
 		ret = imx678_write_reg(sensor, TPG_PATSEL_DUOUT, pattern - 1);
@@ -1080,7 +1103,7 @@ static int imx678_set_test_pattern(struct imx678 *sensor, u32 pattern)
 			(struct vvcam_sccb_data_s *)mode_disable_pattern_generator,
 			ARRAY_SIZE(mode_disable_pattern_generator));
 		if (ret < 0) {
-			pr_err("%s:imx678_write_reg_arry error\n",__func__);
+			dev_err(dev, "%s: imx678_write_reg_arry error\n", __func__);
 			return -EINVAL;
 		}
 	}
@@ -1092,12 +1115,14 @@ static int imx678_set_ratio(struct imx678 *sensor, void* pratio)
 	int ret = 0;
 	struct sensor_hdr_artio_s hdr_ratio;
 	struct vvcam_ae_info_s *pae_info = &sensor->cur_mode.ae_info;
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
+
+	dev_info(dev, "%s\n", __func__);
 	ret = copy_from_user(&hdr_ratio, pratio, sizeof(hdr_ratio));
 
 	if ((hdr_ratio.ratio_l_s != pae_info->hdr_ratio.ratio_l_s) ||
-	    (hdr_ratio.ratio_s_vs != pae_info->hdr_ratio.ratio_s_vs) ||
-	    (hdr_ratio.accuracy != pae_info->hdr_ratio.accuracy)) {
+		(hdr_ratio.ratio_s_vs != pae_info->hdr_ratio.ratio_s_vs) ||
+		(hdr_ratio.accuracy != pae_info->hdr_ratio.accuracy)) {
 		pae_info->hdr_ratio.ratio_l_s = hdr_ratio.ratio_l_s;
 		pae_info->hdr_ratio.ratio_s_vs = hdr_ratio.ratio_s_vs;
 		pae_info->hdr_ratio.accuracy = hdr_ratio.accuracy;
@@ -1111,6 +1136,7 @@ static int imx678_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
 	struct imx678 *sensor = to_imx678_dev(sd);
+	struct device *dev = &sensor->i2c_client->dev;
 	int ret;
 
 	/* v4l2_ctrl_lock() locks our own mutex */
@@ -1120,8 +1146,10 @@ static int imx678_s_ctrl(struct v4l2_ctrl *ctrl)
 	 * not apply any controls to H/W at this time. Instead
 	 * the controls will be restored right after power-up.
 	 */
-	if (sensor->powered_on == 0)
+	if (sensor->powered_on == 0) {
+		dev_info(dev, "%s: No setting during sensor->power off\n", __func__);
 		return 0;
+	}
 
 	switch (ctrl->id) {
 	case V4L2_CID_GAIN:
@@ -1159,7 +1187,8 @@ static const struct v4l2_ctrl_ops imx678_ctrl_ops = {
 
 static int imx678_get_format_code(struct imx678 *sensor, u32 *code)
 {
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &sensor->i2c_client->dev;
+
 	switch (sensor->cur_mode.bayer_pattern) {
 	case BAYER_RGGB:
 		if (sensor->cur_mode.bit_width == 8) {
@@ -1201,43 +1230,45 @@ static int imx678_get_format_code(struct imx678 *sensor, u32 *code)
 		/*nothing need to do*/
 		break;
 	}
+	dev_info(dev, "%s: format code: %x cur_mode.bit_width: %u\n", __func__, *code, sensor->cur_mode.bit_width);
 	return 0;
 }
 
 static int imx678_set_pixel_format(struct imx678 *sensor)
 {
-    int err;
+	int err;
+	struct device *dev = &sensor->i2c_client->dev;
 
-    switch (sensor->format.code) {
-    case MEDIA_BUS_FMT_SRGGB10_1X10:
+	dev_info(dev, "%s: format.code: %x\n", __func__, sensor->format.code);
+	switch (sensor->format.code) {
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
 		err = imx678_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx678_10bit_mode, ARRAY_SIZE(imx678_10bit_mode));
-        break;
-    case MEDIA_BUS_FMT_SRGGB12_1X12:
+		break;
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
 		err = imx678_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)imx678_12bit_mode, ARRAY_SIZE(imx678_12bit_mode));
-        break;
-    default:
-        pr_err("%s: unknown pixel format\n", __func__);
-        return -EINVAL;
-    }
+		break;
+	default:
+		dev_err(dev, "%s: unknown pixel format\n", __func__);
+		return -EINVAL;
+	}
 
-    return err;
+	return err;
 }
 
 static int imx678_s_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct imx678 *sensor = client_to_imx678(client);
+	struct device *dev = &client->dev;
 	
-	pr_info("enter %s\n", __func__);
+	dev_info(dev, "%s: enable: %d\n", __func__, enable);
 	
 	sensor->stream_status = enable;
 	if (enable) {
-		pr_info("Enable stream\n");
 		imx678_write_reg(sensor, STANDBY, 0x00);
 		msleep(30);
 		imx678_write_reg(sensor, XMSTA, 0x00);
 	} else  {
-		pr_info("Disable stream\n");
 		imx678_write_reg(sensor, STANDBY, 0x01);
 		msleep(30);
 		imx678_write_reg(sensor, XMSTA, 0x01);
@@ -1247,17 +1278,19 @@ static int imx678_s_stream(struct v4l2_subdev *sd, int enable)
 }
 
 static int imx678_enum_mbus_code(struct v4l2_subdev *sd,
-			         struct v4l2_subdev_state *state,
-			         struct v4l2_subdev_mbus_code_enum *code)
+					 struct v4l2_subdev_state *state,
+					 struct v4l2_subdev_mbus_code_enum *code)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct imx678 *sensor = client_to_imx678(client);
+	struct device *dev = &client->dev;
+
 	u32 cur_code = MEDIA_BUS_FMT_SRGGB10_1X10;
-	pr_info("enter %s\n", __func__);
 	if (code->index > 0)
 		return -EINVAL;
-	imx678_get_format_code(sensor,&cur_code);
+	imx678_get_format_code(sensor, &cur_code);
 	code->code = cur_code;
+	dev_info(dev, "%s: mbus_code: %x\n", __func__, cur_code);
 
 	return 0;
 }
@@ -1269,12 +1302,13 @@ static int imx678_set_fmt(struct v4l2_subdev *sd,
 	int ret = 0;
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct imx678 *sensor = client_to_imx678(client);
+	struct device *dev = &client->dev;
+
+	dev_info(dev, "%s\n", __func__);
 	mutex_lock(&sensor->lock);
-	pr_info("enter %s\n", __func__);
 	if ((fmt->format.width != sensor->cur_mode.size.bounds_width) ||
-	    (fmt->format.height != sensor->cur_mode.size.bounds_height)) {
-		pr_err("%s:set sensor format %dx%d error\n",
-			__func__,fmt->format.width,fmt->format.height);
+		(fmt->format.height != sensor->cur_mode.size.bounds_height)) {
+		dev_err(dev, "%s: set sensor format %dx%d error\n", __func__, fmt->format.width, fmt->format.height);
 		mutex_unlock(&sensor->lock);
 		return -EINVAL;
 	}
@@ -1285,7 +1319,7 @@ static int imx678_set_fmt(struct v4l2_subdev *sd,
 
 	ret = imx678_set_pixel_format(sensor);
 	if (ret < 0) {
-		pr_err("%s:imx678_write_reg_arry error, failed to set pixel format\n",__func__);
+		dev_err(dev, "%s: imx678_write_reg_arry error, failed to set pixel format\n", __func__);
 		mutex_unlock(&sensor->lock);
 		return -EINVAL;
 	}
@@ -1294,7 +1328,7 @@ static int imx678_set_fmt(struct v4l2_subdev *sd,
 		(struct vvcam_sccb_data_s *)sensor->cur_mode.preg_data,
 		sensor->cur_mode.reg_data_count);
 	if (ret < 0) {
-		pr_err("%s:imx678_write_reg_arry error\n",__func__);
+		dev_err(dev, "%s: imx678_write_reg_arry error\n", __func__);
 		mutex_unlock(&sensor->lock);
 		return -EINVAL;
 	}
@@ -1302,23 +1336,23 @@ static int imx678_set_fmt(struct v4l2_subdev *sd,
 	if (sensor->cur_mode.size.bounds_height == IMX678_DEFAULT_HEIGHT) {
 		ret = imx678_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_3856x2180, ARRAY_SIZE(mode_3856x2180));
 		if (ret < 0) {
-			pr_err("%s:imx678_write_reg_arry error, failed to set up resolution\n",__func__);
+			dev_err(dev, "%s: imx678_write_reg_arry error, failed to set up resolution\n", __func__);
 			return -EINVAL;
 		}
 		ret = imx678_set_data_rate(sensor, IMX678_891_MBPS);
 		if (ret < 0) {
-			pr_err("%s:imx678_write_reg_arry error, failed to set data rate\n",__func__);
+			dev_err(dev, "%s: imx678_write_reg_arry error, failed to set data rate\n", __func__);
 			return -EINVAL;
 		}
 	} else if (sensor->cur_mode.size.bounds_height == IMX678_MODE_BINNING_H2V2_HEIGHT) {
 		ret = imx678_write_reg_arry(sensor, (struct vvcam_sccb_data_s *)mode_h2v2_binning, ARRAY_SIZE(mode_h2v2_binning));
 		if (ret < 0) {
-			pr_err("%s:imx678_write_reg_arry error, failed to set up resolution\n",__func__);
+			dev_err(dev, "%s: imx678_write_reg_arry error, failed to set up resolution\n", __func__);
 			return -EINVAL;
 		}
 		ret = imx678_set_data_rate(sensor, IMX678_720_MBPS);
 		if (ret < 0) {
-			pr_err("%s:imx678_write_reg_arry error, failed to set data rate\n",__func__);
+			dev_err(dev, "%s: imx678_write_reg_arry error, failed to set data rate\n", __func__);
 			return -EINVAL;
 		}
 	}
@@ -1332,22 +1366,24 @@ static int imx678_get_fmt(struct v4l2_subdev *sd,
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct imx678 *sensor = client_to_imx678(client);
-	pr_info("enter %s\n", __func__);
+	struct device *dev = &client->dev;
+
 	mutex_lock(&sensor->lock);
 	fmt->format = sensor->format;
 	mutex_unlock(&sensor->lock);
+	dev_info(dev, "%s: fmt code: %x\n", __func__, fmt->format.code);
 	return 0;
 }
 
-static long imx678_priv_ioctl(struct v4l2_subdev *sd,
-                              unsigned int cmd,
-                              void *arg)
+static long imx678_priv_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct imx678 *sensor = client_to_imx678(client);
+	struct device *dev = &client->dev;
+
 	long ret = 0;
 	struct vvcam_sccb_data_s sensor_reg;
-	pr_info("enter %s %u\n", __func__, cmd);
+	dev_info(dev, "%s %x\n", __func__, cmd);
 	mutex_lock(&sensor->lock);
 	switch (cmd){
 	case VVSENSORIOC_S_POWER:
@@ -1472,8 +1508,8 @@ static struct v4l2_subdev_ops imx678_subdev_ops = {
 };
 
 static int imx678_link_setup(struct media_entity *entity,
-			     const struct media_pad *local,
-			     const struct media_pad *remote, u32 flags)
+				const struct media_pad *local,
+				const struct media_pad *remote, u32 flags)
 {
 	return 0;
 }
@@ -1485,8 +1521,7 @@ static const struct media_entity_operations imx678_sd_media_ops = {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
 static int imx678_probe(struct i2c_client *client)
 #else
-static int imx678_probe(struct i2c_client *client,
-                        const struct i2c_device_id *id)
+static int imx678_probe(struct i2c_client *client, const struct i2c_device_id *id)
 #endif
 {
 	int retval;
@@ -1494,7 +1529,7 @@ static int imx678_probe(struct i2c_client *client,
 	struct v4l2_subdev *sd;
 	struct imx678 *sensor;
 
-	pr_info("enter %s\n", __func__);
+	dev_info(dev, "%s\n", __func__);
 
 	sensor = devm_kmalloc(dev, sizeof(*sensor), GFP_KERNEL);
 	if (!sensor)
@@ -1556,61 +1591,51 @@ static int imx678_probe(struct i2c_client *client,
 	sd->entity.ops = &imx678_sd_media_ops;
 	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
 	sensor->pads[IMX678_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
-	retval = media_entity_pads_init(&sd->entity,
-				IMX678_SENS_PADS_NUM,
-				sensor->pads);
-	if (retval < 0)
+	retval = media_entity_pads_init(&sd->entity, IMX678_SENS_PADS_NUM, sensor->pads);
+	if (retval < 0) {
 		goto probe_err_power_off;
+	}
 
-	memcpy(&sensor->cur_mode, &pimx678_mode_info[0],
-		sizeof(struct vvcam_mode_info_s));
+	memcpy(&sensor->cur_mode, &pimx678_mode_info[0], sizeof(struct vvcam_mode_info_s));
 
 	/* initialize controls */
-    retval = v4l2_ctrl_handler_init(&sensor->ctrls.handler, 7);
-    if (retval < 0) {
-        dev_err(&client->dev,
-            "%s : ctrl handler init Failed\n", __func__);
-        goto probe_err_power_off;
-    }
+	retval = v4l2_ctrl_handler_init(&sensor->ctrls.handler, 7);
+	if (retval < 0) {
+		dev_err(&client->dev, "%s : ctrl handler init Failed\n", __func__);
+		goto probe_err_power_off;
+	}
 
 	sensor->ctrls.handler.lock = &sensor->lock;
 
 	// add new controls
-
-	sensor->ctrls.exposure = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_EXPOSURE,
-					    3, 30000, 1, 1000);
-	sensor->ctrls.gain = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_GAIN,
-					0, 240, 3, 0);
-	sensor->ctrls.black_level = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_BLACK_LEVEL,
-					 0, 1023, 1, 50);
+	sensor->ctrls.exposure = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_EXPOSURE, 3, 30000, 1, 1000);
+	sensor->ctrls.gain = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_GAIN, 0, 240, 3, 0);
+	sensor->ctrls.black_level = v4l2_ctrl_new_std(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_BLACK_LEVEL, 0, 1023, 1, 50);
 	sensor->ctrls.data_rate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx678_ctrl_data_rate, NULL);
 	sensor->ctrls.sync_mode = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx678_ctrl_sync_mode, NULL);
 	sensor->ctrls.framerate = v4l2_ctrl_new_custom(&sensor->ctrls.handler, imx678_ctrl_framerate, NULL);
-	sensor->ctrls.test_pattern = v4l2_ctrl_new_std_menu_items(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_TEST_PATTERN,
-					     ARRAY_SIZE(test_pattern_menu) - 1, 0, 0, test_pattern_menu);
+	sensor->ctrls.test_pattern = v4l2_ctrl_new_std_menu_items(&sensor->ctrls.handler, &imx678_ctrl_ops, V4L2_CID_TEST_PATTERN, ARRAY_SIZE(test_pattern_menu) - 1, 0, 0, test_pattern_menu);
 
 	sensor->sd.ctrl_handler = &sensor->ctrls.handler;
-    if (sensor->ctrls.handler.error) {
-        retval = sensor->ctrls.handler.error;
-        goto free_ctrls;
-    }
-
-    // setup default controls
-    retval = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
-    if (retval) {
-        dev_err(&client->dev,
-            "Error %d setup default controls\n", retval);
-        goto free_ctrls;
-    }
+	if (sensor->ctrls.handler.error) {
+		retval = sensor->ctrls.handler.error;
+		goto free_ctrls;
+	}
+
+	// setup default controls
+	retval = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+	if (retval) {
+		dev_err(&client->dev, "Error %d setup default controls\n", retval);
+		goto free_ctrls;
+	}
 
 	retval = v4l2_async_register_subdev_sensor(sd);
 	if (retval < 0) {
-		dev_err(&client->dev,"%s--Async register failed, ret=%d\n",
-			__func__,retval);
+		dev_err(&client->dev,"%s--Async register failed, ret=%d\n",	__func__, retval);
 		goto probe_err_free_entiny;
 	}
 
-	pr_info("%s camera mipi imx678, is found\n", __func__);
+	dev_info(dev, "%s: camera mipi imx678, is found\n", __func__);
 
 	return 0;
 
@@ -1629,14 +1654,14 @@ probe_err_power_off:
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
 static void imx678_remove(struct i2c_client *client)
 #else
-static void imx678_remove(struct i2c_client *client,
-                        const struct i2c_device_id *id)
+static void imx678_remove(struct i2c_client *client, const struct i2c_device_id *id)
 #endif
 {
+	struct device *dev = &client->dev;
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct imx678 *sensor = client_to_imx678(client);
 
-	pr_info("enter %s\n", __func__);
+	dev_info(dev, "%s\n", __func__);
 
 	v4l2_async_unregister_subdev(sd);
 	media_entity_cleanup(&sd->entity);
-- 
2.25.1

