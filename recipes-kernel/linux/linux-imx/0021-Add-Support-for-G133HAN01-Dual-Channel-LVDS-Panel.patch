From d0a7110da77f710ad8003d417ffc3f73604e16d3 Mon Sep 17 00:00:00 2001
From: Antony Abee Prakash XV <antonyabee.prakashxv@adlinktech.com>
Date: Tue, 4 Feb 2020 17:25:05 +0530
Subject: [PATCH 2/2] Add-Support-for-G133HAN01-Dual-Channel-LVDS-Panel

---
 .../devicetree/bindings/display/bridge/nwl_dsi.txt |   6 +
 arch/arm64/boot/dts/adlink/Makefile                |   3 +
 .../adlink/adlink-imx8mq-evk-dcss-g133han01.dts    | 201 ++++++++++
 .../adlink-lec-imx8m-1gb-ddr3l-dcss-g133han01.dts  |  33 ++
 .../adlink-lec-imx8m-2gb-ddr3l-dcss-g133han01.dts  |  18 +
 arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi         |   5 +-
 drivers/clk/imx/clk-imx8mq.c                       |   4 +-
 drivers/gpu/drm/bridge/nwl-dsi.c                   | 435 ++++++++++++++++++---
 drivers/gpu/drm/imx/dcss/dcss-crtc.c               |   3 +
 drivers/gpu/drm/imx/nwl_dsi-imx.c                  | 209 +++++-----
 drivers/gpu/drm/panel/panel-lecimx8.c              | 215 +++++-----
 drivers/gpu/imx/dpu/dpu-framegen.c                 |   2 +-
 include/drm/bridge/nwl_dsi.h                       |   3 -
 13 files changed, 829 insertions(+), 308 deletions(-)
 create mode 100644 arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-dcss-g133han01.dts
 create mode 100644 arch/arm64/boot/dts/adlink/adlink-lec-imx8m-1gb-ddr3l-dcss-g133han01.dts
 create mode 100644 arch/arm64/boot/dts/adlink/adlink-lec-imx8m-2gb-ddr3l-dcss-g133han01.dts

diff --git a/Documentation/devicetree/bindings/display/bridge/nwl_dsi.txt b/Documentation/devicetree/bindings/display/bridge/nwl_dsi.txt
index 5d4242b..0e30af4 100644
--- a/Documentation/devicetree/bindings/display/bridge/nwl_dsi.txt
+++ b/Documentation/devicetree/bindings/display/bridge/nwl_dsi.txt
@@ -35,6 +35,12 @@ Optional properties:
 			steer handling the MIPI DSI interrupts
 - assigned-clock-parents phandles to parent clocks that needs to be assigned as
 			parents to clocks defined in assigned-clocks
+ - clock-drop-level	number used by internal logic to drop the crtc_clock when
+			a panel is used. The crtc_clock needs to be lower than
+			DSI clock in case of panels so that DSI commands have
+			enough blanking time to be sent. There is no upper limit,
+			but the user can play with this value until stable image
+			is obtained (usually: 0-4).
 
 * The clock assignments must follow the rules defined in:
 Documentation/devicetree/bindings/clock/clock-bindings.txt
diff --git a/arch/arm64/boot/dts/adlink/Makefile b/arch/arm64/boot/dts/adlink/Makefile
index 5c73dfb..f74fafa 100644
--- a/arch/arm64/boot/dts/adlink/Makefile
+++ b/arch/arm64/boot/dts/adlink/Makefile
@@ -5,6 +5,7 @@ dtb-$(CONFIG_ARCH_LEC_IMX8M) += adlink-lec-imx8m.dtb \
 				adlink-imx8mq-evk-lcdif-hv150ux2.dtb \
 				adlink-imx8mq-evk-lcdif-n101bge.dtb \
 				adlink-imx8mq-evk-lcdif-lm215wf3.dtb \
+				adlink-imx8mq-evk-dcss-g133han01.dtb \
 				adlink-2gb-canfd.dtb \
 				adlink-2gb-canfd-40M.dtb \
 				adlink-4gb-canfd.dtb \
@@ -15,12 +16,14 @@ dtb-$(CONFIG_ARCH_LEC_IMX8M) += adlink-lec-imx8m.dtb \
 				adlink-lec-imx8m-2gb-ddr3l-lcdif-g104x1l03.dtb \
 				adlink-lec-imx8m-2gb-ddr3l-lcdif-g185xw01.dtb \
 				adlink-lec-imx8m-2gb-ddr3l-lcdif-n101bge.dtb \
+				adlink-lec-imx8m-2gb-ddr3l-dcss-g133han01.dtb \
 				adlink-lec-imx8m-2gb-ddr3l-usb-otg-master.dtb \
 				adlink-lec-imx8m-1gb-ddr3l.dtb \
 				adlink-lec-imx8m-1gb-ddr3l-dual-display.dtb \
 				adlink-lec-imx8m-1gb-ddr3l-lcdif-g104x1l03.dtb \
 				adlink-lec-imx8m-1gb-ddr3l-lcdif-g185xw01.dtb \
 				adlink-lec-imx8m-1gb-ddr3l-lcdif-n101bge.dtb \
+				adlink-lec-imx8m-1gb-ddr3l-dcss-g133han01.dtb \
 				adlink-lec-imx8m-1gb-ddr3l-usb-otg-master.dtb
 
 always		:= $(dtb-y)
diff --git a/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-dcss-g133han01.dts b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-dcss-g133han01.dts
new file mode 100644
index 0000000..eb2954c
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-dcss-g133han01.dts
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-lec-imx8m.dts"
+
+#define useReg 0
+/ {
+	display-subsystem {
+		status = "okay";
+	};
+#if useReg		
+	regulators {
+		reg_gpio_lvds: regulator-gpio {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vdd>;
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "gpio_lvds";
+			regulator-type = "voltage";
+			gpios = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+			//states = <900000 0x1 1000000 0x0>;
+		};
+	};
+#endif	
+	backlight: backlight {
+  		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 1000000 0>;
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+				     10 11 12 13 14 15 16 17 18 19
+				     20 21 22 23 24 25 26 27 28 29
+				     30 31 32 33 34 35 36 37 38 39
+				     40 41 42 43 44 45 46 47 48 49
+				     50 51 52 53 54 55 56 57 58 59
+				     60 61 62 63 64 65 66 67 68 69
+				     70 71 72 73 74 75 76 77 78 79
+				     80 81 82 83 84 85 86 87 88 89
+				     90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+    		status = "okay";
+	};
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&lcdif {
+        status = "disabled";
+};
+
+&dcss {
+	status = "okay";
+	disp-dev = "mipi_disp";
+
+        clocks = <&clk IMX8MQ_CLK_DISP_APB_ROOT>,
+                 <&clk IMX8MQ_CLK_DISP_AXI_ROOT>,
+                 <&clk IMX8MQ_CLK_DISP_RTRM_ROOT>,
+                 <&clk IMX8MQ_CLK_DC_PIXEL>,
+                 <&clk IMX8MQ_CLK_DUMMY>,
+		 <&clk IMX8MQ_CLK_DISP_DTRC>;
+	clock-names = "apb", "axi", "rtrm", "pix_div", "pix_out", "dtrc";
+        assigned-clocks = <&clk IMX8MQ_CLK_DC_PIXEL>,
+                          <&clk IMX8MQ_CLK_DISP_AXI>,
+                          <&clk IMX8MQ_CLK_DISP_RTRM>,
+                          <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+                          <&clk IMX8MQ_VIDEO_PLL1>;
+        assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+                                 <&clk IMX8MQ_SYS1_PLL_800M>,
+                                 <&clk IMX8MQ_SYS1_PLL_800M>,
+                                 <&clk IMX8MQ_CLK_25M>;
+        assigned-clock-rates = <600000000>,
+                               <800000000>,
+                               <0>,
+                               <400000000>,
+                               <599999999>;
+
+	dcss_disp0: port@0 {
+		reg = <0>;
+
+		dcss_disp0_mipi_dsi: mipi_dsi {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+
+        assigned-clocks = <&clk IMX8MQ_CLK_DSI_PHY_REF>,
+                          <&clk IMX8MQ_CLK_DSI_CORE>,
+                          <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+                          <&clk IMX8MQ_VIDEO_PLL1>;
+        assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+                                 <&clk IMX8MQ_SYS1_PLL_266M>,
+                                 <&clk IMX8MQ_CLK_25M>;
+        assigned-clock-rates = <24000000>,
+                               <266000000>,
+                               <0>,
+                               <599999999>;
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&dcss_disp0_mipi_dsi>;
+		};
+	};
+
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+	clock-drop-level = <2>;
+
+	panel@0 {
+		compatible = "auo,g133han01";
+		reg = <0>;
+    		status = "okay";
+		bridge-i2c-bus = <&i2c4>;
+		bridge-addr = <0x2c>;
+		bridge-info = <4>;
+		pinctrl-0 = <&pinctrl_mipi_dsi_en>;
+		power-gpio = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+		enable-gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+		bklite-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+		bkliteen-gpios = <&gpio1 1 GPIO_ACTIVE_HIGH>;
+		dsi-lanes = <4>;
+		panel-width-mm = <293>;
+		panel-height-mm = <165>;
+		port {
+			panel1_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_out>;
+			};
+		};
+	};
+
+	port@1 {
+		mipi_dsi_bridge_out: endpoint {
+			remote-endpoint = <&panel1_in>;
+		};
+	};
+};
+
+&iomuxc {
+	imx8mq-evk {
+		pinctrl_mipi_dsi_en: mipi_dsi_en {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO00_GPIO1_IO0	0x16					// LVDS_BKLT_EN	
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16					// LCD_BRI_EN	
+				MX8MQ_IOMUXC_SPDIF_TX_GPIO5_IO3		0x16					// LVDS_VDD_EN
+				MX8MQ_IOMUXC_GPIO1_IO01_GPIO1_IO1	0x16
+			>;
+		};
+
+		pinctrl_i2c1_synaptics_dsx_io: synaptics_dsx_iogrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_ECSPI1_MOSI_GPIO5_IO7              0x19
+			>;
+		};
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO01_PWM1_OUT 		0x06				// LVDS_BKLTCTL
+			>;
+		};
+
+	};
+};
+
+&i2c1 {
+	synaptics_dsx_ts@20 {
+		compatible = "synaptics_dsx";
+		reg = <0x20>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_i2c1_synaptics_dsx_io>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <7 8>;
+	/*	rest-gpios = <&gpio5 6 GPIO_ACTIVE_HIGH>;  */
+		status = "disabled";
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "disabled";
+};
diff --git a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m-1gb-ddr3l-dcss-g133han01.dts b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m-1gb-ddr3l-dcss-g133han01.dts
new file mode 100644
index 0000000..e25767f
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m-1gb-ddr3l-dcss-g133han01.dts
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-imx8mq-evk-dcss-g133han01.dts"
+
+/ {
+	cpus {
+		/delete-node/ cpu@2;
+		/delete-node/ cpu@3;
+	};
+
+	pmu {
+                interrupt-affinity = <&A53_0>, <&A53_1>;
+        };
+
+	resmem: reserved-memory {
+		/* change cma size to 384MB for 1GB DDR3L SKU */
+		linux,cma {
+			size = <0 0x18000000>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m-2gb-ddr3l-dcss-g133han01.dts b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m-2gb-ddr3l-dcss-g133han01.dts
new file mode 100644
index 0000000..94be788
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m-2gb-ddr3l-dcss-g133han01.dts
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-imx8mq-evk-dcss-g133han01.dts"
+
+/delete-node/ &vpu_pd;
+/delete-node/ &vpu;
diff --git a/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi b/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
index 9288216..a0217fe 100644
--- a/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
+++ b/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
@@ -630,8 +630,9 @@
 		interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&clk IMX8MQ_CLK_DSI_PHY_REF>,
 			 <&clk IMX8MQ_CLK_DSI_AHB>,
-			 <&clk IMX8MQ_CLK_DSI_IPG_DIV>;
-		clock-names = "phy_ref", "rx_esc", "tx_esc";
+ 			 <&clk IMX8MQ_CLK_DSI_IPG_DIV>,
+			 <&clk IMX8MQ_VIDEO_PLL1>;
+		clock-names = "phy_ref", "rx_esc", "tx_esc", "video_pll";
 		assigned-clocks = <&clk IMX8MQ_CLK_DSI_AHB>;
 		assigned-clock-parents = <&clk IMX8MQ_SYS1_PLL_80M>;
 		assigned-clock-rates = <80000000>;
diff --git a/drivers/clk/imx/clk-imx8mq.c b/drivers/clk/imx/clk-imx8mq.c
index 64492dfa..9e2c701 100644
--- a/drivers/clk/imx/clk-imx8mq.c
+++ b/drivers/clk/imx/clk-imx8mq.c
@@ -638,8 +638,8 @@ static void __init imx8mq_clocks_init(struct device_node *ccm_node)
 	clk_set_parent(clks[IMX8MQ_CLK_AUDIO_AHB], clks[IMX8MQ_SYS2_PLL_500M]);
 
 	/* config video_pll1 clock */
-	clk_set_parent(clks[IMX8MQ_VIDEO_PLL1_REF_SEL], clks[IMX8MQ_CLK_27M]);
-	clk_set_rate(clks[IMX8MQ_VIDEO_PLL1], 593999999);
+	clk_set_parent(clks[IMX8MQ_VIDEO_PLL1_REF_SEL], clks[IMX8MQ_CLK_25M]);
+	clk_set_rate(clks[IMX8MQ_VIDEO_PLL1], 500000000);
 
 	/* increase NOC clock to achieve best DDR access performance */
 	clk_set_rate(clks[IMX8MQ_CLK_NOC], clk_get_rate(clks[IMX8MQ_SYS1_PLL_800M]));
diff --git a/drivers/gpu/drm/bridge/nwl-dsi.c b/drivers/gpu/drm/bridge/nwl-dsi.c
index 8cad5f4..2fd9ef5 100644
--- a/drivers/gpu/drm/bridge/nwl-dsi.c
+++ b/drivers/gpu/drm/bridge/nwl-dsi.c
@@ -29,12 +29,17 @@
 #include <linux/of_graph.h>
 #include <linux/of_platform.h>
 #include <linux/phy/phy.h>
+#include <linux/phy/phy-mixel-mipi-dsi.h>
 #include <linux/spinlock.h>
 #include <video/mipi_display.h>
 #include <video/videomode.h>
 
 #define MIPI_FIFO_TIMEOUT msecs_to_jiffies(500)
 
+/* Maximum Video PLL frequency */
+#define MAX_PLL_FREQ 1200000000
+
+
 /* DSI HOST registers */
 #define CFG_NUM_LANES			0x0
 #define CFG_NONCONTINUOUS_CLK		0x4
@@ -150,6 +155,13 @@
 
 static const char IRQ_NAME[] = "nwl-dsi";
 
+/* Possible valid PHY reference clock rates*/
+static u32 phyref_rates[] = {
+	27000000,
+	25000000,
+	24000000,
+};
+
 enum {
 	CLK_PHY_REF	= BIT(1),
 	CLK_RX_ESC	= BIT(2),
@@ -181,6 +193,17 @@ struct clk_config {
 	bool enabled;
 };
 
+struct mode_config {
+	int				clock;
+	int				crtc_clock;
+	unsigned int			lanes;
+	unsigned long			bitclock;
+	unsigned long			phy_rates[3];
+	unsigned long			pll_rates[3];
+	int				phy_rate_idx;
+	struct list_head		list;
+};
+
 struct nwl_mipi_dsi {
 	struct device			*dev;
 	struct drm_panel		*panel;
@@ -196,17 +219,17 @@ struct nwl_mipi_dsi {
 	struct clk_config		phy_ref;
 	struct clk_config		rx_esc;
 	struct clk_config		tx_esc;
+ 	struct clk			*pll_clk;
 
 	void __iomem			*base;
 	int				irq;
-	enum mipi_dsi_pixel_format	format;
-	struct videomode		vm;
 
 	struct mipi_dsi_transfer	*xfer;
 
+	struct drm_display_mode		*curr_mode;
+	struct list_head		valid_modes;
 	u32				lanes;
-	u32				vc;
-	unsigned long			dsi_mode_flags;
+	u32				clk_drop_lvl;
 	bool				no_clk_reset;
 	bool				enabled;
 };
@@ -270,55 +293,51 @@ static enum dpi_pixel_format nwl_dsi_get_dpi_pixel_format(
 	}
 }
 
-unsigned long nwl_dsi_get_bit_clock(struct drm_bridge *bridge,
-	unsigned long pixclock)
+static unsigned long nwl_dsi_get_bit_clock(struct nwl_mipi_dsi *dsi,
+		unsigned long pixclock)
 {
-	struct nwl_mipi_dsi *dsi;
+	struct mipi_dsi_device *dsi_device = dsi->dsi_device;
 	int bpp;
-	u32 bus_format;
+	u32 bus_fmt;
 	struct drm_crtc *crtc = 0;
 
-	/* Make sure the bridge is correctly initialized */
-	if (!bridge || !bridge->driver_private)
-		return 0;
-
-	dsi = bridge->driver_private;
-
-	if (dsi->lanes < 1 || dsi->lanes > 4)
+	if (dsi_device->lanes < 1 || dsi_device->lanes > 4)
 		return 0;
 
 	/* if CTRC updated the bus format, update dsi->format */
 	if (dsi->bridge.encoder)
 		crtc = dsi->bridge.encoder->crtc;
 	if (crtc && crtc->mode.private_flags & 0x1) {
-		bus_format = (crtc->mode.private_flags & 0x1FFFE) >> 1;
-		dsi->format = mipi_dsi_format_from_bus_format(bus_format);
+		bus_fmt = (crtc->mode.private_flags & 0x1FFFE) >> 1;
 		/* propagate the format to the attached panel/bridge */
-		dsi->dsi_device->format = dsi->format;
+		dsi_device->format = mipi_dsi_format_from_bus_format(bus_fmt);
 		/* clear bus format change indication*/
 		crtc->mode.private_flags &= ~0x1;
 	}
 
-	bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+	bpp = mipi_dsi_pixel_format_to_bpp(dsi_device->format);
 
-	return (pixclock / dsi->lanes) * bpp;
+	return (pixclock * bpp) / dsi_device->lanes;
 }
-EXPORT_SYMBOL_GPL(nwl_dsi_get_bit_clock);
 
 static void nwl_dsi_config_host(struct nwl_mipi_dsi *dsi)
 {
-	if (dsi->lanes < 1 || dsi->lanes > 4)
+	struct mipi_dsi_device *dsi_device = dsi->dsi_device;
+
+	if (dsi_device->lanes < 1 || dsi_device->lanes > 4)
 		return;
 
-	nwl_dsi_write(dsi, CFG_NUM_LANES, dsi->lanes - 1);
+	nwl_dsi_write(dsi, CFG_NUM_LANES, dsi_device->lanes - 1);
 
-	if (dsi->dsi_mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS) {
+	if (dsi_device->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)
 		nwl_dsi_write(dsi, CFG_NONCONTINUOUS_CLK, 0x01);
-		nwl_dsi_write(dsi, CFG_AUTOINSERT_EOTP, 0x01);
-	} else {
+	else
 		nwl_dsi_write(dsi, CFG_NONCONTINUOUS_CLK, 0x00);
+
+	if (dsi_device->mode_flags & MIPI_DSI_MODE_EOT_PACKET)
 		nwl_dsi_write(dsi, CFG_AUTOINSERT_EOTP, 0x00);
-	}
+	else
+		nwl_dsi_write(dsi, CFG_AUTOINSERT_EOTP, 0x01);
 
 	nwl_dsi_write(dsi, CFG_T_PRE, 0x01);
 	nwl_dsi_write(dsi, CFG_T_POST, 0x34);
@@ -333,36 +352,39 @@ static void nwl_dsi_config_host(struct nwl_mipi_dsi *dsi)
 static void nwl_dsi_config_dpi(struct nwl_mipi_dsi *dsi)
 {
 	struct device *dev = dsi->dev;
-	struct videomode *vm = &dsi->vm;
+	struct mipi_dsi_device *dsi_device = dsi->dsi_device;
+	struct videomode vm;
 	enum dpi_pixel_format pixel_format =
-			nwl_dsi_get_dpi_pixel_format(dsi->format);
+		nwl_dsi_get_dpi_pixel_format(dsi_device->format);
 	enum dpi_interface_color_coding color_coding =
-			nwl_dsi_get_dpi_interface_color_coding(dsi->format);
+		nwl_dsi_get_dpi_interface_color_coding(dsi_device->format);
 	bool burst_mode;
 
+	drm_display_mode_to_videomode(dsi->curr_mode, &vm);
+
 	nwl_dsi_write(dsi, INTERFACE_COLOR_CODING, color_coding);
 	nwl_dsi_write(dsi, PIXEL_FORMAT, pixel_format);
 	DRM_DEV_DEBUG_DRIVER(dev, "DSI format is: %d (CC=%d, PF=%d)\n",
-			dsi->format, color_coding, pixel_format);
+			dsi_device->format, color_coding, pixel_format);
 
 	/*TODO: need to make polarity configurable */
 	nwl_dsi_write(dsi, VSYNC_POLARITY, 0x00);
 	nwl_dsi_write(dsi, HSYNC_POLARITY, 0x00);
 
-	burst_mode = (dsi->dsi_mode_flags & MIPI_DSI_MODE_VIDEO_BURST) &&
-		!(dsi->dsi_mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE);
+	burst_mode = (dsi_device->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) &&
+		!(dsi_device->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE);
 
 	if (burst_mode) {
 		nwl_dsi_write(dsi, VIDEO_MODE, 0x2);
 		nwl_dsi_write(dsi, PIXEL_FIFO_SEND_LEVEL, 256);
 	} else {
 		nwl_dsi_write(dsi, VIDEO_MODE, 0x0);
-		nwl_dsi_write(dsi, PIXEL_FIFO_SEND_LEVEL, vm->hactive);
+		nwl_dsi_write(dsi, PIXEL_FIFO_SEND_LEVEL, vm.hactive);
 	}
 
-	nwl_dsi_write(dsi, HFP, vm->hfront_porch);
-	nwl_dsi_write(dsi, HBP, vm->hback_porch);
-	nwl_dsi_write(dsi, HSA, vm->hsync_len);
+	nwl_dsi_write(dsi, HFP, vm.hfront_porch);
+	nwl_dsi_write(dsi, HBP, vm.hback_porch);
+	nwl_dsi_write(dsi, HSA, vm.hsync_len);
 
 	nwl_dsi_write(dsi, ENABLE_MULT_PKTS, 0x0);
 	nwl_dsi_write(dsi, BLLP_MODE, 0x1);
@@ -370,10 +392,10 @@ static void nwl_dsi_config_dpi(struct nwl_mipi_dsi *dsi)
 	nwl_dsi_write(dsi, USE_NULL_PKT_BLLP, 0x0);
 	nwl_dsi_write(dsi, VC, 0x0);
 
-	nwl_dsi_write(dsi, PIXEL_PAYLOAD_SIZE, vm->hactive);
-	nwl_dsi_write(dsi, VACTIVE, vm->vactive - 1);
-	nwl_dsi_write(dsi, VBP, vm->vback_porch);
-	nwl_dsi_write(dsi, VFP, vm->vfront_porch);
+	nwl_dsi_write(dsi, PIXEL_PAYLOAD_SIZE, vm.hactive);
+	nwl_dsi_write(dsi, VACTIVE, vm.vactive);
+	nwl_dsi_write(dsi, VBP, vm.vback_porch);
+	nwl_dsi_write(dsi, VFP, vm.vfront_porch);
 }
 
 static void nwl_dsi_enable_clocks(struct nwl_mipi_dsi *dsi, u32 clks)
@@ -442,25 +464,221 @@ static void nwl_dsi_init_interrupts(struct nwl_mipi_dsi *dsi)
 	nwl_dsi_write(dsi, IRQ_MASK, irq_enable);
 }
 
+/*
+ * Utility function to calculate least commom multiple, using an improved
+ * version of the Euclidean algorithm for greatest common factor.
+ */
+static unsigned long nwl_dsi_get_lcm(unsigned long a, unsigned long b)
+{
+	u32 gcf = 0; /* greatest common factor */
+	unsigned long tmp_a = a;
+	unsigned long tmp_b = b;
+
+	if (!a || !b)
+		return 0;
+
+	while (tmp_a % tmp_b) {
+		gcf = tmp_a % tmp_b;
+		tmp_a = tmp_b;
+		tmp_b = gcf;
+	}
+
+	if (!gcf)
+		return a;
+
+	return ((unsigned long long)a * b) / gcf;
+}
+
+/*
+ * This function tries to adjust the crtc_clock for a DSI device in such a way
+ * that the video pll will be able to satisfy both Display Controller pixel
+ * clock (feeding out DPI interface) and our input phy_ref clock.
+ * Also, the DC pixel clock must be lower than the actual clock in order to
+ * have enough blanking space to send DSI commands, if the device is a panel.
+ */
+static void nwl_dsi_setup_pll_config(struct mode_config *config,
+				     bool panel, u32 lvl)
+{
+	unsigned long pll_rate;
+	int div;
+	size_t i, num_rates = ARRAY_SIZE(config->phy_rates);
+
+	config->crtc_clock = 0;
+
+	for (i = 0; i < num_rates; i++) {
+		int crtc_clock;
+
+		if (!config->phy_rates[i])
+			break;
+		/*
+		 * First, we need to check if phy_ref can actually be obtained
+		 * from pixel clock. To do this, we check their lowest common
+		 * multiple, which has to be in PLL range.
+		 */
+		pll_rate = nwl_dsi_get_lcm(config->clock, config->phy_rates[i]);
+		if (pll_rate > MAX_PLL_FREQ) {
+			/* Drop pll_rate to a realistic value */
+			while (pll_rate > MAX_PLL_FREQ)
+				pll_rate >>= 1;
+			/* Make sure pll_rate can provide phy_ref rate */
+			div = DIV_ROUND_UP(pll_rate, config->phy_rates[i]);
+			pll_rate = config->phy_rates[i] * div;
+		} else {
+			/*
+			 * Increase the pll rate to highest possible rate for
+			 * better accuracy.
+			 */
+			while (pll_rate <= MAX_PLL_FREQ)
+				pll_rate <<= 1;
+			pll_rate >>= 1;
+		}
+
+		/*
+		 * Next, we need to tweak the pll_rate to a value that can also
+		 * satisfy the crtc_clock.
+		 */
+		div = DIV_ROUND_CLOSEST(pll_rate, config->clock);
+		if (panel)
+			pll_rate -= config->phy_rates[i] * lvl;
+		crtc_clock = pll_rate / div;
+		config->pll_rates[i] = pll_rate;
+
+		/* Pick a crtc_clock which is closest to pixel clock */
+		if ((config->clock - crtc_clock) <
+		    (config->clock - config->crtc_clock)) {
+			config->crtc_clock = crtc_clock;
+			config->phy_rate_idx = i;
+		}
+	}
+}
+
+/*
+ * This function will try the required phy speed for current mode
+ * If the phy speed can be achieved, the phy will save the speed
+ * configuration
+ */
+static struct mode_config *nwl_dsi_mode_probe(struct nwl_mipi_dsi *dsi,
+			    const struct drm_display_mode *mode)
+{
+	struct device *dev = dsi->dev;
+	struct mode_config *config;
+	unsigned long clock = mode->clock * 1000;
+	unsigned long bit_clk = 0;
+	unsigned long phy_rates[3] = {0};
+	int match_rates = 0;
+	u32 lanes = dsi->lanes;
+	size_t i = 0, num_rates = ARRAY_SIZE(phyref_rates);
+
+	list_for_each_entry(config, &dsi->valid_modes, list)
+		if (config->clock == clock)
+			return config;
+
+	while (i < num_rates) {
+		int ret;
+
+		bit_clk = nwl_dsi_get_bit_clock(dsi, clock);
+
+		ret = mixel_phy_mipi_set_phy_speed(dsi->phy,
+			bit_clk,
+			phyref_rates[i],
+			false);
+
+		/* Pick the non-failing rate, and search for more */
+		if (!ret) {
+			phy_rates[match_rates++] = phyref_rates[i++];
+			continue;
+		}
+
+		if (match_rates)
+			break;
+
+		/* Reached the end of phyref_rates, try another lane config */
+		if ((i++ == num_rates - 1) && (--lanes > 2)) {
+			i = 0;
+			continue;
+		}
+	}
+
+	if (!match_rates) {
+		DRM_DEV_DEBUG_DRIVER(dev,
+			"Cannot setup PHY for mode: %ux%u @%d kHz\n",
+			mode->hdisplay,
+			mode->vdisplay,
+			mode->clock);
+
+		return NULL;
+	}
+
+	config = devm_kzalloc(dsi->dev, sizeof(struct mode_config), GFP_KERNEL);
+	config->clock = clock;
+	config->lanes = lanes;
+	config->bitclock = bit_clk;
+	memcpy(&config->phy_rates, &phy_rates, sizeof(phy_rates));
+	list_add(&config->list, &dsi->valid_modes);
+
+	return config;
+}
+
+static enum drm_mode_status nwl_dsi_bridge_mode_valid(struct drm_bridge *bridge,
+			   const struct drm_display_mode *mode)
+{
+	struct nwl_mipi_dsi *dsi = bridge->driver_private;
+	struct mode_config *config;
+	unsigned long pll_rate;
+
+	DRM_DEV_DEBUG_DRIVER(dsi->dev, "Validating mode:");
+	drm_mode_debug_printmodeline(mode);
+
+	config = nwl_dsi_mode_probe(dsi, mode);
+	if (!config)
+		return MODE_NOCLOCK;
+
+	pll_rate = config->pll_rates[config->phy_rate_idx];
+	if (dsi->pll_clk && !pll_rate) {
+		nwl_dsi_setup_pll_config(config, false, 0);
+		if (config->clock != config->crtc_clock) {
+			config->pll_rates[config->phy_rate_idx] = 0;
+			return MODE_NOCLOCK;
+		}
+	}
+	return MODE_OK;
+}
+
 static bool nwl_dsi_bridge_mode_fixup(struct drm_bridge *bridge,
 			   const struct drm_display_mode *mode,
-			   struct drm_display_mode *adjusted_mode)
+			   struct drm_display_mode *adjusted)
 {
 	struct nwl_mipi_dsi *dsi = bridge->driver_private;
-	int bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
-	unsigned long pixclock = adjusted_mode->clock * 1000;
-	unsigned long data_rate;
+	struct mode_config *config;
+ 	unsigned long pll_rate;
+
+	DRM_DEV_DEBUG_DRIVER(dsi->dev, "Fixup mode:\n");
+	drm_mode_debug_printmodeline(adjusted);
 
-	if (dsi->lanes < 1 || dsi->lanes > 4)
+	config = nwl_dsi_mode_probe(dsi, adjusted);
+	if (!config)
 		return false;
 
-	/* Data rate is in bit clock for each lane */
-	data_rate = (pixclock / dsi->lanes) * bpp;
+	DRM_DEV_DEBUG_DRIVER(dsi->dev, "lanes=%u, data_rate=%lu\n",
+			     config->lanes, config->bitclock);
+	if (config->lanes < 2 || config->lanes > 4)
+		return false;
 
 	/* Max data rate for this controller is 1.5Gbps */
-	if (data_rate > 1500000000)
+	if (config->bitclock > 1500000000)
 		return false;
 
+ 	pll_rate = config->pll_rates[config->phy_rate_idx];
+	if (dsi->pll_clk && pll_rate) {
+		clk_set_rate(dsi->pll_clk, pll_rate);
+		DRM_DEV_DEBUG_DRIVER(dsi->dev,
+			"Video pll rate: %lu (actual: %lu)",
+			pll_rate, clk_get_rate(dsi->pll_clk));
+	}
+	/* Update the crtc_clock to be used by display controller */
+	if (config->crtc_clock)
+		adjusted->crtc_clock = config->crtc_clock / 1000;
+
 	return true;
 }
 
@@ -469,11 +687,36 @@ static void nwl_dsi_bridge_mode_set(struct drm_bridge *bridge,
 				     struct drm_display_mode *adjusted)
 {
 	struct nwl_mipi_dsi *dsi = bridge->driver_private;
+	struct mode_config *config;
+ 	unsigned long phy_rate, actual_phy_rate;
 
-	drm_display_mode_to_videomode(adjusted, &dsi->vm);
-
-	DRM_DEV_DEBUG_DRIVER(dsi->dev, "\n");
+	DRM_DEV_DEBUG_DRIVER(dsi->dev, "Setting mode:\n");
 	drm_mode_debug_printmodeline(adjusted);
+
+	config = nwl_dsi_mode_probe(dsi, adjusted);
+	/* New mode? This should NOT happen */
+	if (!config) {
+		DRM_DEV_ERROR(dsi->dev, "Unsupported mode provided:\n");
+		drm_mode_debug_printmodeline(adjusted);
+		return;
+	}
+
+ 	phy_rate = config->phy_rates[config->phy_rate_idx];
+
+	mixel_phy_mipi_set_phy_speed(dsi->phy,
+			config->bitclock,
+			phy_rate,
+			false);
+	clk_set_rate(dsi->phy_ref.clk, phy_rate);
+	actual_phy_rate = clk_get_rate(dsi->phy_ref.clk);
+	dsi->dsi_device->lanes = config->lanes;
+	DRM_DEV_DEBUG_DRIVER(dsi->dev,
+		"Using phy_ref rate: %lu (actual: %lu), "
+		"bitclock: %lu, lanes: %u\n",
+		phy_rate, actual_phy_rate,
+		config->bitclock, config->lanes);
+
+	dsi->curr_mode = drm_mode_duplicate(bridge->dev, adjusted);
 }
 
 static int nwl_dsi_host_attach(struct mipi_dsi_host *host,
@@ -490,8 +733,6 @@ static int nwl_dsi_host_attach(struct mipi_dsi_host *host,
 	if (device->lanes < 1 || device->lanes > 4)
 		return -EINVAL;
 
-	dsi->dsi_device = device;
-
 	/*
 	 * Someone has attached to us; it could be a panel or another bridge.
 	 * Check to is if this is a panel or not.
@@ -518,9 +759,39 @@ static int nwl_dsi_host_attach(struct mipi_dsi_host *host,
 	else
 		DRM_DEV_DEBUG_DRIVER(dsi->dev, "Bridge attached\n");
 
+	dsi->dsi_device = device;
 	dsi->lanes = device->lanes;
-	dsi->format = device->format;
-	dsi->dsi_mode_flags = device->mode_flags;
+
+	/*
+	 * If this happened right before a mode_set, it means that our
+	 * bridge/panel doesn't like the current mode parameters and changed
+	 * something on the dsi_device (lanes or format). In this case, we have
+	 * to reconfigure the phy.
+	 */
+	if (dsi->curr_mode) {
+		unsigned long clock = dsi->curr_mode->clock * 1000;
+		unsigned long phy_rate;
+		struct mode_config *config;
+
+		DRM_DEV_DEBUG_DRIVER(dsi->dev, "Re-setting mode:\n");
+		drm_mode_debug_printmodeline(dsi->curr_mode);
+		drm_mode_destroy(dsi->bridge.dev, dsi->curr_mode);
+		list_for_each_entry(config, &dsi->valid_modes, list)
+			if (config->clock == clock)
+				break;
+
+		if (device->lanes != config->lanes)
+			return 0;
+
+ 		phy_rate = config->phy_rates[config->phy_rate_idx];
+		clk_set_rate(dsi->phy_ref.clk, phy_rate);
+		device->lanes = config->lanes;
+		DRM_DEV_DEBUG_DRIVER(dsi->dev,
+			"Using phy_ref rate: %lu (actual: %ld), "
+			"bitclock: %lu, lanes: %d\n",
+			phy_rate, clk_get_rate(dsi->phy_ref.clk),
+			config->bitclock, config->lanes);
+	}
 
 	if (dsi->connector.dev)
 		drm_helper_hpd_irq_event(dsi->connector.dev);
@@ -540,6 +811,8 @@ static int nwl_dsi_host_detach(struct mipi_dsi_host *host,
 	if (dsi->connector.dev)
 		drm_helper_hpd_irq_event(dsi->connector.dev);
 
+	dsi->dsi_device = NULL;
+
 	return 0;
 }
 
@@ -876,11 +1149,32 @@ static int nwl_dsi_connector_get_modes(struct drm_connector *connector)
 	struct nwl_mipi_dsi *dsi = container_of(connector,
 						struct nwl_mipi_dsi,
 						connector);
+ 	struct mode_config *config;
+	int num_modes = 0;
+	struct drm_display_mode *mode;
 
+	DRM_DEV_DEBUG_DRIVER(dsi->dev, "\n");
 	if (dsi->panel)
-		return drm_panel_get_modes(dsi->panel);
+		num_modes = drm_panel_get_modes(dsi->panel);
 
-	return 0;
+	/*
+	 * We need to inform the CRTC about the actual bit clock that we need
+ 	 * for each mode. So, set crtc_clock down with 10% from the actual
+	 * pixel clock so that we will have enough space in the display timing
+	 * to send DSI commands.
+	 */
+	list_for_each_entry(mode, &connector->probed_modes, head) {
+
+		config = nwl_dsi_mode_probe(dsi, mode);
+		if (!config)
+			continue;
+
+ 		nwl_dsi_setup_pll_config(config, true, dsi->clk_drop_lvl);
+		if (config->crtc_clock)
+			mode->crtc_clock = config->crtc_clock / 1000;
+	}
+
+	return num_modes;
 }
 
 static const struct drm_connector_funcs nwl_dsi_connector_funcs = {
@@ -998,13 +1292,14 @@ static void nwl_dsi_bridge_detach(struct drm_bridge *bridge)
 static void nwl_dsi_bridge_enable(struct drm_bridge *bridge)
 {
 	struct nwl_mipi_dsi *dsi = bridge->driver_private;
+	struct mipi_dsi_device *dsi_device = dsi->dsi_device;
 	struct device *dev = dsi->dev;
 	int ret;
 
 	if (dsi->enabled || (!dsi->panel && !dsi->next_bridge))
 		return;
 
-	if (!dsi->lanes) {
+	if (!dsi_device) {
 		DRM_DEV_ERROR(dev, "Bridge not set up properly!\n");
 		return;
 	}
@@ -1045,7 +1340,7 @@ static void nwl_dsi_bridge_enable(struct drm_bridge *bridge)
 		goto enable_err;
 	}
 
-	if (dsi->dsi_mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)
+	if (dsi_device->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)
 		nwl_dsi_write(dsi, CFG_NONCONTINUOUS_CLK, 0x00);
 
 	dsi->enabled = true;
@@ -1096,6 +1391,7 @@ static void nwl_dsi_bridge_disable(struct drm_bridge *bridge)
 static const struct drm_bridge_funcs nwl_dsi_bridge_funcs = {
 	.enable = nwl_dsi_bridge_enable,
 	.disable = nwl_dsi_bridge_disable,
+	.mode_valid = nwl_dsi_bridge_mode_valid,
 	.mode_fixup = nwl_dsi_bridge_mode_fixup,
 	.mode_set = nwl_dsi_bridge_mode_set,
 	.attach = nwl_dsi_bridge_attach,
@@ -1131,6 +1427,11 @@ static int nwl_dsi_probe(struct platform_device *pdev)
 	dsi->phy_ref.rate = clk_get_rate(clk);
 	dsi->phy_ref.enabled = false;
 
+ 	/* The video_pll clock is optional */
+	clk = devm_clk_get(dev, "video_pll");
+	if (!IS_ERR(clk))
+		dsi->pll_clk = clk;
+
 	clk = devm_clk_get(dev, "rx_esc");
 	if (IS_ERR(clk)) {
 		ret = PTR_ERR(clk);
@@ -1174,6 +1475,9 @@ static int nwl_dsi_probe(struct platform_device *pdev)
 
 	dsi->no_clk_reset = of_property_read_bool(dev->of_node, "no_clk_reset");
 
+ 	of_property_read_u32(dev->of_node, "clock-drop-level",
+		&dsi->clk_drop_lvl);
+
 	dsi->dev = dev;
 	platform_set_drvdata(pdev, dsi);
 
@@ -1185,15 +1489,26 @@ static int nwl_dsi_probe(struct platform_device *pdev)
 	if (ret < 0)
 		dev_err(dev, "Failed to add nwl-dsi bridge (%d)\n", ret);
 
+	INIT_LIST_HEAD(&dsi->valid_modes);
+
 	return ret;
 }
 
 static int nwl_dsi_remove(struct platform_device *pdev)
 {
 	struct nwl_mipi_dsi *dsi = platform_get_drvdata(pdev);
+	struct mode_config *config;
+	struct list_head *pos, *tmp;
+
 
 	drm_bridge_remove(&dsi->bridge);
 
+	list_for_each_safe(pos, tmp, &dsi->valid_modes) {
+		config = list_entry(pos, struct mode_config, list);
+		list_del(pos);
+		devm_kfree(dsi->dev, config);
+	}
+
 	pm_runtime_disable(&pdev->dev);
 
 	return 0;
diff --git a/drivers/gpu/drm/imx/dcss/dcss-crtc.c b/drivers/gpu/drm/imx/dcss/dcss-crtc.c
index 9cf8ef6..73e88d0 100644
--- a/drivers/gpu/drm/imx/dcss/dcss-crtc.c
+++ b/drivers/gpu/drm/imx/dcss/dcss-crtc.c
@@ -249,6 +249,9 @@ static void dcss_crtc_atomic_enable(struct drm_crtc *crtc,
 
 	drm_display_mode_to_videomode(mode, &vm);
 
+ 	/* Use crtc_clock instead of clock, for videomode */
+	vm.pixelclock = mode->crtc_clock * 1000;
+
 	pm_runtime_get_sync(dcss_crtc->dev->parent);
 
 	dcss_dtg_ctxld_kick_irq_enable(dcss, true);
diff --git a/drivers/gpu/drm/imx/nwl_dsi-imx.c b/drivers/gpu/drm/imx/nwl_dsi-imx.c
index 37317ce..6586199 100644
--- a/drivers/gpu/drm/imx/nwl_dsi-imx.c
+++ b/drivers/gpu/drm/imx/nwl_dsi-imx.c
@@ -30,7 +30,6 @@
 #include <linux/of.h>
 #include <linux/of_graph.h>
 #include <linux/of_platform.h>
-#include <linux/phy/phy-mixel-mipi-dsi.h>
 #include <linux/phy/phy.h>
 #include <linux/regmap.h>
 #include <soc/imx8/sc/sci.h>
@@ -60,13 +59,6 @@
 #define CLK_BYPASS	"bypass"
 #define CLK_PHYREF	"phy_ref"
 
-/* Possible valid PHY reference clock rates*/
-u32 phyref_rates[] = {
-	24000000,
-	25000000,
-	27000000,
-};
-
 struct imx_mipi_dsi {
 	struct drm_encoder		encoder;
 	struct drm_bridge		bridge;
@@ -86,9 +78,6 @@ struct imx_mipi_dsi {
 	u32 tx_ulps_reg;
 	u32 pxl2dpi_reg;
 
-	unsigned long			bit_clk;
-	unsigned long			pix_clk;
-	u32				phyref_rate;
 	u32				instance;
 	u32				sync_pol;
 	u32				power_on_delay;
@@ -128,9 +117,9 @@ static struct devtype imx8qm_dev = {
 	.poweroff = &imx8qm_dsi_poweroff,
 	.clk_config = {
 		{ .id = CLK_CORE,   .present = false },
-		{ .id = CLK_PIXEL,  .present = true },
-		{ .id = CLK_BYPASS, .present = true },
 		{ .id = CLK_PHYREF, .present = true },
+		{ .id = CLK_BYPASS, .present = true },
+		{ .id = CLK_PIXEL,  .present = true },
 	},
 	.ext_regs = IMX_REG_CSR,
 	.tx_ulps_reg   = 0x00,
@@ -145,9 +134,9 @@ static struct devtype imx8qxp_dev = {
 	.poweroff = &imx8qxp_dsi_poweroff,
 	.clk_config = {
 		{ .id = CLK_CORE,   .present = false },
-		{ .id = CLK_PIXEL,  .present = true },
-		{ .id = CLK_BYPASS, .present = true },
 		{ .id = CLK_PHYREF, .present = true },
+		{ .id = CLK_BYPASS, .present = true },
+		{ .id = CLK_PIXEL,  .present = true },
 	},
 	.ext_regs = IMX_REG_CSR,
 	.tx_ulps_reg   = 0x30,
@@ -201,10 +190,6 @@ static void imx_nwl_dsi_set_clocks(struct imx_mipi_dsi *dsi, bool enable)
 		cur_rate = clk_get_rate(clk);
 		enabled = dsi->clk_config[i].enabled;
 
-		/* BYPASS clk must have the same rate as PHY_REF clk */
-		if (!strcmp(id, CLK_BYPASS) || !strcmp(id, CLK_PHYREF))
-			new_rate = dsi->phyref_rate;
-
 		if (enable) {
 			if (enabled && new_rate != cur_rate)
 				clk_disable_unprepare(clk);
@@ -261,6 +246,31 @@ static int imx8q_dsi_poweron(struct imx_mipi_dsi *dsi, bool v2)
 			     mipi_id,
 			     dc_id);
 
+	/* Assert DPI and MIPI bits */
+	sci_err = sc_misc_set_control(ipc_handle,
+				      mipi_id,
+				      SC_C_DPI_RESET,
+				      0);
+	if (sci_err != SC_ERR_NONE) {
+		DRM_DEV_ERROR(dev,
+			      "Failed to assert DPI reset (%d)\n",
+			      sci_err);
+		ret = -ENODEV;
+		goto err_ipc;
+	}
+
+	sci_err = sc_misc_set_control(ipc_handle,
+				      mipi_id,
+				      SC_C_MIPI_RESET,
+				      0);
+	if (sci_err != SC_ERR_NONE) {
+		DRM_DEV_ERROR(dev,
+			      "Failed to assert MIPI reset (%d)\n",
+			      sci_err);
+		ret = -ENODEV;
+		goto err_ipc;
+	}
+
 	if (v2) {
 		sci_err = sc_misc_set_control(ipc_handle,
 				mipi_id, SC_C_MODE, 0);
@@ -325,14 +335,14 @@ static int imx8q_dsi_poweron(struct imx_mipi_dsi *dsi, bool v2)
 		goto err_ipc;
 	}
 
-	/* Assert DPI and MIPI bits */
+	/* De-Assert DPI and MIPI bits */
 	sci_err = sc_misc_set_control(ipc_handle,
 				      mipi_id,
 				      SC_C_DPI_RESET,
 				      1);
 	if (sci_err != SC_ERR_NONE) {
 		DRM_DEV_ERROR(dev,
-			"Failed to assert DPI reset (%d)\n",
+			"Failed to deassert DPI reset (%d)\n",
 			sci_err);
 		ret = -ENODEV;
 		goto err_ipc;
@@ -344,7 +354,7 @@ static int imx8q_dsi_poweron(struct imx_mipi_dsi *dsi, bool v2)
 				      1);
 	if (sci_err != SC_ERR_NONE) {
 		DRM_DEV_ERROR(dev,
-			"Failed to assert MIPI reset (%d)\n",
+			"Failed to deassert MIPI reset (%d)\n",
 			sci_err);
 		ret = -ENODEV;
 		goto err_ipc;
@@ -468,7 +478,7 @@ static void imx_nwl_dsi_enable(struct imx_mipi_dsi *dsi)
 	const struct of_device_id *of_id = of_match_device(imx_nwl_dsi_dt_ids,
 							   dev);
 	const struct devtype *devtype = of_id->data;
-	unsigned long bit_clk, min_sleep, max_sleep;
+	unsigned long min_sleep, max_sleep;
 	int ret;
 
 	if (dsi->enabled)
@@ -477,25 +487,6 @@ static void imx_nwl_dsi_enable(struct imx_mipi_dsi *dsi)
 	DRM_DEV_DEBUG_DRIVER(dev, "id = %s\n", (dsi->instance)?"DSI1":"DSI0");
 
 	/*
-	 * TODO: we are doing this here, because the ADV7535 which is a drm
-	 * bridge, may change the DSI parameters in mode_set. One of the
-	 * changed parameter is DSI lanes, which affects the PHY settings.
-	 * This is why, we need run this function again, here, in order
-	 * to correctly set-up the PHY. Since we can't do anything here, we
-	 * will ignore it's status.
-	 * In the future, maybe it will be best to move the PHY handling
-	 * into the DSI host driver.
-	 */
-	bit_clk = nwl_dsi_get_bit_clock(dsi->next_bridge, dsi->pix_clk);
-	if (bit_clk != dsi->bit_clk) {
-		mixel_phy_mipi_set_phy_speed(dsi->phy,
-			bit_clk,
-			dsi->phyref_rate,
-			false);
-		dsi->bit_clk = bit_clk;
-	}
-
-	/*
 	 * On some systems we need to wait some time before enabling the
 	 * phy_ref clock, in order to allow the parent PLL to become stable
 	 */
@@ -544,10 +535,32 @@ static void imx_nwl_dsi_disable(struct imx_mipi_dsi *dsi)
 	dsi->enabled = false;
 }
 
-static void imx_nwl_update_sync_polarity(unsigned int *flags, u32 sync_pol)
+static void imx_nwl_dsi_encoder_enable(struct drm_encoder *encoder)
+{
+	struct imx_mipi_dsi *dsi = encoder_to_dsi(encoder);
+
+	pm_runtime_get_sync(dsi->dev);
+	imx_nwl_dsi_enable(dsi);
+}
+
+static void imx_nwl_dsi_encoder_disable(struct drm_encoder *encoder)
+{
+	struct imx_mipi_dsi *dsi = encoder_to_dsi(encoder);
+
+	imx_nwl_dsi_disable(dsi);
+	pm_runtime_put_sync(dsi->dev);
+}
+
+static bool imx_nwl_dsi_mode_fixup(struct imx_mipi_dsi *dsi,
+				 struct drm_display_mode *mode)
 {
+	unsigned int *flags = &mode->flags;
+
+	DRM_DEV_DEBUG_DRIVER(dsi->dev, "Fixup mode:\n");
+	drm_mode_debug_printmodeline(mode);
+
 	/* Make sure all flags are set-up accordingly */
-	if (sync_pol) {
+	if (dsi->sync_pol) {
 		*flags |= DRM_MODE_FLAG_PHSYNC;
 		*flags |= DRM_MODE_FLAG_PVSYNC;
 		*flags &= ~DRM_MODE_FLAG_NHSYNC;
@@ -558,90 +571,48 @@ static void imx_nwl_update_sync_polarity(unsigned int *flags, u32 sync_pol)
 		*flags |= DRM_MODE_FLAG_NHSYNC;
 		*flags |= DRM_MODE_FLAG_NVSYNC;
 	}
-}
 
-/*
- * This function will try the required phy speed for current mode
- * If the phy speed can be achieved, the phy will save the speed
- * configuration
- */
-static int imx_nwl_try_phy_speed(struct imx_mipi_dsi *dsi,
-			    struct drm_display_mode *mode)
-{
-	struct device *dev = dsi->dev;
-	unsigned long pixclock;
-	unsigned long bit_clk;
-	size_t i, num_rates = ARRAY_SIZE(phyref_rates);
-	int ret = 0;
+	return true;
+}
 
-	pixclock = mode->clock * 1000;
-	/*
-	 * DSI host should know the required bit clock, since it has info
-	 * about bits-per-pixel and number of lanes from DSI device
-	 */
-	bit_clk = nwl_dsi_get_bit_clock(dsi->next_bridge, pixclock);
+static void imx_nwl_dsi_mode_set(struct imx_mipi_dsi *dsi,
+				 struct drm_display_mode *mode)
+{	const char *id;
+	struct clk *clk;
+	size_t i;
 
-	/* If bit_clk is the same with current, we're good */
-	if (bit_clk == dsi->bit_clk)
-		return 0;
+	for (i = 0; i < dsi->clk_num; i++) {
+		if (!dsi->clk_config[i].present)
+			continue;
+		id = dsi->clk_config[i].id;
+		clk = dsi->clk_config[i].clk;
 
-	for (i = 0; i < num_rates; i++) {
-		dsi->phyref_rate = phyref_rates[i];
-		DRM_DEV_DEBUG_DRIVER(dev, "Trying PHY ref rate: %u\n",
-			dsi->phyref_rate);
-		ret = mixel_phy_mipi_set_phy_speed(dsi->phy,
-			bit_clk,
-			dsi->phyref_rate,
-			false);
-		/* Pick the first non-failing rate */
-		if (!ret)
-			break;
-	}
-	if (ret < 0) {
-		DRM_DEV_ERROR(dev,
-			"Cannot setup PHY for mode: %ux%u @%d kHz\n",
-			mode->hdisplay,
-			mode->vdisplay,
-			mode->clock);
-		DRM_DEV_ERROR(dev, "PHY_REF clk: %u, bit clk: %lu\n",
-			dsi->phyref_rate, bit_clk);
-	} else {
-		dsi->bit_clk = bit_clk;
-		dsi->pix_clk = pixclock;
+		/* Set bypass and pixel clocks to mode clock rate */
+		if (!strcmp(id, CLK_BYPASS) || !strcmp(id, CLK_PIXEL))
+			dsi->clk_config[i].rate = mode->crtc_clock * 1000;
 	}
 
-	return ret;
 }
 
-static void imx_nwl_dsi_encoder_enable(struct drm_encoder *encoder)
+static int imx_nwl_dsi_encoder_atomic_check(struct drm_encoder *encoder,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state)
 {
 	struct imx_mipi_dsi *dsi = encoder_to_dsi(encoder);
+	struct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc_state);
 
-	pm_runtime_get_sync(dsi->dev);
-	imx_nwl_dsi_enable(dsi);
-}
-
-static void imx_nwl_dsi_encoder_disable(struct drm_encoder *encoder)
-{
-	struct imx_mipi_dsi *dsi = encoder_to_dsi(encoder);
+	imx_crtc_state->bus_format = MEDIA_BUS_FMT_RGB101010_1X30;
 
-	imx_nwl_dsi_disable(dsi);
-	pm_runtime_put_sync(dsi->dev);
+	return !imx_nwl_dsi_mode_fixup(dsi, &crtc_state->adjusted_mode);
 }
 
-static int imx_nwl_dsi_encoder_atomic_check(struct drm_encoder *encoder,
-					struct drm_crtc_state *crtc_state,
-					struct drm_connector_state *conn_state)
+static void imx_nwl_dsi_encoder_mode_set(struct drm_encoder *encoder,
+			 struct drm_display_mode *mode,
+			 struct drm_display_mode *adjusted_mode)
 {
-	struct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc_state);
 	struct imx_mipi_dsi *dsi = encoder_to_dsi(encoder);
-	unsigned int *flags = &crtc_state->adjusted_mode.flags;
 
-	imx_crtc_state->bus_format = MEDIA_BUS_FMT_RGB101010_1X30;
-	imx_nwl_update_sync_polarity(flags, dsi->sync_pol);
-
-	/* Try to see if the phy can satisfy the current mode */
-	return imx_nwl_try_phy_speed(dsi, &crtc_state->adjusted_mode);
+	imx_nwl_dsi_mode_set(dsi, adjusted_mode);
 }
 
 static const struct drm_encoder_helper_funcs
@@ -649,6 +620,7 @@ imx_nwl_dsi_encoder_helper_funcs = {
 	.enable = imx_nwl_dsi_encoder_enable,
 	.disable = imx_nwl_dsi_encoder_disable,
 	.atomic_check = imx_nwl_dsi_encoder_atomic_check,
+	.mode_set = imx_nwl_dsi_encoder_mode_set,
 };
 
 static void imx_nwl_dsi_encoder_destroy(struct drm_encoder *encoder)
@@ -679,14 +651,20 @@ static void imx_nwl_dsi_bridge_disable(struct drm_bridge *bridge)
 
 static bool imx_nwl_dsi_bridge_mode_fixup(struct drm_bridge *bridge,
 			   const struct drm_display_mode *mode,
-			   struct drm_display_mode *adjusted_mode)
+			   struct drm_display_mode *adjusted)
 {
 	struct imx_mipi_dsi *dsi = bridge->driver_private;
-	unsigned int *flags = &adjusted_mode->flags;
 
-	imx_nwl_update_sync_polarity(flags, dsi->sync_pol);
+	return imx_nwl_dsi_mode_fixup(dsi, adjusted);
+}
+
+static void imx_nwl_dsi_bridge_mode_set(struct drm_bridge *bridge,
+			   struct drm_display_mode *mode,
+			   struct drm_display_mode *adjusted)
+{
+	struct imx_mipi_dsi *dsi = bridge->driver_private;
 
-	return (imx_nwl_try_phy_speed(dsi, adjusted_mode) == 0);
+	imx_nwl_dsi_mode_set(dsi, adjusted);
 }
 
 static int imx_nwl_dsi_bridge_attach(struct drm_bridge *bridge)
@@ -727,6 +705,7 @@ static const struct drm_bridge_funcs imx_nwl_dsi_bridge_funcs = {
 	.enable = imx_nwl_dsi_bridge_enable,
 	.disable = imx_nwl_dsi_bridge_disable,
 	.mode_fixup = imx_nwl_dsi_bridge_mode_fixup,
+	.mode_set = imx_nwl_dsi_bridge_mode_set,
 	.attach = imx_nwl_dsi_bridge_attach,
 	.detach = imx_nwl_dsi_bridge_detach,
 };
diff --git a/drivers/gpu/drm/panel/panel-lecimx8.c b/drivers/gpu/drm/panel/panel-lecimx8.c
index 0610e85..f40f45b 100644
--- a/drivers/gpu/drm/panel/panel-lecimx8.c
+++ b/drivers/gpu/drm/panel/panel-lecimx8.c
@@ -40,7 +40,7 @@
 #define BridgeAddr	0x2c
 #define useblk	1
 #define useReg	0
-#define jdebug 0
+
 static int sn65dsi84_i2c_read(struct i2c_adapter *bridge, char *writebuf,
 			   int writelen, char *readbuf, int readlen)
 {
@@ -112,7 +112,6 @@ static int sn65dsi84_write_reg(struct i2c_adapter *bridge, u8 addr, const u8 val
 
 	return sn65dsi84_i2c_write(bridge, buf, sizeof(buf));
 }
-// end of added
 
 struct panel_desc {
 	const struct drm_display_mode *modes;
@@ -169,6 +168,8 @@ struct panel_simple {
 	struct gpio_desc *power_gpio;
 	
 	struct gpio_desc *enable_gpio;
+	struct gpio_desc *bklite_gpio;
+	struct gpio_desc *bkliteen_gpio;
 };
 
 static inline struct panel_simple *to_panel_simple(struct drm_panel *panel)
@@ -244,11 +245,6 @@ static int panel_simple_get_fixed_modes(struct panel_simple *panel)
 static int panel_simple_disable(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_disable start \r\n");
-	#endif
-	// end of added
 	if (!p->enabled)
 		return 0;
 #if useblk
@@ -262,22 +258,12 @@ static int panel_simple_disable(struct drm_panel *panel)
 		msleep(p->desc->delay.disable);
 
 	p->enabled = false;
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_disable end \r\n");
-	#endif
-	// end of added
 	return 0;
 }
 
 static int panel_simple_unprepare(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_unprepare start \r\n");
-	#endif
-	// end of added
 	if (!p->prepared)
 		return 0;
 
@@ -291,11 +277,6 @@ static int panel_simple_unprepare(struct drm_panel *panel)
 		msleep(p->desc->delay.unprepare);
 
 	p->prepared = false;
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_unprepare end \r\n");
-	#endif
-	// end of added
 	return 0;
 }
 
@@ -303,11 +284,6 @@ static int panel_simple_prepare(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_prepare start \r\n");
-	#endif
-	// end of added
 	if (p->prepared)
 		return 0;
 	#if useReg	
@@ -317,11 +293,6 @@ static int panel_simple_prepare(struct drm_panel *panel)
 		return err;
 	}	
 	#endif
-	// added by johnson to test
-	#if jdebug
-	printk("johnson set enable_gpio H \r\n");
-	#endif
-	// end of added
 	if (p->enable_gpio)
 		gpiod_set_value_cansleep(p->enable_gpio, 1);
 
@@ -329,11 +300,6 @@ static int panel_simple_prepare(struct drm_panel *panel)
 		msleep(p->desc->delay.prepare);
 
 	p->prepared = true;
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_prepare end \r\n");
-	#endif
-	// end of added
 	return 0;
 }
 
@@ -443,7 +409,33 @@ static int bridge_sn65dsi84_config(struct panel_simple *p)
 			err = bridge_sn65dsi84_write_values(p, addresses, values, i, size);			
 		}
 		break;
-				
+
+
+                case 4: /* g133han01 */
+                {
+                        char addresses[] = {
+                                                                                        0x09, 0x0A, 0x0B, 0x0D, 0x10, 0x11, 0x12, 0x13,
+                                                                                        0x18, 0x19, 0x1A, 0x1B, 0x20, 0x21, 0x22, 0x23,
+                                                                                        0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B,
+                                                                                        0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
+                                                                                        0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,
+                                                                                        0x3C, 0x3D, 0x3E, 0x0D
+                                                                                        };
+
+                        char values[] = {                                                                                                                                                                                                                                  
+                                                                                        0x00, 0x05, 0x28, 0x00, 0x26, 0x00, 0x58, 0x00,
+                                                                                        0x6F, 0x00, 0x03, 0x00, 0x80, 0x07, 0x00, 0x00,
+                                                                                        0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
+                                                                                        0x1C, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+                                                                                        0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                                                                        0x00, 0x00, 0x00, 0x01                        
+                                                                                        };
+                        i = sizeof(addresses);
+                        size = sizeof(values);
+                        err = bridge_sn65dsi84_write_values(p, addresses, values, i, size);
+                }
+                break;
+
 	default:
 		break;
 	}
@@ -454,16 +446,8 @@ static int bridge_sn65dsi84_enable(struct panel_simple *p)
 	int i, err=0;	
 	int chipid[] = {0x35, 0x38, 0x49, 0x53, 0x44, 0x20, 0x20, 0x20, 0x01};
 	char address, value;
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa bridge_sn65dsi84_enable start \r\n");
-	#endif
-	// end of added
 	if (p->bridge_gpio) 
 	{
-		#if jdebug
-		printk("johnson start to enable bridge \r\n");
-		#endif
 		gpiod_set_value_cansleep(p->bridge_gpio, 0);
 		msleep(10);
 		gpiod_set_value_cansleep(p->bridge_gpio, 1);
@@ -492,6 +476,7 @@ static int bridge_sn65dsi84_enable(struct panel_simple *p)
 		return err;
 	}
 	msleep(50);
+
 	address = 0xe5;
 	err = sn65dsi84_i2c_read(p->bridge, &address, 1, &value, 1);
 	if (err < 0) {
@@ -500,20 +485,12 @@ static int bridge_sn65dsi84_enable(struct panel_simple *p)
 	}	
 	
 	msleep(500);
-	#if jdebug
-	printk("johnson aaa bridge_sn65dsi84_enable end value: 0x%x \r\n", value);
-	#endif
 	return 0;
 }
 // end of added
 static int panel_simple_enable(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_enable start \r\n");
-	#endif
-	// end of added
 	if (p->enabled)
 		return 0;
 
@@ -527,11 +504,6 @@ static int panel_simple_enable(struct drm_panel *panel)
 	}
 #endif
 	p->enabled = true;
-	// added by johnson to test
-	#if jdebug	
-	printk("johnson aaa panel_simple_enable end \r\n");
-	#endif
-	// end of added
 	return 0;
 }
 
@@ -539,11 +511,6 @@ static int panel_simple_get_modes(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	int num = 0;
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_get_modes start \r\n");
-	#endif
-	// end of added
 	/* probe EDID if a DDC bus is available */
 	if (p->ddc) {
 		struct edid *edid = drm_get_edid(panel->connector, p->ddc);
@@ -556,11 +523,6 @@ static int panel_simple_get_modes(struct drm_panel *panel)
 
 	/* add hard-coded panel modes */
 	num += panel_simple_get_fixed_modes(p);
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_get_modes end \r\n");
-	#endif
-	// end of added
 	return num;
 }
 
@@ -570,22 +532,13 @@ static int panel_simple_get_timings(struct drm_panel *panel,
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	unsigned int i;
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_get_timings start \r\n");
-	#endif
-	// end of added
 	if (p->desc->num_timings < num_timings)
 		num_timings = p->desc->num_timings;
 
 	if (timings)
 		for (i = 0; i < num_timings; i++)
 			timings[i] = p->desc->timings[i];
-	// added by johnson to test
-	#if jdebug
-	printk("johnson aaa panel_simple_get_timings end \r\n");
-	#endif
-	// end of added
+
 	return p->desc->num_timings;
 }
 
@@ -604,11 +557,6 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	struct panel_simple *panel;
 	int err;	
 	struct device_node *np = dev->of_node;
-	// added by johnson to test		
-	#if jdebug
-	printk("johnson set panel_simple_probe start \r\n");
-	#endif
-	// end of added
 	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
 	if (!panel)
 		return -ENOMEM;
@@ -618,19 +566,9 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	panel->desc = desc;
 
 	#if useReg
-	// added by johnson to test
-	#if jdebug
-	printk("johnson use regulator 111 \r\n");
-	#endif
-	// end of added
 	panel->supply = devm_regulator_get(dev, "power");
 	if (IS_ERR(panel->supply))
 		return PTR_ERR(panel->supply);
-	// added by johnson to test
-	#if jdebug
-	printk("johnson use regulator 222 \r\n");
-	#endif
-	// end of added
 	#else
 	panel->power_gpio = devm_gpiod_get_optional(dev, "power",
 						     GPIOD_OUT_HIGH);
@@ -640,21 +578,17 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 		return err;
 	}
 	gpiod_set_value_cansleep(panel->power_gpio, 1);
-	#if jdebug
-	printk("johnson use power gpio \r\n");
 	#endif
-	
-	#endif
-	
-	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable",
-						     GPIOD_OUT_LOW);
-	if (IS_ERR(panel->enable_gpio)) {
-		err = PTR_ERR(panel->enable_gpio);
-		dev_err(dev, "failed to request GPIO: %d\n", err);
-		return err;
+
+ 	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable",
+						     GPIOD_OUT_HIGH);
+ 	if (IS_ERR(panel->enable_gpio)) {
+ 		err = PTR_ERR(panel->enable_gpio);
+ 		dev_err(dev, "failed to request GPIO: %d\n", err);
+ 		return err;	
 	}
 #if useblk
-	backlight = of_parse_phandle(dev->of_node, "backlight", 0);
+        backlight = of_parse_phandle(dev->of_node, "backlight", 0);
 	if (backlight) {
 		panel->backlight = of_find_backlight_by_node(backlight);
 		of_node_put(backlight);
@@ -662,6 +596,23 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 		if (!panel->backlight)
 			return -EPROBE_DEFER;
 	}
+	else {
+		panel->bklite_gpio = devm_gpiod_get_optional(dev, "bklite",
+				GPIOD_OUT_HIGH);
+		if (IS_ERR(panel->bklite_gpio)) {
+			err = PTR_ERR(panel->bklite_gpio);
+			dev_err(dev, "failed to request backlight gpio\n");
+			return err;
+		}
+
+		panel->bkliteen_gpio = devm_gpiod_get_optional(dev, "bkliteen",
+				GPIOD_OUT_HIGH);
+		if (IS_ERR(panel->bkliteen_gpio)) {
+			err = PTR_ERR(panel->bkliteen_gpio);
+			dev_err(dev, "failed to request backlight gpio\n");
+			return err;
+		}
+	}
 #endif
 	ddc = of_parse_phandle(dev->of_node, "ddc-i2c-bus", 0);
 	if (ddc) {
@@ -697,9 +648,6 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 		}
 	}
 	bridge_sn65dsi84_enable(panel);
-	#if jdebug
-	printk("johnson get bridge control and gpio control type: %d \r\n", panel->bridge_info);	
-	#endif
 	drm_panel_init(&panel->base);
 	panel->base.dev = dev;
 	panel->base.funcs = &panel_simple_funcs;
@@ -709,11 +657,6 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 		goto free_ddc;
 
 	dev_set_drvdata(dev, panel);
-	// added by johnson to test
-	#if jdebug
-	printk("johnson set panel_simple_probe end \r\n");
-	#endif
-	// end of added
 	return 0;
 
 free_ddc:
@@ -2128,12 +2071,6 @@ static int panel_simple_platform_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *id;
 	
-	// added by johnson to test
-	#if jdebug
-	printk("johnson set panel_simple_platform_probe start \r\n");
-	#endif
-	// end of added
-
 	id = of_match_node(platform_of_match, pdev->dev.of_node);
 	if (!id)
 		return -ENODEV;
@@ -2594,6 +2531,36 @@ static const struct panel_desc_dsi inno_g104x1l03 = {
 	.lanes = 4,
 };
 
+static const struct drm_display_mode auo_g133han01_mode = {
+        .clock = 148000,
+        .hdisplay = 1920,
+        .hsync_start = 1920 + 77,
+        .hsync_end = 1920 + 77 + 56,
+        .htotal = 1920 + 77 + 56 + 117,
+        .vdisplay = 1080,
+        .vsync_start = 1080 + 11,
+        .vsync_end = 1080 + 11 + 19,
+        .vtotal = 1080 + 11 + 19 + 19,
+        .vrefresh = 60,
+        .flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc_dsi auo_g133han01 = {
+        .desc = {
+                .modes = &auo_g133han01_mode,
+                .num_modes = 1,
+                .bpc = 8,
+                .size = {
+                        .width = 293,
+                        .height = 165,
+                },
+                .bus_flags = DRM_BUS_FLAG_DE_LOW,
+        },
+        .flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST,
+        .format = MIPI_DSI_FMT_RGB888,
+        .lanes = 4,
+};
+
 static const struct of_device_id dsi_of_match[] = {
 	{
 		.compatible = "auo,b080uan01",
@@ -2628,6 +2595,9 @@ static const struct of_device_id dsi_of_match[] = {
 	}, {
 		.compatible = "inno,g104x1l03",
 		.data = &inno_g104x1l03
+        }, {
+                .compatible = "auo,g133han01",
+                .data = &auo_g133han01
 	}
 	, {
 		/* sentinel */
@@ -2640,11 +2610,6 @@ static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)
 	const struct panel_desc_dsi *desc;
 	const struct of_device_id *id;
 	int err;
-	// added by johnson to test	;
-	#if jdebug
-	printk("johnson panel_simple_dsi_probe \r\n");
-	#endif
-	// end of added
 	id = of_match_node(dsi_of_match, dsi->dev.of_node);
 	if (!id)
 		return -ENODEV;
diff --git a/drivers/gpu/imx/dpu/dpu-framegen.c b/drivers/gpu/imx/dpu/dpu-framegen.c
index 42f33ee..11f64f8 100644
--- a/drivers/gpu/imx/dpu/dpu-framegen.c
+++ b/drivers/gpu/imx/dpu/dpu-framegen.c
@@ -379,7 +379,7 @@ framegen_cfg_videomode(struct dpu_framegen *fg,
 	dpu_fg_write(fg, 0, FGCCR);
 	mutex_unlock(&fg->mutex);
 
-	disp_clock_rate = m->clock * 1000;
+ 	disp_clock_rate = m->crtc_clock * 1000;
 
 	/*
 	 * To workaround setting clock rate failure issue
diff --git a/include/drm/bridge/nwl_dsi.h b/include/drm/bridge/nwl_dsi.h
index 2ca1e58..df5f25b 100644
--- a/include/drm/bridge/nwl_dsi.h
+++ b/include/drm/bridge/nwl_dsi.h
@@ -39,7 +39,4 @@ enum dpi_pixel_format {
 	DPI_FMT_24_BIT /* 0x3 */
 };
 
-unsigned long nwl_dsi_get_bit_clock(struct drm_bridge *bridge,
-	unsigned long pixclock);
-
 #endif /* __NWL_DSI_H__ */
-- 
2.7.4

