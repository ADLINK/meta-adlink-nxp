From 8b2fb5ec896e03ec3e9c29cfbfd2d170a2edcf58 Mon Sep 17 00:00:00 2001
From: Dinesh V <dinesh.v@adlinktech.com>
Date: Fri, 21 Oct 2022 10:45:55 +0530
Subject: [PATCH 2/5] Added support for sn65dsi83 and panel-b101uan01

---
 drivers/gpu/drm/bridge/Kconfig                |   2 +
 drivers/gpu/drm/bridge/Makefile               |   1 +
 drivers/gpu/drm/bridge/sn65dsi83/Kconfig      |   6 +
 drivers/gpu/drm/bridge/sn65dsi83/Makefile     |   2 +
 .../gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c  | 477 +++++++++++++
 .../gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h  |  61 ++
 .../gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c  | 475 +++++++++++++
 .../drm/bridge/sn65dsi83/sn65dsi83_timing.h   |  33 +
 drivers/gpu/drm/bridge/ti-sn65dsi83.c         | 639 ++++++++++++++++++
 drivers/gpu/drm/panel/Kconfig                 |   9 +
 drivers/gpu/drm/panel/Makefile                |   1 +
 drivers/gpu/drm/panel/panel-b101uan01.c       | 345 ++++++++++
 12 files changed, 2051 insertions(+)
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/Kconfig
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/Makefile
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_timing.h
 create mode 100755 drivers/gpu/drm/bridge/ti-sn65dsi83.c
 create mode 100755 drivers/gpu/drm/panel/panel-b101uan01.c

diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 1dd8b0f6f4b3..b8181ef3cba7 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -245,6 +245,8 @@ config DRM_TI_TFP410
 	help
 	  Texas Instruments TFP410 DVI/HDMI Transmitter driver
 
+source "drivers/gpu/drm/bridge/sn65dsi83/Kconfig"
+
 config DRM_TI_SN65DSI86
 	tristate "TI SN65DSI86 DSI to eDP bridge"
 	depends on OF
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index a8420c81f773..f1c555b2ff71 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -32,3 +32,4 @@ obj-$(CONFIG_DRM_ITE_IT6263) += it6263.o
 obj-$(CONFIG_DRM_ITE_IT6263) += it6161.o
 obj-$(CONFIG_DRM_SEC_MIPI_DSIM) += sec-dsim.o
 obj-$(CONFIG_DRM_NXP_SEIKO_43WVFIG) += nxp-seiko-43wvfig.o
+obj-$(CONFIG_DRM_I2C_SN65DSI83) += sn65dsi83/
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/Kconfig b/drivers/gpu/drm/bridge/sn65dsi83/Kconfig
new file mode 100644
index 000000000000..e1b8e802f61f
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/Kconfig
@@ -0,0 +1,6 @@
+config DRM_I2C_SN65DSI83
+	bool "TI SN65DSI83 MIPI DSI to LVDS bridge"
+	depends on OF
+	select DRM_MIPI_DSI
+	help
+	  TI SN65DSI83 MIPI DSI to LVDS bridge driver
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/Makefile b/drivers/gpu/drm/bridge/sn65dsi83/Makefile
new file mode 100644
index 000000000000..dee7f493b323
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/Makefile
@@ -0,0 +1,2 @@
+sn65dsi83-objs := sn65dsi83_drv.o sn65dsi83_brg.o
+obj-$(CONFIG_DRM_I2C_SN65DSI83) := sn65dsi83.o
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c
new file mode 100644
index 000000000000..8540340f8508
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c
@@ -0,0 +1,477 @@
+/*
+ * Copyright (C) 2018 CopuLab Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/slab.h>
+
+#include <linux/delay.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_connector.h>
+#include <video/mipi_display.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+
+#include "sn65dsi83_brg.h"
+
+/* Register addresses */
+
+#define SN65DSI83_SOFT_RESET         0x09
+#define SN65DSI83_CORE_PLL           0x0A
+    #define LVDS_CLK_RANGE_SHIFT    1
+    #define HS_CLK_SRC_SHIFT        0
+
+#define SN65DSI83_PLL_DIV            0x0B
+    #define DSI_CLK_DIV_SHIFT       3
+
+#define SN65DSI83_PLL_EN             0x0D
+#define SN65DSI83_DSI_CFG            0x10
+    #define CHA_DSI_LANES_SHIFT    3
+
+#define SN65DSI83_DSI_EQ              0x11
+#define SN65DSI83_CHA_DSI_CLK_RNG     0x12
+#define SN65DSI83_CHB_DSI_CLK_RNG     0x13
+#define SN65DSI83_LVDS_MODE           0x18
+    #define DE_NEG_POLARITY_SHIFT 7
+    #define HS_NEG_POLARITY_SHIFT 6
+    #define VS_NEG_POLARITY_SHIFT 5
+    #define LVDS_LINK_CFG_SHIFT   4
+    #define CHA_24BPP_MODE_SHIFT  3
+    #define CHB_24BPP_MODE_SHIFT  2
+    #define CHA_24BPP_FMT1_SHIFT  1
+    #define CHB_24BPP_FMT1_SHIFT  0
+
+#define SN65DSI83_LVDS_SIGN           0x19
+#define SN65DSI83_LVDS_TERM           0x1A
+#define SN65DSI83_LVDS_CM_ADJ         0x1B
+#define SN65DSI83_CHA_LINE_LEN_LO     0x20
+#define SN65DSI83_CHA_LINE_LEN_HI     0x21
+#define SN65DSI83_CHB_LINE_LEN_LO     0x22
+#define SN65DSI83_CHB_LINE_LEN_HI     0x23
+#define SN65DSI83_CHA_VERT_LINES_LO   0x24
+#define SN65DSI83_CHA_VERT_LINES_HI   0x25
+#define SN65DSI83_CHB_VERT_LINES_LO   0x26
+#define SN65DSI83_CHB_VERT_LINES_HI   0x27
+#define SN65DSI83_CHA_SYNC_DELAY_LO   0x28
+#define SN65DSI83_CHA_SYNC_DELAY_HI   0x29
+#define SN65DSI83_CHB_SYNC_DELAY_LO   0x2A
+#define SN65DSI83_CHB_SYNC_DELAY_HI   0x2B
+#define SN65DSI83_CHA_HSYNC_WIDTH_LO  0x2C
+#define SN65DSI83_CHA_HSYNC_WIDTH_HI  0x2D
+#define SN65DSI83_CHB_HSYNC_WIDTH_LO  0x2E
+#define SN65DSI83_CHB_HSYNC_WIDTH_HI  0x2F
+#define SN65DSI83_CHA_VSYNC_WIDTH_LO  0x30
+#define SN65DSI83_CHA_VSYNC_WIDTH_HI  0x31
+#define SN65DSI83_CHB_VSYNC_WIDTH_LO  0x32
+#define SN65DSI83_CHB_VSYNC_WIDTH_HI  0x33
+#define SN65DSI83_CHA_HORZ_BACKPORCH  0x34
+#define SN65DSI83_CHB_HORZ_BACKPORCH  0x35
+#define SN65DSI83_CHA_VERT_BACKPORCH  0x36
+#define SN65DSI83_CHB_VERT_BACKPORCH  0x37
+#define SN65DSI83_CHA_HORZ_FRONTPORCH 0x38
+#define SN65DSI83_CHB_HORZ_FRONTPORCH 0x39
+#define SN65DSI83_CHA_VERT_FRONTPORCH 0x3A
+#define SN65DSI83_CHB_VERT_FRONTPORCH 0x3B
+#define SN65DSI83_CHA_ERR             0xE5
+#define SN65DSI83_TEST_PATTERN        0x3C
+#define SN65DSI83_REG_3D              0x3D
+#define SN65DSI83_REG_3E              0x3E
+
+static int sn65dsi83_brg_power_on(struct sn65dsi83_brg *brg)
+{
+    dev_dbg(&brg->client->dev,"%s\n",__func__);
+    gpiod_set_value_cansleep(brg->gpio_enable, 1);
+    /* Wait for 1ms for the internal voltage regulator to stabilize */
+    msleep(1);
+
+    return 0;
+}
+
+static void sn65dsi83_brg_power_off(struct sn65dsi83_brg *brg)
+{
+    dev_dbg(&brg->client->dev,"%s\n",__func__);
+    gpiod_set_value_cansleep(brg->gpio_enable, 0);
+    /*
+     * The EN pin must be held low for at least 10 ms
+     * before being asserted high
+     */
+    msleep(10);
+}
+
+static int sn65dsi83_write(struct i2c_client *client, u8 reg, u8 val)
+{
+    int ret;
+
+    ret = i2c_smbus_write_byte_data(client, reg, val);
+
+    if (ret)
+        dev_err(&client->dev, "failed to write at 0x%02x", reg);
+
+    dev_dbg(&client->dev, "%s: write reg 0x%02x data 0x%02x", __func__, reg, val);
+
+    return ret;
+}
+#define SN65DSI83_WRITE(reg,val) sn65dsi83_write(client, (reg) , (val))
+
+static int sn65dsi83_read(struct i2c_client *client, u8 reg)
+{
+    int ret;
+
+    dev_dbg(&client->dev, "client 0x%p", client);
+    ret = i2c_smbus_read_byte_data(client, reg);
+
+    if (ret < 0) {
+        dev_err(&client->dev, "failed reading at 0x%02x", reg);
+        return ret;
+    }
+
+    dev_dbg(&client->dev, "%s: read reg 0x%02x data 0x%02x", __func__, reg, ret);
+
+    return ret;
+}
+#define SN65DSI83_READ(reg) sn65dsi83_read(client, (reg))
+
+static int sn65dsi83_brg_start_stream(struct sn65dsi83_brg *brg)
+{
+    int regval;
+    struct i2c_client *client = I2C_CLIENT(brg);
+
+    dev_dbg(&client->dev,"%s\n",__func__);
+    /* Set the PLL_EN bit (CSR 0x0D.0) */
+    SN65DSI83_WRITE(SN65DSI83_PLL_EN, 0x1);
+    /* Wait for the PLL_LOCK bit to be set (CSR 0x0A.7) */
+    msleep(200);
+
+    /* Perform SW reset to apply changes */
+    SN65DSI83_WRITE(SN65DSI83_SOFT_RESET, 0x01);
+
+    /* Read CHA Error register */
+    regval = SN65DSI83_READ(SN65DSI83_CHA_ERR);
+    dev_dbg(&client->dev, "CHA (0x%02x) = 0x%02x",
+         SN65DSI83_CHA_ERR, regval);
+
+    if (!IS_ERR(brg->gpio_panel_enable))
+        gpiod_set_value_cansleep(brg->gpio_panel_enable, 1);
+
+    return 0;
+}
+
+static void sn65dsi83_brg_stop_stream(struct sn65dsi83_brg *brg)
+{
+    struct i2c_client *client = I2C_CLIENT(brg);
+    dev_dbg(&client->dev,"%s\n",__func__);
+    /* Clear the PLL_EN bit (CSR 0x0D.0) */
+    SN65DSI83_WRITE(SN65DSI83_PLL_EN, 0x00);
+
+    if (!IS_ERR(brg->gpio_panel_enable))
+        gpiod_set_value_cansleep(brg->gpio_panel_enable, 0);
+}
+
+static int sn65dsi83_calk_clk_range(int min_regval, int max_regval,
+                unsigned long min_clk, unsigned long inc,
+                unsigned long target_clk)
+{
+    int regval = min_regval;
+    unsigned long clk = min_clk;
+
+    while (regval <= max_regval) {
+        if ((clk <= target_clk) && (target_clk < (clk + inc)))
+            return regval;
+
+        regval++;
+        clk += inc;
+    }
+
+    return -1;
+}
+
+#define ABS(X) ((X) < 0 ? (-1 * (X)) : (X))
+static int sn65dsi83_calk_div(int min_regval, int max_regval, int min_div,
+                int inc, unsigned long source_clk,
+                unsigned long target_clk)
+{
+    int regval = min_regval;
+    int div = min_div;
+    unsigned long curr_delta;
+    unsigned long prev_delta = ABS(DIV_ROUND_UP(source_clk, div) -
+                    target_clk);
+
+    while (regval <= max_regval) {
+        curr_delta = ABS(DIV_ROUND_UP(source_clk, div) - target_clk);
+        if (curr_delta > prev_delta)
+            return --regval;
+
+        regval++;
+        div += inc;
+    }
+
+    return -1;
+}
+
+static int sn65dsi83_brg_configure(struct sn65dsi83_brg *brg)
+{
+    int regval = 0;
+    struct i2c_client *client = I2C_CLIENT(brg);
+    struct videomode *vm = VM(brg);
+
+    u32 dsi_clk = (((PIXCLK * BPP(brg)) / DSI_LANES(brg)) >> 1);
+    bool dual_channel_lvds = (brg->num_channels == 2);
+    u32 lvds_clk = dual_channel_lvds ? (PIXCLK >> 1) : PIXCLK;
+    u32 cha_hsync_width = dual_channel_lvds ? (HPW >> 1) : HPW;
+    u32 cha_horz_backporch = dual_channel_lvds ? (HBP >> 1) : HBP;
+
+    dev_info(&client->dev, "DSI clock [ %u ] Hz\n",dsi_clk);
+    dev_info(&client->dev, "Resolution [ %d x %d ]\n",HACTIVE,VACTIVE);
+
+	printk("[chia] bpp = %u\n",brg->bpp);
+	printk("[chia] num_channels = %u\n",brg->num_channels);
+	printk("[chia] format = %u\n",brg->format);
+	printk("[chia] lanes = %u\n",brg->num_dsi_lanes);
+	printk("[chia] burst_mode = %u\n",brg->burst_mode);
+	printk("[chia] de_neg_polarity = %u\n",brg->de_neg_polarity);
+	printk("[chia] even_odd_swap = %u\n",brg->even_odd_swap);
+	printk("[chia] =========================\n");
+	printk("[chia] lvds_clk = %u\n",lvds_clk);
+	printk("[chia] dsi_clk = %u\n",dsi_clk);
+	printk("[chia] =========================\n");
+	printk("[chia] pixeclock = %lu\n",brg->vm.pixelclock);
+	printk("[chia] hback_porch = %u\n",brg->vm.hback_porch);
+	printk("[chia] hfront_porch = %u\n",brg->vm.hfront_porch);
+	printk("[chia] hsync_len = %u\n",brg->vm.hsync_len);
+	printk("[chia] hactive = %u\n",brg->vm.hactive);
+	printk("[chia] vback_porch = %u\n",brg->vm.vback_porch);
+	printk("[chia] vfront_porch = %u\n",brg->vm.vfront_porch);
+	printk("[chia] vsync_len = %u\n",brg->vm.vsync_len);
+	printk("[chia] vactive = %u\n",brg->vm.vactive);
+
+    /* Reset PLL_EN and SOFT_RESET registers */
+    SN65DSI83_WRITE(SN65DSI83_SOFT_RESET,0x00);
+    SN65DSI83_WRITE(SN65DSI83_PLL_EN,0x00);
+
+    /* LVDS clock setup */
+    if ((25000000 <= lvds_clk) && (lvds_clk < 37500000))
+        regval = 0;
+    else
+        regval = sn65dsi83_calk_clk_range(0x01, 0x05, 37500000, 25000000,
+                    lvds_clk);
+
+    dev_info(&client->dev, "lvds_clk=%u lvds_clk_range=0x%x\n", lvds_clk, regval);
+
+    if (regval < 0) {
+        dev_err(&client->dev, "failed to configure LVDS clock");
+        return -EINVAL;
+    }
+
+    regval = (regval << LVDS_CLK_RANGE_SHIFT);
+    regval |= (1 << HS_CLK_SRC_SHIFT); /* Use DSI clock */
+    SN65DSI83_WRITE(SN65DSI83_CORE_PLL,regval);
+
+    /* DSI clock range */
+    regval = sn65dsi83_calk_clk_range(0x08, 0x64, 40000000, 5000000, dsi_clk);
+    if (regval < 0) {
+        dev_err(&client->dev, "failed to configure DSI clock range\n");
+        return -EINVAL;
+    }
+    SN65DSI83_WRITE(SN65DSI83_CHA_DSI_CLK_RNG,regval);
+    SN65DSI83_WRITE(SN65DSI83_CHB_DSI_CLK_RNG,0x00);
+
+    dev_info(&client->dev, "dsi_clk_range=0x%x\n", regval);
+
+    /* DSI clock divider */
+    regval = sn65dsi83_calk_div(0x0, 0x18, 1, 1, dsi_clk, lvds_clk);
+    if (regval < 0) {
+        dev_err(&client->dev, "failed to calculate DSI clock divider");
+        return -EINVAL;
+    }
+
+    dev_info(&client->dev, "dsi_clk_div=0x%x\n", regval);
+
+    regval = regval << DSI_CLK_DIV_SHIFT;
+    SN65DSI83_WRITE(SN65DSI83_PLL_DIV,regval);
+
+    /* Configure DSI_LANES  */
+    regval = SN65DSI83_READ(SN65DSI83_DSI_CFG);
+    regval &= ~(3 << CHA_DSI_LANES_SHIFT);
+    regval |= ((4 - DSI_LANES(brg)) << CHA_DSI_LANES_SHIFT);
+    SN65DSI83_WRITE(SN65DSI83_DSI_CFG,regval);
+
+    /* CHA_DSI_DATA_EQ - No Equalization */
+    /* CHA_DSI_CLK_EQ  - No Equalization */
+    SN65DSI83_WRITE(SN65DSI83_DSI_EQ,0x00);
+
+    /* Video formats */
+    regval = 0;
+    if (FLAGS & DISPLAY_FLAGS_HSYNC_LOW)
+        regval |= (1 << HS_NEG_POLARITY_SHIFT);
+
+    if (FLAGS & DISPLAY_FLAGS_VSYNC_LOW)
+        regval |= (1 << VS_NEG_POLARITY_SHIFT);
+
+    if (brg->de_neg_polarity)
+        regval |= (1 << DE_NEG_POLARITY_SHIFT);
+
+    if (BPP(brg) == 24) {
+        regval |= (1 << CHA_24BPP_MODE_SHIFT);
+        regval |= (1 << CHB_24BPP_MODE_SHIFT);
+    }
+
+    if (FORMAT(brg) == 1) {
+        regval |= (1 << CHA_24BPP_FMT1_SHIFT);
+        regval |= (1 << CHB_24BPP_FMT1_SHIFT);
+    }
+
+    regval |= ((dual_channel_lvds ? 0 : 1) << LVDS_LINK_CFG_SHIFT);
+
+    //SN65DSI83_WRITE(SN65DSI83_LVDS_MODE,regval); // original
+    SN65DSI83_WRITE(SN65DSI83_LVDS_MODE,0x63); // chia : need to fix 
+
+    /* Voltage and pins */
+    SN65DSI83_WRITE(SN65DSI83_LVDS_SIGN,0x00);
+
+    /* Allow swapping from channel a to channel b */
+    regval = 0x03;
+    regval |= ((brg->even_odd_swap ? 1 : 0) << 6);
+    SN65DSI83_WRITE(SN65DSI83_LVDS_TERM,regval);
+    SN65DSI83_WRITE(SN65DSI83_LVDS_CM_ADJ,0x00);
+
+    /* Configure sync delay to minimal allowed value */
+    SN65DSI83_WRITE(SN65DSI83_CHA_SYNC_DELAY_LO,0x21);
+    SN65DSI83_WRITE(SN65DSI83_CHA_SYNC_DELAY_HI,0x00);
+
+    SN65DSI83_WRITE(SN65DSI83_CHB_SYNC_DELAY_LO,0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_SYNC_DELAY_HI,0x00);
+
+    /* Geometry */
+    SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_LO,LOW(HACTIVE));
+    SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_HI,HIGH(HACTIVE));
+
+    SN65DSI83_WRITE(SN65DSI83_CHB_LINE_LEN_LO,0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_LINE_LEN_HI,0x00);
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_LO,LOW(VACTIVE));
+    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_HI,HIGH(VACTIVE));
+
+    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_LINES_LO,0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_LINES_HI,0x00);
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_HSYNC_WIDTH_LO,LOW(cha_hsync_width));
+    SN65DSI83_WRITE(SN65DSI83_CHA_HSYNC_WIDTH_HI,HIGH(HPW));
+
+    SN65DSI83_WRITE(SN65DSI83_CHB_HSYNC_WIDTH_LO,0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_HSYNC_WIDTH_HI,0x00);
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_VSYNC_WIDTH_LO,LOW(VPW));
+    SN65DSI83_WRITE(SN65DSI83_CHA_VSYNC_WIDTH_HI,HIGH(VPW));
+
+    SN65DSI83_WRITE(SN65DSI83_CHB_VSYNC_WIDTH_LO,0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VSYNC_WIDTH_HI,0x00);
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_HORZ_BACKPORCH,LOW(cha_horz_backporch));
+    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_BACKPORCH,LOW(VBP));
+
+    SN65DSI83_WRITE(SN65DSI83_CHB_HORZ_BACKPORCH,0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_BACKPORCH,0x00);
+
+    SN65DSI83_WRITE(SN65DSI83_CHA_HORZ_FRONTPORCH,LOW(HFP));
+    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_FRONTPORCH,LOW(VFP));
+
+    SN65DSI83_WRITE(SN65DSI83_CHB_HORZ_FRONTPORCH,0x00);
+    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_FRONTPORCH,0x00);
+
+    SN65DSI83_WRITE(SN65DSI83_TEST_PATTERN,0x00);
+    SN65DSI83_WRITE(SN65DSI83_REG_3D,0x00);
+    SN65DSI83_WRITE(SN65DSI83_REG_3E,0x00);
+
+	//--------------
+#if 1 // chia: need to fix
+
+	//SN65DSI83_WRITE(0x10,0x26);
+	SN65DSI83_WRITE(0x20,0x40);
+	SN65DSI83_WRITE(0x21,0x06);
+	SN65DSI83_WRITE(0x22,0x00);
+	SN65DSI83_WRITE(0x23,0x00);
+	SN65DSI83_WRITE(0x24,0x00);
+	SN65DSI83_WRITE(0x25,0x00);
+	SN65DSI83_WRITE(0x26,0x00);
+	SN65DSI83_WRITE(0x27,0x00);
+	SN65DSI83_WRITE(0x28,0xeb);
+	SN65DSI83_WRITE(0x29,0x03);
+	SN65DSI83_WRITE(0x2A,0x00);
+	SN65DSI83_WRITE(0x2B,0x00);
+	SN65DSI83_WRITE(0x2C,0x64);
+	SN65DSI83_WRITE(0x2D,0x00);
+	SN65DSI83_WRITE(0x2E,0x00);
+	SN65DSI83_WRITE(0x2F,0x00);
+	SN65DSI83_WRITE(0x30,0x14);
+	SN65DSI83_WRITE(0x31,0x00);
+	SN65DSI83_WRITE(0x32,0x00);
+	SN65DSI83_WRITE(0x33,0x00);
+	SN65DSI83_WRITE(0x34,0x5a);
+	SN65DSI83_WRITE(0x35,0x00);
+	SN65DSI83_WRITE(0x36,0x00);
+	SN65DSI83_WRITE(0x37,0x00);
+	SN65DSI83_WRITE(0x38,0x00);
+	SN65DSI83_WRITE(0x39,0x00);
+	SN65DSI83_WRITE(0x3A,0x00);
+	SN65DSI83_WRITE(0x3B,0x00);
+	//SN65DSI83_WRITE(0x3C,0x10);	
+#endif	
+    return 0;
+}
+
+static int sn65dsi83_brg_setup(struct sn65dsi83_brg *brg)
+{
+    struct i2c_client *client = I2C_CLIENT(brg);
+    dev_dbg(&client->dev,"%s\n",__func__);
+    sn65dsi83_brg_power_on(brg);
+    return sn65dsi83_brg_configure(brg);
+}
+
+static int sn65dsi83_brg_reset(struct sn65dsi83_brg *brg)
+{
+    /* Soft Reset reg value at power on should be 0x00 */
+    struct i2c_client *client = I2C_CLIENT(brg);
+    int ret = SN65DSI83_READ(SN65DSI83_SOFT_RESET);
+    dev_dbg(&client->dev,"%s\n",__func__);
+    if (ret != 0x00) {
+        dev_err(&client->dev,"Failed to reset the device");
+        return -ENODEV;
+    }
+    return 0;
+}
+
+static struct sn65dsi83_brg_funcs brg_func = {
+    .power_on = sn65dsi83_brg_power_on,
+    .power_off = sn65dsi83_brg_power_off,
+    .setup = sn65dsi83_brg_setup,
+    .reset = sn65dsi83_brg_reset,
+    .start_stream = sn65dsi83_brg_start_stream,
+    .stop_stream = sn65dsi83_brg_stop_stream,
+};
+
+static struct sn65dsi83_brg brg = {
+    .funcs = &brg_func,
+};
+
+struct sn65dsi83_brg *sn65dsi83_brg_get(void) {
+    return &brg;
+}
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h
new file mode 100644
index 000000000000..cbdeb910e675
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h
@@ -0,0 +1,61 @@
+#ifndef _SN65DSI83_BRG_H__
+#define _SN65DSI83_BRG_H__
+
+#include <linux/i2c.h>
+#include <linux/gpio/consumer.h>
+#include <video/videomode.h>
+
+struct sn65dsi83_brg;
+struct sn65dsi83_brg_funcs {
+    int (*power_on)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    void (*power_off)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    int (*reset)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    int (*setup)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    int (*start_stream)(struct sn65dsi83_brg *sn65dsi8383_brg);
+    void (*stop_stream)(struct sn65dsi83_brg *sn65dsi8383_brg);
+};
+
+struct sn65dsi83_brg {
+    struct i2c_client *client;
+    struct gpio_desc *gpio_enable;
+    struct gpio_desc *gpio_panel_enable;
+    /* Bridge Panel Parameters */
+    struct videomode vm;
+    u32 width_mm;
+    u32 height_mm;
+    u32 format;
+    u32 bpp;
+
+    u8 num_dsi_lanes;
+    u8 burst_mode;
+    u8 de_neg_polarity;
+    u8 num_channels;
+    struct sn65dsi83_brg_funcs *funcs;
+    u8 even_odd_swap;
+	u8 pixel_format;
+};
+struct sn65dsi83_brg *sn65dsi83_brg_get(void);
+
+#define I2C_DEVICE(A) &(A)->client->dev
+#define I2C_CLIENT(A) (A)->client
+#define VM(A) &(A)->vm
+#define BPP(A) (A)->bpp
+#define FORMAT(A) (A)->format
+#define DSI_LANES(A) (A)->num_dsi_lanes
+
+/* The caller has to have a vm structure defined */
+#define PIXCLK vm->pixelclock
+#define HACTIVE vm->hactive
+#define HFP vm->hfront_porch
+#define HBP vm->hback_porch
+#define HPW vm->hsync_len
+#define VACTIVE vm->vactive
+#define VFP vm->vfront_porch
+#define VBP vm->vback_porch
+#define VPW vm->vsync_len
+#define FLAGS vm->flags
+
+#define HIGH(A) (((A) >> 8) & 0xFF)
+#define LOW(A)  ((A)  & 0xFF)
+
+#endif /* _SN65DSI83_BRG_H__ */
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c
new file mode 100644
index 000000000000..25f5a3827f56
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c
@@ -0,0 +1,475 @@
+/*
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/slab.h>
+
+#include <linux/delay.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_print.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_crtc_helper.h>
+#include <video/mipi_display.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+
+#include "sn65dsi83_timing.h"
+#include "sn65dsi83_brg.h"
+
+#include <linux/backlight.h>
+
+
+struct sn65dsi83 {
+    u8 channel_id;
+    enum drm_connector_status status;
+    bool powered;
+    struct drm_display_mode curr_mode;
+    struct drm_bridge bridge;
+    struct drm_connector connector;
+    struct device_node *host_node;
+    struct mipi_dsi_device *dsi;
+    struct sn65dsi83_brg *brg;
+	struct backlight_device *backlight;
+	bool enabled;
+};
+
+static int sn65dsi83_attach_dsi(struct sn65dsi83 *sn65dsi83);
+#define DRM_DEVICE(A) A->dev->dev
+/* Connector funcs */
+static struct sn65dsi83 *connector_to_sn65dsi83(struct drm_connector *connector)
+{
+    return container_of(connector, struct sn65dsi83, connector);
+}
+
+static int sn65dsi83_connector_get_modes(struct drm_connector *connector)
+{
+    struct sn65dsi83 *sn65dsi83 = connector_to_sn65dsi83(connector);
+    struct sn65dsi83_brg *brg = sn65dsi83->brg;
+    struct device *dev = connector->dev->dev;
+    struct drm_display_mode *mode;
+    u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+    u32 *bus_flags = &connector->display_info.bus_flags;
+    int ret;
+
+    dev_dbg(dev, "%s\n",__func__);
+    mode = drm_mode_create(connector->dev);
+    if (!mode) {
+        DRM_DEV_ERROR(dev, "Failed to create display mode!\n");
+        return 0;
+    }
+
+    drm_display_mode_from_videomode(&brg->vm, mode);
+    mode->width_mm = brg->width_mm;
+    mode->height_mm = brg->height_mm;
+    mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+
+    drm_mode_probed_add(connector, mode);
+
+    connector->display_info.width_mm = mode->width_mm;
+    connector->display_info.height_mm = mode->height_mm;
+
+    if (brg->vm.flags & DISPLAY_FLAGS_DE_HIGH)
+        *bus_flags |= DRM_BUS_FLAG_DE_HIGH;
+    if (brg->vm.flags & DISPLAY_FLAGS_DE_LOW)
+        *bus_flags |= DRM_BUS_FLAG_DE_LOW;
+    if (brg->vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
+        *bus_flags |= DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;
+    if (brg->vm.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
+        *bus_flags |= DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
+
+    ret = drm_display_info_set_bus_formats(&connector->display_info,
+                           &bus_format, 1);
+    if (ret)
+        return ret;
+
+    return 1;
+}
+
+static enum drm_mode_status
+sn65dsi83_connector_mode_valid(struct drm_connector *connector,
+                 struct drm_display_mode *mode)
+{
+    struct sn65dsi83 *sn65dsi83 = connector_to_sn65dsi83(connector);
+    struct device *dev = connector->dev->dev;
+	if (mode->clock > ( sn65dsi83->brg->vm.pixelclock / 1000 ))
+		return MODE_CLOCK_HIGH;
+
+    dev_dbg(dev, "%s: mode: %d*%d@%d is valid\n",__func__,
+            mode->hdisplay,mode->vdisplay,mode->clock);
+    return MODE_OK;
+}
+
+static struct drm_connector_helper_funcs sn65dsi83_connector_helper_funcs = {
+    .get_modes = sn65dsi83_connector_get_modes,
+    .mode_valid = sn65dsi83_connector_mode_valid,
+};
+
+static enum drm_connector_status
+sn65dsi83_connector_detect(struct drm_connector *connector, bool force)
+{
+    struct sn65dsi83 *sn65dsi83 = connector_to_sn65dsi83(connector);
+    struct device *dev = connector->dev->dev;
+    enum drm_connector_status status;
+    dev_dbg(dev, "%s\n",__func__);
+
+    status = connector_status_connected;
+    sn65dsi83->status = status;
+    return status;
+}
+
+int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
+                        uint32_t maxX, uint32_t maxY);
+
+static struct drm_connector_funcs sn65dsi83_connector_funcs = {
+    .fill_modes = drm_helper_probe_single_connector_modes,
+    .detect = sn65dsi83_connector_detect,
+    .destroy = drm_connector_cleanup,
+    .reset = drm_atomic_helper_connector_reset,
+    .atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+    .atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+/* Bridge funcs */
+static struct sn65dsi83 *bridge_to_sn65dsi83(struct drm_bridge *bridge)
+{
+    return container_of(bridge, struct sn65dsi83, bridge);
+}
+
+static void sn65dsi83_bridge_enable(struct drm_bridge *bridge)
+{
+    struct sn65dsi83 *sn65dsi83 = bridge_to_sn65dsi83(bridge);
+    dev_dbg(DRM_DEVICE(bridge),"%s\n",__func__);
+    sn65dsi83->brg->funcs->setup(sn65dsi83->brg);
+    sn65dsi83->brg->funcs->start_stream(sn65dsi83->brg);
+	if (sn65dsi83->backlight) {
+		sn65dsi83->backlight->props.state &= ~BL_CORE_FBBLANK;
+        sn65dsi83->backlight->props.power = FB_BLANK_UNBLANK;
+        backlight_update_status(sn65dsi83->backlight);
+	}
+}
+
+static void sn65dsi83_bridge_disable(struct drm_bridge *bridge)
+{
+    struct sn65dsi83 *sn65dsi83 = bridge_to_sn65dsi83(bridge);
+    dev_dbg(DRM_DEVICE(bridge),"%s\n",__func__);
+	if (sn65dsi83->backlight) {
+		sn65dsi83->backlight->props.state &= ~FB_BLANK_POWERDOWN;
+        sn65dsi83->backlight->props.power = BL_CORE_FBBLANK;
+        backlight_update_status(sn65dsi83->backlight);
+	}
+    sn65dsi83->brg->funcs->stop_stream(sn65dsi83->brg);
+    sn65dsi83->brg->funcs->power_off(sn65dsi83->brg);
+}
+
+static void sn65dsi83_bridge_mode_set(struct drm_bridge *bridge,
+                    const struct drm_display_mode *mode,
+                    const struct drm_display_mode *adj_mode)
+{
+    struct sn65dsi83 *sn65dsi83 = bridge_to_sn65dsi83(bridge);
+    dev_dbg(DRM_DEVICE(bridge), "%s: mode: %d*%d@%d\n",__func__,
+            mode->hdisplay,mode->vdisplay,mode->clock);
+    drm_mode_copy(&sn65dsi83->curr_mode, adj_mode);
+}
+
+static int sn65dsi83_bridge_attach(struct drm_bridge *bridge,
+					enum drm_bridge_attach_flags flags)
+{
+    struct sn65dsi83 *sn65dsi83 = bridge_to_sn65dsi83(bridge);
+    int ret;
+
+    dev_dbg(DRM_DEVICE(bridge),"%s\n",__func__);
+    if (!bridge->encoder) {
+        DRM_ERROR("Parent encoder object not found");
+        return -ENODEV;
+    }
+
+	if (flags != DRM_BRIDGE_ATTACH_NO_CONNECTOR) {
+		sn65dsi83->connector.polled = DRM_CONNECTOR_POLL_CONNECT;
+
+		ret = drm_connector_init(bridge->dev, &sn65dsi83->connector,
+		             &sn65dsi83_connector_funcs,
+		             DRM_MODE_CONNECTOR_DSI);
+		if (ret) {
+		    DRM_ERROR("Failed to initialize connector with drm\n");
+		    return ret;
+		}
+		drm_connector_helper_add(&sn65dsi83->connector,
+		             &sn65dsi83_connector_helper_funcs);
+		drm_connector_attach_encoder(&sn65dsi83->connector, bridge->encoder);
+	}
+
+    ret = sn65dsi83_attach_dsi(sn65dsi83);
+
+    return ret;
+}
+
+static struct drm_bridge_funcs sn65dsi83_bridge_funcs = {
+    .enable = sn65dsi83_bridge_enable,
+    .disable = sn65dsi83_bridge_disable,
+    .mode_set = sn65dsi83_bridge_mode_set,
+    .attach = sn65dsi83_bridge_attach,
+};
+
+static int sn65dsi83_parse_dt(struct device_node *np,
+    struct sn65dsi83 *sn65dsi83)
+{
+    struct device *dev = &sn65dsi83->brg->client->dev;
+    u32 num_lanes = 2, bpp = 24, format = 2, width = 149, height = 93;
+    u32 num_channels;
+    u32 even_odd_swap;
+    u8 burst_mode = 0;
+    u8 de_neg_polarity = 0;
+    struct device_node *endpoint;
+
+    endpoint = of_graph_get_next_endpoint(np, NULL);
+    if (!endpoint)
+        return -ENODEV;
+
+    sn65dsi83->host_node = of_graph_get_remote_port_parent(endpoint);
+    if (!sn65dsi83->host_node) {
+        of_node_put(endpoint);
+        return -ENODEV;
+    }
+
+    of_property_read_u32(np, "ti,dsi-lanes", &num_lanes);
+    of_property_read_u32(np, "ti,lvds-format", &format);
+    of_property_read_u32(np, "ti,lvds-bpp", &bpp);
+    of_property_read_u32(np, "ti,width-mm", &width);
+    of_property_read_u32(np, "ti,height-mm", &height);
+    burst_mode = of_property_read_bool(np, "ti,burst-mode");
+    de_neg_polarity = of_property_read_bool(np, "ti,de-neg-polarity");
+
+    if (num_lanes < 1 || num_lanes > 4) {
+        dev_err(dev, "Invalid dsi-lanes: %d\n", num_lanes);
+        return -EINVAL;
+    }
+    if (of_property_read_u32(np, "ti,even-odd-swap", &even_odd_swap) < 0) {
+        dev_info(dev, "even_odd_swap property not found, using default\n");
+        even_odd_swap = 0;
+    }
+    sn65dsi83->brg->even_odd_swap = even_odd_swap;
+
+    if (of_property_read_u32(np, "ti,lvds-channels", &num_channels) < 0) {
+        dev_info(dev, "lvds-channels property not found, using default\n");
+        num_channels = 1;
+    } else {
+        if (num_channels < 1 || num_channels > 2 ) {
+            dev_err(dev, "lvds-channels must be 1 or 2, not %u", num_channels);
+            return -EINVAL;
+        }
+    }
+
+    sn65dsi83->brg->num_dsi_lanes = num_lanes;
+    sn65dsi83->brg->burst_mode = burst_mode;
+    sn65dsi83->brg->de_neg_polarity = de_neg_polarity;
+    sn65dsi83->brg->num_channels = num_channels;
+
+    sn65dsi83->brg->gpio_enable = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
+    if (IS_ERR(sn65dsi83->brg->gpio_enable)) {
+        dev_err(dev, "failed to parse enable gpio");
+        return PTR_ERR(sn65dsi83->brg->gpio_enable);
+    }
+
+    sn65dsi83->brg->gpio_panel_enable = devm_gpiod_get(dev, "enable-panel", GPIOD_OUT_LOW);
+    if (!IS_ERR(sn65dsi83->brg->gpio_panel_enable)) {
+        gpiod_set_value_cansleep(sn65dsi83->brg->gpio_panel_enable, 0);
+        msleep(200);
+    } else
+        dev_dbg(dev, "failed to parse enable panel gpio");
+
+    sn65dsi83->brg->format = format;
+    sn65dsi83->brg->bpp = bpp;
+
+    sn65dsi83->brg->width_mm = width;
+    sn65dsi83->brg->height_mm = height;
+
+    /* Read default timing if there is not device tree node for */
+    if ((of_get_videomode(np, &sn65dsi83->brg->vm, 0)) < 0)
+        videomode_from_timing(&panel_default_timing, &sn65dsi83->brg->vm);
+
+    of_node_put(endpoint);
+    of_node_put(sn65dsi83->host_node);
+
+    return 0;
+}
+
+static int sn65dsi83_probe(struct i2c_client *i2c,
+    const struct i2c_device_id *id)
+{
+    struct sn65dsi83 *sn65dsi83;
+    struct device *dev = &i2c->dev;
+	struct device_node *backlight;
+    int ret;
+
+    dev_dbg(dev,"%s\n",__func__);
+    if (!dev->of_node)
+        return -EINVAL;
+
+    sn65dsi83 = devm_kzalloc(dev, sizeof(*sn65dsi83), GFP_KERNEL);
+    if (!sn65dsi83)
+        return -ENOMEM;
+
+    /* Initialize it before DT parser */
+    sn65dsi83->brg = sn65dsi83_brg_get();
+    sn65dsi83->brg->client = i2c;
+
+    sn65dsi83->powered = false;
+    sn65dsi83->status = connector_status_disconnected;
+
+    i2c_set_clientdata(i2c, sn65dsi83);
+
+	
+	backlight = of_parse_phandle(dev->of_node, "backlight", 0);
+	if (backlight) {
+			sn65dsi83->backlight = of_find_backlight_by_node(backlight);
+			of_node_put(backlight);
+
+			if (!sn65dsi83->backlight)
+					return -EPROBE_DEFER;
+			
+	}
+
+    ret = sn65dsi83_parse_dt(dev->of_node, sn65dsi83);
+    if (ret)
+        return ret;
+
+    sn65dsi83->brg->funcs->power_off(sn65dsi83->brg);
+    sn65dsi83->brg->funcs->power_on(sn65dsi83->brg);
+    ret  = sn65dsi83->brg->funcs->reset(sn65dsi83->brg);
+    if (ret != 0x00) {
+        dev_err(dev, "Failed to reset the device");
+        return -ENODEV;
+    }
+    sn65dsi83->brg->funcs->power_off(sn65dsi83->brg);
+
+
+    sn65dsi83->bridge.funcs = &sn65dsi83_bridge_funcs;
+    sn65dsi83->bridge.of_node = dev->of_node;
+
+    drm_bridge_add(&sn65dsi83->bridge);
+
+    return 0;
+}
+
+static int sn65dsi83_attach_dsi(struct sn65dsi83 *sn65dsi83)
+{
+    struct device *dev = &sn65dsi83->brg->client->dev;
+    struct mipi_dsi_host *host;
+    struct mipi_dsi_device *dsi;
+    int ret = 0;
+    const struct mipi_dsi_device_info info = { .type = "sn65dsi83",
+                           .channel = 0,
+                           .node = NULL,
+                         };
+
+    dev_dbg(dev, "%s\n",__func__);
+    host = of_find_mipi_dsi_host_by_node(sn65dsi83->host_node);
+    if (!host) {
+        dev_err(dev, "failed to find dsi host\n");
+        return -EPROBE_DEFER;
+    }
+
+    dsi = mipi_dsi_device_register_full(host, &info);
+    if (IS_ERR(dsi)) {
+        dev_err(dev, "failed to create dsi device\n");
+        ret = PTR_ERR(dsi);
+        return -ENODEV;
+    }
+
+    sn65dsi83->dsi = dsi;
+
+	sn65dsi83->brg->pixel_format = MIPI_DSI_FMT_RGB888;
+    dsi->lanes = sn65dsi83->brg->num_dsi_lanes;
+    dsi->format = MIPI_DSI_FMT_RGB888;
+    dsi->mode_flags = MIPI_DSI_MODE_VIDEO;
+    if (sn65dsi83->brg->burst_mode)
+        dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_BURST;
+    else
+        dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+
+    ret = mipi_dsi_attach(dsi);
+    if (ret < 0) {
+        dev_err(dev, "failed to attach dsi to host\n");
+        mipi_dsi_device_unregister(dsi);
+    }
+
+    return ret;
+}
+
+static void sn65dsi83_detach_dsi(struct sn65dsi83 *sn65dsi83)
+{
+    struct device *dev = &sn65dsi83->brg->client->dev;
+    dev_dbg(dev, "%s\n",__func__);
+    mipi_dsi_detach(sn65dsi83->dsi);
+    mipi_dsi_device_unregister(sn65dsi83->dsi);
+}
+
+static int sn65dsi83_remove(struct i2c_client *i2c)
+{
+    struct sn65dsi83 *sn65dsi83 = i2c_get_clientdata(i2c);
+    struct device *dev = &sn65dsi83->brg->client->dev;
+    dev_dbg(dev, "%s\n",__func__);
+
+    sn65dsi83_detach_dsi(sn65dsi83);
+    drm_bridge_remove(&sn65dsi83->bridge);
+
+    return 0;
+}
+
+static const struct i2c_device_id sn65dsi83_i2c_ids[] = {
+    { "sn65dsi83", 0 },
+    { }
+};
+MODULE_DEVICE_TABLE(i2c, sn65dsi83_i2c_ids);
+
+static const struct of_device_id sn65dsi83_of_ids[] = {
+    { .compatible = "ti,sn65dsi83" },
+    { }
+};
+MODULE_DEVICE_TABLE(of, sn65dsi83_of_ids);
+
+static struct mipi_dsi_driver sn65dsi83_dsi_driver = {
+    .driver.name = "sn65dsi83",
+};
+
+static struct i2c_driver sn65dsi83_driver = {
+    .driver = {
+        .name = "sn65dsi83",
+        .of_match_table = sn65dsi83_of_ids,
+    },
+    .id_table = sn65dsi83_i2c_ids,
+    .probe = sn65dsi83_probe,
+    .remove = sn65dsi83_remove,
+};
+
+static int __init sn65dsi83_init(void)
+{
+    if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+        mipi_dsi_driver_register(&sn65dsi83_dsi_driver);
+
+    return i2c_add_driver(&sn65dsi83_driver);
+}
+module_init(sn65dsi83_init);
+
+static void __exit sn65dsi83_exit(void)
+{
+    i2c_del_driver(&sn65dsi83_driver);
+
+    if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+        mipi_dsi_driver_unregister(&sn65dsi83_dsi_driver);
+}
+module_exit(sn65dsi83_exit);
+
+MODULE_AUTHOR("CompuLab <compulab@compula.co.il>");
+MODULE_DESCRIPTION("SN65DSI bridge driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_timing.h b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_timing.h
new file mode 100644
index 000000000000..e9bb6633c376
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_timing.h
@@ -0,0 +1,33 @@
+#ifndef __SN65DSI83_TIMING_H__
+#define __SN65DSI83_TIMING_H__
+
+/* Default Video Parameters */
+#define PIXCLK_INIT 62500000
+
+#define HACTIVE_INIT 1280
+#define HPW_INIT 2
+#define HBP_INIT 6
+#define HFP_INIT 5
+
+#define VACTIVE_INIT 800
+#define VPW_INIT 1
+#define VBP_INIT 2
+#define VFP_INIT 3
+
+static const struct display_timing panel_default_timing = {
+    .pixelclock = { PIXCLK_INIT, PIXCLK_INIT, PIXCLK_INIT },
+    .hactive = { HACTIVE_INIT, HACTIVE_INIT, HACTIVE_INIT },
+    .hfront_porch = { HFP_INIT, HFP_INIT, HFP_INIT },
+    .hsync_len = { HPW_INIT, HPW_INIT, HPW_INIT },
+    .hback_porch = { HBP_INIT, HBP_INIT, HBP_INIT },
+    .vactive = { VACTIVE_INIT, VACTIVE_INIT, VACTIVE_INIT },
+    .vfront_porch = { VFP_INIT, VFP_INIT, VFP_INIT },
+    .vsync_len = { VPW_INIT, VPW_INIT, VPW_INIT },
+    .vback_porch = { VBP_INIT, VBP_INIT, VBP_INIT },
+    .flags = DISPLAY_FLAGS_HSYNC_LOW |
+         DISPLAY_FLAGS_VSYNC_LOW |
+         DISPLAY_FLAGS_DE_LOW |
+         DISPLAY_FLAGS_PIXDATA_NEGEDGE,
+};
+
+#endif /* __SN65DSI83_TIMING_H__ */
diff --git a/drivers/gpu/drm/bridge/ti-sn65dsi83.c b/drivers/gpu/drm/bridge/ti-sn65dsi83.c
new file mode 100755
index 000000000000..471df09a1c07
--- /dev/null
+++ b/drivers/gpu/drm/bridge/ti-sn65dsi83.c
@@ -0,0 +1,639 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * TI SN65DSI83,84,85 driver
+ *
+ * Currently supported:
+ * - SN65DSI83
+ *   = 1x Single-link DSI ~ 1x Single-link LVDS
+ *   - Supported
+ *   - Single-link LVDS mode tested
+ * - SN65DSI84
+ *   = 1x Single-link DSI ~ 2x Single-link or 1x Dual-link LVDS
+ *   - Supported
+ *   - Dual-link LVDS mode tested
+ *   - 2x Single-link LVDS mode unsupported
+ *     (should be easy to add by someone who has the HW)
+ * - SN65DSI85
+ *   = 2x Single-link or 1x Dual-link DSI ~ 2x Single-link or 1x Dual-link LVDS
+ *   - Unsupported
+ *     (should be easy to add by someone who has the HW)
+ *
+ * Copyright (C) 2021 Marek Vasut <marex@denx.de>
+ *
+ * Based on previous work of:
+ * Valentin Raevsky <valentin@compulab.co.il>
+ * Philippe Schenker <philippe.schenker@toradex.com>
+ */
+
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/regmap.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_of.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+
+/* ID registers */
+#define REG_ID(n)				(0x00 + (n))
+/* Reset and clock registers */
+#define REG_RC_RESET				0x09
+#define  REG_RC_RESET_SOFT_RESET		BIT(0)
+#define REG_RC_LVDS_PLL				0x0a
+#define  REG_RC_LVDS_PLL_PLL_EN_STAT		BIT(7)
+#define  REG_RC_LVDS_PLL_LVDS_CLK_RANGE(n)	(((n) & 0x7) << 1)
+#define  REG_RC_LVDS_PLL_HS_CLK_SRC_DPHY	BIT(0)
+#define REG_RC_DSI_CLK				0x0b
+#define  REG_RC_DSI_CLK_DSI_CLK_DIVIDER(n)	(((n) & 0x1f) << 3)
+#define  REG_RC_DSI_CLK_REFCLK_MULTIPLIER(n)	((n) & 0x3)
+#define REG_RC_PLL_EN				0x0d
+#define  REG_RC_PLL_EN_PLL_EN			BIT(0)
+/* DSI registers */
+#define REG_DSI_LANE				0x10
+#define  REG_DSI_LANE_LVDS_LINK_CFG_DUAL	BIT(5) /* dual or 2x single */
+#define  REG_DSI_LANE_CHA_DSI_LANES(n)		(((n) & 0x3) << 3)
+#define  REG_DSI_LANE_CHB_DSI_LANES(n)		(((n) & 0x3) << 1)
+#define  REG_DSI_LANE_SOT_ERR_TOL_DIS		BIT(0)
+#define REG_DSI_EQ				0x11
+#define  REG_DSI_EQ_CHA_DSI_DATA_EQ(n)		(((n) & 0x3) << 6)
+#define  REG_DSI_EQ_CHA_DSI_CLK_EQ(n)		(((n) & 0x3) << 2)
+#define REG_DSI_CLK				0x12
+#define  REG_DSI_CLK_CHA_DSI_CLK_RANGE(n)	((n) & 0xff)
+/* LVDS registers */
+#define REG_LVDS_FMT				0x18
+#define  REG_LVDS_FMT_DE_NEG_POLARITY		BIT(7)
+#define  REG_LVDS_FMT_HS_NEG_POLARITY		BIT(6)
+#define  REG_LVDS_FMT_VS_NEG_POLARITY		BIT(5)
+#define  REG_LVDS_FMT_LVDS_LINK_CFG		BIT(4)	/* 0:AB 1:A-only */
+#define  REG_LVDS_FMT_CHA_24BPP_MODE		BIT(3)
+#define  REG_LVDS_FMT_CHB_24BPP_MODE		BIT(2)
+#define  REG_LVDS_FMT_CHA_24BPP_FORMAT1		BIT(1)
+#define  REG_LVDS_FMT_CHB_24BPP_FORMAT1		BIT(0)
+#define REG_LVDS_VCOM				0x19
+#define  REG_LVDS_VCOM_CHA_LVDS_VOCM		BIT(6)
+#define  REG_LVDS_VCOM_CHB_LVDS_VOCM		BIT(4)
+#define  REG_LVDS_VCOM_CHA_LVDS_VOD_SWING(n)	(((n) & 0x3) << 2)
+#define  REG_LVDS_VCOM_CHB_LVDS_VOD_SWING(n)	((n) & 0x3)
+#define REG_LVDS_LANE				0x1a
+#define  REG_LVDS_LANE_EVEN_ODD_SWAP		BIT(6)
+#define  REG_LVDS_LANE_CHA_REVERSE_LVDS		BIT(5)
+#define  REG_LVDS_LANE_CHB_REVERSE_LVDS		BIT(4)
+#define  REG_LVDS_LANE_CHA_LVDS_TERM		BIT(1)
+#define  REG_LVDS_LANE_CHB_LVDS_TERM		BIT(0)
+#define REG_LVDS_CM				0x1b
+#define  REG_LVDS_CM_CHA_LVDS_CM_ADJUST(n)	(((n) & 0x3) << 4)
+#define  REG_LVDS_CM_CHB_LVDS_CM_ADJUST(n)	((n) & 0x3)
+/* Video registers */
+#define REG_VID_CHA_ACTIVE_LINE_LENGTH_LOW	0x20
+#define REG_VID_CHA_ACTIVE_LINE_LENGTH_HIGH	0x21
+#define REG_VID_CHA_VERTICAL_DISPLAY_SIZE_LOW	0x24
+#define REG_VID_CHA_VERTICAL_DISPLAY_SIZE_HIGH	0x25
+#define REG_VID_CHA_SYNC_DELAY_LOW		0x28
+#define REG_VID_CHA_SYNC_DELAY_HIGH		0x29
+#define REG_VID_CHA_HSYNC_PULSE_WIDTH_LOW	0x2c
+#define REG_VID_CHA_HSYNC_PULSE_WIDTH_HIGH	0x2d
+#define REG_VID_CHA_VSYNC_PULSE_WIDTH_LOW	0x30
+#define REG_VID_CHA_VSYNC_PULSE_WIDTH_HIGH	0x31
+#define REG_VID_CHA_HORIZONTAL_BACK_PORCH	0x34
+#define REG_VID_CHA_VERTICAL_BACK_PORCH		0x36
+#define REG_VID_CHA_HORIZONTAL_FRONT_PORCH	0x38
+#define REG_VID_CHA_VERTICAL_FRONT_PORCH	0x3a
+#define REG_VID_CHA_TEST_PATTERN		0x3c
+/* IRQ registers */
+#define REG_IRQ_GLOBAL				0xe0
+#define  REG_IRQ_GLOBAL_IRQ_EN			BIT(0)
+#define REG_IRQ_EN				0xe1
+#define  REG_IRQ_EN_CHA_SYNCH_ERR_EN		BIT(7)
+#define  REG_IRQ_EN_CHA_CRC_ERR_EN		BIT(6)
+#define  REG_IRQ_EN_CHA_UNC_ECC_ERR_EN		BIT(5)
+#define  REG_IRQ_EN_CHA_COR_ECC_ERR_EN		BIT(4)
+#define  REG_IRQ_EN_CHA_LLP_ERR_EN		BIT(3)
+#define  REG_IRQ_EN_CHA_SOT_BIT_ERR_EN		BIT(2)
+#define  REG_IRQ_EN_CHA_PLL_UNLOCK_EN		BIT(0)
+#define REG_IRQ_STAT				0xe5
+#define  REG_IRQ_STAT_CHA_SYNCH_ERR		BIT(7)
+#define  REG_IRQ_STAT_CHA_CRC_ERR		BIT(6)
+#define  REG_IRQ_STAT_CHA_UNC_ECC_ERR		BIT(5)
+#define  REG_IRQ_STAT_CHA_COR_ECC_ERR		BIT(4)
+#define  REG_IRQ_STAT_CHA_LLP_ERR		BIT(3)
+#define  REG_IRQ_STAT_CHA_SOT_BIT_ERR		BIT(2)
+#define  REG_IRQ_STAT_CHA_PLL_UNLOCK		BIT(0)
+
+enum sn65dsi83_model {
+	MODEL_SN65DSI83,
+	MODEL_SN65DSI84,
+};
+
+struct sn65dsi83 {
+	struct drm_bridge		bridge;
+	struct drm_display_mode		mode;
+	struct device			*dev;
+	struct regmap			*regmap;
+	struct device_node		*host_node;
+	struct mipi_dsi_device		*dsi;
+	struct drm_bridge		*panel_bridge;
+	struct gpio_desc		*enable_gpio;
+	int				dsi_lanes;
+	bool				lvds_dual_link;
+	bool				lvds_dual_link_even_odd_swap;
+};
+
+static const struct regmap_range sn65dsi83_readable_ranges[] = {
+	regmap_reg_range(REG_ID(0), REG_ID(8)),
+	regmap_reg_range(REG_RC_LVDS_PLL, REG_RC_DSI_CLK),
+	regmap_reg_range(REG_RC_PLL_EN, REG_RC_PLL_EN),
+	regmap_reg_range(REG_DSI_LANE, REG_DSI_CLK),
+	regmap_reg_range(REG_LVDS_FMT, REG_LVDS_CM),
+	regmap_reg_range(REG_VID_CHA_ACTIVE_LINE_LENGTH_LOW,
+			 REG_VID_CHA_ACTIVE_LINE_LENGTH_HIGH),
+	regmap_reg_range(REG_VID_CHA_VERTICAL_DISPLAY_SIZE_LOW,
+			 REG_VID_CHA_VERTICAL_DISPLAY_SIZE_HIGH),
+	regmap_reg_range(REG_VID_CHA_SYNC_DELAY_LOW,
+			 REG_VID_CHA_SYNC_DELAY_HIGH),
+	regmap_reg_range(REG_VID_CHA_HSYNC_PULSE_WIDTH_LOW,
+			 REG_VID_CHA_HSYNC_PULSE_WIDTH_HIGH),
+	regmap_reg_range(REG_VID_CHA_VSYNC_PULSE_WIDTH_LOW,
+			 REG_VID_CHA_VSYNC_PULSE_WIDTH_HIGH),
+	regmap_reg_range(REG_VID_CHA_HORIZONTAL_BACK_PORCH,
+			 REG_VID_CHA_HORIZONTAL_BACK_PORCH),
+	regmap_reg_range(REG_VID_CHA_VERTICAL_BACK_PORCH,
+			 REG_VID_CHA_VERTICAL_BACK_PORCH),
+	regmap_reg_range(REG_VID_CHA_HORIZONTAL_FRONT_PORCH,
+			 REG_VID_CHA_HORIZONTAL_FRONT_PORCH),
+	regmap_reg_range(REG_VID_CHA_VERTICAL_FRONT_PORCH,
+			 REG_VID_CHA_VERTICAL_FRONT_PORCH),
+	regmap_reg_range(REG_VID_CHA_TEST_PATTERN, REG_VID_CHA_TEST_PATTERN),
+	regmap_reg_range(REG_IRQ_GLOBAL, REG_IRQ_EN),
+	regmap_reg_range(REG_IRQ_STAT, REG_IRQ_STAT),
+};
+
+static const struct regmap_access_table sn65dsi83_readable_table = {
+	.yes_ranges = sn65dsi83_readable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sn65dsi83_readable_ranges),
+};
+
+static const struct regmap_range sn65dsi83_writeable_ranges[] = {
+	regmap_reg_range(REG_RC_RESET, REG_RC_DSI_CLK),
+	regmap_reg_range(REG_RC_PLL_EN, REG_RC_PLL_EN),
+	regmap_reg_range(REG_DSI_LANE, REG_DSI_CLK),
+	regmap_reg_range(REG_LVDS_FMT, REG_LVDS_CM),
+	regmap_reg_range(REG_VID_CHA_ACTIVE_LINE_LENGTH_LOW,
+			 REG_VID_CHA_ACTIVE_LINE_LENGTH_HIGH),
+	regmap_reg_range(REG_VID_CHA_VERTICAL_DISPLAY_SIZE_LOW,
+			 REG_VID_CHA_VERTICAL_DISPLAY_SIZE_HIGH),
+	regmap_reg_range(REG_VID_CHA_SYNC_DELAY_LOW,
+			 REG_VID_CHA_SYNC_DELAY_HIGH),
+	regmap_reg_range(REG_VID_CHA_HSYNC_PULSE_WIDTH_LOW,
+			 REG_VID_CHA_HSYNC_PULSE_WIDTH_HIGH),
+	regmap_reg_range(REG_VID_CHA_VSYNC_PULSE_WIDTH_LOW,
+			 REG_VID_CHA_VSYNC_PULSE_WIDTH_HIGH),
+	regmap_reg_range(REG_VID_CHA_HORIZONTAL_BACK_PORCH,
+			 REG_VID_CHA_HORIZONTAL_BACK_PORCH),
+	regmap_reg_range(REG_VID_CHA_VERTICAL_BACK_PORCH,
+			 REG_VID_CHA_VERTICAL_BACK_PORCH),
+	regmap_reg_range(REG_VID_CHA_HORIZONTAL_FRONT_PORCH,
+			 REG_VID_CHA_HORIZONTAL_FRONT_PORCH),
+	regmap_reg_range(REG_VID_CHA_VERTICAL_FRONT_PORCH,
+			 REG_VID_CHA_VERTICAL_FRONT_PORCH),
+	regmap_reg_range(REG_VID_CHA_TEST_PATTERN, REG_VID_CHA_TEST_PATTERN),
+	regmap_reg_range(REG_IRQ_GLOBAL, REG_IRQ_EN),
+	regmap_reg_range(REG_IRQ_STAT, REG_IRQ_STAT),
+};
+
+static const struct regmap_access_table sn65dsi83_writeable_table = {
+	.yes_ranges = sn65dsi83_writeable_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sn65dsi83_writeable_ranges),
+};
+
+static const struct regmap_range sn65dsi83_volatile_ranges[] = {
+	regmap_reg_range(REG_RC_RESET, REG_RC_RESET),
+	regmap_reg_range(REG_RC_LVDS_PLL, REG_RC_LVDS_PLL),
+	regmap_reg_range(REG_IRQ_STAT, REG_IRQ_STAT),
+};
+
+static const struct regmap_access_table sn65dsi83_volatile_table = {
+	.yes_ranges = sn65dsi83_volatile_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sn65dsi83_volatile_ranges),
+};
+
+static const struct regmap_config sn65dsi83_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.rd_table = &sn65dsi83_readable_table,
+	.wr_table = &sn65dsi83_writeable_table,
+	.volatile_table = &sn65dsi83_volatile_table,
+	.cache_type = REGCACHE_RBTREE,
+	.max_register = REG_IRQ_STAT,
+};
+
+static struct sn65dsi83 *bridge_to_sn65dsi83(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct sn65dsi83, bridge);
+}
+
+static int sn65dsi83_attach(struct drm_bridge *bridge,
+			    enum drm_bridge_attach_flags flags)
+{
+	struct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);
+	struct device *dev = ctx->dev;
+	struct mipi_dsi_device *dsi;
+	struct mipi_dsi_host *host;
+	int ret = 0;
+
+	const struct mipi_dsi_device_info info = {
+		.type = "sn65dsi83",
+		.channel = 0,
+		.node = NULL,
+	};
+
+	host = of_find_mipi_dsi_host_by_node(ctx->host_node);
+	if (!host) {
+		dev_err(dev, "failed to find dsi host\n");
+		return -EPROBE_DEFER;
+	}
+
+	dsi = mipi_dsi_device_register_full(host, &info);
+	if (IS_ERR(dsi)) {
+		return dev_err_probe(dev, PTR_ERR(dsi),
+				     "failed to create dsi device\n");
+	}
+
+	ctx->dsi = dsi;
+
+	dsi->lanes = ctx->dsi_lanes;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "failed to attach dsi to host\n");
+		goto err_dsi_attach;
+	}
+
+	return drm_bridge_attach(bridge->encoder, ctx->panel_bridge,
+				 &ctx->bridge, flags);
+
+err_dsi_attach:
+	mipi_dsi_device_unregister(dsi);
+	return ret;
+}
+
+static void sn65dsi83_pre_enable(struct drm_bridge *bridge)
+{
+	struct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);
+
+	/*
+	 * Reset the chip, pull EN line low for t_reset=10ms,
+	 * then high for t_en=1ms.
+	 */
+	regcache_mark_dirty(ctx->regmap);
+	gpiod_set_value(ctx->enable_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value(ctx->enable_gpio, 1);
+	usleep_range(1000, 1100);
+}
+
+static u8 sn65dsi83_get_lvds_range(struct sn65dsi83 *ctx)
+{
+	/*
+	 * The encoding of the LVDS_CLK_RANGE is as follows:
+	 * 000 - 25 MHz <= LVDS_CLK < 37.5 MHz
+	 * 001 - 37.5 MHz <= LVDS_CLK < 62.5 MHz
+	 * 010 - 62.5 MHz <= LVDS_CLK < 87.5 MHz
+	 * 011 - 87.5 MHz <= LVDS_CLK < 112.5 MHz
+	 * 100 - 112.5 MHz <= LVDS_CLK < 137.5 MHz
+	 * 101 - 137.5 MHz <= LVDS_CLK <= 154 MHz
+	 * which is a range of 12.5MHz..162.5MHz in 50MHz steps, except that
+	 * the ends of the ranges are clamped to the supported range. Since
+	 * sn65dsi83_mode_valid() already filters the valid modes and limits
+	 * the clock to 25..154 MHz, the range calculation can be simplified
+	 * as follows:
+	 */
+	int mode_clock = ctx->mode.clock;
+
+	if (ctx->lvds_dual_link)
+		mode_clock /= 2;
+
+	return (mode_clock - 12500) / 25000;
+}
+
+static u8 sn65dsi83_get_dsi_range(struct sn65dsi83 *ctx)
+{
+	/*
+	 * The encoding of the CHA_DSI_CLK_RANGE is as follows:
+	 * 0x00 through 0x07 - Reserved
+	 * 0x08 - 40 <= DSI_CLK < 45 MHz
+	 * 0x09 - 45 <= DSI_CLK < 50 MHz
+	 * ...
+	 * 0x63 - 495 <= DSI_CLK < 500 MHz
+	 * 0x64 - 500 MHz
+	 * 0x65 through 0xFF - Reserved
+	 * which is DSI clock in 5 MHz steps, clamped to 40..500 MHz.
+	 * The DSI clock are calculated as:
+	 *  DSI_CLK = mode clock * bpp / dsi_data_lanes / 2
+	 * the 2 is there because the bus is DDR.
+	 */
+	return DIV_ROUND_UP(clamp((unsigned int)ctx->mode.clock *
+			    mipi_dsi_pixel_format_to_bpp(ctx->dsi->format) /
+			    ctx->dsi_lanes / 2, 40000U, 500000U), 5000U);
+}
+
+static u8 sn65dsi83_get_dsi_div(struct sn65dsi83 *ctx)
+{
+	/* The divider is (DSI_CLK / LVDS_CLK) - 1, which really is: */
+	unsigned int dsi_div = mipi_dsi_pixel_format_to_bpp(ctx->dsi->format);
+
+	dsi_div /= ctx->dsi_lanes;
+
+	if (!ctx->lvds_dual_link)
+		dsi_div /= 2;
+
+	return dsi_div - 1;
+}
+
+static void sn65dsi83_enable(struct drm_bridge *bridge)
+{
+	struct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);
+	unsigned int pval;
+	u16 val;
+	int ret;
+
+	/* Clear reset, disable PLL */
+	regmap_write(ctx->regmap, REG_RC_RESET, 0x00);
+	regmap_write(ctx->regmap, REG_RC_PLL_EN, 0x00);
+
+	/* Reference clock derived from DSI link clock. */
+	regmap_write(ctx->regmap, REG_RC_LVDS_PLL,
+		REG_RC_LVDS_PLL_LVDS_CLK_RANGE(sn65dsi83_get_lvds_range(ctx)) |
+		REG_RC_LVDS_PLL_HS_CLK_SRC_DPHY);
+	regmap_write(ctx->regmap, REG_DSI_CLK,
+		REG_DSI_CLK_CHA_DSI_CLK_RANGE(sn65dsi83_get_dsi_range(ctx)));
+	regmap_write(ctx->regmap, REG_RC_DSI_CLK,
+		REG_RC_DSI_CLK_DSI_CLK_DIVIDER(sn65dsi83_get_dsi_div(ctx)));
+
+	/* Set number of DSI lanes and LVDS link config. */
+	regmap_write(ctx->regmap, REG_DSI_LANE,
+		REG_DSI_LANE_LVDS_LINK_CFG_DUAL |
+		REG_DSI_LANE_CHA_DSI_LANES(~(ctx->dsi_lanes - 1)) |
+		/* CHB is DSI85-only, set to default on DSI83/DSI84 */
+		REG_DSI_LANE_CHB_DSI_LANES(3));
+	/* No equalization. */
+	regmap_write(ctx->regmap, REG_DSI_EQ, 0x00);
+
+	/* RGB888 is the only format supported so far. */
+	val = (ctx->mode.flags & DRM_MODE_FLAG_NHSYNC ?
+	       REG_LVDS_FMT_HS_NEG_POLARITY : 0) |
+	      (ctx->mode.flags & DRM_MODE_FLAG_NVSYNC ?
+	       REG_LVDS_FMT_VS_NEG_POLARITY : 0) |
+	      REG_LVDS_FMT_CHA_24BPP_MODE;
+	if (ctx->lvds_dual_link)
+		val |= REG_LVDS_FMT_CHB_24BPP_MODE;
+	else
+		val |= REG_LVDS_FMT_LVDS_LINK_CFG;
+
+	regmap_write(ctx->regmap, REG_LVDS_FMT, val);
+	regmap_write(ctx->regmap, REG_LVDS_VCOM, 0x05);
+	regmap_write(ctx->regmap, REG_LVDS_LANE,
+		(ctx->lvds_dual_link_even_odd_swap ?
+		 REG_LVDS_LANE_EVEN_ODD_SWAP : 0) |
+		REG_LVDS_LANE_CHA_LVDS_TERM |
+		REG_LVDS_LANE_CHB_LVDS_TERM);
+	regmap_write(ctx->regmap, REG_LVDS_CM, 0x00);
+
+	regmap_bulk_write(ctx->regmap, REG_VID_CHA_ACTIVE_LINE_LENGTH_LOW,
+			  &ctx->mode.hdisplay, 2);
+	regmap_bulk_write(ctx->regmap, REG_VID_CHA_VERTICAL_DISPLAY_SIZE_LOW,
+			  &ctx->mode.vdisplay, 2);
+	val = 32 + 1;	/* 32 + 1 pixel clock to ensure proper operation */
+	regmap_bulk_write(ctx->regmap, REG_VID_CHA_SYNC_DELAY_LOW, &val, 2);
+	val = ctx->mode.hsync_end - ctx->mode.hsync_start;
+	regmap_bulk_write(ctx->regmap, REG_VID_CHA_HSYNC_PULSE_WIDTH_LOW,
+			  &val, 2);
+	val = ctx->mode.vsync_end - ctx->mode.vsync_start;
+	regmap_bulk_write(ctx->regmap, REG_VID_CHA_VSYNC_PULSE_WIDTH_LOW,
+			  &val, 2);
+	regmap_write(ctx->regmap, REG_VID_CHA_HORIZONTAL_BACK_PORCH,
+		     ctx->mode.htotal - ctx->mode.hsync_end);
+	regmap_write(ctx->regmap, REG_VID_CHA_VERTICAL_BACK_PORCH,
+		     ctx->mode.vtotal - ctx->mode.vsync_end);
+	regmap_write(ctx->regmap, REG_VID_CHA_HORIZONTAL_FRONT_PORCH,
+		     ctx->mode.hsync_start - ctx->mode.hdisplay);
+	regmap_write(ctx->regmap, REG_VID_CHA_VERTICAL_FRONT_PORCH,
+		     ctx->mode.vsync_start - ctx->mode.vdisplay);
+	regmap_write(ctx->regmap, REG_VID_CHA_TEST_PATTERN, 0x00);
+
+	/* Enable PLL */
+	regmap_write(ctx->regmap, REG_RC_PLL_EN, REG_RC_PLL_EN_PLL_EN);
+	usleep_range(3000, 4000);
+	ret = regmap_read_poll_timeout(ctx->regmap, REG_RC_LVDS_PLL, pval,
+					pval & REG_RC_LVDS_PLL_PLL_EN_STAT,
+					1000, 100000);
+	if (ret) {
+		dev_err(ctx->dev, "failed to lock PLL, ret=%i\n", ret);
+		/* On failure, disable PLL again and exit. */
+		regmap_write(ctx->regmap, REG_RC_PLL_EN, 0x00);
+		return;
+	}
+
+	/* Trigger reset after CSR register update. */
+	regmap_write(ctx->regmap, REG_RC_RESET, REG_RC_RESET_SOFT_RESET);
+
+	/* Clear all errors that got asserted during initialization. */
+	regmap_read(ctx->regmap, REG_IRQ_STAT, &pval);
+	regmap_write(ctx->regmap, REG_IRQ_STAT, pval);
+}
+
+static void sn65dsi83_disable(struct drm_bridge *bridge)
+{
+	struct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);
+
+	/* Clear reset, disable PLL */
+	regmap_write(ctx->regmap, REG_RC_RESET, 0x00);
+	regmap_write(ctx->regmap, REG_RC_PLL_EN, 0x00);
+}
+
+static void sn65dsi83_post_disable(struct drm_bridge *bridge)
+{
+	struct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);
+
+	/* Put the chip in reset, pull EN line low. */
+	gpiod_set_value(ctx->enable_gpio, 0);
+}
+
+static enum drm_mode_status
+sn65dsi83_mode_valid(struct drm_bridge *bridge,
+		     const struct drm_display_info *info,
+		     const struct drm_display_mode *mode)
+{
+	/* LVDS output clock range 25..154 MHz */
+	if (mode->clock < 25000)
+		return MODE_CLOCK_LOW;
+	if (mode->clock > 154000)
+		return MODE_CLOCK_HIGH;
+
+	return MODE_OK;
+}
+
+static void sn65dsi83_mode_set(struct drm_bridge *bridge,
+			       const struct drm_display_mode *mode,
+			       const struct drm_display_mode *adj)
+{
+	struct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);
+
+	ctx->mode = *adj;
+}
+
+static const struct drm_bridge_funcs sn65dsi83_funcs = {
+	.attach		= sn65dsi83_attach,
+	.pre_enable	= sn65dsi83_pre_enable,
+	.enable		= sn65dsi83_enable,
+	.disable	= sn65dsi83_disable,
+	.post_disable	= sn65dsi83_post_disable,
+	.mode_valid	= sn65dsi83_mode_valid,
+	.mode_set	= sn65dsi83_mode_set,
+};
+
+static int sn65dsi83_parse_dt(struct sn65dsi83 *ctx, enum sn65dsi83_model model)
+{
+	struct drm_bridge *panel_bridge;
+	struct device *dev = ctx->dev;
+	struct device_node *endpoint;
+	struct drm_panel *panel;
+	int ret;
+
+	endpoint = of_graph_get_endpoint_by_regs(dev->of_node, 0, 0);
+	ctx->dsi_lanes = of_property_count_u32_elems(endpoint, "data-lanes");
+	ctx->host_node = of_graph_get_remote_port_parent(endpoint);
+	of_node_put(endpoint);
+
+	if (ctx->dsi_lanes < 0 || ctx->dsi_lanes > 4)
+		return -EINVAL;
+	if (!ctx->host_node)
+		return -ENODEV;
+
+	ctx->lvds_dual_link = false;
+	ctx->lvds_dual_link_even_odd_swap = false;
+	if (model != MODEL_SN65DSI83) {
+		struct device_node *port2, *port3;
+		int dual_link;
+
+		port2 = of_graph_get_port_by_id(dev->of_node, 2);
+		port3 = of_graph_get_port_by_id(dev->of_node, 3);
+		dual_link = drm_of_lvds_get_dual_link_pixel_order(port2, port3);
+		of_node_put(port2);
+		of_node_put(port3);
+
+		if (dual_link == DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS) {
+			ctx->lvds_dual_link = true;
+			/* Odd pixels to LVDS Channel A, even pixels to B */
+			ctx->lvds_dual_link_even_odd_swap = false;
+		} else if (dual_link == DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS) {
+			ctx->lvds_dual_link = true;
+			/* Even pixels to LVDS Channel A, odd pixels to B */
+			ctx->lvds_dual_link_even_odd_swap = true;
+		}
+	}
+
+	ret = drm_of_find_panel_or_bridge(dev->of_node, 2, 0, &panel, &panel_bridge);
+	if (ret < 0)
+		return ret;
+	if (panel) {
+		panel_bridge = devm_drm_panel_bridge_add(dev, panel);
+		if (IS_ERR(panel_bridge))
+			return PTR_ERR(panel_bridge);
+	}
+
+	ctx->panel_bridge = panel_bridge;
+
+	return 0;
+}
+
+static int sn65dsi83_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	enum sn65dsi83_model model;
+	struct sn65dsi83 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->dev = dev;
+
+	if (dev->of_node)
+		model = (enum sn65dsi83_model)of_device_get_match_data(dev);
+	else
+		model = id->driver_data;
+
+	ctx->enable_gpio = devm_gpiod_get(ctx->dev, "enable", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->enable_gpio))
+		return PTR_ERR(ctx->enable_gpio);
+
+	ret = sn65dsi83_parse_dt(ctx, model);
+	if (ret)
+		return ret;
+
+	ctx->regmap = devm_regmap_init_i2c(client, &sn65dsi83_regmap_config);
+	if (IS_ERR(ctx->regmap))
+		return PTR_ERR(ctx->regmap);
+
+	dev_set_drvdata(dev, ctx);
+	i2c_set_clientdata(client, ctx);
+
+	ctx->bridge.funcs = &sn65dsi83_funcs;
+	ctx->bridge.of_node = dev->of_node;
+	drm_bridge_add(&ctx->bridge);
+
+	return 0;
+}
+
+static int sn65dsi83_remove(struct i2c_client *client)
+{
+	struct sn65dsi83 *ctx = i2c_get_clientdata(client);
+
+	mipi_dsi_detach(ctx->dsi);
+	mipi_dsi_device_unregister(ctx->dsi);
+	drm_bridge_remove(&ctx->bridge);
+	of_node_put(ctx->host_node);
+
+	return 0;
+}
+
+static struct i2c_device_id sn65dsi83_id[] = {
+	{ "ti,sn65dsi83", MODEL_SN65DSI83 },
+	{ "ti,sn65dsi84", MODEL_SN65DSI84 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, sn65dsi83_id);
+
+static const struct of_device_id sn65dsi83_match_table[] = {
+	{ .compatible = "ti,sn65dsi83", .data = (void *)MODEL_SN65DSI83 },
+	{ .compatible = "ti,sn65dsi84", .data = (void *)MODEL_SN65DSI84 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sn65dsi83_match_table);
+
+static struct i2c_driver sn65dsi83_driver = {
+	.probe = sn65dsi83_probe,
+	.remove = sn65dsi83_remove,
+	.id_table = sn65dsi83_id,
+	.driver = {
+		.name = "sn65dsi83",
+		.of_match_table = sn65dsi83_match_table,
+	},
+};
+module_i2c_driver(sn65dsi83_driver);
+
+MODULE_AUTHOR("Marek Vasut <marex@denx.de>");
+MODULE_DESCRIPTION("TI SN65DSI83 DSI to LVDS bridge driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 436013189166..590440d91c05 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -285,6 +285,15 @@ config DRM_PANEL_RAYDIUM_RM67191
 	  Say Y here if you want to enable support for Raydium RM67191 FHD
 	  (1080x1920) DSI panel.
 
+config DRM_PANEL_AUO_B101UAN1V7
+	tristate "AUO B101UAN1v7 WUXGA 16:10 TFT-LCD 1920x1200 DSI video mode panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for AUO B101UAN1v7 WUXGA (1920x1200)
+	  DSI panel.
+
 config DRM_PANEL_RAYDIUM_RM68200
 	tristate "Raydium RM68200 720x1280 DSI video mode panel"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 3be941e15fd5..1749b7effbe1 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -54,3 +54,4 @@ obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
 obj-$(CONFIG_DRM_PANEL_WKS_101WX001) += panel-wks-101wx001.o
+obj-$(CONFIG_DRM_PANEL_AUO_B101UAN1V7) += panel-b101uan01.o
diff --git a/drivers/gpu/drm/panel/panel-b101uan01.c b/drivers/gpu/drm/panel/panel-b101uan01.c
new file mode 100755
index 000000000000..532b8818019e
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-b101uan01.c
@@ -0,0 +1,345 @@
+/*
+ * i.MX drm driver - B101UAN01 MIPI-DSI panel driver
+ *
+ * Copyright (C) 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <drm/drm_vblank.h>
+#include <drm/drm_print.h>
+#include <drm/drm_crtc.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_device.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+
+#include <video/display_timing.h>
+#include <video/of_display_timing.h>
+
+#include <linux/backlight.h>
+
+static const u32 b101uan01_bus_formats[] = {
+	MEDIA_BUS_FMT_RGB888_1X24,
+	MEDIA_BUS_FMT_RGB666_1X18,
+	MEDIA_BUS_FMT_RGB565_1X16,
+};
+
+struct b101uan01_panel {
+	struct drm_panel base;
+	struct mipi_dsi_device *dsi;
+
+	bool prepared;
+	bool enabled;
+	struct backlight_device *backlight;
+
+	struct videomode vm;
+	u32 width_mm;
+	u32 height_mm;
+	struct gpio_desc *enable_gpio;
+};
+
+static inline struct b101uan01_panel *to_b101uan01_panel(struct drm_panel *panel)
+{
+	return container_of(panel, struct b101uan01_panel, base);
+}
+
+static int b101uan01_panel_prepare(struct drm_panel *panel)
+{
+	struct b101uan01_panel *b101uan01 = to_b101uan01_panel(panel);
+
+	if (b101uan01->prepared) {
+		return 0;
+	}
+	gpiod_set_value_cansleep(b101uan01->enable_gpio, 1);
+	b101uan01->prepared = true;
+
+	return 0;
+}
+
+static int b101uan01_panel_unprepare(struct drm_panel *panel)
+{
+	struct b101uan01_panel *b101uan01 = to_b101uan01_panel(panel);
+
+	if (!b101uan01->prepared) {
+		return 0;
+	}
+
+	if (b101uan01->enabled) {
+		return -EPERM;
+	}
+
+	gpiod_set_value_cansleep(b101uan01->enable_gpio, 0);
+	b101uan01->prepared = false;
+
+	return 0;
+}
+
+static int b101uan01_panel_enable(struct drm_panel *panel)
+{
+	struct b101uan01_panel *b101uan01 = to_b101uan01_panel(panel);
+    struct mipi_dsi_device *dsi = b101uan01->dsi;
+
+	if (b101uan01->enabled) {
+		return 0;
+	}
+
+	if (!b101uan01->prepared) {
+		return -EPERM;
+	}
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	if (b101uan01->backlight) {
+		b101uan01->backlight->props.state &= ~BL_CORE_FBBLANK;
+		b101uan01->backlight->props.power = FB_BLANK_UNBLANK;
+		backlight_update_status(b101uan01->backlight);
+	}
+
+	b101uan01->enabled = true;
+
+	return 0;
+}
+
+static int b101uan01_panel_disable(struct drm_panel *panel)
+{
+	struct b101uan01_panel *b101uan01 = to_b101uan01_panel(panel);
+    struct mipi_dsi_device *dsi = b101uan01->dsi;
+
+	if (!b101uan01->enabled) {
+		return 0;
+	};
+
+	if (b101uan01->backlight) {
+		b101uan01->backlight->props.power = FB_BLANK_POWERDOWN;
+		b101uan01->backlight->props.state |= BL_CORE_FBBLANK;
+		backlight_update_status(b101uan01->backlight);
+	}
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	b101uan01->enabled = false;
+	return 0;
+}
+
+static int b101uan01_panel_get_modes(struct drm_panel *panel, struct drm_connector *connector)
+{
+	struct b101uan01_panel *b101uan01 = to_b101uan01_panel(panel);
+	struct device *dev = &b101uan01->dsi->dev;
+	struct drm_display_mode *mode;
+	u32 *bus_flags = &connector->display_info.bus_flags;
+	int ret;
+
+	mode = drm_mode_create(connector->dev);
+	if (!mode) {
+		DRM_DEV_ERROR(dev, "Failed to create display mode!\n");
+		return 0;
+	}
+
+	drm_display_mode_from_videomode(&b101uan01->vm, mode);
+	mode->width_mm = b101uan01->width_mm;
+	mode->height_mm = b101uan01->height_mm;
+	connector->display_info.width_mm = b101uan01->width_mm;
+	connector->display_info.height_mm = b101uan01->height_mm;
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+
+	if (b101uan01->vm.flags & DISPLAY_FLAGS_DE_HIGH)
+		*bus_flags |= DRM_BUS_FLAG_DE_HIGH;
+	if (b101uan01->vm.flags & DISPLAY_FLAGS_DE_LOW)
+		*bus_flags |= DRM_BUS_FLAG_DE_LOW;
+	if (b101uan01->vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
+		*bus_flags |= DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE;
+	if (b101uan01->vm.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
+		*bus_flags |= DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE;
+
+	ret = drm_display_info_set_bus_formats(&connector->display_info,
+			b101uan01_bus_formats, ARRAY_SIZE(b101uan01_bus_formats));
+	if (ret)
+		return ret;
+
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs b101uan01_panel_funcs = {
+	.prepare = b101uan01_panel_prepare,
+	.unprepare = b101uan01_panel_unprepare,
+	.enable = b101uan01_panel_enable,
+	.disable = b101uan01_panel_disable,
+	.get_modes = b101uan01_panel_get_modes,
+};
+
+static int b101uan01_panel_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *timings;
+	struct b101uan01_panel *panel;
+	struct device_node *backlight;
+	int ret;
+	u32 video_mode;
+
+	panel = devm_kzalloc(&dsi->dev, sizeof(*panel), GFP_KERNEL);
+	if (!panel)
+		return -ENOMEM;
+
+	mipi_dsi_set_drvdata(dsi, panel);
+
+	panel->dsi = dsi;
+
+	dsi->format = MIPI_DSI_FMT_RGB888;
+
+    dsi->mode_flags = MIPI_DSI_MODE_VIDEO_HSE
+		            | MIPI_DSI_MODE_VIDEO
+		            | MIPI_DSI_MODE_VIDEO_SYNC_PULSE
+		            | MIPI_DSI_MODE_EOT_PACKET
+		            | MIPI_DSI_MODE_LPM;
+
+/*	dsi->mode_flags =  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO |
+			   MIPI_DSI_CLOCK_NON_CONTINUOUS;*/
+
+	ret = of_property_read_u32(np, "video-mode", &video_mode);
+	if (!ret) {
+		switch (video_mode) {
+		case 0:
+			/* burst mode */
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_BURST;
+			break;
+		case 1:
+			/* non-burst mode with sync event */
+			break;
+		case 2:
+			/* non-burst mode with sync pulse */
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+			break;
+		default:
+			dev_warn(dev, "invalid video mode %d\n", video_mode);
+			break;
+
+		}
+	}
+
+	ret = of_property_read_u32(np, "dsi-lanes", &dsi->lanes);
+	if (ret < 0) {
+		dev_err(dev, "Failed to get dsi-lanes property (%d)\n", ret);
+
+		return ret;
+	}
+
+	/*
+	 * 'display-timings' is optional, so verify if the node is present
+	 * before calling of_get_videomode so we won't get console error
+	 * messages
+	 */
+	timings = of_get_child_by_name(np, "display-timings");
+	if (timings) {
+		of_node_put(timings);
+		ret = of_get_videomode(np, &panel->vm, 0);
+	}
+
+	if (ret < 0)
+		return ret;
+
+
+	of_property_read_u32(np, "panel-width-mm", &panel->width_mm);
+	of_property_read_u32(np, "panel-height-mm", &panel->height_mm);
+
+	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable",
+						     GPIOD_OUT_LOW);
+	if (IS_ERR(panel->enable_gpio)) {
+		ret = PTR_ERR(panel->enable_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "failed to request GPIO: %d\n", ret);
+		return ret;
+	}
+
+	backlight = of_parse_phandle(dev->of_node, "backlight", 0);
+	if (backlight) {
+		panel->backlight = of_find_backlight_by_node(backlight);
+		of_node_put(backlight);
+
+		if (!panel->backlight)
+			return -EPROBE_DEFER;
+	}
+
+
+	drm_panel_init(&panel->base, dev, &b101uan01_panel_funcs, DRM_MODE_CONNECTOR_DSI);
+	panel->base.funcs = &b101uan01_panel_funcs;
+	panel->base.dev = dev;
+
+	drm_panel_add(&panel->base);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&panel->base);
+	}
+
+	return ret;
+}
+
+static int b101uan01_panel_remove(struct mipi_dsi_device *dsi)
+{
+	struct b101uan01_panel *b101uan01 = mipi_dsi_get_drvdata(dsi);
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		DRM_DEV_ERROR(dev, "Failed to detach from host (%d)\n",
+			ret);
+
+
+	if (b101uan01->backlight)
+		put_device(&b101uan01->backlight->dev);
+
+	if (b101uan01->base.dev)
+		drm_panel_remove(&b101uan01->base);
+
+	return 0;
+}
+
+static void b101uan01_panel_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct b101uan01_panel *b101uan01 = mipi_dsi_get_drvdata(dsi);
+
+	b101uan01_panel_disable(&b101uan01->base);
+	b101uan01_panel_unprepare(&b101uan01->base);
+}
+
+static const struct of_device_id dsi_of_match[] = {
+	{ .compatible = "auo,b101uan01v7", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, dsi_of_match);
+
+static struct mipi_dsi_driver b101uan01_panel_driver = {
+	.driver = {
+		.name = "panel-b101uan01",
+		.of_match_table = dsi_of_match,
+	},
+	.probe = b101uan01_panel_probe,
+	.remove = b101uan01_panel_remove,
+	.shutdown = b101uan01_panel_shutdown,
+};
+module_mipi_dsi_driver(b101uan01_panel_driver);
+
+MODULE_AUTHOR("NXP Semiconductor");
+MODULE_DESCRIPTION("B101UAN01");
+MODULE_LICENSE("GPL v2");
-- 
2.25.1

