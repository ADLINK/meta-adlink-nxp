From 75741c1bf1e761b05a49d4185a737bd3d44e146f Mon Sep 17 00:00:00 2001
From: Dinesh kumar <dineshkumar.varadarajan@adlinktech.com>
Date: Tue, 7 May 2019 21:33:06 +0530
Subject: [PATCH 5/7] Add-can-interface-in-ecspi2 This patch adds CAN interface
 in ecspi2 node, driver changes for CAN controller(MCP2515) and spi.

---
 arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts |  58 +-
 arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi      |  30 +-
 drivers/net/can/spi/mcp251x.c                   |  85 ++-
 drivers/spi/Kconfig                             |  90 +--
 drivers/spi/spi-imx.c                           | 703 ++++++------------------
 include/linux/err.h                             |  15 +
 6 files changed, 325 insertions(+), 656 deletions(-)

diff --git a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
index 0fb3480..bd7be2a 100644
--- a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
+++ b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
@@ -21,6 +21,14 @@
 	model = "Adlink LEC iMX8M";
 	compatible = "adlink,lec-imx8m", "fsl,imx8mq";
 
+	clocks {
+		clk20M: can_clock {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <20000000>;
+		};
+	};
+
 	chosen {
 		bootargs = "console=ttymxc0,115200 earlycon=ec_imx6q,0x30860000,115200";
 		stdout-path = &uart1;
@@ -211,6 +219,14 @@
 			>;
 		};
 
+		pinctrl_mcp251x: mcp251xgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI1_RXC_GPIO4_IO1		0x56	//K1 ,U23[11],CAN0_INT-L
+				MX8MQ_IOMUXC_NAND_RE_B_GPIO3_IO15	0x56	//K19,U23[10],CAN0_RX0BF
+				MX8MQ_IOMUXC_NAND_DATA05_GPIO3_IO11	0x56	//J22,U23[ 9],CAN0_RX1BF
+			>;
+		};
+
 		pinctrl_pcie0: pcie0grp {
 			fsl,pins = <
 			>;
@@ -228,18 +244,6 @@
 			>;
 		};
 
-		pinctrl_qspi: qspigrp {
-			fsl,pins = <
-				MX8MQ_IOMUXC_NAND_ALE_QSPI_A_SCLK	0x82
-				MX8MQ_IOMUXC_NAND_CE0_B_QSPI_A_SS0_B	0x82
-				MX8MQ_IOMUXC_NAND_DATA00_QSPI_A_DATA0	0x82
-				MX8MQ_IOMUXC_NAND_DATA01_QSPI_A_DATA1	0x82
-				MX8MQ_IOMUXC_NAND_DATA02_QSPI_A_DATA2	0x82
-				MX8MQ_IOMUXC_NAND_DATA03_QSPI_A_DATA3	0x82
-
-			>;
-		};
-
 		pinctrl_uart1: uart1grp {
 			fsl,pins = <
 				MX8MQ_IOMUXC_UART1_RXD_UART1_DCE_RX		0x49
@@ -367,6 +371,15 @@
 			>;
 		};
 
+		pinctrl_ecspi2: ecspi2grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_ECSPI2_SCLK_ECSPI2_SCLK 0x11
+				MX8MQ_IOMUXC_ECSPI2_MOSI_ECSPI2_MOSI 0x11
+				MX8MQ_IOMUXC_ECSPI2_MISO_ECSPI2_MISO 0x11
+				MX8MQ_IOMUXC_ECSPI2_SS0_ECSPI2_SS0  0x11
+			>;
+		};
+
 		pinctrl_sai5: sai5grp {
 			fsl,pins = <
 				MX8MQ_IOMUXC_SAI5_MCLK_SAI5_MCLK	0xd6
@@ -663,18 +676,23 @@
 	status = "okay";
 };
 
-&qspi {
+&ecspi2 {
+	//fsl,spi-num-chipselects = <1>;
+	//cs-gpios = <&gpio5 13 GPIO_ACTIVE_LOW>;
+	//pinctrl-0 = <&pinctrl_ecspi2_1 >;
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_qspi>;
+	pinctrl-0 = <&pinctrl_ecspi2>;
 	status = "okay";
 
-	flash0: n25q256a@0 {
+	can0: can@0 {
+		compatible = "microchip,mcp2515";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_mcp251x>;
 		reg = <0>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "micron,n25q256a";
-		spi-max-frequency = <29000000>;
-		spi-nor,ddr-quad-read-dummy = <6>;
+		clocks = <&clk20M>;
+		spi-max-frequency = <10000000>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <1 IRQ_TYPE_EDGE_FALLING>;		
 	};
 };
 
diff --git a/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi b/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
index f4dcf7a..7885d25 100755
--- a/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
+++ b/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
@@ -35,9 +35,6 @@
 		serial1 = &uart2;
 		serial2 = &uart3;
 		serial3 = &uart4;
-		spi0 = &ecspi1;
-		spi1 = &ecspi2;
-		spi2 = &ecspi3;
 		mmc0 = &usdhc1;
 		mmc1 = &usdhc2;
 		gpio0 = &gpio1;
@@ -47,6 +44,7 @@
 		gpio4 = &gpio5;
 		dsi_phy0 = &mipi_dsi_phy;
 		mipi_dsi0 = &mipi_dsi;
+		spi2 = &ecspi2;
 	};
 
 	cpus {
@@ -791,22 +789,10 @@
 		status = "disabled";
 	};
 
-	ecspi1: ecspi@30820000 {
-		#address-cells = <1>;
-		#size-cells = <0>;
-		compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi";
-		reg = <0x0 0x30820000 0x0 0x10000>;
-		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
-		clocks = <&clk IMX8MQ_CLK_ECSPI1_ROOT>,
-			 <&clk IMX8MQ_CLK_ECSPI1_ROOT>;
-		clock-names = "ipg", "per";
-		status = "disabled";
-	};
-
 	ecspi2: ecspi@30830000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
-		compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi";
+		compatible = "fsl,imx6ul-ecspi", "fsl,imx51-ecspi";
 		reg = <0x0 0x30830000 0x0 0x10000>;
 		interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&clk IMX8MQ_CLK_ECSPI2_ROOT>,
@@ -815,18 +801,6 @@
 		status = "disabled";
 	};
 
-	ecspi3: ecspi@30840000 {
-		#address-cells = <1>;
-		#size-cells = <0>;
-		compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi";
-		reg = <0x0 0x30840000 0x0 0x10000>;
-		interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
-		clocks = <&clk IMX8MQ_CLK_ECSPI3_ROOT>,
-			 <&clk IMX8MQ_CLK_ECSPI3_ROOT>;
-		clock-names = "ipg", "per";
-		status = "disabled";
-	};
-
 	uart1: serial@30860000 {
 		compatible = "fsl,imx8mq-uart",
 			     "fsl,imx6q-uart", "fsl,imx21-uart";
diff --git a/drivers/net/can/spi/mcp251x.c b/drivers/net/can/spi/mcp251x.c
index f3f05fe..f2e0632 100644
--- a/drivers/net/can/spi/mcp251x.c
+++ b/drivers/net/can/spi/mcp251x.c
@@ -54,6 +54,12 @@
  *
  */
 
+//#define ADLINK_DEBUG
+
+#ifdef ADLINK_DEBUG
+static int DebugFlag=1;
+#endif
+
 #include <linux/can/core.h>
 #include <linux/can/dev.h>
 #include <linux/can/led.h>
@@ -317,14 +323,46 @@ static int mcp251x_spi_trans(struct spi_device *spi, int len)
 		.rx_buf = priv->spi_rx_buf,
 		.len = len,
 		.cs_change = 0,
+		.delay_usecs = 0,//ky_add: store the padding bytes;
 	};
 	struct spi_message m;
-	int ret;
+	int i,ret;
+
+	//ky_add: re-arrange tx buffer...
+	if(!len) return 0;
+	else if(len<4) {
+		t.bits_per_word=len*8;
+		if(3==len) {//24 bits, : Refer iMX8 10.1.7.2 ECSPIx_TXDATA, should shift the contain;
+			for(i=3;0<i;--i) priv->spi_tx_buf[i]=priv->spi_tx_buf[i-1];
+			priv->spi_tx_buf[0]=0xAD;//No meaning; ADlink;
+			t.len=4;//Real length is 3, but we must set t.len=4 to pass checked by __spi_validate()@spi.c
+		}
+	}
+	else {
+		t.bits_per_word=32;
+		i=len%4;//Check size;
+		if(i) {//we muts append dummy data to fit u32 alignment;
+			int dummy=4-i;
+			int j,NewEnd=len+dummy-1;
+			//Shift contains, dummy should on first DWORD, and on MSB(Left) side; see 10.1.7.2 ECSPIx_TXDATA;
+			for(j=len-1;0<=j;--j,--NewEnd) {
+				priv->spi_tx_buf[NewEnd]=priv->spi_tx_buf[j];
+			}
+			for(j=0;j<dummy;++j) priv->spi_tx_buf[j]=0xAD;
+			t.delay_usecs=dummy;//ky_add: Special setting for size check; The side effect will happen if user set this value on range 1~3;
+			t.len+=dummy;
+		}
+	}
+
+#ifdef ADLINK_DEBUG
+if(DebugFlag)
+am_((PDD "%s(0x%08X,%2d); t->len=%d\n",__func__,*(int *)priv->spi_tx_buf,len,t.len));
+#endif
 
 	spi_message_init(&m);
 
 	if (mcp251x_enable_dma) {
-		t.tx_dma = priv->spi_tx_dma;
+efl_	t.tx_dma = priv->spi_tx_dma;
 		t.rx_dma = priv->spi_rx_dma;
 		m.is_dma_mapped = 1;
 	}
@@ -334,6 +372,13 @@ static int mcp251x_spi_trans(struct spi_device *spi, int len)
 	ret = spi_sync(spi, &m);
 	if (ret)
 		dev_err(&spi->dev, "spi transfer failed: ret = %d\n", ret);
+
+	//ky_add: re-arrange rx buffer...
+	if(3==len) {
+		for(i=0;i<3;++i) priv->spi_rx_buf[i]=priv->spi_rx_buf[i+1];
+	}
+
+
 	return ret;
 }
 
@@ -346,8 +391,14 @@ static u8 mcp251x_read_reg(struct spi_device *spi, uint8_t reg)
 	priv->spi_tx_buf[1] = reg;
 
 	mcp251x_spi_trans(spi, 3);
-	val = priv->spi_rx_buf[2];
 
+//ky_test;
+//am_((PDD "spi_rx[0-7]= 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
+//priv->spi_rx_buf[0],priv->spi_rx_buf[1],priv->spi_rx_buf[2],priv->spi_rx_buf[3],
+//priv->spi_rx_buf[4],priv->spi_rx_buf[5],priv->spi_rx_buf[6],priv->spi_rx_buf[7]));
+
+	val = priv->spi_rx_buf[2];
+am_((PDD "Read Reg %02Xh = 0x%02X\n",reg,val));
 	return val;
 }
 
@@ -363,6 +414,7 @@ static void mcp251x_read_2regs(struct spi_device *spi, uint8_t reg,
 
 	*v1 = priv->spi_rx_buf[2];
 	*v2 = priv->spi_rx_buf[3];
+am_((PDD "Read Reg %02Xh = 0x%02X, 0x%02X\n",reg,*v1,*v2));
 }
 
 static void mcp251x_write_reg(struct spi_device *spi, u8 reg, uint8_t val)
@@ -453,7 +505,7 @@ static void mcp251x_hw_rx_frame(struct spi_device *spi, u8 *buf,
 			buf[i] = mcp251x_read_reg(spi, RXBCTRL(buf_idx) + i);
 	} else {
 		priv->spi_tx_buf[RXBCTRL_OFF] = INSTRUCTION_READ_RXB(buf_idx);
-		mcp251x_spi_trans(spi, SPI_TRANSFER_BUF_LEN);
+		mcp251x_spi_trans(spi, SPI_TRANSFER_BUF_LEN + 2);
 		memcpy(buf, priv->spi_rx_buf, SPI_TRANSFER_BUF_LEN);
 	}
 }
@@ -806,6 +858,9 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
 	struct spi_device *spi = priv->spi;
 	struct net_device *net = priv->net;
 
+am_((PDD "%s(irq=%d): \n",__func__,irq));
+//@@ mcp251x_can_ist(irq=163):
+
 	mutex_lock(&priv->mcp_lock);
 	while (!priv->force_quit) {
 		enum can_state new_state;
@@ -928,6 +983,13 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
 		}
 
 	}
+
+#ifdef ADLINK_DEBUG
+	DebugFlag=0;
+	mcp251x_read_2regs(spi, TEC,(char *)&irq+0,(char *)&irq+1);
+	mcp251x_read_reg(spi, TXBCTRL(0));
+	DebugFlag=1;
+#endif
 	mutex_unlock(&priv->mcp_lock);
 	return IRQ_HANDLED;
 }
@@ -941,7 +1003,7 @@ static int mcp251x_open(struct net_device *net)
 
 	ret = open_candev(net);
 	if (ret) {
-		dev_err(&spi->dev, "unable to set initial baudrate!\n");
+efl_	dev_err(&spi->dev, "unable to set initial baudrate!\n");
 		return ret;
 	}
 
@@ -955,11 +1017,12 @@ static int mcp251x_open(struct net_device *net)
 	ret = request_threaded_irq(spi->irq, NULL, mcp251x_can_ist,
 				   flags | IRQF_ONESHOT, DEVICE_NAME, priv);
 	if (ret) {
-		dev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);
+efl_	dev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);
 		mcp251x_power_enable(priv->transceiver, 0);
 		close_candev(net);
 		goto open_unlock;
 	}
+am_((PDD "%s(irq=%d)\n",__func__,spi->irq));//@@ mcp251x_open(irq=163)
 
 	priv->wq = alloc_workqueue("mcp251x_wq", WQ_FREEZABLE | WQ_MEM_RECLAIM,
 				   0);
@@ -968,17 +1031,17 @@ static int mcp251x_open(struct net_device *net)
 
 	ret = mcp251x_hw_reset(spi);
 	if (ret) {
-		mcp251x_open_clean(net);
+efl_	mcp251x_open_clean(net);
 		goto open_unlock;
 	}
 	ret = mcp251x_setup(net, priv, spi);
 	if (ret) {
-		mcp251x_open_clean(net);
+efl_	mcp251x_open_clean(net);
 		goto open_unlock;
 	}
 	ret = mcp251x_set_normal_mode(spi);
 	if (ret) {
-		mcp251x_open_clean(net);
+efl_	mcp251x_open_clean(net);
 		goto open_unlock;
 	}
 
@@ -1127,13 +1190,13 @@ static int mcp251x_can_probe(struct spi_device *spi)
 
 	/* Allocate non-DMA buffers */
 	if (!mcp251x_enable_dma) {
-		priv->spi_tx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,
+		priv->spi_tx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN + 4,
 						GFP_KERNEL);
 		if (!priv->spi_tx_buf) {
 			ret = -ENOMEM;
 			goto error_probe;
 		}
-		priv->spi_rx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,
+		priv->spi_rx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN + 4,
 						GFP_KERNEL);
 		if (!priv->spi_rx_buf) {
 			ret = -ENOMEM;
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index f06e271..c51dd7a 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -55,6 +55,7 @@ comment "SPI Master Controller Drivers"
 
 config SPI_ALTERA
 	tristate "Altera SPI Controller"
+	select SPI_BITBANG
 	help
 	  This is the driver for the Altera SPI Controller.
 
@@ -66,13 +67,6 @@ config SPI_ATH79
 	  This enables support for the SPI controller present on the
 	  Atheros AR71XX/AR724X/AR913X SoCs.
 
-config SPI_ARMADA_3700
-	tristate "Marvell Armada 3700 SPI Controller"
-	depends on (ARCH_MVEBU && OF) || COMPILE_TEST
-	help
-	  This enables support for the SPI controller present on the
-	  Marvell Armada 3700 SoCs.
-
 config SPI_ATMEL
 	tristate "Atmel SPI Controller"
 	depends on HAS_DMA
@@ -161,8 +155,8 @@ config SPI_BCM63XX_HSSPI
 
 config SPI_BCM_QSPI
 	tristate "Broadcom BSPI and MSPI controller support"
-	depends on ARCH_BRCMSTB || ARCH_BCM || ARCH_BCM_IPROC || \
-			BMIPS_GENERIC || COMPILE_TEST
+	depends on ARCH_BRCMSTB || ARCH_BCM || ARCH_BCM_IPROC || COMPILE_TEST
+	depends on MTD_NORFLASH
 	default ARCH_BCM_IPROC
 	help
 	  Enables support for the Broadcom SPI flash and MSPI controller.
@@ -263,7 +257,7 @@ config SPI_EP93XX
 	  mode.
 
 config SPI_FALCON
-	bool "Falcon SPI controller support"
+	tristate "Falcon SPI controller support"
 	depends on SOC_FALCON
 	help
 	  The external bus unit (EBU) found on the FALC-ON SoC has SPI
@@ -271,12 +265,6 @@ config SPI_FALCON
 	  has only been tested with m25p80 type chips. The hardware has no
 	  support for other types of SPI peripherals.
 
-config SPI_FSL_LPSPI
-	tristate "Freescale i.MX LPSPI controller"
-	depends on ARCH_MXC || ARCH_MXC_ARM64 || COMPILE_TEST
-	help
-	  This enables Freescale i.MX LPSPI controllers in master mode.
-
 config SPI_GPIO
 	tristate "GPIO-based bitbanging SPI Master"
 	depends on GPIOLIB || COMPILE_TEST
@@ -302,7 +290,7 @@ config SPI_IMG_SPFI
 
 config SPI_IMX
 	tristate "Freescale i.MX SPI controllers"
-	depends on ARCH_MXC || ARCH_MXC_ARM64 || COMPILE_TEST
+	depends on ARCH_MXC || COMPILE_TEST || ARCH_MXC_ARM64
 	select SPI_BITBANG
 	help
 	  This enables using the Freescale i.MX SPI controllers in master
@@ -378,7 +366,6 @@ config SPI_FSL_SPI
 config SPI_FSL_DSPI
 	tristate "Freescale DSPI controller"
 	select REGMAP_MMIO
-	depends on HAS_DMA
 	depends on SOC_VF610 || SOC_LS1021A || ARCH_LAYERSCAPE || COMPILE_TEST
 	help
 	  This enables support for the Freescale DSPI controller in master
@@ -387,17 +374,18 @@ config SPI_FSL_DSPI
 config SPI_FSL_ESPI
 	tristate "Freescale eSPI controller"
 	depends on FSL_SOC
+	select SPI_FSL_LIB
 	help
 	  This enables using the Freescale eSPI controllers in master mode.
 	  From MPC8536, 85xx platform uses the controller, and all P10xx,
 	  P20xx, P30xx,P40xx, P50xx uses this controller.
 
-config SPI_MESON_SPICC
-	tristate "Amlogic Meson SPICC controller"
-	depends on ARCH_MESON || COMPILE_TEST
+config SPI_FSL_LPSPI
+	tristate "Freescale i.MX LPSPI controller"
+	depends on ARCH_MXC || ARCH_MXC_ARM64 || COMPILE_TEST
+	select SPI_BITBANG
 	help
-	  This enables master mode support for the SPICC (SPI communication
-	  controller) available in Amlogic Meson SoCs.
+	  This enables Freescale i.MX LPSPI controllers in master mode.
 
 config SPI_MESON_SPIFC
 	tristate "Amlogic Meson SPIFC controller"
@@ -423,14 +411,6 @@ config SPI_NUC900
 	help
 	  SPI driver for Nuvoton NUC900 series ARM SoCs
 
-config SPI_LANTIQ_SSC
-	tristate "Lantiq SSC SPI controller"
-	depends on LANTIQ || COMPILE_TEST
-	help
-	  This driver supports the Lantiq SSC SPI controller in master
-	  mode. This controller is found on Intel (former Lantiq) SoCs like
-	  the Danube, Falcon, xRX200, xRX300.
-
 config SPI_OC_TINY
 	tristate "OpenCores tiny SPI"
 	depends on GPIOLIB || COMPILE_TEST
@@ -463,7 +443,6 @@ config SPI_OMAP24XX
 
 config SPI_TI_QSPI
 	tristate "DRA7xxx QSPI controller support"
-	depends on HAS_DMA
 	depends on ARCH_OMAP2PLUS || COMPILE_TEST
 	help
 	  QSPI master controller for DRA7xxx used for flash devices.
@@ -480,8 +459,7 @@ config SPI_ORION
 	tristate "Orion SPI master"
 	depends on PLAT_ORION || ARCH_MVEBU || COMPILE_TEST
 	help
-	  This enables using the SPI master controller on the Orion
-	  and MVEBU chips.
+	  This enables using the SPI master controller on the Orion chips.
 
 config SPI_PIC32
 	tristate "Microchip PIC32 series SPI"
@@ -517,8 +495,8 @@ config SPI_PPC4xx
 
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
-	depends on (ARCH_PXA || ARCH_MMP || PCI || ACPI)
-	select PXA_SSP if ARCH_PXA || ARCH_MMP
+	depends on (ARCH_PXA || PCI || ACPI)
+	select PXA_SSP if ARCH_PXA
 	help
 	  This enables using a PXA2xx or Sodaville SSP port as a SPI master
 	  controller. The driver can be configured to use any SSP port and
@@ -583,7 +561,7 @@ config SPI_S3C24XX_FIQ
 
 config SPI_S3C64XX
 	tristate "Samsung S3C64XX series type SPI"
-	depends on (PLAT_SAMSUNG || ARCH_EXYNOS || COMPILE_TEST)
+	depends on (PLAT_SAMSUNG || ARCH_EXYNOS)
 	help
 	  SPI driver for Samsung S3C64XX and newer SoCs.
 
@@ -626,16 +604,6 @@ config SPI_SIRF
 	help
 	  SPI driver for CSR SiRFprimaII SoCs
 
-config SPI_STM32
-	tristate "STMicroelectronics STM32 SPI controller"
-	depends on ARCH_STM32 || COMPILE_TEST
-	help
-	  SPI driver for STMicroelectonics STM32 SoCs.
-
-	  STM32 SPI controller supports DMA and PIO modes. When DMA
-	  is not available, the driver automatically falls back to
-	  PIO mode.
-
 config SPI_ST_SSC4
 	tristate "STMicroelectronics SPI SSC-based driver"
 	depends on ARCH_STI || COMPILE_TEST
@@ -732,7 +700,7 @@ config SPI_XILINX
 
 config SPI_XLP
 	tristate "Netlogic XLP SPI controller driver"
-	depends on CPU_XLP || ARCH_THUNDER2 || COMPILE_TEST
+	depends on CPU_XLP || ARCH_VULCAN || COMPILE_TEST
 	help
 	  Enable support for the SPI controller on the Netlogic XLP SoCs.
 	  Currently supported XLP variants are XLP8XX, XLP3XX, XLP2XX, XLP9XX
@@ -801,30 +769,6 @@ config SPI_TLE62X0
 
 endif # SPI_MASTER
 
-#
-# SLAVE side ... listening to other SPI masters
-#
-
-config SPI_SLAVE
-	bool "SPI slave protocol handlers"
-	help
-	  If your system has a slave-capable SPI controller, you can enable
-	  slave protocol handlers.
-
-if SPI_SLAVE
-
-config SPI_SLAVE_TIME
-	tristate "SPI slave handler reporting boot up time"
-	help
-	  SPI slave handler responding with the time of reception of the last
-	  SPI message.
-
-config SPI_SLAVE_SYSTEM_CONTROL
-	tristate "SPI slave handler controlling system state"
-	help
-	  SPI slave handler to allow remote control of system reboot, power
-	  off, halt, and suspend.
-
-endif # SPI_SLAVE
+# (slave support would go here)
 
 endif # SPI
diff --git a/drivers/spi/spi-imx.c b/drivers/spi/spi-imx.c
index 9c39025..a90f6a4 100644
--- a/drivers/spi/spi-imx.c
+++ b/drivers/spi/spi-imx.c
@@ -18,12 +18,16 @@
  * Boston, MA  02110-1301, USA.
  */
 
+#define ADLINK_ENABLE_BURST_LENGTH//Refer ECSPIx_CONREG[31:20] ;
+
+//#define ADLINK_DEBUG//ky_add: see linux/err.h
+#include <linux/err.h>
+
 #include <linux/clk.h>
 #include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
-#include <linux/err.h>
 #include <linux/gpio.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
@@ -42,6 +46,7 @@
 #include <linux/platform_data/dma-imx.h>
 #include <linux/platform_data/spi-imx.h>
 
+
 #define DRIVER_NAME "spi_imx"
 
 #define MXC_CSPIRXDATA		0x00
@@ -53,13 +58,13 @@
 /* generic defines to abstract from the different register layouts */
 #define MXC_INT_RR	(1 << 0) /* Receive data ready interrupt */
 #define MXC_INT_TE	(1 << 1) /* Transmit FIFO empty interrupt */
-#define MXC_INT_RDR	BIT(4) /* Receive date threshold interrupt */
 
 /* The maximum  bytes that a sdma BD can transfer.*/
 #define MAX_SDMA_BD_BYTES  (1 << 15)
-#define MX51_ECSPI_CTRL_MAX_BURST	512
-/* The maximum bytes that IMX53_ECSPI can transfer in slave mode.*/
-#define MX53_MAX_TRANSFER_BYTES		512
+struct spi_imx_config {
+	unsigned int speed_hz;
+	unsigned int bpw;
+};
 
 enum spi_imx_devtype {
 	IMX1_CSPI,
@@ -67,8 +72,7 @@ enum spi_imx_devtype {
 	IMX27_CSPI,
 	IMX31_CSPI,
 	IMX35_CSPI,	/* CSPI on all i.mx except above */
-	IMX51_ECSPI,	/* ECSPI on i.mx51 */
-	IMX53_ECSPI,	/* ECSPI on i.mx53 and later */
+	IMX51_ECSPI,	/* ECSPI on i.mx51 and later */
 	IMX6UL_ECSPI,
 };
 
@@ -76,16 +80,10 @@ enum spi_imx_devtype {
 
 struct spi_imx_devtype_data {
 	void (*intctrl)(struct spi_imx_data *, int);
-	int (*config)(struct spi_device *);
+	int (*config)(struct spi_device *, struct spi_imx_config *);
 	void (*trigger)(struct spi_imx_data *);
 	int (*rx_available)(struct spi_imx_data *);
 	void (*reset)(struct spi_imx_data *);
-	void (*setup_wml)(struct spi_imx_data *);
-	void (*disable)(struct spi_imx_data *);
-	bool has_dmamode;
-	bool has_slavemode;
-	unsigned int fifo_size;
-	bool dynamic_burst;
 	enum spi_imx_devtype devtype;
 };
 
@@ -102,23 +100,14 @@ struct spi_imx_data {
 	unsigned long spi_clk;
 	unsigned int spi_bus_clk;
 
-	unsigned int speed_hz;
-	unsigned int bits_per_word;
-	unsigned int spi_drctl;
+	unsigned int bytes_per_word;
 
-	unsigned int count, remainder;
+	unsigned int count;
 	void (*tx)(struct spi_imx_data *);
 	void (*rx)(struct spi_imx_data *);
 	void *rx_buf;
 	const void *tx_buf;
 	unsigned int txfifo; /* number of words pushed in tx FIFO */
-	unsigned int dynamic_burst, read_u32;
-	unsigned int word_mask;
-
-	/* Slave mode */
-	bool slave_mode;
-	bool slave_aborted;
-	unsigned int slave_burst;
 
 	/* DMA */
 	bool usedma;
@@ -145,22 +134,26 @@ static inline int is_imx51_ecspi(struct spi_imx_data *d)
 	       d->devtype_data->devtype == IMX6UL_ECSPI;
 }
 
-static inline int is_imx53_ecspi(struct spi_imx_data *d)
+static inline unsigned spi_imx_get_fifosize(struct spi_imx_data *d)
 {
-	return d->devtype_data->devtype == IMX53_ECSPI;
+	return is_imx51_ecspi(d) ? 64 : 8;
 }
 
+//ky_add: some transfer might use length=1, we must swap the contain for 16,32 bits_per_word transfer;
+#define ToBE(type,va) (1==sizeof(type))?(va):(2==sizeof(type))?(cpu_to_be16(va)):(cpu_to_be32(va))
+
 #define MXC_SPI_BUF_RX(type)						\
 static void spi_imx_buf_rx_##type(struct spi_imx_data *spi_imx)		\
 {									\
 	unsigned int val = readl(spi_imx->base + MXC_CSPIRXDATA);	\
-									\
+	val = ToBE(type,val);						\
 	if (spi_imx->rx_buf) {						\
 		*(type *)spi_imx->rx_buf = val;				\
 		spi_imx->rx_buf += sizeof(type);			\
 	}								\
 }
 
+
 #define MXC_SPI_BUF_TX(type)						\
 static void spi_imx_buf_tx_##type(struct spi_imx_data *spi_imx)		\
 {									\
@@ -168,6 +161,7 @@ static inline int is_imx53_ecspi(struct spi_imx_data *d)
 									\
 	if (spi_imx->tx_buf) {						\
 		val = *(type *)spi_imx->tx_buf;				\
+		val = ToBE(type,val); \
 		spi_imx->tx_buf += sizeof(type);			\
 	}								\
 									\
@@ -191,16 +185,15 @@ static inline int is_imx53_ecspi(struct spi_imx_data *d)
 
 /* MX21, MX27 */
 static unsigned int spi_imx_clkdiv_1(unsigned int fin,
-		unsigned int fspi, unsigned int max, unsigned int *fres)
+		unsigned int fspi, unsigned int max)
 {
 	int i;
 
 	for (i = 2; i < max; i++)
 		if (fspi * mxc_clkdivs[i] >= fin)
-			break;
+			return i;
 
-	*fres = fin / mxc_clkdivs[i];
-	return i;
+	return max;
 }
 
 /* MX1, MX31, MX35, MX51 CSPI */
@@ -220,32 +213,37 @@ static unsigned int spi_imx_clkdiv_2(unsigned int fin,
 	return i;
 }
 
-static int spi_imx_bytes_per_word(const int bits_per_word)
+static int spi_imx_bytes_per_word(const int bpw)
 {
-	return DIV_ROUND_UP(bits_per_word, BITS_PER_BYTE);
+	return DIV_ROUND_UP(bpw, BITS_PER_BYTE);
 }
 
 static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 			 struct spi_transfer *transfer)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
-	unsigned int bytes_per_word;
+	unsigned int bpw;
 
 	if (!master->dma_rx)
 		return false;
 
-	if (spi_imx->slave_mode)
+	if (!transfer)
 		return false;
 
-	bytes_per_word = spi_imx_bytes_per_word(transfer->bits_per_word);
+	bpw = transfer->bits_per_word;
+	if (!bpw)
+		bpw = spi->bits_per_word;
 
-	if (bytes_per_word != 1 && bytes_per_word != 2 && bytes_per_word != 4)
+	bpw = spi_imx_bytes_per_word(bpw);
+
+	if (bpw != 1 && bpw != 2 && bpw != 4)
 		return false;
 
-	if (transfer->len < spi_imx->devtype_data->fifo_size / 2)
+	if (transfer->len < spi_imx->wml * bpw)
 		return false;
 
-	spi_imx->dynamic_burst = 0;
+	if (transfer->len % (spi_imx->wml * bpw))
+		return false;
 
 	return true;
 }
@@ -255,12 +253,10 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 #define MX51_ECSPI_CTRL_XCH		(1 <<  2)
 #define MX51_ECSPI_CTRL_SMC		(1 << 3)
 #define MX51_ECSPI_CTRL_MODE_MASK	(0xf << 4)
-#define MX51_ECSPI_CTRL_DRCTL(drctl)	((drctl) << 16)
 #define MX51_ECSPI_CTRL_POSTDIV_OFFSET	8
 #define MX51_ECSPI_CTRL_PREDIV_OFFSET	12
 #define MX51_ECSPI_CTRL_CS(cs)		((cs) << 18)
 #define MX51_ECSPI_CTRL_BL_OFFSET	20
-#define MX51_ECSPI_CTRL_BL_MASK		(0xfff << 20)
 
 #define MX51_ECSPI_CONFIG	0x0c
 #define MX51_ECSPI_CONFIG_SCLKPHA(cs)	(1 << ((cs) +  0))
@@ -272,7 +268,6 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 #define MX51_ECSPI_INT		0x10
 #define MX51_ECSPI_INT_TEEN		(1 <<  0)
 #define MX51_ECSPI_INT_RREN		(1 <<  3)
-#define MX51_ECSPI_INT_RDREN		(1 <<  4)
 
 #define MX51_ECSPI_DMA      0x14
 #define MX51_ECSPI_DMA_TX_WML(wml)	((wml) & 0x3f)
@@ -289,144 +284,6 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 #define MX51_ECSPI_TESTREG	0x20
 #define MX51_ECSPI_TESTREG_LBC	BIT(31)
 
-static void spi_imx_buf_rx_swap_u32(struct spi_imx_data *spi_imx)
-{
-	unsigned int val = readl(spi_imx->base + MXC_CSPIRXDATA);
-#ifdef __LITTLE_ENDIAN
-	unsigned int bytes_per_word;
-#endif
-
-	if (spi_imx->rx_buf) {
-#ifdef __LITTLE_ENDIAN
-		bytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);
-		if (bytes_per_word == 1)
-			val = cpu_to_be32(val);
-		else if (bytes_per_word == 2)
-			val = (val << 16) | (val >> 16);
-#endif
-		val &= spi_imx->word_mask;
-		*(u32 *)spi_imx->rx_buf = val;
-		spi_imx->rx_buf += sizeof(u32);
-	}
-}
-
-static void spi_imx_buf_rx_swap(struct spi_imx_data *spi_imx)
-{
-	unsigned int bytes_per_word;
-
-	bytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);
-	if (spi_imx->read_u32) {
-		spi_imx_buf_rx_swap_u32(spi_imx);
-		return;
-	}
-
-	if (bytes_per_word == 1)
-		spi_imx_buf_rx_u8(spi_imx);
-	else if (bytes_per_word == 2)
-		spi_imx_buf_rx_u16(spi_imx);
-}
-
-static void spi_imx_buf_tx_swap_u32(struct spi_imx_data *spi_imx)
-{
-	u32 val = 0;
-#ifdef __LITTLE_ENDIAN
-	unsigned int bytes_per_word;
-#endif
-
-	if (spi_imx->tx_buf) {
-		val = *(u32 *)spi_imx->tx_buf;
-		val &= spi_imx->word_mask;
-		spi_imx->tx_buf += sizeof(u32);
-	}
-
-	spi_imx->count -= sizeof(u32);
-#ifdef __LITTLE_ENDIAN
-	bytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);
-
-	if (bytes_per_word == 1)
-		val = cpu_to_be32(val);
-	else if (bytes_per_word == 2)
-		val = (val << 16) | (val >> 16);
-#endif
-	writel(val, spi_imx->base + MXC_CSPITXDATA);
-}
-
-static void spi_imx_buf_tx_swap(struct spi_imx_data *spi_imx)
-{
-	u32 ctrl, val;
-	unsigned int bytes_per_word;
-
-	if (spi_imx->count == spi_imx->remainder) {
-		ctrl = readl(spi_imx->base + MX51_ECSPI_CTRL);
-		ctrl &= ~MX51_ECSPI_CTRL_BL_MASK;
-		if (spi_imx->count > MX51_ECSPI_CTRL_MAX_BURST) {
-			spi_imx->remainder = spi_imx->count %
-					     MX51_ECSPI_CTRL_MAX_BURST;
-			val = MX51_ECSPI_CTRL_MAX_BURST * 8 - 1;
-		} else if (spi_imx->count >= sizeof(u32)) {
-			spi_imx->remainder = spi_imx->count % sizeof(u32);
-			val = (spi_imx->count - spi_imx->remainder) * 8 - 1;
-		} else {
-			spi_imx->remainder = 0;
-			val = spi_imx->bits_per_word - 1;
-			spi_imx->read_u32 = 0;
-		}
-
-		ctrl |= (val << MX51_ECSPI_CTRL_BL_OFFSET);
-		writel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);
-	}
-
-	if (spi_imx->count >= sizeof(u32)) {
-		spi_imx_buf_tx_swap_u32(spi_imx);
-		return;
-	}
-
-	bytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);
-
-	if (bytes_per_word == 1)
-		spi_imx_buf_tx_u8(spi_imx);
-	else if (bytes_per_word == 2)
-		spi_imx_buf_tx_u16(spi_imx);
-}
-
-static void mx53_ecspi_rx_slave(struct spi_imx_data *spi_imx)
-{
-	u32 val = be32_to_cpu(readl(spi_imx->base + MXC_CSPIRXDATA));
-
-	if (spi_imx->rx_buf) {
-		int n_bytes = spi_imx->slave_burst % sizeof(val);
-
-		if (!n_bytes)
-			n_bytes = sizeof(val);
-
-		memcpy(spi_imx->rx_buf,
-		       ((u8 *)&val) + sizeof(val) - n_bytes, n_bytes);
-
-		spi_imx->rx_buf += n_bytes;
-		spi_imx->slave_burst -= n_bytes;
-	}
-}
-
-static void mx53_ecspi_tx_slave(struct spi_imx_data *spi_imx)
-{
-	u32 val = 0;
-	int n_bytes = spi_imx->count % sizeof(val);
-
-	if (!n_bytes)
-		n_bytes = sizeof(val);
-
-	if (spi_imx->tx_buf) {
-		memcpy(((u8 *)&val) + sizeof(val) - n_bytes,
-		       spi_imx->tx_buf, n_bytes);
-		val = cpu_to_be32(val);
-		spi_imx->tx_buf += n_bytes;
-	}
-
-	spi_imx->count -= n_bytes;
-
-	writel(val, spi_imx->base + MXC_CSPITXDATA);
-}
-
 /* MX51 eCSPI */
 static unsigned int mx51_ecspi_clkdiv(struct spi_imx_data *spi_imx,
 				      unsigned int fspi, unsigned int *fres)
@@ -476,9 +333,6 @@ static void mx51_ecspi_intctrl(struct spi_imx_data *spi_imx, int enable)
 	if (enable & MXC_INT_RR)
 		val |= MX51_ECSPI_INT_RREN;
 
-	if (enable & MXC_INT_RDR)
-		val |= MX51_ECSPI_INT_RDREN;
-
 	writel(val, spi_imx->base + MX51_ECSPI_INT);
 }
 
@@ -498,57 +352,34 @@ static void mx51_ecspi_trigger(struct spi_imx_data *spi_imx)
 	writel(reg, spi_imx->base + MX51_ECSPI_CTRL);
 }
 
-static void mx51_ecspi_disable(struct spi_imx_data *spi_imx)
-{
-	u32 ctrl;
-
-	ctrl = readl(spi_imx->base + MX51_ECSPI_CTRL);
-	ctrl &= ~MX51_ECSPI_CTRL_ENABLE;
-	writel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);
-}
-
-static int mx51_ecspi_config(struct spi_device *spi)
+static int mx51_ecspi_config(struct spi_device *spi,
+			     struct spi_imx_config *config)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	u32 ctrl = MX51_ECSPI_CTRL_ENABLE;
-	u32 clk = spi_imx->speed_hz, delay, reg;
+	u32 clk = config->speed_hz, delay, reg;
 	u32 cfg = readl(spi_imx->base + MX51_ECSPI_CONFIG);
-
-	/* set Master or Slave mode */
-	if (spi_imx->slave_mode)
-		ctrl &= ~MX51_ECSPI_CTRL_MODE_MASK;
-	else
-		ctrl |= MX51_ECSPI_CTRL_MODE_MASK;
+	int tx_wml = 0;
 
 	/*
-	 * Enable SPI_RDY handling (falling edge/level triggered).
+	 * The hardware seems to have a race condition when changing modes. The
+	 * current assumption is that the selection of the channel arrives
+	 * earlier in the hardware than the mode bits when they are written at
+	 * the same time.
+	 * So set master mode for all channels as we do not support slave mode.
 	 */
-	if (spi->mode & SPI_READY)
-		ctrl |= MX51_ECSPI_CTRL_DRCTL(spi_imx->spi_drctl);
+	ctrl |= MX51_ECSPI_CTRL_MODE_MASK;
 
 	/* set clock speed */
-	ctrl |= mx51_ecspi_clkdiv(spi_imx, spi_imx->speed_hz, &clk);
+	ctrl |= mx51_ecspi_clkdiv(spi_imx, config->speed_hz, &clk);
 	spi_imx->spi_bus_clk = clk;
 
 	/* set chip select to use */
 	ctrl |= MX51_ECSPI_CTRL_CS(spi->chip_select);
 
-	if (spi_imx->slave_mode)
-		ctrl |= (spi_imx->slave_burst * 8 - 1)
-			<< MX51_ECSPI_CTRL_BL_OFFSET;
-	else
-		ctrl |= (spi_imx->bits_per_word - 1)
-			<< MX51_ECSPI_CTRL_BL_OFFSET;
+	ctrl |= (config->bpw - 1) << MX51_ECSPI_CTRL_BL_OFFSET;
 
-	/*
-	 * eCSPI burst completion by Chip Select signal in Slave mode
-	 * is not functional for imx53 Soc, config SPI burst completed when
-	 * BURST_LENGTH + 1 bits are received
-	 */
-	if (spi_imx->slave_mode && is_imx53_ecspi(spi_imx))
-		cfg &= ~MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
-	else
-		cfg |= MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
+	cfg |= MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
 
 	if (spi->mode & SPI_CPHA)
 		cfg |= MX51_ECSPI_CONFIG_SCLKPHA(spi->chip_select);
@@ -599,26 +430,20 @@ static int mx51_ecspi_config(struct spi_device *spi)
 	else			/* SCLK is _very_ slow */
 		usleep_range(delay, delay + 10);
 
-	return 0;
-}
-
-static void mx51_setup_wml(struct spi_imx_data *spi_imx)
-{
-	int tx_wml = 0;
-
 	/*
 	 * Configure the DMA register: setup the watermark
 	 * and enable DMA request.
 	 */
 	if (spi_imx->devtype_data->devtype == IMX6UL_ECSPI)
-		tx_wml = spi_imx->wml;
+		tx_wml = spi_imx->wml / 2;
 
-	if (spi_imx->usedma)
-		writel(MX51_ECSPI_DMA_RX_WML(spi_imx->wml - 1) |
-			MX51_ECSPI_DMA_TX_WML(tx_wml) |
-			MX51_ECSPI_DMA_RXT_WML(spi_imx->wml) |
-			MX51_ECSPI_DMA_TEDEN | MX51_ECSPI_DMA_RXDEN |
-			MX51_ECSPI_DMA_RXTDEN, spi_imx->base + MX51_ECSPI_DMA);
+	writel(MX51_ECSPI_DMA_RX_WML(spi_imx->wml) |
+		MX51_ECSPI_DMA_TX_WML(tx_wml) |
+		MX51_ECSPI_DMA_RXT_WML(spi_imx->wml) |
+		MX51_ECSPI_DMA_TEDEN | MX51_ECSPI_DMA_RXDEN |
+		MX51_ECSPI_DMA_RXTDEN, spi_imx->base + MX51_ECSPI_DMA);
+
+	return 0;
 }
 
 static int mx51_ecspi_rx_available(struct spi_imx_data *spi_imx)
@@ -639,7 +464,6 @@ static void mx51_ecspi_reset(struct spi_imx_data *spi_imx)
 #define MX31_CSPICTRL_ENABLE	(1 << 0)
 #define MX31_CSPICTRL_MASTER	(1 << 1)
 #define MX31_CSPICTRL_XCH	(1 << 2)
-#define MX31_CSPICTRL_SMC	(1 << 3)
 #define MX31_CSPICTRL_POL	(1 << 4)
 #define MX31_CSPICTRL_PHA	(1 << 5)
 #define MX31_CSPICTRL_SSCTL	(1 << 6)
@@ -650,10 +474,6 @@ static void mx51_ecspi_reset(struct spi_imx_data *spi_imx)
 #define MX35_CSPICTRL_CS_SHIFT	12
 #define MX31_CSPICTRL_DR_SHIFT	16
 
-#define MX31_CSPI_DMAREG	0x10
-#define MX31_DMAREG_RH_DEN	(1<<4)
-#define MX31_DMAREG_TH_DEN	(1<<1)
-
 #define MX31_CSPISTATUS		0x14
 #define MX31_STATUS_RR		(1 << 3)
 
@@ -685,21 +505,21 @@ static void mx31_trigger(struct spi_imx_data *spi_imx)
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 }
 
-static int mx31_config(struct spi_device *spi)
+static int mx31_config(struct spi_device *spi, struct spi_imx_config *config)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	unsigned int reg = MX31_CSPICTRL_ENABLE | MX31_CSPICTRL_MASTER;
 	unsigned int clk;
 
-	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->speed_hz, &clk) <<
+	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz, &clk) <<
 		MX31_CSPICTRL_DR_SHIFT;
 	spi_imx->spi_bus_clk = clk;
 
 	if (is_imx35_cspi(spi_imx)) {
-		reg |= (spi_imx->bits_per_word - 1) << MX35_CSPICTRL_BL_SHIFT;
+		reg |= (config->bpw - 1) << MX35_CSPICTRL_BL_SHIFT;
 		reg |= MX31_CSPICTRL_SSCTL;
 	} else {
-		reg |= (spi_imx->bits_per_word - 1) << MX31_CSPICTRL_BC_SHIFT;
+		reg |= (config->bpw - 1) << MX31_CSPICTRL_BC_SHIFT;
 	}
 
 	if (spi->mode & SPI_CPHA)
@@ -708,14 +528,11 @@ static int mx31_config(struct spi_device *spi)
 		reg |= MX31_CSPICTRL_POL;
 	if (spi->mode & SPI_CS_HIGH)
 		reg |= MX31_CSPICTRL_SSPOL;
-	if (!gpio_is_valid(spi->cs_gpio))
-		reg |= (spi->chip_select) <<
+	if (spi->cs_gpio < 0)
+		reg |= (spi->cs_gpio + 32) <<
 			(is_imx35_cspi(spi_imx) ? MX35_CSPICTRL_CS_SHIFT :
 						  MX31_CSPICTRL_CS_SHIFT);
 
-	if (spi_imx->usedma)
-		reg |= MX31_CSPICTRL_SMC;
-
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 
 	reg = readl(spi_imx->base + MX31_CSPI_TESTREG);
@@ -725,13 +542,6 @@ static int mx31_config(struct spi_device *spi)
 		reg &= ~MX31_TEST_LBC;
 	writel(reg, spi_imx->base + MX31_CSPI_TESTREG);
 
-	if (spi_imx->usedma) {
-		/* configure DMA requests when RXFIFO is half full and
-		   when TXFIFO is half empty */
-		writel(MX31_DMAREG_RH_DEN | MX31_DMAREG_TH_DEN,
-			spi_imx->base + MX31_CSPI_DMAREG);
-	}
-
 	return 0;
 }
 
@@ -781,18 +591,15 @@ static void mx21_trigger(struct spi_imx_data *spi_imx)
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 }
 
-static int mx21_config(struct spi_device *spi)
+static int mx21_config(struct spi_device *spi, struct spi_imx_config *config)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	unsigned int reg = MX21_CSPICTRL_ENABLE | MX21_CSPICTRL_MASTER;
 	unsigned int max = is_imx27_cspi(spi_imx) ? 16 : 18;
-	unsigned int clk;
 
-	reg |= spi_imx_clkdiv_1(spi_imx->spi_clk, spi_imx->speed_hz, max, &clk)
-		<< MX21_CSPICTRL_DR_SHIFT;
-	spi_imx->spi_bus_clk = clk;
-
-	reg |= spi_imx->bits_per_word - 1;
+	reg |= spi_imx_clkdiv_1(spi_imx->spi_clk, config->speed_hz, max) <<
+		MX21_CSPICTRL_DR_SHIFT;
+	reg |= config->bpw - 1;
 
 	if (spi->mode & SPI_CPHA)
 		reg |= MX21_CSPICTRL_PHA;
@@ -800,8 +607,8 @@ static int mx21_config(struct spi_device *spi)
 		reg |= MX21_CSPICTRL_POL;
 	if (spi->mode & SPI_CS_HIGH)
 		reg |= MX21_CSPICTRL_SSPOL;
-	if (!gpio_is_valid(spi->cs_gpio))
-		reg |= spi->chip_select << MX21_CSPICTRL_CS_SHIFT;
+	if (spi->cs_gpio < 0)
+		reg |= (spi->cs_gpio + 32) << MX21_CSPICTRL_CS_SHIFT;
 
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 
@@ -850,17 +657,17 @@ static void mx1_trigger(struct spi_imx_data *spi_imx)
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 }
 
-static int mx1_config(struct spi_device *spi)
+static int mx1_config(struct spi_device *spi, struct spi_imx_config *config)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	unsigned int reg = MX1_CSPICTRL_ENABLE | MX1_CSPICTRL_MASTER;
 	unsigned int clk;
 
-	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->speed_hz, &clk) <<
+	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz, &clk) <<
 		MX1_CSPICTRL_DR_SHIFT;
 	spi_imx->spi_bus_clk = clk;
 
-	reg |= spi_imx->bits_per_word - 1;
+	reg |= config->bpw - 1;
 
 	if (spi->mode & SPI_CPHA)
 		reg |= MX1_CSPICTRL_PHA;
@@ -888,10 +695,6 @@ static void mx1_reset(struct spi_imx_data *spi_imx)
 	.trigger = mx1_trigger,
 	.rx_available = mx1_rx_available,
 	.reset = mx1_reset,
-	.fifo_size = 8,
-	.has_dmamode = false,
-	.dynamic_burst = false,
-	.has_slavemode = false,
 	.devtype = IMX1_CSPI,
 };
 
@@ -901,10 +704,6 @@ static void mx1_reset(struct spi_imx_data *spi_imx)
 	.trigger = mx21_trigger,
 	.rx_available = mx21_rx_available,
 	.reset = mx21_reset,
-	.fifo_size = 8,
-	.has_dmamode = false,
-	.dynamic_burst = false,
-	.has_slavemode = false,
 	.devtype = IMX21_CSPI,
 };
 
@@ -915,10 +714,6 @@ static void mx1_reset(struct spi_imx_data *spi_imx)
 	.trigger = mx21_trigger,
 	.rx_available = mx21_rx_available,
 	.reset = mx21_reset,
-	.fifo_size = 8,
-	.has_dmamode = false,
-	.dynamic_burst = false,
-	.has_slavemode = false,
 	.devtype = IMX27_CSPI,
 };
 
@@ -928,10 +723,6 @@ static void mx1_reset(struct spi_imx_data *spi_imx)
 	.trigger = mx31_trigger,
 	.rx_available = mx31_rx_available,
 	.reset = mx31_reset,
-	.fifo_size = 8,
-	.has_dmamode = false,
-	.dynamic_burst = false,
-	.has_slavemode = false,
 	.devtype = IMX31_CSPI,
 };
 
@@ -942,10 +733,6 @@ static void mx1_reset(struct spi_imx_data *spi_imx)
 	.trigger = mx31_trigger,
 	.rx_available = mx31_rx_available,
 	.reset = mx31_reset,
-	.fifo_size = 8,
-	.has_dmamode = true,
-	.dynamic_burst = false,
-	.has_slavemode = false,
 	.devtype = IMX35_CSPI,
 };
 
@@ -955,40 +742,15 @@ static void mx1_reset(struct spi_imx_data *spi_imx)
 	.trigger = mx51_ecspi_trigger,
 	.rx_available = mx51_ecspi_rx_available,
 	.reset = mx51_ecspi_reset,
-	.setup_wml = mx51_setup_wml,
-	.fifo_size = 64,
-	.has_dmamode = true,
-	.dynamic_burst = true,
-	.has_slavemode = true,
-	.disable = mx51_ecspi_disable,
 	.devtype = IMX51_ECSPI,
 };
 
-static struct spi_imx_devtype_data imx53_ecspi_devtype_data = {
-	.intctrl = mx51_ecspi_intctrl,
-	.config = mx51_ecspi_config,
-	.trigger = mx51_ecspi_trigger,
-	.rx_available = mx51_ecspi_rx_available,
-	.reset = mx51_ecspi_reset,
-	.fifo_size = 64,
-	.has_dmamode = true,
-	.has_slavemode = true,
-	.disable = mx51_ecspi_disable,
-	.devtype = IMX53_ECSPI,
-};
-
 static struct spi_imx_devtype_data imx6ul_ecspi_devtype_data = {
 	.intctrl = mx51_ecspi_intctrl,
 	.config = mx51_ecspi_config,
 	.trigger = mx51_ecspi_trigger,
 	.rx_available = mx51_ecspi_rx_available,
 	.reset = mx51_ecspi_reset,
-	.setup_wml = mx51_setup_wml,
-	.fifo_size = 64,
-	.has_dmamode = true,
-	.dynamic_burst = true,
-	.has_slavemode = true,
-	.disable = mx51_ecspi_disable,
 	.devtype = IMX6UL_ECSPI,
 };
 
@@ -1012,9 +774,6 @@ static void mx1_reset(struct spi_imx_data *spi_imx)
 		.name = "imx51-ecspi",
 		.driver_data = (kernel_ulong_t) &imx51_ecspi_devtype_data,
 	}, {
-		.name = "imx53-ecspi",
-		.driver_data = (kernel_ulong_t) &imx53_ecspi_devtype_data,
-	}, {
 		.name = "imx6ul-ecspi",
 		.driver_data = (kernel_ulong_t) &imx6ul_ecspi_devtype_data,
 	}, {
@@ -1029,7 +788,6 @@ static void mx1_reset(struct spi_imx_data *spi_imx)
 	{ .compatible = "fsl,imx31-cspi", .data = &imx31_cspi_devtype_data, },
 	{ .compatible = "fsl,imx35-cspi", .data = &imx35_cspi_devtype_data, },
 	{ .compatible = "fsl,imx51-ecspi", .data = &imx51_ecspi_devtype_data, },
-	{ .compatible = "fsl,imx53-ecspi", .data = &imx53_ecspi_devtype_data, },
 	{ .compatible = "fsl,imx6ul-ecspi", .data = &imx6ul_ecspi_devtype_data, },
 	{ /* sentinel */ }
 };
@@ -1040,9 +798,6 @@ static void spi_imx_chipselect(struct spi_device *spi, int is_active)
 	int active = is_active != BITBANG_CS_INACTIVE;
 	int dev_is_lowactive = !(spi->mode & SPI_CS_HIGH);
 
-	if (spi->mode & SPI_NO_CS)
-		return;
-
 	if (!gpio_is_valid(spi->cs_gpio))
 		return;
 
@@ -1051,26 +806,22 @@ static void spi_imx_chipselect(struct spi_device *spi, int is_active)
 
 static void spi_imx_push(struct spi_imx_data *spi_imx)
 {
-	while (spi_imx->txfifo < spi_imx->devtype_data->fifo_size) {
+	while (spi_imx->txfifo < spi_imx_get_fifosize(spi_imx)) {
 		if (!spi_imx->count)
 			break;
-		if (spi_imx->txfifo && (spi_imx->count == spi_imx->remainder))
-			break;
-		spi_imx->tx(spi_imx);
+		spi_imx->tx(spi_imx); Link2(MXC_SPI_BUF_TX);
 		spi_imx->txfifo++;
 	}
 
-	if (!spi_imx->slave_mode)
-		spi_imx->devtype_data->trigger(spi_imx);
+	spi_imx->devtype_data->trigger(spi_imx); Link2(mx51_ecspi_trigger);
 }
 
 static irqreturn_t spi_imx_isr(int irq, void *dev_id)
 {
 	struct spi_imx_data *spi_imx = dev_id;
 
-	while (spi_imx->txfifo &&
-	       spi_imx->devtype_data->rx_available(spi_imx)) {
-		spi_imx->rx(spi_imx);
+	while (spi_imx->devtype_data->rx_available(spi_imx)) { Link2(mx51_ecspi_rx_available);
+		spi_imx->rx(spi_imx);  Link2(MXC_SPI_BUF_RX);
 		spi_imx->txfifo--;
 	}
 
@@ -1094,14 +845,19 @@ static irqreturn_t spi_imx_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int spi_imx_dma_configure(struct spi_master *master)
+static int spi_imx_dma_configure(struct spi_master *master,
+				 int bytes_per_word)
 {
 	int ret;
 	enum dma_slave_buswidth buswidth;
 	struct dma_slave_config rx = {}, tx = {};
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
 
-	switch (spi_imx_bytes_per_word(spi_imx->bits_per_word)) {
+	if (bytes_per_word == spi_imx->bytes_per_word)
+		/* Same as last time */
+		return 0;
+
+	switch (bytes_per_word) {
 	case 4:
 		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
 		break;
@@ -1118,7 +874,7 @@ static int spi_imx_dma_configure(struct spi_master *master)
 	tx.direction = DMA_MEM_TO_DEV;
 	tx.dst_addr = spi_imx->base_phys + MXC_CSPITXDATA;
 	tx.dst_addr_width = buswidth;
-	tx.dst_maxburst = spi_imx->wml;
+	tx.dst_maxburst = spi_imx->wml / 2;
 	ret = dmaengine_slave_config(master->dma_tx, &tx);
 	if (ret) {
 		dev_err(spi_imx->dev, "TX dma configuration failed with %d\n", ret);
@@ -1135,6 +891,8 @@ static int spi_imx_dma_configure(struct spi_master *master)
 		return ret;
 	}
 
+	spi_imx->bytes_per_word = bytes_per_word;
+
 	return 0;
 }
 
@@ -1142,45 +900,27 @@ static int spi_imx_setupxfer(struct spi_device *spi,
 				 struct spi_transfer *t)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
+	struct spi_imx_config config;
+	int ret;
 
-	if (!t)
-		return 0;
+	config.bpw = t ? t->bits_per_word : spi->bits_per_word;
+	config.speed_hz  = t ? t->speed_hz : spi->max_speed_hz;
 
-	spi_imx->bits_per_word = t->bits_per_word;
-	spi_imx->speed_hz  = t->speed_hz;
+	if (!config.speed_hz)
+		config.speed_hz = spi->max_speed_hz;
+	if (!config.bpw)
+		config.bpw = spi->bits_per_word;
 
 	/* Initialize the functions for transfer */
-	if (spi_imx->devtype_data->dynamic_burst && !spi_imx->slave_mode) {
-		u32 mask;
-
-		spi_imx->dynamic_burst = 0;
-		spi_imx->remainder = 0;
-		spi_imx->read_u32  = 1;
-
-		mask = (1 << spi_imx->bits_per_word) - 1;
-		spi_imx->rx = spi_imx_buf_rx_swap;
-		spi_imx->tx = spi_imx_buf_tx_swap;
-		spi_imx->dynamic_burst = 1;
-		spi_imx->remainder = t->len;
-
-		if (spi_imx->bits_per_word <= 8)
-			spi_imx->word_mask = mask << 24 | mask << 16
-					     | mask << 8 | mask;
-		else if (spi_imx->bits_per_word <= 16)
-			spi_imx->word_mask = mask << 16 | mask;
-		else
-			spi_imx->word_mask = mask;
+	if (config.bpw <= 8) {
+		spi_imx->rx = spi_imx_buf_rx_u8;
+		spi_imx->tx = spi_imx_buf_tx_u8;
+	} else if (config.bpw <= 16) {
+		spi_imx->rx = spi_imx_buf_rx_u16;
+		spi_imx->tx = spi_imx_buf_tx_u16;
 	} else {
-		if (spi_imx->bits_per_word <= 8) {
-			spi_imx->rx = spi_imx_buf_rx_u8;
-			spi_imx->tx = spi_imx_buf_tx_u8;
-		} else if (spi_imx->bits_per_word <= 16) {
-			spi_imx->rx = spi_imx_buf_rx_u16;
-			spi_imx->tx = spi_imx_buf_tx_u16;
-		} else {
-			spi_imx->rx = spi_imx_buf_rx_u32;
-			spi_imx->tx = spi_imx_buf_tx_u32;
-		}
+		spi_imx->rx = spi_imx_buf_rx_u32; Link2(MXC_SPI_BUF_RX);
+		spi_imx->tx = spi_imx_buf_tx_u32; Link2(MXC_SPI_BUF_TX);
 	}
 
 	if (spi_imx_can_dma(spi_imx->bitbang.master, spi, t))
@@ -1188,13 +928,26 @@ static int spi_imx_setupxfer(struct spi_device *spi,
 	else
 		spi_imx->usedma = 0;
 
-	if (spi_imx->slave_mode) {
-		spi_imx->rx = mx53_ecspi_rx_slave;
-		spi_imx->tx = mx53_ecspi_tx_slave;
-		spi_imx->slave_burst = t->len;
+#ifdef ADLINK_ENABLE_BURST_LENGTH
+	//ky_changed: Long burst only acceptable on 32 bits wide;
+	if(32==config.bpw && t->len<=512) {
+		config.bpw=t->len*8;
+		if(0<t->delay_usecs && t->delay_usecs<4) { Link2(mcp251x_spi_trans);
+am_((PDD "%s(): Modify config.bpw form %d to %d\n",__func__,config.bpw,config.bpw-8*t->delay_usecs));
+			config.bpw-=t->delay_usecs*8;
+			t->delay_usecs=0;
+		}
+	}
+#endif
+
+	if (spi_imx->usedma) {
+		ret = spi_imx_dma_configure(spi->master,
+					    spi_imx_bytes_per_word(config.bpw));
+		if (ret)
+			return ret;
 	}
 
-	spi_imx->devtype_data->config(spi);
+	spi_imx->devtype_data->config(spi, &config); Link2(mx51_ecspi_config);
 
 	return 0;
 }
@@ -1219,7 +972,7 @@ static int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,
 {
 	int ret;
 
-	spi_imx->wml = spi_imx->devtype_data->fifo_size / 2;
+	spi_imx->wml = spi_imx_get_fifosize(spi_imx) / 2;
 
 	/* Prepare for TX DMA: */
 	master->dma_tx = dma_request_slave_channel_reason(dev, "tx");
@@ -1239,6 +992,8 @@ static int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,
 		goto err;
 	}
 
+	spi_imx_dma_configure(master, 1);
+
 	init_completion(&spi_imx->dma_rx_completion);
 	init_completion(&spi_imx->dma_tx_completion);
 	master->can_dma = spi_imx_can_dma;
@@ -1288,31 +1043,6 @@ static int spi_imx_dma_transfer(struct spi_imx_data *spi_imx,
 	unsigned long timeout;
 	struct spi_master *master = spi_imx->bitbang.master;
 	struct sg_table *tx = &transfer->tx_sg, *rx = &transfer->rx_sg;
-	struct scatterlist *last_sg = sg_last(rx->sgl, rx->nents);
-	unsigned int bytes_per_word, i;
-	int ret;
-
-	/* Get the right burst length from the last sg to ensure no tail data */
-	bytes_per_word = spi_imx_bytes_per_word(transfer->bits_per_word);
-	for (i = spi_imx->devtype_data->fifo_size / 2; i > 0; i--) {
-		if (!(sg_dma_len(last_sg) % (i * bytes_per_word)))
-			break;
-	}
-	/* Use 1 as wml in case no available burst length got */
-	if (i == 0)
-		i = 1;
-	spi_imx->wml =  i;
-
-	ret = spi_imx_dma_configure(master);
-	if (ret)
-		return ret;
-
-	if (!spi_imx->devtype_data->setup_wml) {
-		dev_err(spi_imx->dev, "No setup_wml()?\n");
-		return -EINVAL;
-	}
-
-	spi_imx->devtype_data->setup_wml(spi_imx);
 
 	/*
 	 * The TX DMA setup starts the transfer, so make sure RX is configured
@@ -1401,61 +1131,11 @@ static int spi_imx_pio_transfer(struct spi_device *spi,
 	return transfer->len;
 }
 
-static int spi_imx_pio_transfer_slave(struct spi_device *spi,
-				      struct spi_transfer *transfer)
-{
-	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
-	int ret = transfer->len;
-
-	if ((is_imx51_ecspi(spi_imx) || is_imx53_ecspi(spi_imx)) &&
-	    transfer->len > MX53_MAX_TRANSFER_BYTES) {
-		dev_err(&spi->dev, "Transaction too big, max size is %d bytes\n",
-			MX53_MAX_TRANSFER_BYTES);
-		return -EMSGSIZE;
-	}
-
-	spi_imx->tx_buf = transfer->tx_buf;
-	spi_imx->rx_buf = transfer->rx_buf;
-	spi_imx->count = transfer->len;
-	spi_imx->txfifo = 0;
-
-	reinit_completion(&spi_imx->xfer_done);
-	spi_imx->slave_aborted = false;
-
-	spi_imx_push(spi_imx);
-
-	spi_imx->devtype_data->intctrl(spi_imx, MXC_INT_TE | MXC_INT_RDR);
-
-	if (wait_for_completion_interruptible(&spi_imx->xfer_done) ||
-	    spi_imx->slave_aborted) {
-		dev_dbg(&spi->dev, "interrupted\n");
-		ret = -EINTR;
-	}
-
-	/* ecspi has a HW issue when works in Slave mode,
-	 * after 64 words writtern to TXFIFO, even TXFIFO becomes empty,
-	 * ECSPI_TXDATA keeps shift out the last word data,
-	 * so we have to disable ECSPI when in slave mode after the
-	 * transfer completes
-	 */
-	if (spi_imx->devtype_data->disable)
-		spi_imx->devtype_data->disable(spi_imx);
-
-	return ret;
-}
-
 static int spi_imx_transfer(struct spi_device *spi,
 				struct spi_transfer *transfer)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 
-	/* flush rxfifo before transfer */
-	while (spi_imx->devtype_data->rx_available(spi_imx))
-		spi_imx->rx(spi_imx);
-
-	if (spi_imx->slave_mode)
-		return spi_imx_pio_transfer_slave(spi, transfer);
-
 	if (spi_imx->usedma)
 		return spi_imx_dma_transfer(spi_imx, transfer);
 	else
@@ -1467,9 +1147,6 @@ static int spi_imx_setup(struct spi_device *spi)
 	dev_dbg(&spi->dev, "%s: mode %d, %u bpw, %d hz\n", __func__,
 		 spi->mode, spi->bits_per_word, spi->max_speed_hz);
 
-	if (spi->mode & SPI_NO_CS)
-		return 0;
-
 	if (gpio_is_valid(spi->cs_gpio))
 		gpio_direction_output(spi->cs_gpio,
 				      spi->mode & SPI_CS_HIGH ? 0 : 1);
@@ -1512,16 +1189,6 @@ static void spi_imx_cleanup(struct spi_device *spi)
 	return 0;
 }
 
-static int spi_imx_slave_abort(struct spi_master *master)
-{
-	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
-
-	spi_imx->slave_aborted = true;
-	complete(&spi_imx->xfer_done);
-
-	return 0;
-}
-
 static int spi_imx_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -1532,81 +1199,49 @@ static int spi_imx_probe(struct platform_device *pdev)
 	struct spi_master *master;
 	struct spi_imx_data *spi_imx;
 	struct resource *res;
-	int i, ret, irq, spi_drctl, num_cs;
-	const struct spi_imx_devtype_data *devtype_data = of_id ? of_id->data :
-		(struct spi_imx_devtype_data *)pdev->id_entry->driver_data;
-	bool slave_mode;
+	int i, ret, irq;
 
 	if (!np && !mxc_platform_info) {
 		dev_err(&pdev->dev, "can't get the platform data\n");
 		return -EINVAL;
 	}
 
-	slave_mode = devtype_data->has_slavemode &&
-			of_property_read_bool(np, "spi-slave");
-	if (slave_mode)
-		master = spi_alloc_slave(&pdev->dev,
-					 sizeof(struct spi_imx_data));
-	else
-		master = spi_alloc_master(&pdev->dev,
-					  sizeof(struct spi_imx_data));
+	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_imx_data));
 	if (!master)
 		return -ENOMEM;
 
-	ret = of_property_read_u32(np, "fsl,spi-rdy-drctl", &spi_drctl);
-	if ((ret < 0) || (spi_drctl >= 0x3)) {
-		/* '11' is reserved */
-		spi_drctl = 0;
-	}
-
 	platform_set_drvdata(pdev, master);
 
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);
 	master->bus_num = np ? -1 : pdev->id;
 
-	ret = of_property_read_u32(np, "fsl,spi-num-chipselects", &num_cs);
-	if (ret < 0) {
-		if (mxc_platform_info) {
-			num_cs = mxc_platform_info->num_chipselect;
-			master->num_chipselect = num_cs;
-		}
-	} else {
-		master->num_chipselect = num_cs;
-	}
-
 	spi_imx = spi_master_get_devdata(master);
 	spi_imx->bitbang.master = master;
 	spi_imx->dev = &pdev->dev;
-	spi_imx->slave_mode = slave_mode;
 
-	spi_imx->devtype_data = devtype_data;
+	spi_imx->devtype_data = of_id ? of_id->data :
+		(struct spi_imx_devtype_data *)pdev->id_entry->driver_data;
 
-	master->cs_gpios = devm_kzalloc(&master->dev,
+	if (mxc_platform_info) {//ky_NO;
+efl_	master->num_chipselect = mxc_platform_info->num_chipselect;
+		master->cs_gpios = devm_kzalloc(&master->dev,
 			sizeof(int) * master->num_chipselect, GFP_KERNEL);
-
-	if (!spi_imx->slave_mode) {
+		if (!master->cs_gpios)
+			return -ENOMEM;
+
+		for (i = 0; i < master->num_chipselect; i++)
+			master->cs_gpios[i] = mxc_platform_info->chipselect[i];
+ 	}
+	// master->cs_gpios can not be NULL. write dummy value on dts is not a good idea.
+	// Here we accept this situation and assign dummy on driver site;
+	else if(-ENOENT==of_gpio_named_count(np,"cs-gpios")) {//ky_add: Solve cs-gpios property
+		master->cs_gpios=devm_kzalloc(&master->dev,sizeof(int)*master->num_chipselect,GFP_KERNEL);
 		if (!master->cs_gpios) {
-			dev_err(&pdev->dev, "No CS GPIOs available\n");
-			ret = -EINVAL;
+			ret=-ENOMEM;
 			goto out_master_put;
 		}
-
-		for (i = 0; i < master->num_chipselect; i++) {
-			int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
-			if (!gpio_is_valid(cs_gpio) && mxc_platform_info)
-				cs_gpio = mxc_platform_info->chipselect[i];
-
-			master->cs_gpios[i] = cs_gpio;
-			if (!gpio_is_valid(cs_gpio))
-				continue;
-
-			ret = devm_gpio_request(&pdev->dev, master->cs_gpios[i],
-						DRIVER_NAME);
-			if (ret) {
-				dev_err(&pdev->dev, "Can't get CS GPIO %i\n",
-					master->cs_gpios[i]);
-				goto out_master_put;
-			}
+		for(i=0;i<master->num_chipselect;i++) {
+			master->cs_gpios[i]=-1;
 		}
 	}
 
@@ -1617,14 +1252,9 @@ static int spi_imx_probe(struct platform_device *pdev)
 	spi_imx->bitbang.master->cleanup = spi_imx_cleanup;
 	spi_imx->bitbang.master->prepare_message = spi_imx_prepare_message;
 	spi_imx->bitbang.master->unprepare_message = spi_imx_unprepare_message;
-	spi_imx->bitbang.master->slave_abort = spi_imx_slave_abort;
-	spi_imx->bitbang.master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH \
-					     | SPI_NO_CS;
-	if (is_imx35_cspi(spi_imx) || is_imx51_ecspi(spi_imx) ||
-	    is_imx53_ecspi(spi_imx))
-		spi_imx->bitbang.master->mode_bits |= SPI_LOOP | SPI_READY;
-
-	spi_imx->spi_drctl = spi_drctl;
+	spi_imx->bitbang.master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
+	if (is_imx35_cspi(spi_imx) || is_imx51_ecspi(spi_imx))
+		spi_imx->bitbang.master->mode_bits |= SPI_LOOP;
 
 	init_completion(&spi_imx->xfer_done);
 
@@ -1670,11 +1300,16 @@ static int spi_imx_probe(struct platform_device *pdev)
 		goto out_put_per;
 
 	spi_imx->spi_clk = clk_get_rate(spi_imx->clk_per);
+
+am_((PDD "PA=0x%08lX, VA=%p, Irq=%d, clk=%lu KHz\n",spi_imx->base_phys,spi_imx->base,irq,spi_imx->spi_clk/1000));
+//PA=0x30830000, VA=ffff00000adb0000, Irq=38, clk=200000 KHz
+//ky_note: A53-IRQ is 32 for ecspi2, see Table 7-1;
+
 	/*
-	 * Only validated on i.mx35 and i.mx6 now, can remove the constraint
-	 * if validated on other chips.
+	 * Only validated on i.mx6 now, can remove the constrain if validated on
+	 * other chips.
 	 */
-	if (spi_imx->devtype_data->has_dmamode) {
+	if (is_imx51_ecspi(spi_imx)) {
 		ret = spi_imx_sdma_init(&pdev->dev, spi_imx, master);
 		if (ret == -EPROBE_DEFER)
 			goto out_clk_put;
@@ -1684,9 +1319,9 @@ static int spi_imx_probe(struct platform_device *pdev)
 				ret);
 	}
 
-	spi_imx->devtype_data->reset(spi_imx);
+	spi_imx->devtype_data->reset(spi_imx); Link2(mx51_ecspi_reset);
 
-	spi_imx->devtype_data->intctrl(spi_imx, 0);
+	spi_imx->devtype_data->intctrl(spi_imx, 0); Link2(mx51_ecspi_intctrl);
 
 	master->dev.of_node = pdev->dev.of_node;
 	ret = spi_bitbang_start(&spi_imx->bitbang);
@@ -1695,6 +1330,26 @@ static int spi_imx_probe(struct platform_device *pdev)
 		goto out_clk_put;
 	}
 
+	if (!master->cs_gpios) {
+		dev_err(&pdev->dev, "No CS GPIOs available\n");
+		ret = -EINVAL;
+		goto out_clk_put;
+	}
+
+	for (i = 0; i < master->num_chipselect; i++) {
+		if (!gpio_is_valid(master->cs_gpios[i]))
+			continue;
+
+		ret = devm_gpio_request(&pdev->dev, master->cs_gpios[i],
+					DRIVER_NAME);
+		if (ret) {
+			dev_err(&pdev->dev, "Can't get CS GPIO %i\n",
+				master->cs_gpios[i]);
+			goto out_clk_put;
+		}
+	}
+am_((PDD "Probed Success: %s, BusNum=%d\n",dev_name(&master->dev),master->bus_num));
+
 	dev_info(&pdev->dev, "probed\n");
 
 	clk_disable_unprepare(spi_imx->clk_ipg);
diff --git a/include/linux/err.h b/include/linux/err.h
index 87be243..91fe761 100644
--- a/include/linux/err.h
+++ b/include/linux/err.h
@@ -67,4 +67,19 @@ static inline int __must_check PTR_ERR_OR_ZERO(__force const void *ptr)
 
 #endif
 
+#ifdef ADLINK_DEBUG //printk(KERN_EMERG PREFIX_DD )
+#define PDD     " @@ "
+#define Fl_             printk(PDD "%s(%d)\n",__FILE__,__LINE__);
+#define fl_             printk(PDD "%s(%d)\n",__func__,__LINE__);
+#define efl_    printk(PDD "Error! %s(%d)\n",__func__,__LINE__);
+#define am_(x)  printk x
+#else
+#define PDD ""
+#define Fl_
+#define fl_
+#define efl_
+#define am_(x)
+#endif
+#define Link2(x)
+
 #endif /* _LINUX_ERR_H */
-- 
1.9.1

