From 99d00d376844f713dba2df2d92d62703a812000b Mon Sep 17 00:00:00 2001
From: "po.cheng" <po.cheng@adlinktech.com>
Date: Mon, 27 Nov 2023 16:59:22 +0800
Subject: [PATCH 12/16] sp2-imx8mp: patch: pwm-backlight: add
 pre-pwm-on-delay-ms and pwm-on-delay-ms to delay pwm and enable

Signed-off-by: po.cheng <po.cheng@adlinktech.com>
---
 drivers/video/backlight/pwm_bl.c | 21 +++++++++++++++++++++
 include/linux/pwm_backlight.h    |  3 +++
 2 files changed, 24 insertions(+)

diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index a8823e317b69..e0cc4d79b72b 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -29,8 +29,11 @@ struct pwm_bl_data {
 	struct gpio_desc	*enable_gpio;
 	unsigned int		scale;
 	bool			legacy;
+	unsigned int		pre_pwm_on_delay;
+	unsigned int		pwm_on_delay;
 	unsigned int		post_pwm_on_delay;
 	unsigned int		pwm_off_delay;
+	unsigned int		post_pwm_off_delay;
 	int			(*notify)(struct device *,
 					  int brightness);
 	void			(*notify_after)(struct device *,
@@ -49,10 +52,16 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb)
 	if (pb->enabled)
 		return;
 
+	if (pb->pre_pwm_on_delay)
+		msleep(pb->pre_pwm_on_delay);
+
 	err = regulator_enable(pb->power_supply);
 	if (err < 0)
 		dev_err(pb->dev, "failed to enable power supply\n");
 
+	if (pb->pwm_on_delay)
+		msleep(pb->pwm_on_delay);
+
 	state.enabled = true;
 	pwm_apply_state(pb->pwm, &state);
 
@@ -85,6 +94,9 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 
 	regulator_disable(pb->power_supply);
 	pb->enabled = false;
+
+	if (pb->post_pwm_off_delay)
+		msleep(pb->post_pwm_off_delay);
 }
 
 static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)
@@ -265,9 +277,15 @@ static int pwm_backlight_parse_dt(struct device *dev,
 	 * These values are optional and set as 0 by default, the out values
 	 * are modified only if a valid u32 value can be decoded.
 	 */
+	of_property_read_u32(node, "pre-pwm-on-delay-ms",
+			     &data->pre_pwm_on_delay);
+	of_property_read_u32(node, "pwm-on-delay-ms",
+			     &data->pwm_on_delay);
 	of_property_read_u32(node, "post-pwm-on-delay-ms",
 			     &data->post_pwm_on_delay);
 	of_property_read_u32(node, "pwm-off-delay-ms", &data->pwm_off_delay);
+	of_property_read_u32(node, "post-pwm-off-delay-ms",
+			     &data->post_pwm_off_delay);
 
 	/*
 	 * Determine the number of brightness levels, if this property is not
@@ -507,8 +525,11 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
+	pb->pre_pwm_on_delay = data->pre_pwm_on_delay;
+	pb->pwm_on_delay = data->pwm_on_delay;
 	pb->post_pwm_on_delay = data->post_pwm_on_delay;
 	pb->pwm_off_delay = data->pwm_off_delay;
+	pb->post_pwm_off_delay = data->post_pwm_off_delay;
 	strcpy(pb->fb_id, data->fb_id);
 
 	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable",
diff --git a/include/linux/pwm_backlight.h b/include/linux/pwm_backlight.h
index c922b067ad41..05c315693d4e 100644
--- a/include/linux/pwm_backlight.h
+++ b/include/linux/pwm_backlight.h
@@ -14,8 +14,11 @@ struct platform_pwm_backlight_data {
 	unsigned int lth_brightness;
 	unsigned int pwm_period_ns;
 	unsigned int *levels;
+	unsigned int pre_pwm_on_delay;
+	unsigned int pwm_on_delay;
 	unsigned int post_pwm_on_delay;
 	unsigned int pwm_off_delay;
+	unsigned int post_pwm_off_delay;
 	int (*init)(struct device *dev);
 	int (*notify)(struct device *dev, int brightness);
 	void (*notify_after)(struct device *dev, int brightness);
-- 
2.25.1

