From c8dd871a089d22cc39114c03bb726f5df98fd5f0 Mon Sep 17 00:00:00 2001
From: Antony <antonyabee.prakashxv@adlinktech.com>
Date: Wed, 10 Jul 2019 09:57:54 +0530
Subject: [PATCH 2/2] Add-external-thermal-sensor-support

---
 arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts |  4 ++
 arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi      |  4 +-
 drivers/thermal/Kconfig                         |  6 ++
 drivers/thermal/qoriq_thermal.c                 | 92 ++++++++++++++++++++++++-
 4 files changed, 102 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
index ffc9a1c..2e24fc1 100644
--- a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
+++ b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
@@ -767,3 +767,7 @@
 	};
 };
 #endif
+
+&tmu {
+        temp-i2c-bus = <&i2c4>;
+};
diff --git a/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi b/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
index 79b8a90..9288216 100644
--- a/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
+++ b/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
@@ -422,12 +422,12 @@
 			thermal-sensors = <&tmu>;
 			trips {
 				cpu_alert0: trip0 {
-					temperature = <85000>;
+					temperature = <100000>;
 					hysteresis = <2000>;
 					type = "passive";
 				};
 				cpu_crit0: trip1 {
-					temperature = <95000>;
+					temperature = <103000>;
 					hysteresis = <2000>;
 					type = "critical";
 				};
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index d446b46..46bd20c 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -234,6 +234,12 @@ config IMX8MM_THERMAL
 	  cpufreq is used as the cooling device to throttle CPUs when the
 	  passive trip is crossed.
 
+config IMX8M_EXT_THERMAL
+	tristate "i.MX8M Ext Thermal Sensor support"
+	depends on IMX8M_THERMAL	
+	help
+	  Support for external Thermal Sensor support on i.MX8M platforms.
+
 config IMX_SC_THERMAL
 	tristate "thermal sensor driver for NXP i.MX8 SoCs"
 	depends on THERMAL_OF && ARCH_MXC_ARM64
diff --git a/drivers/thermal/qoriq_thermal.c b/drivers/thermal/qoriq_thermal.c
index c832ee8..9d582a4 100644
--- a/drivers/thermal/qoriq_thermal.c
+++ b/drivers/thermal/qoriq_thermal.c
@@ -23,7 +23,10 @@
 #include <linux/thermal.h>
 
 #include "thermal_core.h"
-
+#ifdef CONFIG_IMX8M_EXT_THERMAL	
+#include <linux/i2c.h>
+#define BridgeAddr 0x48
+#endif
 #define SITES_MAX	16
 
 #define TMU_TEMP_PASSIVE_COOL_DELTA	10000
@@ -84,6 +87,9 @@ struct qoriq_tmu_data {
 	bool little_endian;
 	int temp_passive;
 	int temp_critical;
+#ifdef CONFIG_IMX8M_EXT_THERMAL	
+	struct i2c_adapter *ext;
+#endif		
 };
 
 enum tmu_trip {
@@ -92,6 +98,48 @@ enum tmu_trip {
 	TMU_TRIP_NUM,
 };
 
+#ifdef CONFIG_IMX8M_EXT_THERMAL	
+static int temp_i2c_read(struct i2c_adapter *bridge, char *writebuf, int writelen, char *readbuf, int readlen)
+{
+	int ret;
+
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+				.addr = BridgeAddr,
+				.flags = 0,
+				.len = writelen,
+				.buf = writebuf,
+			},
+			{
+				.addr = BridgeAddr,
+				.flags = I2C_M_RD,
+				.len = readlen,
+				.buf = readbuf,
+			},
+		};
+
+		ret = i2c_transfer(bridge, msgs, 2);
+		if (ret < 0)
+			printk("%s: i2c read error.\n", __func__);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+				.addr = BridgeAddr,
+				.flags = I2C_M_RD,
+				.len = readlen,
+				.buf = readbuf,
+			},
+		};
+
+		ret = i2c_transfer(bridge, msgs, 1);
+		if (ret < 0)
+			printk("%s:i2c read error.\n", __func__);
+	}
+
+	return ret;
+}
+#endif
 static void tmu_write(struct qoriq_tmu_data *p, u32 val, void __iomem *addr)
 {
 	if (p->little_endian)
@@ -111,11 +159,36 @@ static u32 tmu_read(struct qoriq_tmu_data *p, void __iomem *addr)
 static int tmu_get_temp(void *p, int *temp)
 {
 	u32 val;
+#ifdef CONFIG_IMX8M_EXT_THERMAL	
+	int err=0;	
+	char address=0;
+	u16 extval=0;
+	int t1=0;
+	u8 *ptr;
+#endif	
 	struct qoriq_tmu_data *data = p;
 
 	val = tmu_read(data, &data->regs->site[data->sensor_id].tritsr);
 	*temp = (val & 0xff) * 1000;
 
+#ifdef CONFIG_IMX8M_EXT_THERMAL		
+	if(data->ext)
+	{
+		err = temp_i2c_read(data->ext, &address, 1, (char *)&extval, 2);
+		if (err < 0) 
+		{
+			printk("failed to read ext temp chip id\n");			
+		}
+		else
+		{
+			ptr = (u8 *)&extval;
+			t1 = ((ptr[0]<<8) | ptr[1])>>4;			
+			// under 0, 12-bit format
+			if( t1&0x800)
+				*temp = 0;
+		}
+	}
+#endif
 	return 0;
 }
 
@@ -249,6 +322,12 @@ static int qoriq_tmu_probe(struct platform_device *pdev)
 	struct qoriq_tmu_data *data;
 	struct device_node *np = pdev->dev.of_node;
 	u32 site = 0;
+#ifdef CONFIG_IMX8M_EXT_THERMAL	
+	struct device_node *ext_temp;	
+	char address=0;
+	u16 extval=0;
+	u8 *ptr;
+#endif
 
 	if (!np) {
 		dev_err(&pdev->dev, "Device OF-Node is NULL");
@@ -277,7 +356,16 @@ static int qoriq_tmu_probe(struct platform_device *pdev)
 		ret = -ENODEV;
 		goto err_iomap;
 	}
-
+#ifdef CONFIG_IMX8M_EXT_THERMAL		
+	ext_temp = of_parse_phandle(pdev->dev.of_node, "temp-i2c-bus", 0);
+	if (ext_temp) {
+		data->ext = of_find_i2c_adapter_by_node(ext_temp);
+		of_node_put(ext_temp);		
+		if (!data->ext) 
+			dev_err(&pdev->dev, "failed to get i2c adapter \n");
+	}
+	
+#endif	
 	qoriq_tmu_init_device(data);	/* TMU initialization */
 
 	ret = qoriq_tmu_calibration(pdev);	/* TMU calibration */
-- 
2.7.4

