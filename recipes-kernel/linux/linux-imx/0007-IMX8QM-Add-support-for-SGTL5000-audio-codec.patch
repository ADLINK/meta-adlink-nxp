From 1934c61c7ecfeb4a3c7db36f6cbae6a8ac8aae41 Mon Sep 17 00:00:00 2001
From: Arun Kumar <arunkumar.ev@adlinktech.com>
Date: Tue, 9 Jun 2020 13:00:10 +0530
Subject: [PATCH 07/11] IMX8QM: Add support for SGTL5000 audio codec

 * Add support for SGTL5000 audio codec on iMX8QM + LEC Base.
   Audio routing enabled for playback and recording.
 * DTS configuration of SGTL5000 codec
 * Disable regulator configurations in codec driver.

Signed-off-by: Arun Kumar <arunkumar.ev@adlinktech.com>
---
 .../boot/dts/adlink/adlink-lec-imx8qm.dtsi    | 81 +++++++++++--------
 arch/arm64/configs/adlink_imx8qm_defconfig    |  2 +
 sound/soc/codecs/sgtl5000.c                   | 26 ++++--
 sound/soc/fsl/imx-sgtl5000.c                  | 46 +++++++----
 4 files changed, 101 insertions(+), 54 deletions(-)

diff --git a/arch/arm64/boot/dts/adlink/adlink-lec-imx8qm.dtsi b/arch/arm64/boot/dts/adlink/adlink-lec-imx8qm.dtsi
index 77ce95d41855..c56d250152bf 100644
--- a/arch/arm64/boot/dts/adlink/adlink-lec-imx8qm.dtsi
+++ b/arch/arm64/boot/dts/adlink/adlink-lec-imx8qm.dtsi
@@ -132,38 +132,15 @@
 	};
 
 	sound: sound {
-		compatible = "fsl,imx7d-evk-wm8960",
-			   "fsl,imx-audio-wm8960";
-		model = "wm8960-audio";
-		cpu-dai = <&sai1>;
-		audio-codec = <&wm8960>;
-		codec-master;
-		/*
-		 * hp-det = <hp-det-pin hp-det-polarity>;
-		 * hp-det-pin: JD1 JD2  or JD3
-		 * hp-det-polarity = 0: hp detect high for headphone
-		 * hp-det-polarity = 1: hp detect high for speaker
-		 */
-		hp-det = <2 0>;
-		hp-det-gpios = <&gpio0 31 0>;
-		mic-det-gpios = <&gpio0 31 0>;
+		compatible = "fsl,imx-audio-sgtl5000";
+		model = "imx-sgtl5000";
+		cpu-dai = <&sai0>;
+		audio-codec = <&sgtl5000>;
 		audio-routing =
-			"Headphone Jack", "HP_L",
-			"Headphone Jack", "HP_R",
-			"Ext Spk", "SPK_LP",
-			"Ext Spk", "SPK_LN",
-			"Ext Spk", "SPK_RP",
-			"Ext Spk", "SPK_RN",
-			"LINPUT2", "Mic Jack",
-			"LINPUT3", "Mic Jack",
-			"RINPUT1", "Main MIC",
-			"RINPUT2", "Main MIC",
-			"Mic Jack", "MICB",
-			"Main MIC", "MICB",
-			"CPU-Playback", "ASRC-Playback",
-			"Playback", "CPU-Playback",
-			"ASRC-Capture", "CPU-Capture",
-			"CPU-Capture", "Capture";
+			"Mic Jack", "MIC_IN",
+			"Line In Jack", "LINE_IN",
+			"Line Out Jack", "LINE_OUT";
+		status = "okay";
 	};
 
 	sound-cs42888 {
@@ -173,7 +150,7 @@
 		esai-controller = <&esai0>;
 		audio-codec = <&cs42888>;
 		asrc-controller = <&asrc0>;
-		status = "okay";
+		status = "disabled";
 	};
 
 	lvds_backlight0: lvds_backlight@0 {
@@ -418,6 +395,17 @@
 			>;
 		};
 
+		pinctrl_sai0: sai0grp {
+			fsl,pins = <
+				SC_P_SPI0_SDO_AUD_SAI0_TXD		0x06000040
+				SC_P_SPI0_SDI_AUD_SAI0_RXD		0x06000040
+				SC_P_SPI0_CS1_AUD_SAI0_TXC		0x06000040
+				SC_P_SPI0_SCK_AUD_SAI0_RXC		0x06000040
+				SC_P_SPI0_CS0_AUD_SAI0_RXFS		0x06000040
+				SC_P_SPI2_CS1_AUD_SAI0_TXFS		0x06000040
+			>;
+		};
+
 		pinctrl_sai1: sai1grp {
 			fsl,pins = <
 				SC_P_SAI1_RXD_AUD_SAI1_RXD		0x06000040
@@ -696,6 +684,18 @@
 	pinctrl-1 = <&pinctrl_sim0>;
 	status = "okay";
 };
+
+&sai0 {
+	assigned-clocks = <&clk IMX8QM_AUD_PLL0_DIV>,
+			<&clk IMX8QM_AUD_ACM_AUD_PLL_CLK0_DIV>,
+			<&clk IMX8QM_AUD_ACM_AUD_REC_CLK0_DIV>,
+			<&clk IMX8QM_AUD_SAI_0_MCLK>;
+	assigned-clock-rates = <786432000>, <49152000>, <12288000>, <49152000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai0>;
+	status = "okay";
+};
+
 &sai1 {
 	assigned-clocks = <&clk IMX8QM_AUD_PLL0_DIV>,
 			<&clk IMX8QM_AUD_ACM_AUD_PLL_CLK0_DIV>,
@@ -818,6 +818,20 @@
 	pinctrl-0 = <&pinctrl_i2c0>;
 	status = "okay";
 
+	sgtl5000: codec@2a {
+		compatible = "fsl,sgtl5000";
+		reg = <0x2a>;
+		clocks = <&clk IMX8QM_AUD_MCLKOUT0>;
+		clock-names = "mclk";
+		power-domains = <&pd_mclk_out0>;
+		assigned-clocks = <&clk IMX8QM_AUD_PLL0_DIV>,
+			<&clk IMX8QM_AUD_ACM_AUD_PLL_CLK0_DIV>,
+			<&clk IMX8QM_AUD_ACM_AUD_REC_CLK0_DIV>,
+			<&clk IMX8QM_AUD_MCLKOUT0>;
+		assigned-clock-rates = <786432000>, <49152000>, <12288000>, <12288000>;
+		status = "okay";
+	};
+
 	isl29023@44 {
 		pinctrl-names = "default";
 		pinctrl-0 = <&pinctrl_isl29023>;
@@ -880,6 +894,7 @@
 				<&clk IMX8QM_AUD_ACM_AUD_REC_CLK0_DIV>,
 				<&clk IMX8QM_AUD_MCLKOUT0>;
 		assigned-clock-rates = <786432000>, <49152000>, <12288000>, <12288000>;
+		status = "disabled";
 	};
 };
 
@@ -915,7 +930,7 @@
 				<&clk IMX8QM_AUD_MCLKOUT0>;
 		assigned-clock-rates = <786432000>, <49152000>, <12288000>, <12288000>;
 		fsl,txs-rxm;
-		status = "okay";
+		status = "disabled";
 	};
 };
 
diff --git a/arch/arm64/configs/adlink_imx8qm_defconfig b/arch/arm64/configs/adlink_imx8qm_defconfig
index 0efb9d0cad39..ecf751064a9d 100644
--- a/arch/arm64/configs/adlink_imx8qm_defconfig
+++ b/arch/arm64/configs/adlink_imx8qm_defconfig
@@ -528,6 +528,7 @@ CONFIG_SND_SOC_IMX_AK4458=y
 CONFIG_SND_SOC_IMX_AK5558=y
 CONFIG_SND_SOC_IMX_AK4497=y
 CONFIG_SND_SOC_IMX_WM8960=y
+CONFIG_SND_SOC_IMX_SGTL5000=y
 CONFIG_SND_SOC_IMX_WM8524=y
 CONFIG_SND_SOC_IMX_CS42888=y
 CONFIG_SND_SOC_IMX_WM8962=y
@@ -541,6 +542,7 @@ CONFIG_SND_SOC_IMX_AUDMIX=y
 CONFIG_SND_SOC_SAMSUNG=y
 CONFIG_SND_SOC_RCAR=y
 CONFIG_SND_SOC_AK4613=y
+CONFIG_SND_SOC_SGTL5000=y
 CONFIG_SND_SIMPLE_CARD=y
 CONFIG_HID_A4TECH=y
 CONFIG_HID_APPLE=y
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index add18d6d77da..ff8c5cf6e811 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -31,6 +31,8 @@
 #define SGTL5000_DAP_REG_OFFSET	0x0100
 #define SGTL5000_MAX_REG_OFFSET	0x013A
 
+//#define ADLINK_DTS_REGULATOR
+
 /* default value of sgtl5000 registers */
 static const struct reg_default sgtl5000_reg_defaults[] = {
 	{ SGTL5000_CHIP_DIG_POWER,		0x0000 },
@@ -121,7 +123,9 @@ struct sgtl5000_priv {
 	int sysclk;	/* sysclk rate */
 	int master;	/* i2s master or not */
 	int fmt;	/* i2s data format */
+#ifdef ADLINK_DTS_REGULATOR
 	struct regulator_bulk_data supplies[SGTL5000_SUPPLY_NUM];
+#endif
 	int num_supplies;
 	struct regmap *regmap;
 	struct clk *mclk;
@@ -1112,6 +1116,7 @@ static const u8 vol_quot_table[] = {
  * 1. vddd provided by external or not
  * 2. vdda and vddio voltage value. > 3.1v or not
  */
+#ifdef ADLINK_DTS_REGULATOR
 static int sgtl5000_set_power_regs(struct snd_soc_component *component)
 {
 	int vddd;
@@ -1274,18 +1279,20 @@ static int sgtl5000_enable_regulators(struct i2c_client *client)
 
 	return ret;
 }
+#endif
 
 static int sgtl5000_probe(struct snd_soc_component *component)
 {
-	int ret;
 	u16 reg;
 	struct sgtl5000_priv *sgtl5000 = snd_soc_component_get_drvdata(component);
 
+#ifdef ADLINK_DTS_REGULATOR
+	int ret;
 	/* power up sgtl5000 */
 	ret = sgtl5000_set_power_regs(component);
 	if (ret)
 		goto err;
-
+#endif
 	/* enable small pop, introduce 400ms delay in turning off */
 	snd_soc_component_update_bits(component, SGTL5000_CHIP_REF_CTRL,
 				SGTL5000_SMALL_POP, 1);
@@ -1329,8 +1336,10 @@ static int sgtl5000_probe(struct snd_soc_component *component)
 
 	return 0;
 
+#ifdef ADLINK_DTS_REGULATOR
 err:
 	return ret;
+#endif
 }
 
 static const struct snd_soc_component_driver sgtl5000_driver = {
@@ -1404,10 +1413,11 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 
 	i2c_set_clientdata(client, sgtl5000);
 
+#ifdef ADLINK_DTS_REGULATOR
 	ret = sgtl5000_enable_regulators(client);
 	if (ret)
 		return ret;
-
+#endif
 	sgtl5000->regmap = devm_regmap_init_i2c(client, &sgtl5000_regmap);
 	if (IS_ERR(sgtl5000->regmap)) {
 		ret = PTR_ERR(sgtl5000->regmap);
@@ -1466,6 +1476,10 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 
 	/* Follow section 2.2.1.1 of AN3663 */
 	ana_pwr = SGTL5000_ANA_POWER_DEFAULT;
+
+#ifndef ADLINK_DTS_REGULATOR
+	sgtl5000->num_supplies = 0;
+#endif
 	if (sgtl5000->num_supplies <= VDDD) {
 		/* internal VDDD at 1.2V */
 		ret = regmap_update_bits(sgtl5000->regmap,
@@ -1556,9 +1570,10 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 	clk_disable_unprepare(sgtl5000->mclk);
 
 disable_regs:
+#ifdef ADLINK_DTS_REGULATOR
 	regulator_bulk_disable(sgtl5000->num_supplies, sgtl5000->supplies);
 	regulator_bulk_free(sgtl5000->num_supplies, sgtl5000->supplies);
-
+#endif
 	return ret;
 }
 
@@ -1567,9 +1582,10 @@ static int sgtl5000_i2c_remove(struct i2c_client *client)
 	struct sgtl5000_priv *sgtl5000 = i2c_get_clientdata(client);
 
 	clk_disable_unprepare(sgtl5000->mclk);
+#ifdef ADLINK_DTS_REGULATOR
 	regulator_bulk_disable(sgtl5000->num_supplies, sgtl5000->supplies);
 	regulator_bulk_free(sgtl5000->num_supplies, sgtl5000->supplies);
-
+#endif
 	return 0;
 }
 
diff --git a/sound/soc/fsl/imx-sgtl5000.c b/sound/soc/fsl/imx-sgtl5000.c
index 9b9a7ec52905..e4d5635b6898 100644
--- a/sound/soc/fsl/imx-sgtl5000.c
+++ b/sound/soc/fsl/imx-sgtl5000.c
@@ -43,22 +43,22 @@ static int imx_sgtl5000_dai_init(struct snd_soc_pcm_runtime *rtd)
 static const struct snd_soc_dapm_widget imx_sgtl5000_dapm_widgets[] = {
 	SND_SOC_DAPM_MIC("Mic Jack", NULL),
 	SND_SOC_DAPM_LINE("Line In Jack", NULL),
-	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	//SND_SOC_DAPM_HP("Headphone Jack", NULL),
 	SND_SOC_DAPM_SPK("Line Out Jack", NULL),
-	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+	//SND_SOC_DAPM_SPK("Ext Spk", NULL),
 };
 
 static int imx_sgtl5000_probe(struct platform_device *pdev)
 {
-	struct device_node *np = pdev->dev.of_node;
-	struct device_node *ssi_np, *codec_np;
-	struct platform_device *ssi_pdev;
+	//struct device_node *np = pdev->dev.of_node;
+	struct device_node *cpu_np = NULL, *codec_np = NULL;
+	struct platform_device *cpu_pdev;
 	struct i2c_client *codec_dev;
 	struct imx_sgtl5000_data *data = NULL;
-	int int_port, ext_port;
+	//int int_port, ext_port;
 	int ret;
-
-	ret = of_property_read_u32(np, "mux-int-port", &int_port);
+#if 0
+	/*ret = of_property_read_u32(np, "mux-int-port", &int_port);
 	if (ret) {
 		dev_err(&pdev->dev, "mux-int-port missing or invalid\n");
 		return ret;
@@ -93,22 +93,36 @@ static int imx_sgtl5000_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "audmux external port setup failed\n");
 		return ret;
 	}
+#endif
+	//ssi_np = of_parse_phandle(pdev->dev.of_node, "ssi-controller", 0);
+	cpu_np = of_parse_phandle(pdev->dev.of_node, "cpu-dai", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "cpu dai phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	cpu_pdev = of_find_device_by_node(cpu_np);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "failed to find SAI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
 
-	ssi_np = of_parse_phandle(pdev->dev.of_node, "ssi-controller", 0);
 	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
-	if (!ssi_np || !codec_np) {
+	if (!codec_np) {
 		dev_err(&pdev->dev, "phandle missing or invalid\n");
 		ret = -EINVAL;
 		goto fail;
 	}
 
-	ssi_pdev = of_find_device_by_node(ssi_np);
+	/*ssi_pdev = of_find_device_by_node(ssi_np);
 	if (!ssi_pdev) {
 		dev_err(&pdev->dev, "failed to find SSI platform device\n");
 		ret = -EPROBE_DEFER;
 		goto fail;
 	}
-	put_device(&ssi_pdev->dev);
+	put_device(&ssi_pdev->dev);*/
 	codec_dev = of_find_i2c_device_by_node(codec_np);
 	if (!codec_dev) {
 		dev_err(&pdev->dev, "failed to find codec platform device\n");
@@ -133,8 +147,8 @@ static int imx_sgtl5000_probe(struct platform_device *pdev)
 	data->dai.stream_name = "HiFi";
 	data->dai.codec_dai_name = "sgtl5000";
 	data->dai.codec_of_node = codec_np;
-	data->dai.cpu_of_node = ssi_np;
-	data->dai.platform_of_node = ssi_np;
+	data->dai.cpu_of_node = cpu_np;
+	data->dai.platform_of_node = cpu_np;
 	data->dai.init = &imx_sgtl5000_dai_init;
 	data->dai.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
 			    SND_SOC_DAIFMT_CBM_CFM;
@@ -161,7 +175,7 @@ static int imx_sgtl5000_probe(struct platform_device *pdev)
 		goto fail;
 	}
 
-	of_node_put(ssi_np);
+	of_node_put(cpu_np);
 	of_node_put(codec_np);
 
 	return 0;
@@ -169,7 +183,7 @@ static int imx_sgtl5000_probe(struct platform_device *pdev)
 fail:
 	if (data && !IS_ERR(data->codec_clk))
 		clk_put(data->codec_clk);
-	of_node_put(ssi_np);
+	of_node_put(cpu_np);
 	of_node_put(codec_np);
 
 	return ret;
-- 
2.17.1

