From 9fea951088ea6bdab504518a9e24a1469d31f124 Mon Sep 17 00:00:00 2001
From: "deepak.s" <deepak.s@adlinktech.com>
Date: Fri, 5 Apr 2024 15:43:59 +0530
Subject: [PATCH] use-buit-in-wifi-bt-firmware-thermal-TJ-point-to-100

---
 drivers/bluetooth/btmrvl_sdio.c             |  4 +-
 drivers/net/wireless/marvell/mwifiex/sdio.h |  6 +-
 drivers/thermal/imx8mm_thermal.c            | 92 +++++++++++++++++++++
 kernel/dma/mapping.c                        |  2 +
 4 files changed, 99 insertions(+), 5 deletions(-)

diff --git a/drivers/bluetooth/btmrvl_sdio.c b/drivers/bluetooth/btmrvl_sdio.c
index ba057ebfda5c..6b9525143641 100644
--- a/drivers/bluetooth/btmrvl_sdio.c
+++ b/drivers/bluetooth/btmrvl_sdio.c
@@ -290,7 +290,7 @@ static const struct btmrvl_sdio_device btmrvl_sdio_sd8987 = {
 
 static const struct btmrvl_sdio_device btmrvl_sdio_sd8997 = {
 	.helper         = NULL,
-	.firmware       = "mrvl/sdsd8997_combo_v4.bin",
+	.firmware       = "nxp/sdsd8997_combo_v4.bin",
 	.reg            = &btmrvl_reg_89xx,
 	.support_pscan_win_report = true,
 	.sd_blksz_fw_dl = 256,
@@ -1778,4 +1778,4 @@ MODULE_FIRMWARE("mrvl/sd8887_uapsta.bin");
 MODULE_FIRMWARE("mrvl/sd8897_uapsta.bin");
 MODULE_FIRMWARE("mrvl/sdsd8977_combo_v2.bin");
 MODULE_FIRMWARE("mrvl/sd8987_uapsta.bin");
-MODULE_FIRMWARE("mrvl/sdsd8997_combo_v4.bin");
+MODULE_FIRMWARE("nxp/sdsd8997_combo_v4.bin");
diff --git a/drivers/net/wireless/marvell/mwifiex/sdio.h b/drivers/net/wireless/marvell/mwifiex/sdio.h
index 3a24bb48b299..f86e7ab8d8d0 100644
--- a/drivers/net/wireless/marvell/mwifiex/sdio.h
+++ b/drivers/net/wireless/marvell/mwifiex/sdio.h
@@ -24,10 +24,10 @@
 #define SD8897_DEFAULT_FW_NAME "mrvl/sd8897_uapsta.bin"
 #define SD8887_DEFAULT_FW_NAME "mrvl/sd8887_uapsta.bin"
 #define SD8801_DEFAULT_FW_NAME "mrvl/sd8801_uapsta.bin"
-#define SD8977_DEFAULT_FW_NAME "mrvl/sdsd8977_combo_v2.bin"
+#define SD8977_DEFAULT_FW_NAME "nxp/sdsd8977_combo_v2.bin"
 #define SD8987_DEFAULT_FW_NAME "mrvl/sd8987_uapsta.bin"
-#define SD8997_DEFAULT_FW_NAME "mrvl/sdsd8997_combo_v4.bin"
-#define SD8997_SDIOUART_FW_NAME "mrvl/sdiouart8997_combo_v4.bin"
+#define SD8997_DEFAULT_FW_NAME "nxp/sdsd8997_combo_v4.bin"
+#define SD8997_SDIOUART_FW_NAME "nxp/sdsd8997_combo_v4.bin"
 
 #define BLOCK_MODE	1
 #define BYTE_MODE	0
diff --git a/drivers/thermal/imx8mm_thermal.c b/drivers/thermal/imx8mm_thermal.c
index 13394f4dbc3c..be1d2a60d742 100644
--- a/drivers/thermal/imx8mm_thermal.c
+++ b/drivers/thermal/imx8mm_thermal.c
@@ -92,6 +92,88 @@ static int imx8mm_tmu_get_temp(void *data, int *temp)
 	return 0;
 }
 
+#define OCOTP_BASE_ADDR 0x30350000
+struct ocotp_regs {
+       u32     ctrl;
+       u32     ctrl_set;
+       u32     ctrl_clr;
+       u32     ctrl_tog;
+       u32     timing;
+       u32     rsvd0[3];
+       u32     data;
+       u32     rsvd1[3];
+       u32     read_ctrl;
+       u32     rsvd2[3];
+       u32     read_fuse_data;
+       u32     rsvd3[3];
+       u32     sw_sticky;
+       u32     rsvd4[3];
+       u32     scs;
+       u32     scs_set;
+       u32     scs_clr;
+       u32     scs_tog;
+       u32     crc_addr;
+       u32     rsvd5[3];
+       u32     crc_value;
+       u32     rsvd6[3];
+       u32     version;
+       u32     rsvd7[0xdb];
+
+       /* fuse banks */
+       struct fuse_bank {
+               u32     fuse_regs[0x10];
+       } bank[0];
+};
+
+struct fuse_bank1_regs {
+       u32 tester3;
+       u32 rsvd0[3];
+       u32 tester4;
+       u32 rsvd1[3];
+       u32 tester5;
+       u32 rsvd2[3];
+       u32 cfg0;
+       u32 rsvd3[3];
+};
+
+
+static int get_cpu_temp_grade_maxc(void)
+{
+       unsigned int val = 0;
+       int minc = 0, maxc = 0;
+
+       if (of_machine_is_compatible("fsl,imx8mp") || of_machine_is_compatible("fsl,imx8mm")) {
+               struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+               struct fuse_bank *bank = &ocotp->bank[1];
+               struct fuse_bank1_regs *fuse = (struct fuse_bank1_regs *)bank->fuse_regs;
+               void __iomem *tmpp = ioremap_cache((phys_addr_t)fuse, sizeof(struct fuse_bank1_regs));
+               if (!tmpp)
+                       return -ENOMEM;
+
+               fuse = (struct fuse_bank1_regs *)tmpp;
+               val = fuse->tester3;
+               switch ((val >> 5) & 0x3) {
+               case 0: // Commercial (0 to 95 ¢FXC)
+                       minc = 0;
+                       maxc = 95;
+                       break;
+               case 1: // Extended Commercial (-20 ¢FXC to 105 ¢FXC)
+                       minc = -20;
+                       maxc = 105;
+                       break;
+               case 2: // Industrial (-40 ¢FXC to 105 ¢FXC)
+                       minc = -40;
+                       maxc = 105;
+                       break;
+               case 3: // Automotive (-40 ¢FXC to 125 ¢FXC)
+                       minc = -40;
+                       maxc = 125;
+                       break;
+               }
+       }
+       return maxc;
+}
+
 static int imx8mp_tmu_get_temp(void *data, int *temp)
 {
 	struct tmu_sensor *sensor = data;
@@ -235,6 +317,16 @@ static int imx8mm_tmu_probe(struct platform_device *pdev)
 			goto disable_clk;
 		}
 		tmu->sensors[i].hw_id = i;
+               trips = of_thermal_get_trip_points(tmu->sensors[i].tzd);
+
+               /* get the thermal trip temp */
+               if (of_machine_is_compatible("fsl,imx8mp") || of_machine_is_compatible("fsl,imx8mm")) {
+                       tmu->sensors[i].temp_passive = ((get_cpu_temp_grade_maxc() - 10) * 1000);
+                       tmu->sensors[i].temp_critical = (get_cpu_temp_grade_maxc() * 1000);
+               } else {
+               tmu->sensors[i].temp_passive = trips[0].temperature;
+               tmu->sensors[i].temp_critical = trips[1].temperature;
+               }
 
 		tmu->sensors[i].cdev = devfreq_cooling_register();
 		if (IS_ERR(tmu->sensors[i].cdev)) {
diff --git a/kernel/dma/mapping.c b/kernel/dma/mapping.c
index 33437d620644..cfab97d76d27 100644
--- a/kernel/dma/mapping.c
+++ b/kernel/dma/mapping.c
@@ -495,6 +495,8 @@ void *dma_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,
 {
 	const struct dma_map_ops *ops = get_dma_ops(dev);
 	void *cpu_addr;
+	
+       	dma_set_mask_and_coherent(dev,DMA_BIT_MASK(32));
 
 	WARN_ON_ONCE(!dev->coherent_dma_mask);
 
-- 
2.43.2

