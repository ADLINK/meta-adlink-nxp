From 468e3b92120559df372052d4dd20a88a4e2b8a0c Mon Sep 17 00:00:00 2001
From: Arun Kumar E V <arunkumar@ltts.com>
Date: Wed, 27 Nov 2019 16:22:47 +0530
Subject: [PATCH] IMX6R2: Added support for OV13850 camera sensor

 * Added driver for ov13850 camera sensor, only raw capture
   is supported. Sensor operating on 4 lanes. Only reset line is
   controlled from driver for power sequence as other power down
   and voltage line is not software controlled.
 * Supported resolutions - 2112 x 1568, 4224x3136
 * Changes in IPU and CSI to enable BGGR data, IPU will interpret
   this data as GENERIC data.
 * Host is configured to run in 8 bit mode, as 10 bit image capture
   is still not working.
 * Discard IC path as no image processing in IPU supported for this
   format and hardcode to NONGATED clock mode as suggested for MIPI.
 * Add an additional streamon ioctl as frequent frame sync issues
   were observed with default streamon procedure.

Signed-off-by: Arun Kumar E V <arunkumar@ltts.com>

diff --git a/arch/arm/boot/dts/lec-imx6.dtsi b/arch/arm/boot/dts/lec-imx6.dtsi
index dd1e715..9914b1e 100644
--- a/arch/arm/boot/dts/lec-imx6.dtsi
+++ b/arch/arm/boot/dts/lec-imx6.dtsi
@@ -17,9 +17,11 @@
 #define CONFIG_I2S_AUDIO	2
 
 /* The LEC-Base carrier doesn't include cameras, but allows connecting some. */
-#define CONFIG_SER_CAMERA	3c /* I2C addr of serial camera, hex without "0x" */
+//#define CONFIG_SER_CAMERA	3c /* I2C addr of serial camera, hex without "0x" */
 //#define CONFIG_PAR_CAMERA	3c /* I2C addr of parallel camera */
 
+#define ENABLE_OV13850	1
+
 /* Freescale defines 2 alternative DT nodes for the VPU: The one normally active
  * loads a driver called 'mxc_vpu'. The other, disabled one, would invoke a
  * different driver named 'coda'. I don't know what state it is in; none of
@@ -269,7 +271,7 @@
 		pinctrl-names = "default";
 		pinctrl-0 = <&pinctrl_ipu1>;
 		disp-power-on-supply = <&reg_smarc_lcd_vdd>; /* unsupported by driver */
-		status = "okay";
+		status = "disabled";
 	};
 
 	backlight {
@@ -301,7 +303,7 @@
 	};
 #endif
 
-#ifdef CONFIG_SER_CAMERA
+#if defined(CONFIG_SER_CAMERA) || defined(ENABLE_OV13850)
 	v4l2_cap_1 {
 		compatible = "fsl,imx6q-v4l2-capture";
 		ipu_id = <0>;
@@ -336,10 +338,6 @@
 	pinctrl-0 = <&pinctrl_ipu1_csi0>;
 };
 
-&mipi_csi {
-	status = "okay";
-};
-
 #if VPU_CODA
 &vpu {
 	status = "okay";
@@ -504,6 +502,22 @@
 		reg = <0x58>;
 	};
 
+	ov13850: ov13850@10 {
+		compatible = "ovti,ov13850";
+		reg = <0x10>;
+		pinctrl-names = "ov13850_camera_default", "ov13850_camera_sleep";
+		pinctrl-0 = <&pinctrl_ov13850_default>;
+		pinctrl-1 = <&pinctrl_ov13850_sleep>;
+		rst-gpios = <&gpio5 8 GPIO_ACTIVE_HIGH>;
+		/*pwdn-gpios = <&gpio5 7 GPIO_ACTIVE_HIGH>;*/
+		clocks = <&clks IMX6QDL_CLK_CKO>;
+		clock-names = "csi_mclk";
+		csi_id = <1>;
+                mclk = <24000000>;
+                mclk_source = <0>;
+		status = "okay";
+	};
+
 	carrier_misc_control: pcf8575@20 {	/* GPIO expander on LEC-Base R1 carrier */
 		compatible = "nxp,pcf8575";
 		reg = <0x20>;
@@ -1096,6 +1110,21 @@
 				MX6QDL_PAD_GPIO_1__WDOG2_B 0x80000000
 			>;
 		};
+
+		pinctrl_ov13850_default: ov13850_default {
+			fsl,pins = <
+				MX6QDL_PAD_DISP0_DAT14__GPIO5_IO08	0x80000000
+				MX6QDL_PAD_DISP0_DAT13__GPIO5_IO07	0x80000000
+			>;
+		};
+
+		pinctrl_ov13850_sleep: ov13850_sleep {
+			fsl,pins = <
+				MX6QDL_PAD_DISP0_DAT14__GPIO5_IO08	0x80000000
+				MX6QDL_PAD_DISP0_DAT13__GPIO5_IO07	0x80000000
+			>;
+		};
+
 	};
 };
 
@@ -1160,6 +1189,16 @@
 };
 #endif
 
+#ifdef ENABLE_OV13850
+&mipi_csi {
+	ipu_id = <0>;
+	csi_id = <1>;
+	v_channel = <1>;
+	lanes = <4>;
+	status = "okay";
+};
+#endif
+
 &mlb {		/* SMARC AFB_DIFF1-3 */
 	/* Driver doesn't seem to support differential (6-pin) mode. */
 	//status = "okay";
diff --git a/drivers/media/platform/mxc/capture/Kconfig b/drivers/media/platform/mxc/capture/Kconfig
index 040b6a0..5c0ac36 100644
--- a/drivers/media/platform/mxc/capture/Kconfig
+++ b/drivers/media/platform/mxc/capture/Kconfig
@@ -49,6 +49,13 @@ config MXC_CAMERA_OV5642
 	---help---
 	  If you plan to use the ov5642 Camera with your MXC system, say Y here.
 
+config CAMERA_OV13850
+	tristate "Omnivision OV13850 camera sensor"
+        depends on !VIDEO_MXC_EMMA_CAMERA && I2C
+	depends on VIDEO_V4L2_MXC_INT_DEVICE
+	---help---
+	  This is a MIPI sensor driver for OV13850 camera sensor.
+
 config MXC_CAMERA_OV5640_MIPI
 	tristate "OmniVision ov5640 camera support using mipi"
 	depends on !VIDEO_MXC_EMMA_CAMERA && I2C && MXC_MIPI_CSI2
diff --git a/drivers/media/platform/mxc/capture/Makefile b/drivers/media/platform/mxc/capture/Makefile
index e6e4b99..69c7496 100644
--- a/drivers/media/platform/mxc/capture/Makefile
+++ b/drivers/media/platform/mxc/capture/Makefile
@@ -36,3 +36,5 @@ adv7180_tvin-objs := adv7180.o
 obj-$(CONFIG_MXC_TVIN_ADV7180) += adv7180_tvin.o
 
 obj-$(CONFIG_VIDEO_V4L2_MXC_INT_DEVICE) += v4l2-int-device.o
+
+obj-$(CONFIG_CAMERA_OV13850) += ov13850.o
diff --git a/drivers/media/platform/mxc/capture/ipu_csi_enc.c b/drivers/media/platform/mxc/capture/ipu_csi_enc.c
index 3a824a9..366d3a1 100644
--- a/drivers/media/platform/mxc/capture/ipu_csi_enc.c
+++ b/drivers/media/platform/mxc/capture/ipu_csi_enc.c
@@ -49,6 +49,7 @@ static irqreturn_t csi_enc_callback(int irq, void *dev_id)
 {
 	cam_data *cam = (cam_data *) dev_id;
 
+	pr_debug("%s: %d\n", __func__, irq);
 	if (cam->enc_callback == NULL)
 		return IRQ_HANDLED;
 
@@ -126,6 +127,9 @@ static int csi_enc_setup(cam_data *cam)
 		pixel_fmt = IPU_PIX_FMT_BGR32;
 	else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_RGB32)
 		pixel_fmt = IPU_PIX_FMT_RGB32;
+	/*add SBGGR8 pixel format here, pass IPU_PIX_FMT_GENERIC*/
+	else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_SBGGR8)
+		pixel_fmt = IPU_PIX_FMT_GENERIC;
 	else {
 		printk(KERN_ERR "format not supported\n");
 		return -EINVAL;
@@ -141,6 +145,8 @@ static int csi_enc_setup(cam_data *cam)
 
 			if (cam->ipu == ipu_get_soc(ipu_id)
 				&& cam->csi == csi_id) {
+				pr_debug("%s: ipu: %d, csi: %d\n",
+						__func__, ipu_id, csi_id);
 				params.csi_mem.mipi_en = true;
 				params.csi_mem.mipi_vc =
 				mipi_csi2_get_virtual_channel(mipi_csi2_info);
diff --git a/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c b/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c
index 3d7adec..d936852 100644
--- a/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c
+++ b/drivers/media/platform/mxc/capture/mxc_v4l2_capture.c
@@ -125,15 +125,24 @@ static struct v4l2_output mxc_capture_outputs[MXC_V4L2_CAPTURE_NUM_OUTPUTS] = {
 	 },
 };
 
+/*Disable IPU processing path*/
 static struct v4l2_input mxc_capture_inputs[MXC_V4L2_CAPTURE_NUM_INPUTS] = {
 	{
 	 .index = 0,
+#ifdef USE_IC_MEM
 	 .name = "CSI IC MEM",
+#else
+	 .name = "CSI MEM",
+#endif
 	 .type = V4L2_INPUT_TYPE_CAMERA,
 	 .audioset = 0,
 	 .tuner = 0,
 	 .std = V4L2_STD_UNKNOWN,
-	 .status = 0,
+#ifdef USE_IC_MEM
+	.status = 0,
+#else
+	.status = V4L2_IN_ST_NO_POWER,
+#endif
 	 },
 	{
 	 .index = 1,
@@ -401,6 +410,7 @@ static inline int valid_mode(u32 palette)
  *
  * @return status  0 Success
  */
+
 static int mxc_streamon(cam_data *cam)
 {
 	struct mxc_v4l_frame *frame;
@@ -475,7 +485,12 @@ static int mxc_streamon(cam_data *cam)
 			return err;
 	}
 
-	cam->capture_on = true;
+	/*Trigger sensor streaming once entire host is setup*/
+	vidioc_int_s_streamon(cam->sensor, &err);
+	if(err < 0)
+		return err;
+	else
+		cam->capture_on = true;
 
 	return err;
 }
@@ -816,10 +831,27 @@ static int mxc_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 
 	pr_debug("In MVC: mxc_v4l2_s_fmt\n");
 
+	/*Reset all crop parameters as per received width and height*/
+	cam->crop_bounds.top = cam->crop_bounds.left = 0;
+	cam->crop_bounds.width = f->fmt.pix.width;
+	cam->crop_bounds.height = f->fmt.pix.height;
+	cam->crop_defrect.top = cam->crop_defrect.left = 0;
+	cam->crop_defrect.width = f->fmt.pix.width;
+	cam->crop_defrect.height = f->fmt.pix.height;
+	cam->crop_current.top = cam->crop_current.left = 0;
+	cam->crop_current.width = f->fmt.pix.width;
+	cam->crop_current.height = f->fmt.pix.height;
+
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 		pr_debug("   type=V4L2_BUF_TYPE_VIDEO_CAPTURE\n");
-		if (!valid_mode(f->fmt.pix.pixelformat)) {
+		if(f->fmt.pix.pixelformat == V4L2_PIX_FMT_SBGGR8)
+		{
+			/*Pass this format as valid*/
+			pr_debug("%s: received fmt: SBGGR8\n",
+						__func__);
+		}
+		else if (!valid_mode(f->fmt.pix.pixelformat)) {
 			pr_err("ERROR: v4l2 capture: mxc_v4l2_s_fmt: format "
 			       "not supported\n");
 			return -EINVAL;
@@ -831,6 +863,7 @@ static int mxc_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 		 */
 		if (strcmp(mxc_capture_inputs[cam->current_input].name,
 			   "CSI MEM") == 0) {
+			pr_debug(KERN_INFO "%s: CSI MEM select\n", __func__);
 			f->fmt.pix.width = cam->crop_current.width;
 			f->fmt.pix.height = cam->crop_current.height;
 		}
@@ -914,11 +947,18 @@ static int mxc_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 			size = f->fmt.pix.width * f->fmt.pix.height * 3 / 2;
 			bytesperline = f->fmt.pix.width;
 			break;
+		case V4L2_PIX_FMT_SBGGR8:
+			/*adding RAW format here, (width * height) for
+			 8 bits and (width * height * 2) for 10 bits*/
+			pr_debug("%s: pix fmt - PIX_FMT_SBGGR8\n", __func__);
+			size = f->fmt.pix.width * f->fmt.pix.height;
+			bytesperline = f->fmt.pix.width;
+			break;
 		default:
 			break;
 		}
 
-		if (f->fmt.pix.bytesperline < bytesperline)
+		/*if (f->fmt.pix.bytesperline < bytesperline)
 			f->fmt.pix.bytesperline = bytesperline;
 		else
 			bytesperline = f->fmt.pix.bytesperline;
@@ -926,7 +966,13 @@ static int mxc_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 		if (f->fmt.pix.sizeimage < size)
 			f->fmt.pix.sizeimage = size;
 		else
-			size = f->fmt.pix.sizeimage;
+			size = f->fmt.pix.sizeimage;*/
+		f->fmt.pix.sizeimage = size;
+		f->fmt.pix.bytesperline = bytesperline;
+
+		retval = vidioc_int_s_fmt_cap(cam->sensor, f);
+		if(retval)
+			return -EINVAL;
 
 		cam->v2f.fmt.pix = f->fmt.pix;
 		break;
@@ -1265,6 +1311,7 @@ static int mxc_v4l2_s_ctrl(cam_data *cam, struct v4l2_control *c)
 	return ret;
 }
 
+
 /*!
  * V4L2 - mxc_v4l2_s_param function
  * Allows setting of capturemode and frame rate.
@@ -1349,6 +1396,8 @@ static int mxc_v4l2_s_param(cam_data *cam, struct v4l2_streamparm *parm)
 		csi_param.clk_mode = IPU_CSI_CLK_MODE_CCIR656_INTERLACED;
 	else
 		csi_param.clk_mode = IPU_CSI_CLK_MODE_GATED_CLK;
+	/*MIPI should be driven in NONGATED clk mode*/
+	csi_param.clk_mode = IPU_CSI_CLK_MODE_NONGATED_CLK;
 
 	csi_param.pixclk_pol = ifparm.u.bt656.latch_clk_inv;
 
@@ -1361,9 +1410,13 @@ static int mxc_v4l2_s_param(cam_data *cam, struct v4l2_streamparm *parm)
 		csi_param.data_width = IPU_CSI_DATA_WIDTH_8;
 	}
 
-	csi_param.Vsync_pol = ifparm.u.bt656.nobt_vs_inv;
-	csi_param.Hsync_pol = ifparm.u.bt656.nobt_hs_inv;
-	csi_param.ext_vsync = ifparm.u.bt656.bt_sync_correct;
+	/*hardcoding 8 bits here, only this mode supported now*/
+	csi_param.data_width = IPU_CSI_DATA_WIDTH_8;
+
+	/*We are not handling these controls yet*/
+	//csi_param.Vsync_pol = ifparm.u.bt656.nobt_vs_inv;
+	//csi_param.Hsync_pol = ifparm.u.bt656.nobt_hs_inv;
+	//csi_param.ext_vsync = ifparm.u.bt656.bt_sync_correct;
 
 	/* if the capturemode changed, the size bounds will have changed. */
 	cam_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
@@ -1398,7 +1451,6 @@ static int mxc_v4l2_s_param(cam_data *cam, struct v4l2_streamparm *parm)
 			       cam->crop_bounds.height,
 			       cam_fmt.fmt.pix.pixelformat, csi_param);
 
-
 exit:
 	if (cam->overlay_on == true)
 		start_preview(cam);
@@ -1489,6 +1541,9 @@ static int mxc_v4l2_g_std(cam_data *cam, v4l2_std_id *e)
 	return 0;
 }
 
+/*add dump function from ipu_common.c*/
+extern void ipu_dump_registers(struct ipu_soc*);
+
 /*!
  * Dequeue one V4L capture buffer
  *
@@ -1506,6 +1561,10 @@ static int mxc_v4l_dqueue(cam_data *cam, struct v4l2_buffer *buf)
 
 	pr_debug("In MVC:mxc_v4l_dqueue\n");
 
+	/*dump IPU and CSI registers*/
+	pr_debug("**** Register dump before v4l dequeue****\n");
+	ipu_dump_registers(ipu_get_soc(cam->ipu_id));
+
 	if (!wait_event_interruptible_timeout(cam->enc_queue,
 					      cam->enc_counter != 0,
 					      10 * HZ)) {
@@ -1551,6 +1610,11 @@ static int mxc_v4l_dqueue(cam_data *cam, struct v4l2_buffer *buf)
 	buf->field = cam->frame[frame->index].buffer.field;
 	spin_unlock_irqrestore(&cam->dqueue_int_lock, lock_flags);
 
+	pr_debug("%s: buf index: %u\n", __func__, buf->index);
+	pr_debug("%s: bytesused: %u\n", __func__, buf->bytesused);
+	pr_debug("%s: timestamp: %lu\n", __func__, buf->timestamp.tv_usec);
+
+
 	up(&cam->busy_lock);
 	return retval;
 }
@@ -1646,6 +1710,9 @@ static int mxc_v4l_open(struct file *file)
 		else
 			csi_param.data_width = IPU_CSI_DATA_WIDTH_8;
 
+		/*harcoding 8 bits here, since only this mode is supported*/
+		csi_param.data_width = IPU_CSI_DATA_WIDTH_8;
+
 
 		csi_param.Vsync_pol = ifparm.u.bt656.nobt_vs_inv;
 		csi_param.Hsync_pol = ifparm.u.bt656.nobt_hs_inv;
@@ -1684,6 +1751,8 @@ static int mxc_v4l_open(struct file *file)
 			__func__,
 			cam->crop_current.width, cam->crop_current.height);
 
+		/*hardcode GENERIC data here, GENERIC_16 not yet supported*/
+		cam_fmt.fmt.pix.pixelformat = IPU_PIX_FMT_GENERIC;
 		csi_param.data_fmt = cam_fmt.fmt.pix.pixelformat;
 		pr_debug("On Open: Input to ipu size is %d x %d\n",
 				cam_fmt.fmt.pix.width, cam_fmt.fmt.pix.height);
@@ -1697,6 +1766,7 @@ static int mxc_v4l_open(struct file *file)
 					cam->crop_bounds.height,
 					cam_fmt.fmt.pix.pixelformat,
 					csi_param);
+
 		clk_prepare_enable(sensor->sensor_clk);
 		vidioc_int_s_power(cam->sensor, 1);
 		vidioc_int_init(cam->sensor);
@@ -2075,6 +2145,7 @@ static long mxc_v4l_do_ioctl(struct file *file,
 	case VIDIOC_STREAMON: {
 		pr_debug("   case VIDIOC_STREAMON\n");
 		retval = mxc_streamon(cam);
+
 		break;
 	}
 
diff --git a/drivers/media/platform/mxc/capture/ov13850.c b/drivers/media/platform/mxc/capture/ov13850.c
new file mode 100644
index 00000000..a1924e9
--- /dev/null
+++ b/drivers/media/platform/mxc/capture/ov13850.c
@@ -0,0 +1,1555 @@
+/*
+ * ov13850 sensor level driver
+ * This driver used to capture raw BGGR data
+ * 4 lanes, mipi 8 bit mode
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/mipi_csi2.h>
+#include <media/media-entity.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of_gpio.h>
+#include "v4l2-int-device.h"
+#include "mxc_v4l2_capture.h"
+
+#define OV13850_XVCLK_FREQ		24000000
+
+#define CHIP_ID				0x00d850
+#define OV13850_REG_CHIP_ID		0x300a
+
+#define OV13850_REG_CTRL_MODE		0x0100
+#define OV13850_MODE_SW_STANDBY		0x0
+#define OV13850_MODE_STREAMING		BIT(0)
+
+#define OV13850_REG_EXPOSURE		0x3500
+#define	OV13850_EXPOSURE_MIN		4
+#define	OV13850_EXPOSURE_STEP		1
+#define OV13850_VTS_MAX			0x7fff
+
+#define OV13850_REG_GAIN_H		0x350a
+#define OV13850_REG_GAIN_L		0x350b
+#define OV13850_GAIN_H_MASK		0x07
+#define OV13850_GAIN_H_SHIFT		8
+#define OV13850_GAIN_L_MASK		0xff
+#define OV13850_GAIN_MIN		0x10
+#define OV13850_GAIN_MAX		0xf8
+#define OV13850_GAIN_STEP		1
+#define OV13850_GAIN_DEFAULT		0x10
+
+#define OV13850_REG_TEST_PATTERN	0x5e00
+#define ENABLE_TEST_PATTERN	0
+
+#define OV13850_REG_VTS			0x380e
+
+#define REG_NULL			0xFFFF
+
+#define OV13850_REG_VALUE_08BIT		1
+#define OV13850_REG_VALUE_16BIT		2
+#define OV13850_REG_VALUE_24BIT		3
+
+#define OV13850_LANES			4
+#define OV13850_BITS_PER_SAMPLE		10
+
+#define OV13850_CHIP_REVISION_REG	0x302A
+#define OV13850_R1A			0xb1
+#define OV13850_R2A			0xb2
+
+#define OF_CAMERA_PINCTRL_STATE_DEFAULT	"ov13850_camera_default"
+#define OF_CAMERA_PINCTRL_STATE_SLEEP	"ov13850_camera_sleep"
+
+#define OV13850_NAME			"ov13850_mipi_raw"
+#define OV13850_VCHANNEL	0x4813
+
+#define OV13850_RES_HIGH_WIDTH		4224
+#define OV13850_RES_HIGH_HEIGHT		3136
+#define OV13850_RES_LOW_WIDTH		2112
+#define OV13850_RES_LOW_HEIGHT		1568
+
+#define DEFAULT_FPS	15
+
+static int reset_gpio;//, pwdn_gpio;
+static struct sensor_data ov13850_data;
+static u32 ov13850_revid;
+
+static const struct regval *ov13850_global_regs;
+
+struct regval {
+	u16 addr;
+	u8 val;
+};
+
+struct ov13850_mode {
+	u32 width;
+	u32 height;
+	struct v4l2_fract max_fps;
+	u32 hts_def;
+	u32 vts_def;
+	u32 exp_def;
+	const struct regval *reg_list;
+};
+
+struct ov13850 {
+	struct i2c_client	*client;
+	struct clk		*xvclk;
+	int			reset_gpio;
+	int			pwdn_gpio;
+
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pins_default;
+	struct pinctrl_state	*pins_sleep;
+
+	struct media_pad	pad;
+	struct v4l2_ctrl	*exposure;
+	struct v4l2_ctrl	*anal_gain;
+	struct v4l2_ctrl	*digi_gain;
+	struct v4l2_ctrl	*hblank;
+	struct v4l2_ctrl	*vblank;
+	struct v4l2_ctrl	*test_pattern;
+	struct mutex		mutex;
+	bool			streaming;
+	bool			power_on;
+	const struct ov13850_mode *cur_mode;
+	u32			module_index;
+};
+
+struct ov13850 ov13850_info;
+
+/*Init settings for 3.3MP resolution*/
+static const struct regval ov13850_init_2112x1568_r2a[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x01},
+	{0x0301, 0x00},
+	{0x0302, 0x28},
+	{0x0303, 0x00},
+	{0x030a, 0x00},
+	{0x300f, 0x10},
+	{0x3010, 0x01},
+	{0x3011, 0x76},
+	{0x3012, 0x41},
+	{0x3013, 0x12},
+	{0x3014, 0x11},
+	{0x301f, 0x03},
+	{0x3106, 0x00},
+	{0x3210, 0x47},
+	{0x3500, 0x00},
+	{0x3501, 0xc0},
+	{0x3502, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x350a, 0x00},
+	{0x350b, 0x80},
+	{0x350e, 0x00},
+	{0x350f, 0x10},
+	{0x351a, 0x00},
+	{0x351b, 0x10},
+	{0x351c, 0x00},
+	{0x351d, 0x20},
+	{0x351e, 0x00},
+	{0x351f, 0x40},
+	{0x3520, 0x00},
+	{0x3521, 0x80},
+	{0x3600, 0xc0},
+	{0x3601, 0xfc},
+	{0x3602, 0x02},
+	{0x3603, 0x78},
+	{0x3604, 0xb1},
+	{0x3605, 0x95},
+	{0x3606, 0x73},
+	{0x3607, 0x07},
+	{0x3609, 0x40},
+	{0x360a, 0x30},
+	{0x360b, 0x91},
+	{0x360C, 0x09},
+	{0x360f, 0x02},
+	{0x3611, 0x10},
+	{0x3612, 0x27},
+	{0x3613, 0x33},
+	{0x3615, 0x0c},
+	{0x3616, 0x0e},
+	{0x3641, 0x02},
+	{0x3660, 0x82},
+	{0x3668, 0x54},
+	{0x3669, 0x00},
+	{0x366a, 0x3f},
+	{0x3667, 0xa0},
+	{0x3702, 0x40},
+	{0x3703, 0x44},
+	{0x3704, 0x2c},
+	{0x3705, 0x01},
+	{0x3706, 0x15},
+	{0x3707, 0x44},
+	{0x3708, 0x3c},
+	{0x3709, 0x1f},
+	{0x370a, 0x27},
+	{0x370b, 0x3c},
+	{0x3720, 0x55},
+	{0x3722, 0x84},
+	{0x3728, 0x40},
+	{0x372a, 0x00},
+	{0x372b, 0x02},
+	{0x372e, 0x22},
+	{0x372f, 0xa0},
+	{0x3730, 0x00},
+	{0x3731, 0x00},
+	{0x3732, 0x00},
+	{0x3733, 0x00},
+	{0x3710, 0x28},
+	{0x3716, 0x03},
+	{0x3718, 0x1c},
+	{0x3719, 0x0c},
+	{0x371a, 0x08},
+	{0x371c, 0xfc},
+	{0x3748, 0x00},
+	{0x3760, 0x13},
+	{0x3761, 0x33},
+	{0x3762, 0x86},
+	{0x3763, 0x16},
+	{0x3767, 0x24},
+	{0x3768, 0x06},
+	{0x3769, 0x45},
+	{0x376c, 0x23},
+	{0x376f, 0x80},
+	{0x3773, 0x06},
+	{0x3d84, 0x00},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xbf},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x4b},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x11},
+	{0x380d, 0xa0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x01},
+	{0x3821, 0x06},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x08},
+	{0x3837, 0x02},
+	{0x4000, 0xf1},
+	{0x4001, 0x00},
+	{0x400b, 0x0c},
+	{0x4011, 0x00},
+	{0x401a, 0x00},
+	{0x401b, 0x00},
+	{0x401c, 0x00},
+	{0x401d, 0x00},
+	{0x4020, 0x00},
+	{0x4021, 0xe4},
+	{0x4022, 0x04},
+	{0x4023, 0xd7},
+	{0x4024, 0x05},
+	{0x4025, 0xbc},
+	{0x4026, 0x05},
+	{0x4027, 0xbf},
+	{0x4028, 0x00},
+	{0x4029, 0x02},
+	{0x402a, 0x04},
+	{0x402b, 0x08},
+	{0x402c, 0x02},
+	{0x402d, 0x02},
+	{0x402e, 0x0c},
+	{0x402f, 0x08},
+	{0x403d, 0x2c},
+	{0x403f, 0x7F},
+	{0x4041, 0x07},
+	{0x4500, 0x82},
+	{0x4501, 0x3c},
+	{0x458b, 0x00},
+	{0x459c, 0x00},
+	{0x459d, 0x00},
+	{0x459e, 0x00},
+	{0x4601, 0x83},
+	{0x4602, 0x22},
+	{0x4603, 0x01},
+	{0x4837, 0x19},
+	{0x4d00, 0x04},
+	{0x4d01, 0x42},
+	{0x4d02, 0xd1},
+	{0x4d03, 0x90},
+	{0x4d04, 0x66},
+	{0x4d05, 0x65},
+	{0x4d0b, 0x00},
+	{0x5000, 0x0e},
+	{0x5001, 0x01},
+	{0x5002, 0x07},
+	{0x5003, 0x4f},
+	{0x5013, 0x40},
+	{0x501c, 0x00},
+	{0x501d, 0x10},
+	{0x5100, 0x30},
+	{0x5101, 0x02},
+	{0x5102, 0x01},
+	{0x5103, 0x01},
+	{0x5104, 0x02},
+	{0x5105, 0x01},
+	{0x5106, 0x01},
+	{0x5107, 0x00},
+	{0x5108, 0x00},
+	{0x5109, 0x00},
+	{0x510f, 0xfc},
+	{0x5110, 0xf0},
+	{0x5111, 0x10},
+	{0x536d, 0x02},
+	{0x536e, 0x67},
+	{0x536f, 0x01},
+	{0x5370, 0x4c},
+	{0x5400, 0x00},
+	{0x5400, 0x00},
+	{0x5401, 0x61},
+	{0x5402, 0x00},
+	{0x5403, 0x00},
+	{0x5404, 0x00},
+	{0x5405, 0x40},
+	{0x540c, 0x05},
+	{0x5501, 0x00},
+	{0x5b00, 0x00},
+	{0x5b01, 0x00},
+	{0x5b02, 0x01},
+	{0x5b03, 0xff},
+	{0x5b04, 0x02},
+	{0x5b05, 0x6c},
+	{0x5b09, 0x02},
+	{0x5e10, 0x1c},
+	{REG_NULL, 0x00},
+};
+
+/*Init settings for 13MP resolution*/
+static const struct regval ov13850_init_4224x3136_r2a[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x00},
+	{0x0301, 0x00},
+	{0x0302, 0x32},
+	{0x0303, 0x01},
+	{0x030a, 0x00},
+	{0x300f, 0x10},
+	{0x3010, 0x01},
+	{0x3011, 0x76},
+	{0x3012, 0x41},
+	{0x3013, 0x12},
+	{0x3014, 0x11},
+	{0x301f, 0x03},
+	{0x3106, 0x00},
+	{0x3210, 0x47},
+	{0x3500, 0x00},
+	{0x3501, 0xc0},
+	{0x3502, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x350a, 0x00},
+	{0x350b, 0x80},
+	{0x350e, 0x00},
+	{0x350f, 0x10},
+	{0x351a, 0x00},
+	{0x351b, 0x10},
+	{0x351c, 0x00},
+	{0x351d, 0x20},
+	{0x351e, 0x00},
+	{0x351f, 0x40},
+	{0x3520, 0x00},
+	{0x3521, 0x80},
+	{0x3600, 0xc0},
+	{0x3601, 0xfc},
+	{0x3602, 0x02},
+	{0x3603, 0x78},
+	{0x3604, 0xb1},
+	{0x3605, 0x95},
+	{0x3606, 0x73},
+	{0x3607, 0x07},
+	{0x3609, 0x40},
+	{0x360a, 0x30},
+	{0x360b, 0x91},
+	{0x360C, 0x09},
+	{0x360f, 0x02},
+	{0x3611, 0x10},
+	{0x3612, 0x28},
+	{0x3613, 0x33},
+	{0x3614, 0x2a},
+	{0x3615, 0x0c},
+	{0x3616, 0x0e},
+	{0x3641, 0x02},
+	{0x3660, 0x82},
+	{0x3668, 0x54},
+	{0x3669, 0x00},
+	{0x366a, 0x3f},
+	{0x3667, 0xa0},
+	{0x3702, 0x40},
+	{0x3703, 0x44},
+	{0x3704, 0x2c},
+	{0x3705, 0x01},
+	{0x3706, 0x15},
+	{0x3707, 0x44},
+	{0x3708, 0x3c},
+	{0x3709, 0x1f},
+	{0x370a, 0x24},
+	{0x370b, 0x3c},
+	{0x3710, 0x28},
+	{0x3716, 0x03},
+	{0x3718, 0x10},
+	{0x3719, 0x0c},
+	{0x371a, 0x08},
+	{0x371b, 0x01},
+	{0x371c, 0xfc},
+	{0x3720, 0x55},
+	{0x3722, 0x84},
+	{0x3728, 0x40},
+	{0x372a, 0x05},
+	{0x372b, 0x02},
+	{0x372e, 0x22},
+	{0x372f, 0xa0},
+	{0x3730, 0x04},
+	{0x3731, 0xb8},
+	{0x3732, 0x04},
+	{0x3733, 0xcc},
+	{0x3738, 0x04},
+	{0x3739, 0xce},
+	{0x373a, 0x04},
+	{0x373b, 0xd0},
+	{0x3740, 0x01},
+	{0x3741, 0xd0},
+	{0x3742, 0x00},
+	{0x3743, 0x01},
+	{0x3748, 0x21},
+	{0x3749, 0x22},
+	{0x374a, 0x28},
+	{0x3760, 0x13},
+	{0x3761, 0x33},
+	{0x3762, 0x86},
+	{0x3763, 0x16},
+	{0x3767, 0x24},
+	{0x3768, 0x06},
+	{0x3769, 0x45},
+	{0x376c, 0x23},
+	{0x376f, 0x80},
+	{0x3773, 0x06},
+	{0x3780, 0x90},
+	{0x3781, 0x00},
+	{0x3782, 0x01},
+	{0x3d84, 0x00},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xbf},
+	{0x3800, 0x00},
+	{0x3801, 0x0C},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x93},
+	{0x3806, 0x0c},
+	{0x3807, 0x4B},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x11},
+	{0x380d, 0xa0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x04},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x04},
+	{0x3837, 0x01},
+	{0x4000, 0xf1},
+	{0x4001, 0x00},
+	{0x400b, 0x0c},
+	{0x4011, 0x00},
+	{0x401a, 0x00},
+	{0x401b, 0x00},
+	{0x401c, 0x00},
+	{0x401d, 0x00},
+	{0x4020, 0x03},
+	{0x4021, 0x6C},
+	{0x4022, 0x0D},
+	{0x4023, 0x17},
+	{0x4024, 0x0D},
+	{0x4025, 0xFC},
+	{0x4026, 0x0D},
+	{0x4027, 0xFF},
+	{0x4028, 0x00},
+	{0x4029, 0x02},
+	{0x402a, 0x04},
+	{0x402b, 0x08},
+	{0x402c, 0x02},
+	{0x402d, 0x02},
+	{0x402e, 0x0c},
+	{0x402f, 0x08},
+	{0x403d, 0x2c},
+	{0x403f, 0x7F},
+	{0x4041, 0x07},
+	{0x4500, 0x82},
+	{0x4501, 0x38},
+	{0x458b, 0x00},
+	{0x459c, 0x00},
+	{0x459d, 0x00},
+	{0x459e, 0x00},
+	{0x4601, 0x04},
+	{0x4602, 0x22},
+	{0x4603, 0x00},
+	{0x4837, 0x1b},
+	{0x4d00, 0x04},
+	{0x4d01, 0x42},
+	{0x4d02, 0xd1},
+	{0x4d03, 0x90},
+	{0x4d04, 0x66},
+	{0x4d05, 0x65},
+	{0x4d0b, 0x00},
+	{0x5000, 0x0e},
+	{0x5001, 0x01},
+	{0x5002, 0x07},
+	{0x5003, 0x4f},
+	{0x5013, 0x40},
+	{0x501c, 0x00},
+	{0x501d, 0x10},
+	{0x5100, 0x30},
+	{0x5101, 0x02},
+	{0x5102, 0x01},
+	{0x5103, 0x01},
+	{0x5104, 0x02},
+	{0x5105, 0x01},
+	{0x5106, 0x01},
+	{0x5107, 0x00},
+	{0x5108, 0x00},
+	{0x5109, 0x00},
+	{0x510f, 0xfc},
+	{0x5110, 0xf0},
+	{0x5111, 0x10},
+	{0x536d, 0x02},
+	{0x536e, 0x67},
+	{0x536f, 0x01},
+	{0x5370, 0x4c},
+	{0x5400, 0x00},
+	{0x5400, 0x00},
+	{0x5401, 0x71},
+	{0x5402, 0x00},
+	{0x5403, 0x00},
+	{0x5404, 0x00},
+	{0x5405, 0x80},
+	{0x540c, 0x05},
+	{0x5501, 0x00},
+	{0x5b00, 0x00},
+	{0x5b01, 0x00},
+	{0x5b02, 0x01},
+	{0x5b03, 0xff},
+	{0x5b04, 0x02},
+	{0x5b05, 0x6c},
+	{0x5b09, 0x02},
+	{0x5e00, 0x00},
+	{0x5e10, 0x1c},
+	{REG_NULL, 0x00},
+};
+
+/*3.3MP Resolution at 15fps*/
+static const struct regval ov13850_2112x1568_regs[] = {
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x4b},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x11},
+	{0x380d, 0xa0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x01},
+	{0x3821, 0x06},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x08},
+	{0x3837, 0x02},
+	{REG_NULL, 0x00},
+};
+
+/*13MP resolution at 7fps*/
+static const struct regval ov13850_4224x3136_regs[] = {
+	{0x3800, 0x00},
+	{0x3801, 0x0C},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x93},
+	{0x3806, 0x0c},
+	{0x3807, 0x4B},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x11},
+	{0x380d, 0xa0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x04},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x04},
+	{0x3837, 0x01},
+	{REG_NULL, 0x00},
+};
+
+static const struct ov13850_mode supported_modes[] = {
+	{
+		.width = 2112,
+		.height = 1568,
+		.max_fps = {
+			.numerator = 20000,
+			.denominator = 300000,
+		},
+		.exp_def = 0x0600,
+		.hts_def = 0x12c0,
+		.vts_def = 0x0680,
+		.reg_list = ov13850_2112x1568_regs,
+	},{
+		.width = 4224,
+		.height = 3136,
+		.max_fps = {
+			.numerator = 20000,
+			.denominator = 150000,
+		},
+		.exp_def = 0x0600,
+		.hts_def = 0x12c0,
+		.vts_def = 0x0d00,
+		.reg_list = ov13850_4224x3136_regs,
+	},
+};
+
+
+/* Write registers up to 4 at a time */
+static int ov13850_write_reg(struct i2c_client *client, u16 reg,
+			     u32 len, u32 val)
+{
+	u32 buf_i, val_i;
+	u8 buf[6];
+	u8 *val_p;
+	__be32 val_be;
+
+	if (len > 4)
+		return -EINVAL;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	val_be = cpu_to_be32(val);
+	val_p = (u8 *)&val_be;
+	buf_i = 2;
+	val_i = 4 - len;
+
+	while (val_i < 4)
+		buf[buf_i++] = val_p[val_i++];
+
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+static int ov13850_write_array(struct i2c_client *client,
+			       const struct regval *regs)
+{
+	u32 i;
+	int ret = 0;
+
+	for (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)
+		ret = ov13850_write_reg(client, regs[i].addr,
+					OV13850_REG_VALUE_08BIT,
+					regs[i].val);
+
+	return ret;
+}
+
+/* Read registers up to 4 at a time */
+static int ov13850_read_reg(struct i2c_client *client, u16 reg,
+			    unsigned int len, u32 *val)
+{
+	struct i2c_msg msgs[2];
+	u8 *data_be_p;
+	__be32 data_be = 0;
+	__be16 reg_addr_be = cpu_to_be16(reg);
+	int ret;
+
+	if (len > 4 || !len)
+		return -EINVAL;
+
+	data_be_p = (u8 *)&data_be;
+	/* Write register address */
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = 2;
+	msgs[0].buf = (u8 *)&reg_addr_be;
+
+	/* Read data from register */
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_be_p[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = be32_to_cpu(data_be);
+
+	return 0;
+}
+
+/*@ov13850_enable_test_pattern - This enables the test pattern
+   Valid valued for pattern are 1 - 4
+ Return value - 0 on success, negative on failure*/
+static int ov13850_enable_test_pattern(u32 pattern)
+{
+	u32 val;
+	val = (pattern - 1) | 0x80;
+
+	return ov13850_write_reg(ov13850_info.client,
+				 OV13850_REG_TEST_PATTERN,
+				 OV13850_REG_VALUE_08BIT,
+				 val);
+}
+
+/*@__ov13850_start_stream - writing mode register settings
+ and streaming register
+ Return value - 0 on success, negative on failure*/
+static int __ov13850_start_stream(void)
+{
+	int ret = 0;
+
+	pr_debug("%s: %d\n", __func__, __LINE__);
+
+	if(ov13850_info.streaming)
+	{
+		pr_debug("OV13850: Already streaming \n");
+		return ret;
+	}
+
+	ret = ov13850_write_array(ov13850_info.client, ov13850_info.cur_mode->reg_list);
+	if (ret)
+		return ret;
+	ret = ov13850_write_reg(ov13850_info.client,
+				 OV13850_REG_CTRL_MODE,
+				 OV13850_REG_VALUE_08BIT,
+				 OV13850_MODE_STREAMING);
+	if(!ret)
+	{
+		pr_debug("%s: streaming started \n", __func__);
+		ov13850_info.streaming = 1;
+	}
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	return ret;
+}
+
+static int __ov13850_stop_stream(void)
+{
+	int ret = 0;
+
+	if(!ov13850_info.streaming)
+		return ret;
+
+	ret = ov13850_write_reg(ov13850_info.client,
+				 OV13850_REG_CTRL_MODE,
+				 OV13850_REG_VALUE_08BIT,
+				 OV13850_MODE_SW_STANDBY);
+	if(!ret)
+	{
+		pr_debug("%s: streaming stopped \n", __func__);
+		ov13850_info.streaming = 0;
+	}
+	return ret;
+
+}
+
+/* Calculate the delay in us by clock rate and clock cycles */
+static inline u32 ov13850_cal_delay(u32 cycles)
+{
+	return DIV_ROUND_UP(cycles, OV13850_XVCLK_FREQ / 1000 / 1000);
+}
+
+
+/*@__ov13850_power_on - We only control reset gpio as per board
+ requirement, power down line is not software controlled*/
+static void __ov13850_power_on(void)
+{
+	int ret;
+	u32 delay_us;
+
+	if (!IS_ERR_OR_NULL(ov13850_info.pins_default)) {
+		ret = pinctrl_select_state(ov13850_info.pinctrl,
+					   ov13850_info.pins_default);
+		if (ret < 0)
+			pr_err("OV13850: could not set pins\n");
+	}
+	
+	gpio_set_value(reset_gpio, 0);
+	usleep_range(3000, 5000);
+
+	gpio_set_value(reset_gpio, 1);
+	usleep_range(3000, 5000);
+
+	/* 8192 cycles prior to first SCCB transaction */
+	delay_us = ov13850_cal_delay(8192);
+	usleep_range(delay_us, delay_us * 2);
+
+}
+
+static void __ov13850_power_off(void)
+{
+	int ret;
+
+	__ov13850_stop_stream();
+	msleep(10);
+	gpio_set_value(reset_gpio, 0);
+	if (!IS_ERR_OR_NULL(ov13850_info.pins_sleep)) {
+		ret = pinctrl_select_state(ov13850_info.pinctrl,
+					   ov13850_info.pins_sleep);
+		if (ret < 0)
+			pr_err("OV13850: could not set pins\n");
+	}
+}
+
+static int ov13850_check_sensor_id(struct i2c_client *client)
+{
+	u32 id = 0;
+	int ret;
+
+	ret = ov13850_read_reg(client, OV13850_REG_CHIP_ID,
+			       OV13850_REG_VALUE_16BIT, &id);
+	printk(KERN_ALERT "OV13850, register 0x300A: %d\n", id);
+	if (id != CHIP_ID) {
+		pr_err("Unexpected sensor id(%06x), ret(%d)\n", id, ret);
+		return -ENODEV;
+	}
+
+	ret = ov13850_read_reg(client, OV13850_CHIP_REVISION_REG,
+			       OV13850_REG_VALUE_08BIT, &id);
+	if (ret) {
+		pr_err("Read chip revision register error\n");
+		return ret;
+	}
+
+	/*We check revision above, but current driver only write settings
+	 for revision 0xb2 chips*/
+	ov13850_global_regs = ov13850_init_2112x1568_r2a;
+	ov13850_revid = id;
+	pr_info("Detected OV13850: %06x sensor, REVISION 0x%x\n", CHIP_ID, id);
+
+	return 0;
+}
+
+/*@ov13850_set_virtual_channel - virtual channel is 1 for
+  ipu 0 and csi 1, write 1 to virtual channel register*/
+static int ov13850_set_virtual_channel(int channel)
+{
+	int retval = 0;
+	retval = ov13850_write_reg(ov13850_info.client, OV13850_VCHANNEL,
+					OV13850_REG_VALUE_08BIT, channel);
+	if(retval)
+		pr_err("%s: failed\n", __func__);
+	return retval;
+}
+
+/*ov13850_start_capture - if valid pattern value then enable test
+  pattern, else go for normal streaming. Change ENABLE_TEST_PATTERN
+  with value 1 to 4 to enable test pattern */
+static int ov13850_start_capture(int frame_rate, int pattern)
+{
+	int retval = 0;	
+
+	if(pattern > 0 && pattern <= 4)
+		ov13850_enable_test_pattern(pattern);
+	retval = __ov13850_start_stream();
+	if (retval) {
+		pr_err("OV13850 start stream failed !\n");
+		return retval;
+	}
+
+	ov13850_set_virtual_channel(ov13850_data.csi);
+	return 0;
+}
+
+static int ov13850_write_init_settings(const struct regval *settings)
+{
+	int retval = 0;
+	retval = ov13850_write_array(ov13850_info.client, settings);
+	if (retval) {
+		pr_err("OV13850 global settings failed !\n");
+		return retval;
+	}
+	msleep(5);
+	return retval;
+}
+
+/*@ov13850_init_mode - This is called during device init. Enable csi here,
+  start streaming, check mipi status and stop the streaming.
+  Return - 0 on success, negative on failure*/
+static int ov13850_init_mode(int frame_rate)
+{
+	int retval = 0;
+	void *mipi_csi2_info;
+	u32 mipi_reg;
+	int k = 0;
+
+	mipi_csi2_info = mipi_csi2_get_info();
+
+	/* initial mipi dphy */
+	if (!mipi_csi2_info) {
+		printk(KERN_ERR "%s() in %s: Fail to get mipi_csi2_info!\n",
+		       __func__, __FILE__);
+		return -1;
+	}
+
+	if (!mipi_csi2_get_status(mipi_csi2_info))
+		mipi_csi2_enable(mipi_csi2_info);
+
+	if (!mipi_csi2_get_status(mipi_csi2_info)) {
+		pr_err("Can not enable mipi csi2 driver!\n");
+		return -1;
+	}
+
+	mipi_csi2_set_lanes(mipi_csi2_info);
+
+	mipi_csi2_reset(mipi_csi2_info);
+
+	if (ov13850_data.pix.pixelformat == V4L2_PIX_FMT_SBGGR8)
+		mipi_csi2_set_datatype(mipi_csi2_info, MIPI_DT_RAW8);
+	else
+		pr_err("currently this sensor format can not be supported!\n");
+
+	retval = ov13850_write_init_settings(ov13850_global_regs);
+	if(retval)
+		return retval;
+
+	while(k++<10)
+	{
+		mipi_reg = mipi_csi2_dphy_status(mipi_csi2_info);
+		pr_debug(KERN_INFO "mipi_csi2_dphy_status: %u\n", mipi_reg);
+		msleep(2);
+	}
+
+	retval = __ov13850_start_stream();
+	if (retval) {
+		pr_err("OV13850 start stream failed !\n");
+		return retval;
+	}
+
+	retval = ov13850_set_virtual_channel(ov13850_data.csi);
+	if(retval)
+		goto err1;
+
+	if (mipi_csi2_info) {
+		unsigned int i;
+
+		i = 0;
+
+		/* wait for mipi sensor ready */
+		mipi_reg = mipi_csi2_dphy_status(mipi_csi2_info);
+		while ((mipi_reg == 0x200) && i < 10) {
+			/*if(mipi_reg == 0x300 || mipi_reg == 0x330)
+				break;
+			if(mipi_reg == 0x200) break;*/
+			mipi_reg = mipi_csi2_dphy_status(mipi_csi2_info);
+			i++;
+			msleep(10);
+		}
+
+		if (i >= 10) {
+			pr_err("mipi csi2 can not receive sensor clk!\n");
+			retval = -1;
+			goto err1;
+		}
+
+		i = 0;
+
+		/* wait for mipi stable */
+		mipi_reg = mipi_csi2_get_error1(mipi_csi2_info);
+		while ((mipi_reg != 0x0) && (i < 10)) {
+			mipi_reg = mipi_csi2_get_error1(mipi_csi2_info);
+			i++;
+			msleep(10);
+		}
+
+		if (i >= 10) {
+			pr_err("mipi csi2 can not reveive data correctly!\n");
+			retval = -1;
+			goto err1;
+		}
+	
+		k = 0;
+		while(k++<10)
+		{	
+			mipi_reg = mipi_csi2_get_error2(mipi_csi2_info);
+			pr_debug(KERN_INFO "mipi_csi2_get_error2: %u\n", mipi_reg);
+			msleep(2);
+		}
+
+		k = 0;
+		while(k++<10)
+		{
+			mipi_reg = mipi_csi2_dphy_status(mipi_csi2_info);
+			pr_debug("mipi_csi2_dphy_status: %u\n", mipi_reg);
+			if(mipi_reg == 0x300)
+				break;
+			msleep(2);
+		}
+	}
+err1:
+	__ov13850_stop_stream();
+	return retval;
+}
+
+/*@ioctl_enum_framesizes - Return the two supported frame sizes here*/
+static int ioctl_enum_framesizes(struct v4l2_int_device *s,
+				 struct v4l2_frmsizeenum *fsize)
+{
+	if (fsize->index > 2)
+                return -EINVAL;
+	fsize->pixel_format = ov13850_data.pix.pixelformat;
+	fsize->discrete.width = supported_modes[fsize->index].width;
+	fsize->discrete.height = supported_modes[fsize->index].height;
+	return 0;
+}
+
+/*@ioctl_g_fmt_cap - Return v4l2_pix_format structure here*/
+static int ioctl_g_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct sensor_data *sensor = s->priv;
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	f->fmt.pix = sensor->pix;
+	return 0;
+}
+
+static int ioctl_enum_fmt_cap(struct v4l2_int_device *s,
+			      struct v4l2_fmtdesc *fmt)
+{
+	if (fmt->index > 0)
+                return -EINVAL;
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	fmt->pixelformat = ov13850_data.pix.pixelformat;
+
+	return 0;
+}
+
+static int ioctl_s_power(struct v4l2_int_device *s, int on)
+{
+	printk(KERN_INFO "%s: %d\n", __func__, __LINE__);
+	if (on) {
+		__ov13850_power_on();
+	} else if (!on) {
+		__ov13850_power_off();
+	}
+	printk(KERN_INFO "%s: %d\n", __func__, __LINE__);
+
+	return 0;
+}
+
+static int ioctl_init(struct v4l2_int_device *s)
+{
+	return 0;
+}
+
+static int ioctl_dev_exit(struct v4l2_int_device *s)
+{
+	void *mipi_csi2_info;
+
+	printk(KERN_INFO "%s: %d\n", __func__, __LINE__);
+	mipi_csi2_info = mipi_csi2_get_info();
+
+	/* disable mipi csi2 */
+	if (mipi_csi2_info)
+		if (mipi_csi2_get_status(mipi_csi2_info))
+			mipi_csi2_disable(mipi_csi2_info);
+
+	return 0;
+}
+
+static int ioctl_g_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
+{
+	int ret = 0;
+
+	switch (vc->id) {
+	/*Need to implement control here further*/
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int ioctl_enum_frameintervals(struct v4l2_int_device *s,
+					 struct v4l2_frmivalenum *fival)
+{
+	if(fival->index > 2)
+		return -EINVAL;
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator =
+			supported_modes[fival->index].max_fps.numerator;
+	fival->discrete.denominator =
+			supported_modes[fival->index].max_fps.denominator;
+	return 0;
+}
+
+static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
+{
+	int ret = 0;
+
+	pr_debug("In ov13850: ioctl_s_ctrl %d\n",
+		 vc->id);
+
+	switch (vc->id) {
+	case V4L2_CID_EXPOSURE:
+		ret = ov13850_write_reg(ov13850_info.client,
+					OV13850_REG_EXPOSURE,
+					OV13850_REG_VALUE_24BIT,
+					vc->value << 4);
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov13850_write_reg(ov13850_info.client,
+					OV13850_REG_GAIN_H,
+					OV13850_REG_VALUE_08BIT,
+					(vc->value >> OV13850_GAIN_H_SHIFT) &
+					OV13850_GAIN_H_MASK);
+		ret |= ov13850_write_reg(ov13850_info.client,
+					 OV13850_REG_GAIN_L,
+					 OV13850_REG_VALUE_08BIT,
+					 vc->value & OV13850_GAIN_L_MASK);
+		break;
+	case V4L2_CID_VBLANK:
+		ret = ov13850_write_reg(ov13850_info.client,
+					OV13850_REG_VTS,
+					OV13850_REG_VALUE_16BIT,
+					vc->value + ov13850_info.cur_mode->height);
+		break;
+	default:
+		ret = -EPERM;
+		break;
+	}
+
+	return ret;
+}
+
+static int ioctl_g_chip_ident(struct v4l2_int_device *s, int *id)
+{
+	((struct v4l2_dbg_chip_ident *)id)->match.type =
+					V4L2_CHIP_MATCH_I2C_DRIVER;
+	strcpy(((struct v4l2_dbg_chip_ident *)id)->match.name,
+		OV13850_NAME);
+	pr_debug("%s: %d\n", __func__, __LINE__);
+
+	return 0;
+}
+
+static int ioctl_g_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	struct sensor_data *sensor = s->priv;
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+	int ret = 0;
+
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	switch (a->type) {
+	/*Need to verify below settings further*/
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		pr_debug("%s: %d\n", __func__, __LINE__);
+		memset(a, 0, sizeof(*a));
+		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cparm->capability = sensor->streamcap.capability;
+		cparm->timeperframe = sensor->streamcap.timeperframe;
+		cparm->capturemode = sensor->streamcap.capturemode;
+		ret = 0;
+		break;
+	/*These cases not applicable now*/
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int ioctl_s_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	int ret = 0;
+	struct sensor_data *sensor = s->priv;
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+
+	switch (a->type) {
+	/* This is the only case currently handled. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	/*Need to set fps as per request */
+		pr_debug("%s: %d\n", __func__, __LINE__);
+		sensor->streamcap.timeperframe = *timeperframe;
+		sensor->streamcap.capturemode =
+				(u32)a->parm.capture.capturemode;
+		break;
+	/* These cases not applicable for now*/
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		pr_debug("   type is not " \
+			"V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
+			a->type);
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int ioctl_g_ifparm(struct v4l2_int_device *s, struct v4l2_ifparm *p)
+{
+	if (s == NULL) {
+		pr_err("   ERROR!! no slave device set!\n");
+		return -1;
+	}
+
+	memset(p, 0, sizeof(*p));
+	pr_debug("   clock_curr=mclk=%d\n", ov13850_data.mclk);
+
+	return 0;
+}
+
+static int ioctl_dev_init(struct v4l2_int_device *s)
+{
+	int ret;
+	void *mipi_csi2_info;
+	int frame_rate;
+
+	printk(KERN_INFO "ov13850, %s: %d\n", __func__, __LINE__);
+
+        ov13850_data.on = true;
+	ov13850_data.mclk = OV13850_XVCLK_FREQ;
+	pr_debug("   Setting mclk to %d MHz\n", OV13850_XVCLK_FREQ);
+
+	frame_rate = DEFAULT_FPS;
+	mipi_csi2_info = mipi_csi2_get_info();
+
+        /* enable mipi csi2 */
+	if (mipi_csi2_info)
+		mipi_csi2_enable(mipi_csi2_info);
+	else {
+		printk(KERN_ERR "%s() in %s: Fail to get mipi_csi2_info!\n",
+		       __func__, __FILE__);
+		return -EPERM;
+	}
+	printk(KERN_INFO "ov13850, %s: %d\n", __func__, __LINE__);
+
+	ret = ov13850_init_mode(frame_rate);
+	return ret;
+}
+
+/*@ioctl_s_streamon - This is called from mxc capture driver
+   Return - 0 on success, negative on failure*/
+static void ioctl_s_streamon(struct v4l2_int_device *s, int *err)
+{
+	*err = -EINVAL;
+	if(strcmp(s->name, OV13850_NAME) == 0)
+		*err = ov13850_start_capture(DEFAULT_FPS, ENABLE_TEST_PATTERN);
+	/*FPS is not handled for now, to handle FPS, need to change
+	HTS and VTS register as per request*/
+	pr_debug("%s: %s - %d\n", __func__, s->name, *err);
+}
+
+/*@ioctl_s_fmt_cap - Switch init register settings and supported mode as
+ per received width and height*/
+static int ioctl_s_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	int retval = 0;
+
+	if(f->fmt.pix.width == OV13850_RES_HIGH_WIDTH &&
+		f->fmt.pix.height == OV13850_RES_HIGH_HEIGHT)
+	{
+		ov13850_info.cur_mode = &supported_modes[1];
+		ov13850_global_regs = ov13850_init_4224x3136_r2a;
+	}
+	else if(f->fmt.pix.width == OV13850_RES_LOW_WIDTH &&
+		f->fmt.pix.height == OV13850_RES_LOW_HEIGHT)
+	{
+		ov13850_info.cur_mode = &supported_modes[0];
+		ov13850_global_regs = ov13850_init_2112x1568_r2a;
+	}
+	else
+	{
+		printk(KERN_INFO "OV13850: Unsupported resolution passed\n");
+		return -1;
+	}
+
+	retval = ov13850_write_init_settings(ov13850_global_regs);
+	return retval; 
+}
+
+static struct v4l2_int_ioctl_desc ov13850_ioctl_desc[] = {
+	{vidioc_int_dev_init_num, (v4l2_int_ioctl_func *) ioctl_dev_init},
+	{vidioc_int_dev_exit_num, ioctl_dev_exit},
+	{vidioc_int_s_power_num, (v4l2_int_ioctl_func *) ioctl_s_power},
+	{vidioc_int_g_ifparm_num, (v4l2_int_ioctl_func *) ioctl_g_ifparm},
+	{vidioc_int_init_num, (v4l2_int_ioctl_func *) ioctl_init},
+	{vidioc_int_enum_fmt_cap_num,
+				(v4l2_int_ioctl_func *) ioctl_enum_fmt_cap},
+	{vidioc_int_g_fmt_cap_num, (v4l2_int_ioctl_func *) ioctl_g_fmt_cap},
+	{vidioc_int_s_fmt_cap_num, (v4l2_int_ioctl_func *) ioctl_s_fmt_cap},
+	{vidioc_int_g_parm_num, (v4l2_int_ioctl_func *) ioctl_g_parm},
+	{vidioc_int_s_parm_num, (v4l2_int_ioctl_func *) ioctl_s_parm},
+	{vidioc_int_g_ctrl_num, (v4l2_int_ioctl_func *) ioctl_g_ctrl},
+	{vidioc_int_s_ctrl_num, (v4l2_int_ioctl_func *) ioctl_s_ctrl},
+	{vidioc_int_enum_framesizes_num,
+				(v4l2_int_ioctl_func *) ioctl_enum_framesizes},
+	{vidioc_int_enum_frameintervals_num,
+			(v4l2_int_ioctl_func *) ioctl_enum_frameintervals},
+	{vidioc_int_g_chip_ident_num,
+				(v4l2_int_ioctl_func *) ioctl_g_chip_ident},
+	{vidioc_int_s_streamon_num, (v4l2_int_ioctl_func *) ioctl_s_streamon},
+};
+
+static struct v4l2_int_slave ov13850_slave = {
+	.ioctls = ov13850_ioctl_desc,
+	.num_ioctls = ARRAY_SIZE(ov13850_ioctl_desc),
+};
+
+static struct v4l2_int_device ov13850_int_device = {
+	.module = THIS_MODULE,
+	.name = OV13850_NAME,
+	.type = v4l2_int_type_slave,
+	.u = {
+		.slave = &ov13850_slave,
+	},
+};
+
+static int ov13850_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	int ret;
+
+	pr_info("OV13850: ov13850_probe called\n");
+	ov13850_info.client = client;
+	ov13850_info.cur_mode = &supported_modes[0];
+	ov13850_info.streaming = 0;
+
+	reset_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+	if (!gpio_is_valid(reset_gpio)) {
+		dev_err(dev, "no sensor reset pin available");
+		return -EINVAL;
+	}
+	ret = devm_gpio_request_one(dev, reset_gpio, GPIOF_OUT_INIT_LOW,
+					"ov13850_reset");
+	if (ret < 0) {
+		dev_err(dev, "failed to acquire sensor reset pin");
+		return ret;
+	}
+
+	memset(&ov13850_data, 0, sizeof(ov13850_data));
+	ov13850_data.sensor_clk = devm_clk_get(dev, "csi_mclk");
+	if (IS_ERR(ov13850_data.sensor_clk)) {
+                ov13850_data.sensor_clk = NULL;
+                dev_err(dev, "clock-frequency missing or invalid\n");
+                return PTR_ERR(ov13850_data.sensor_clk);
+        }
+
+	ov13850_info.pinctrl = devm_pinctrl_get(dev);
+	if (!IS_ERR(ov13850_info.pinctrl)) {
+		ov13850_info.pins_default =
+			pinctrl_lookup_state(ov13850_info.pinctrl,
+					     OF_CAMERA_PINCTRL_STATE_DEFAULT);
+		if (IS_ERR(ov13850_info.pins_default))
+			dev_err(dev, "could not get default pinstate\n");
+
+		ov13850_info.pins_sleep =
+			pinctrl_lookup_state(ov13850_info.pinctrl,
+					     OF_CAMERA_PINCTRL_STATE_SLEEP);
+		if (IS_ERR(ov13850_info.pins_sleep))
+			dev_err(dev, "could not get sleep pinstate\n");
+	}
+
+	mutex_init(&ov13850_info.mutex);
+	
+	ret = of_property_read_u32(dev->of_node, "mclk",
+					&(ov13850_data.mclk));
+	if (ret) {
+		dev_err(dev, "mclk missing or invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mclk_source",
+					(u32 *) &(ov13850_data.mclk_source));
+	if (ret) {
+		dev_err(dev, "mclk_source missing or invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "csi_id",
+					&(ov13850_data.csi));
+	if (ret) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(ov13850_data.sensor_clk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable xvclk\n");
+		return ret;
+	}
+
+	ov13850_data.io_init = __ov13850_power_on;
+	ov13850_data.i2c_client = client;
+	/*Only cab handle 8bit mode for now*/
+	ov13850_data.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	ov13850_data.pix.width = OV13850_RES_LOW_WIDTH;
+        ov13850_data.pix.height = OV13850_RES_LOW_HEIGHT;
+	ov13850_data.streamcap.capability = V4L2_MODE_HIGHQUALITY |
+                                           V4L2_CAP_TIMEPERFRAME;
+        ov13850_data.streamcap.capturemode = 0;
+        ov13850_data.streamcap.timeperframe.denominator = DEFAULT_FPS;
+        ov13850_data.streamcap.timeperframe.numerator = 1;
+
+	__ov13850_power_on();
+
+	ret = ov13850_check_sensor_id(client);
+	if (ret)
+	{
+		dev_err(dev, "ov13850 mipi not found\n");
+		clk_disable_unprepare(ov13850_data.sensor_clk);
+		goto err_free_handler;
+	}
+
+	ov13850_int_device.priv = &ov13850_data;
+        ret = v4l2_int_device_register(&ov13850_int_device);
+        clk_disable_unprepare(ov13850_data.sensor_clk);
+	__ov13850_power_off();
+
+	pr_info("OV13850: ov13850_probe successful\n");
+
+	return 0;
+
+err_free_handler:
+	mutex_destroy(&ov13850_info.mutex);
+
+	return ret;
+}
+
+static int ov13850_remove(struct i2c_client *client)
+{
+	v4l2_int_device_unregister(&ov13850_int_device);
+	mutex_destroy(&ov13850_info.mutex);
+	return 0;
+}
+
+
+#if IS_ENABLED(CONFIG_OF)
+static const struct of_device_id ov13850_of_match[] = {
+        { .compatible = "ovti,ov13850" },
+        {},
+};
+MODULE_DEVICE_TABLE(of, ov13850_of_match);
+#endif
+
+static const struct i2c_device_id ov13850_match_id[] = {
+        { "ovti,ov13850", 0 },
+        { },
+};
+
+static struct i2c_driver ov13850_i2c_driver = {
+        .driver = {
+                .name = OV13850_NAME,
+                .of_match_table = of_match_ptr(ov13850_of_match),
+        },
+        .probe          = &ov13850_probe,
+        .remove         = &ov13850_remove,
+        .id_table       = ov13850_match_id,
+};
+
+static int __init sensor_mod_init(void)
+{
+	return i2c_add_driver(&ov13850_i2c_driver);
+}
+
+static void __exit sensor_mod_exit(void)
+{
+	i2c_del_driver(&ov13850_i2c_driver);
+}
+
+device_initcall_sync(sensor_mod_init);
+module_exit(sensor_mod_exit);
+
+MODULE_AUTHOR("Arun kumar");
+MODULE_DESCRIPTION("ov13850 sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/mxc/capture/v4l2-int-device.h b/drivers/media/platform/mxc/capture/v4l2-int-device.h
index 810d87f..c7bb5be 100644
--- a/drivers/media/platform/mxc/capture/v4l2-int-device.h
+++ b/drivers/media/platform/mxc/capture/v4l2-int-device.h
@@ -223,6 +223,7 @@ enum v4l2_int_ioctl_num {
 	vidioc_int_init_num,
 	/* VIDIOC_DBG_G_CHIP_IDENT */
 	vidioc_int_g_chip_ident_num,
+	vidioc_int_s_streamon_num,
 
 	/*
 	 *
@@ -305,5 +306,6 @@ V4L2_INT_WRAPPER_1(enum_frameintervals, struct v4l2_frmivalenum, *);
 V4L2_INT_WRAPPER_0(reset);
 V4L2_INT_WRAPPER_0(init);
 V4L2_INT_WRAPPER_1(g_chip_ident, int, *);
+V4L2_INT_WRAPPER_1(s_streamon, int, *);
 
 #endif
diff --git a/drivers/mxc/ipu3/ipu_capture.c b/drivers/mxc/ipu3/ipu_capture.c
index f304c81..5d2190c 100644
--- a/drivers/mxc/ipu3/ipu_capture.c
+++ b/drivers/mxc/ipu3/ipu_capture.c
@@ -82,6 +82,10 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 	uint32_t data = 0;
 	uint32_t csi = cfg_param.csi;
 
+	unsigned int val;
+	//CSI2IPU gasket register
+	void __iomem *io = ioremap(0x21DC000, 4);
+
 	/* Set SENS_DATA_FORMAT bits (8, 9 and 10)
 	   RGB or YUV444 is 0 which is current value in data so not set
 	   explicitly
@@ -100,6 +104,7 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 		break;
 	case IPU_PIX_FMT_GENERIC:
 	case IPU_PIX_FMT_GENERIC_16:
+		pr_debug(KERN_INFO "%s: IPU_PIX_FMT_GENERIC data\n", __func__);
 		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
 		break;
 	case IPU_PIX_FMT_RGB565:
@@ -112,6 +117,8 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 		return -EINVAL;
 	}
 
+	cfg_param.clk_mode = 1; //NONGATED clk mode
+
 	/* Set the CSI_SENS_CONF register remaining fields */
 	data |= cfg_param.data_width << CSI_SENS_CONF_DATA_WIDTH_SHIFT |
 		cfg_param.data_fmt << CSI_SENS_CONF_DATA_FMT_SHIFT |
@@ -131,6 +138,11 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 
 	ipu_csi_write(ipu, csi, data, CSI_SENS_CONF);
 
+	//writing csi2ipu gasket for NON_GATED clk mode*/
+	val = ioread32(io);
+	iowrite32(val|0x2, io);
+	iounmap(io);
+
 	/* Setup sensor frame size */
 	ipu_csi_write(ipu, csi, (width - 1) | (height - 1) << 16, CSI_SENS_FRM_SIZE);
 
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
index c5b82f78..7d8d85d 100644
--- a/drivers/mxc/ipu3/ipu_common.c
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -671,12 +671,21 @@ int ipu_remove(struct platform_device *pdev)
 
 void ipu_dump_registers(struct ipu_soc *ipu)
 {
+	/*add additional register dump here*/
+	dev_dbg(ipu->dev, "IPU_STAT1 = \t0x%08X\n", ipu_cm_read(ipu, IPU_INT_STAT(ipu->devtype, 1)));
+	dev_dbg(ipu->dev, "IPU_STAT2 = \t0x%08X\n", ipu_cm_read(ipu, IPU_INT_STAT(ipu->devtype, 2)));
+	dev_dbg(ipu->dev, "IPU_CSI_SENS = \t0x%08X\n", ipu_csi_read(ipu, 1, CSI_SENS_CONF));
+	dev_dbg(ipu->dev, "CSI_SENS_FRM_SIZE = \t0x%08X\n", ipu_csi_read(ipu, 1, CSI_SENS_FRM_SIZE));
+	dev_dbg(ipu->dev, "CSI_ACT_FRM_SIZE = \t0x%08X\n", ipu_csi_read(ipu, 1, CSI_ACT_FRM_SIZE));
+	dev_dbg(ipu->dev, "CSI_OUT_FRM_CTRL = \t0x%08X\n", ipu_csi_read(ipu, 1, CSI_OUT_FRM_CTRL));
 	dev_dbg(ipu->dev, "IPU_CONF = \t0x%08X\n", ipu_cm_read(ipu, IPU_CONF));
 	dev_dbg(ipu->dev, "IDMAC_CONF = \t0x%08X\n", ipu_idmac_read(ipu, IDMAC_CONF));
 	dev_dbg(ipu->dev, "IDMAC_CHA_EN1 = \t0x%08X\n",
 	       ipu_idmac_read(ipu, IDMAC_CHA_EN(0)));
 	dev_dbg(ipu->dev, "IDMAC_CHA_EN2 = \t0x%08X\n",
 	       ipu_idmac_read(ipu, IDMAC_CHA_EN(32)));
+	dev_dbg(ipu->dev, "IPU_SMFC_MAP = \t0x%08X\n", ipu_smfc_read(ipu, SMFC_MAP));
+
 	dev_dbg(ipu->dev, "IDMAC_CHA_PRI1 = \t0x%08X\n",
 	       ipu_idmac_read(ipu, IDMAC_CHA_PRI(0)));
 	dev_dbg(ipu->dev, "IDMAC_CHA_PRI2 = \t0x%08X\n",
@@ -722,6 +731,8 @@ void ipu_dump_registers(struct ipu_soc *ipu)
 	       ipu_ic_read(ipu, IC_CONF));
 }
 
+EXPORT_SYMBOL(ipu_dump_registers);
+
 /*!
  * This function is called to initialize a logical IPU channel.
  *
diff --git a/drivers/mxc/mipi/mxc_mipi_csi2.c b/drivers/mxc/mipi/mxc_mipi_csi2.c
index df45c36..4e2a0cb 100644
--- a/drivers/mxc/mipi/mxc_mipi_csi2.c
+++ b/drivers/mxc/mipi/mxc_mipi_csi2.c
@@ -290,7 +290,9 @@ int mipi_csi2_reset(struct mipi_csi2_info *info)
 	mipi_csi2_write(info, 0x00000002, MIPI_CSI2_PHY_TST_CTRL0);
 	mipi_csi2_write(info, 0x00010044, MIPI_CSI2_PHY_TST_CTRL1);
 	mipi_csi2_write(info, 0x00000000, MIPI_CSI2_PHY_TST_CTRL0);
-	mipi_csi2_write(info, 0x00000014, MIPI_CSI2_PHY_TST_CTRL1);
+	//mipi_csi2_write(info, 0x00000014, MIPI_CSI2_PHY_TST_CTRL1);
+	/*Decrease the PHY clock as per range 600 - 650 Mhz*/
+	mipi_csi2_write(info, 0x00000010, MIPI_CSI2_PHY_TST_CTRL1);
 	mipi_csi2_write(info, 0x00000002, MIPI_CSI2_PHY_TST_CTRL0);
 	mipi_csi2_write(info, 0x00000000, MIPI_CSI2_PHY_TST_CTRL0);
 
-- 
2.7.4

