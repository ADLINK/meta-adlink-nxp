From cfc0d1fec8c03587b5a2aee6d9b0c25f41bea3ff Mon Sep 17 00:00:00 2001
From: Dinesh V <dinesh.v@adlinktech.com>
Date: Fri, 21 Oct 2022 10:37:42 +0530
Subject: [PATCH 1/5] Added TPM 2.0 support

---
 drivers/char/tpm/Kconfig         |  26 ++
 drivers/char/tpm/Makefile        |   1 +
 drivers/char/tpm/tpm-interface.c |  17 +-
 drivers/char/tpm/tpm.h           |  31 +-
 drivers/char/tpm/tpm_tis_core.c  | 142 +++++++--
 drivers/char/tpm/tpm_tis_core.h  |  54 +++-
 drivers/char/tpm/tpm_tis_i2c.c   | 526 +++++++++++++++++++++++++++++++
 drivers/char/tpm/tpm_tis_spi.c   | 237 ++++++++++++++
 8 files changed, 1007 insertions(+), 27 deletions(-)
 create mode 100755 drivers/char/tpm/tpm_tis_i2c.c
 create mode 100755 drivers/char/tpm/tpm_tis_spi.c

diff --git a/drivers/char/tpm/Kconfig b/drivers/char/tpm/Kconfig
index a18c314da211..6bc3a61fb3c5 100644
--- a/drivers/char/tpm/Kconfig
+++ b/drivers/char/tpm/Kconfig
@@ -86,6 +86,32 @@ config TCG_TIS_SYNQUACER
 	  To compile this driver as a module, choose  M here;
 	  the module will be called tpm_tis_synquacer.
 
+config TCG_TIS_I2C
+	tristate "TPM Interface Specification 1.3 Interface / TPM 2.0 FIFO Interface - (I2C)"
+	depends on I2C
+	depends on CRC_CCITT
+	select TCG_TIS_CORE
+	help
+	  If you have a TPM security chip which is connected to a regular,
+	  non-tcg I2C master (i.e. most embedded platforms) that is compliant with the
+	  TCG TIS 1.3 TPM specification (TPM1.2) or the TCG PTP FIFO
+	  specification (TPM2.0) say Yes and it will be accessible from
+	  within Linux. To compile this driver as a module, choose  M here;
+	  the module will be called tpm_tis_i2c.
+
+config TCG_TIS_I2C
+	tristate "TPM I2C Interface Specification"
+	depends on I2C
+        depends on CRC_CCITT
+	select TCG_TIS_CORE
+	help
+	  If you have a TPM security chip which is connected to a regular
+	  I2C master (i.e. most embedded platforms) that is compliant with the
+	  TCG TPM I2C Interface Specification say Yes and it will be accessible from
+	  within Linux. To compile this driver as a module, choose  M here;
+	  the module will be called tpm_tis_i2c.
+
+
 config TCG_TIS_I2C_ATMEL
 	tristate "TPM Interface Specification 1.2 Interface (I2C - Atmel)"
 	depends on I2C
diff --git a/drivers/char/tpm/Makefile b/drivers/char/tpm/Makefile
index 84db4fb3a9c9..011cebc81173 100644
--- a/drivers/char/tpm/Makefile
+++ b/drivers/char/tpm/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_TCG_TIS_SPI) += tpm_tis_spi.o
 tpm_tis_spi-y := tpm_tis_spi_main.o
 tpm_tis_spi-$(CONFIG_TCG_TIS_SPI_CR50) += tpm_tis_spi_cr50.o
 
+obj-$(CONFIG_TCG_TIS_I2C) += tpm_tis_i2c.o
 obj-$(CONFIG_TCG_TIS_I2C_ATMEL) += tpm_i2c_atmel.o
 obj-$(CONFIG_TCG_TIS_I2C_INFINEON) += tpm_i2c_infineon.o
 obj-$(CONFIG_TCG_TIS_I2C_NUVOTON) += tpm_i2c_nuvoton.o
diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c
index 1621ce818705..f4248ffac820 100644
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -64,6 +64,8 @@ static ssize_t tpm_try_transmit(struct tpm_chip *chip, void *buf, size_t bufsiz)
 	int rc;
 	ssize_t len = 0;
 	u32 count, ordinal;
+	//change ST@2020.10.29
+	unsigned int delay_msec = TPM_TIMEOUT_POLL;
 	unsigned long stop;
 
 	if (bufsiz < TPM_HEADER_SIZE)
@@ -114,7 +116,10 @@ static ssize_t tpm_try_transmit(struct tpm_chip *chip, void *buf, size_t bufsiz)
 			return -ECANCELED;
 		}
 
-		tpm_msleep(TPM_TIMEOUT_POLL);
+		//change ST@2020.10.29
+		//tpm_msleep(TPM_TIMEOUT_POLL);
+		tpm_msleep(delay_msec);
+		delay_msec = delay_msec+delay_msec;
 		rmb();
 	} while (time_before(jiffies, stop));
 
@@ -157,6 +162,7 @@ ssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)
 	u8 save[TPM_HEADER_SIZE + 3*sizeof(u32)];
 	unsigned int delay_msec = TPM2_DURATION_SHORT;
 	u32 rc = 0;
+	u32 i = TPM_RETRY;
 	ssize_t ret;
 	const size_t save_size = min(sizeof(save), bufsiz);
 	/* the command code is where the return code will be */
@@ -172,7 +178,13 @@ ssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)
 	for (;;) {
 		ret = tpm_try_transmit(chip, buf, bufsiz);
 		if (ret < 0)
-			break;
+		{
+			i--;
+			if (i<=0)
+				break;
+		}
+		else
+		{
 		rc = be32_to_cpu(header->return_code);
 		if (rc != TPM2_RC_RETRY && rc != TPM2_RC_TESTING)
 			break;
@@ -194,6 +206,7 @@ ssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)
 		tpm_msleep(delay_msec);
 		delay_msec *= 2;
 		memcpy(buf, save, save_size);
+		}	
 	}
 	return ret;
 }
diff --git a/drivers/char/tpm/tpm.h b/drivers/char/tpm/tpm.h
index 283f78211c3a..734f34c702be 100644
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@ -37,9 +37,15 @@
 #define TPM_RETRY		50
 
 enum tpm_timeout {
+#ifdef CONFIG_TCG_TIS_I2C
+	TPM_TIMEOUT = 1,	/* msecs */
+	TPM_TIMEOUT_RETRY = 2, /* msecs */
+	TPM_TIMEOUT_RANGE_US = 20,	/* usecs */
+#else
 	TPM_TIMEOUT = 5,	/* msecs */
 	TPM_TIMEOUT_RETRY = 100, /* msecs */
 	TPM_TIMEOUT_RANGE_US = 300,	/* usecs */
+#endif
 	TPM_TIMEOUT_POLL = 1,	/* msecs */
 	TPM_TIMEOUT_USECS_MIN = 100,      /* usecs */
 	TPM_TIMEOUT_USECS_MAX = 500      /* usecs */
@@ -57,6 +63,18 @@ enum tpm_addr {
 #define TPM_ERR_DISABLED        0x7
 #define TPM_ERR_INVALID_POSTINIT 38
 
+#define TPM_HEADER_SIZE		10
+
+/* Indicates from what layer of the software stack the error comes from */
+#define TSS2_RC_LAYER_SHIFT	 16
+#define TSS2_RESMGR_TPM_RC_LAYER (11 << TSS2_RC_LAYER_SHIFT)
+
+#define TPM_VID_INTEL    0x8086
+#define TPM_VID_WINBOND  0x1050
+#define TPM_VID_STM      0x104A
+
+#define to_tpm_chip(d) container_of(d, struct tpm_chip, dev)
+
 #define TPM_TAG_RQU_COMMAND 193
 
 /* TPM2 specific constants. */
@@ -185,10 +203,21 @@ int tpm_pm_resume(struct device *dev);
 
 static inline void tpm_msleep(unsigned int delay_msec)
 {
+#ifdef CONFIG_TCG_TIS_I2C
+	usleep_range(delay_msec * 1000,
+			(delay_msec * 1000) + TPM_TIMEOUT_RANGE_US);
+#else
 	usleep_range((delay_msec * 1000) - TPM_TIMEOUT_RANGE_US,
 		     delay_msec * 1000);
+#endif
 };
-
+#ifdef CONFIG_TCG_TIS_I2C
+static inline void tpm_msleep_opt(unsigned int delay_msec)
+{
+	usleep_range(delay_msec * 1000,
+			(delay_msec * 1000) + TPM_TIMEOUT_RANGE_US);
+};
+#endif
 int tpm_chip_start(struct tpm_chip *chip);
 void tpm_chip_stop(struct tpm_chip *chip);
 struct tpm_chip *tpm_find_get_ops(struct tpm_chip *chip);
diff --git a/drivers/char/tpm/tpm_tis_core.c b/drivers/char/tpm/tpm_tis_core.c
index 69579efb247b..94883137eee1 100644
--- a/drivers/char/tpm/tpm_tis_core.c
+++ b/drivers/char/tpm/tpm_tis_core.c
@@ -90,6 +90,53 @@ static int wait_for_tpm_stat(struct tpm_chip *chip, u8 mask,
 	return -ETIME;
 }
 
+static int wait_for_tpm_stat_result (struct tpm_chip *chip, u8 mask ,u8 mask_result
+,unsigned long timeout, wait_queue_head_t *queue,	bool check_cancel)
+{
+	unsigned long stop;
+	long rc;
+	u8 status;
+	bool canceled = false;
+	/* check current status */
+	status = chip->ops->status(chip);
+	
+	if ((status & mask) == mask_result)		
+					return 0;
+					
+	stop = jiffies + timeout;
+
+	if (chip->flags & TPM_CHIP_FLAG_IRQ) {
+again:
+		timeout = stop - jiffies;
+		if ((long)timeout <= 0)
+			return -ETIME;
+		rc = wait_event_interruptible_timeout(*queue,
+			wait_for_tpm_stat_cond(chip, mask, check_cancel,
+					       &canceled),
+			timeout);
+		if (rc > 0) {
+			if (canceled)
+				return -ECANCELED;
+			return 0;
+		}
+		if (rc == -ERESTARTSYS && freezing(current)) {
+			clear_thread_flag(TIF_SIGPENDING);
+			goto again;
+		}
+	} else {
+		do {
+			usleep_range(TPM_TIMEOUT_USECS_MIN,
+				     TPM_TIMEOUT_USECS_MAX);
+			status = chip->ops->status(chip);
+			
+			if ((status & mask) == mask_result)		
+					return 0;
+			
+		} while (time_before(jiffies, stop));
+	}
+	return -ETIME;
+}
+
 /* Before we attempt to access the TPM we must see that the valid bit is set.
  * The specification says that this bit is 0 at reset and remains 0 until the
  * 'TPM has gone through its self test and initialization and has established
@@ -179,7 +226,11 @@ static int request_locality(struct tpm_chip *chip, int l)
 		do {
 			if (check_locality(chip, l))
 				return l;
+#ifdef CONFIG_TCG_TIS_I2C
+			tpm_msleep_opt(TPM_TIMEOUT);
+#else
 			tpm_msleep(TPM_TIMEOUT);
+#endif
 		} while (time_before(jiffies, stop));
 	}
 	return -1;
@@ -220,6 +271,16 @@ static u8 tpm_tis_status(struct tpm_chip *chip)
 	return status;
 }
 
+static bool tpm_tis_check_data(struct tpm_chip *chip, const u8 *buf, 
+size_t len) {
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+
+	if (priv->phy_ops->check_data)
+		return priv->phy_ops->check_data(priv, buf, len);
+	return true;
+}
+
+
 static void tpm_tis_ready(struct tpm_chip *chip)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
@@ -259,6 +320,13 @@ static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)
 	int size = 0, burstcnt, rc;
 
 	while (size < count) {
+#ifdef CONFIG_TCG_TIS_I2C
+		if (priv->interface_id) {
+			burstcnt = 1280;
+		} else {
+			burstcnt = 32;
+		}
+#else
 		rc = wait_for_tpm_stat(chip,
 				 TPM_STS_DATA_AVAIL | TPM_STS_VALID,
 				 chip->timeout_c,
@@ -270,6 +338,7 @@ static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)
 			dev_err(&chip->dev, "Unable to read burstcount\n");
 			return burstcnt;
 		}
+#endif
 		burstcnt = min_t(int, burstcnt, count - size);
 
 		rc = tpm_tis_read_bytes(priv, TPM_DATA_FIFO(priv->locality),
@@ -284,9 +353,13 @@ static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)
 
 static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 {
+#ifndef CONFIG_TCG_TIS_I2C
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+#endif
 	int size = 0;
+#ifndef CONFIG_TCG_TIS_I2C
 	int status;
+#endif
 	u32 expected;
 
 	if (count < TPM_HEADER_SIZE) {
@@ -314,7 +387,7 @@ static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 		size = -ETIME;
 		goto out;
 	}
-
+#ifndef CONFIG_TCG_TIS_I2C
 	if (wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,
 				&priv->int_queue, false) < 0) {
 		size = -ETIME;
@@ -326,7 +399,7 @@ static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 		size = -EIO;
 		goto out;
 	}
-
+#endif
 out:
 	tpm_tis_ready(chip);
 	return size;
@@ -342,7 +415,9 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	int rc, status, burstcnt;
 	size_t count = 0;
+#ifndef CONFIG_TCG_TIS_I2C
 	bool itpm = priv->flags & TPM_TIS_ITPM_WORKAROUND;
+#endif
 
 	status = tpm_tis_status(chip);
 	if ((status & TPM_STS_COMMAND_READY) == 0) {
@@ -355,6 +430,16 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 		}
 	}
 
+#ifdef CONFIG_TCG_TIS_I2C
+	while (count < len) {
+		if (priv->interface_id) {
+			burstcnt = 1280;
+		} else {
+			burstcnt = 32;
+		}
+
+		burstcnt = min_t(int, burstcnt, len - count);
+#else
 	while (count < len - 1) {
 		burstcnt = get_burstcount(chip);
 		if (burstcnt < 0) {
@@ -363,13 +448,14 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 			goto out_err;
 		}
 		burstcnt = min_t(int, burstcnt, len - count - 1);
+#endif
 		rc = tpm_tis_write_bytes(priv, TPM_DATA_FIFO(priv->locality),
 					 burstcnt, buf + count);
 		if (rc < 0)
 			goto out_err;
 
 		count += burstcnt;
-
+#ifndef CONFIG_TCG_TIS_I2C
 		if (wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,
 					&priv->int_queue, false) < 0) {
 			rc = -ETIME;
@@ -380,8 +466,9 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 			rc = -EIO;
 			goto out_err;
 		}
+#endif
 	}
-
+#ifndef CONFIG_TCG_TIS_I2C
 	/* write last byte */
 	rc = tpm_tis_write8(priv, TPM_DATA_FIFO(priv->locality), buf[count]);
 	if (rc < 0)
@@ -397,7 +484,7 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 		rc = -EIO;
 		goto out_err;
 	}
-
+#endif
 	return 0;
 
 out_err:
@@ -434,15 +521,25 @@ static void disable_interrupts(struct tpm_chip *chip)
 static int tpm_tis_send_main(struct tpm_chip *chip, const u8 *buf, size_t len)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
-	int rc;
+	int rc,i;
 	u32 ordinal;
 	unsigned long dur;
-
-	rc = tpm_tis_send_data(chip, buf, len);
-	if (rc < 0)
-		return rc;
+	bool data_valid = false;
+	
+	//rc = tpm_tis_send_data(chip, buf, len);
+	//if (rc < 0)
+	//	return rc;
 
 	/* go and do it */
+	for (i = 0; i < TPM_RETRY && !data_valid; i++) {
+		rc = tpm_tis_send_data(chip, buf, len);
+		if (rc < 0)
+			return rc;
+		data_valid = tpm_tis_check_data(chip, buf, len);
+	}
+	if (!data_valid)
+		return -EIO;
+	
 	rc = tpm_tis_write8(priv, TPM_STS(priv->locality), TPM_STS_GO);
 	if (rc < 0)
 		goto out_err;
@@ -665,17 +762,7 @@ static int probe_itpm(struct tpm_chip *chip)
 
 static bool tpm_tis_req_canceled(struct tpm_chip *chip, u8 status)
 {
-	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
-
-	switch (priv->manufacturer_id) {
-	case TPM_VID_WINBOND:
-		return ((status == TPM_STS_VALID) ||
-			(status == (TPM_STS_VALID | TPM_STS_COMMAND_READY)));
-	case TPM_VID_STM:
-		return (status == (TPM_STS_VALID | TPM_STS_COMMAND_READY));
-	default:
-		return (status == TPM_STS_COMMAND_READY);
-	}
+	return ((status & TPM_STS_COMMAND_READY) == TPM_STS_COMMAND_READY);
 }
 
 static irqreturn_t tis_int_handler(int dummy, void *dev_id)
@@ -925,6 +1012,9 @@ int tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,
 	u32 vendor;
 	u32 intfcaps;
 	u32 intmask;
+#ifdef CONFIG_TCG_TIS_I2C
+	u32 BusInterface;
+#endif
 	u32 clkrun_val;
 	u8 rid;
 	int rc, probe;
@@ -1001,7 +1091,17 @@ int tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,
 	dev_info(dev, "%s TPM (device-id 0x%X, rev-id %d)\n",
 		 (chip->flags & TPM_CHIP_FLAG_TPM2) ? "2.0" : "1.2",
 		 vendor >> 16, rid);
+#ifdef CONFIG_TCG_TIS_I2C
+	rc = tpm_tis_read32(priv, TPM_INTF_CAPABILITY(0), &BusInterface);
+	if (rc < 0)
+		goto out_err;
 
+	priv->interface_id = BusInterface;
+
+	dev_info(dev, " TPM %s / Interface : %s)\n",
+		(chip->flags & TPM_CHIP_FLAG_TPM2) ? "2.0" : "1.2",
+		(priv->interface_id) ? "I2C" : "SPI" );
+#endif
 	probe = probe_itpm(chip);
 	if (probe < 0) {
 		rc = -ENODEV;
diff --git a/drivers/char/tpm/tpm_tis_core.h b/drivers/char/tpm/tpm_tis_core.h
index b2a3c6c72882..a7c8d0b2ef55 100644
--- a/drivers/char/tpm/tpm_tis_core.h
+++ b/drivers/char/tpm/tpm_tis_core.h
@@ -72,6 +72,11 @@ enum tis_defaults {
 #define	TPM_STS(l)			(0x0018 | ((l) << 12))
 #define	TPM_STS3(l)			(0x001b | ((l) << 12))
 #define	TPM_DATA_FIFO(l)		(0x0024 | ((l) << 12))
+#ifdef CONFIG_TCG_TIS_I2C
+/* fix BHO I2C implementation */
+#define	TPM_INTF_CAPABILITY(l)		(0x0030 | ((l) << 12))
+/* fix BHO I2C implementation */
+#endif
 
 #define	TPM_DID_VID(l)			(0x0F00 | ((l) << 12))
 #define	TPM_RID(l)			(0x0F04 | ((l) << 12))
@@ -88,6 +93,11 @@ enum tpm_tis_flags {
 
 struct tpm_tis_data {
 	u16 manufacturer_id;
+#ifdef CONFIG_TCG_TIS_I2C
+	/* fix BHO I2C implementation */
+	u8 interface_id;
+	/* fix BHO I2C implementation */
+#endif
 	int locality;
 	int irq;
 	bool irq_tested;
@@ -108,6 +118,11 @@ struct tpm_tis_phy_ops {
 	int (*read16)(struct tpm_tis_data *data, u32 addr, u16 *result);
 	int (*read32)(struct tpm_tis_data *data, u32 addr, u32 *result);
 	int (*write32)(struct tpm_tis_data *data, u32 addr, u32 src);
+#ifdef CONFIG_TCG_TIS_I2C
+	/* fix BHO I2C implementation */
+	bool (*check_data)(struct tpm_tis_data *data, u8 *buf, size_t len);
+	/* fix BHO I2C implementation */
+#endif
 };
 
 static inline int tpm_tis_read_bytes(struct tpm_tis_data *data, u32 addr,
@@ -124,19 +139,42 @@ static inline int tpm_tis_read8(struct tpm_tis_data *data, u32 addr, u8 *result)
 static inline int tpm_tis_read16(struct tpm_tis_data *data, u32 addr,
 				 u16 *result)
 {
-	return data->phy_ops->read16(data, addr, result);
+	__le16 result_le;
+	int rc;
+
+	if (data->phy_ops->read16)
+		return data->phy_ops->read16(data, addr, result);
+
+	rc = data->phy_ops->read_bytes(data, addr, sizeof(u16),
+				       (u8 *)&result_le);
+	if (!rc)
+		*result = le16_to_cpu(result_le);
+
+	return rc;
 }
 
 static inline int tpm_tis_read32(struct tpm_tis_data *data, u32 addr,
 				 u32 *result)
 {
-	return data->phy_ops->read32(data, addr, result);
+	__le32 result_le;
+	int rc;
+
+	if (data->phy_ops->read32)
+		return data->phy_ops->read32(data, addr, result);
+
+	rc = data->phy_ops->read_bytes(data, addr, sizeof(u32),
+				       (u8 *)&result_le);
+	if (!rc)
+		*result = le32_to_cpu(result_le);
+
+	return rc;
 }
 
 static inline int tpm_tis_write_bytes(struct tpm_tis_data *data, u32 addr,
 				      u16 len, const u8 *value)
 {
 	return data->phy_ops->write_bytes(data, addr, len, value);
+
 }
 
 static inline int tpm_tis_write8(struct tpm_tis_data *data, u32 addr, u8 value)
@@ -147,7 +185,17 @@ static inline int tpm_tis_write8(struct tpm_tis_data *data, u32 addr, u8 value)
 static inline int tpm_tis_write32(struct tpm_tis_data *data, u32 addr,
 				  u32 value)
 {
-	return data->phy_ops->write32(data, addr, value);
+	__le32 value_le;
+	int rc;
+
+	if (data->phy_ops->write32)
+		return data->phy_ops->write32(data, addr, value);
+
+	value_le = cpu_to_le32(value);
+	rc = data->phy_ops->write_bytes(data, addr, sizeof(u32),
+					(u8 *)&value_le);
+
+	return rc;
 }
 
 static inline bool is_bsw(void)
diff --git a/drivers/char/tpm/tpm_tis_i2c.c b/drivers/char/tpm/tpm_tis_i2c.c
new file mode 100755
index 000000000000..fe16c270dc0d
--- /dev/null
+++ b/drivers/char/tpm/tpm_tis_i2c.c
@@ -0,0 +1,526 @@
+/*
+ * STMicroelectronics TCG TPM I2C Linux driver
+ * Copyright (C) 2018 STMicroelectronics
+ *
+ * Authors:
+ *
+ * Christophe Ricard <christophe-h.ricard@st.com>
+ * Benoit Houy√®re	<benoit.houyere@st.com>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/acpi.h>
+#include <linux/freezer.h>
+#include <linux/crc-ccitt.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/tpm.h>
+#include <linux/timer.h>
+#include "tpm.h"
+#include "tpm_tis_core.h"
+
+#define TPM_LOC_SEL						0x04
+#define TPM_I2C_INTERFACE_CAPABILITY	0x30
+#define TPM_I2C_DEVICE_ADDRESS			0x38
+#define TPM_DATA_CSUM_ENABLE			0x40
+#define TPM_DATA_CSUM					0x44
+#define TPM_I2C_DID_VID					0x48
+#define TPM_I2C_RID						0x4C
+
+#define TPM_I2C_DEFAULT_GUARD_TIME	0xFA
+
+enum tpm_tis_i2c_operation {
+	TPM_I2C_NONE,
+	TPM_I2C_RECV,
+	TPM_I2C_SEND,
+};
+
+#define TPM_I2C_DEVADRCHANGE(x)		((0x18000000 & x) >> 27)
+#define TPM_I2C_READ_READ(x)		((0x00100000 & x) >> 20)
+#define TPM_I2C_READ_WRITE(x)		((0x00080000 & x) >> 19)
+#define TPM_I2C_WRITE_READ(x)		((0x00040000 & x) >> 18)
+#define TPM_I2C_WRITE_WRITE(x)		((0x00020000 & x) >> 17)
+#define TPM_I2C_GUARD_TIME(x)		((0x0001FE00 & x) >> 9)
+
+struct tpm_tis_i2c_phy {
+	struct i2c_client *client;
+	struct tpm_tis_data priv;
+	u8 buf[TPM_BUFSIZE +1];
+	u8 last_i2c_ops;
+
+	struct timer_list guard_timer;
+	struct mutex phy_lock;
+
+	u8 data_csum;
+	bool devadrchange;
+	bool read_read;
+	bool read_write;
+	bool write_read;
+	bool write_write;
+	u8 guard_time;
+};
+
+static inline struct tpm_tis_i2c_phy *to_tpm_tis_i2c_phy(struct tpm_tis_data *data)
+{
+	return container_of(data, struct tpm_tis_i2c_phy, priv);
+}
+
+static int tpm_tis_i2c_ptp_register_mapper(u32 addr, u8 *i2c_reg)
+{
+	*i2c_reg = (u8)(0x000000ff & addr);
+
+	switch (addr) {
+	case TPM_ACCESS(0):
+		*i2c_reg = TPM_LOC_SEL;
+		break;
+	case TPM_LOC_SEL:
+		*i2c_reg = TPM_ACCESS(0);
+		break;
+	case TPM_DID_VID(0):
+		*i2c_reg = TPM_I2C_DID_VID;
+		break;
+	case TPM_RID(0):
+		*i2c_reg = TPM_I2C_RID;
+		break;
+	case TPM_INTF_CAPABILITY(0):
+		*i2c_reg = TPM_I2C_INTERFACE_CAPABILITY;
+		break;
+	case TPM_INT_VECTOR(0):
+		return -1;
+	}
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+static void tpm_tis_i2c_guard_time_timeout(struct timer_list *data)
+{
+	struct tpm_tis_i2c_phy *phy = from_timer(phy, data, guard_timer);
+#else
+static void tpm_tis_i2c_guard_time_timeout(unsigned long data)
+{
+	struct tpm_tis_i2c_phy *phy = (struct tpm_tis_i2c_phy *)data;
+#endif
+
+	/* GUARD_TIME expired */
+	phy->last_i2c_ops = TPM_I2C_NONE;
+}
+
+static void tpm_tis_i2c_sleep_guard_time(struct tpm_tis_i2c_phy *phy,
+					 u8 i2c_operation)
+{
+	del_timer_sync(&phy->guard_timer);
+	switch (i2c_operation) {
+	case TPM_I2C_RECV:
+		switch (phy->last_i2c_ops) {
+		case TPM_I2C_RECV:
+		if (phy->read_read)
+			udelay(phy->guard_time);
+		break;
+		case TPM_I2C_SEND:
+		if (phy->write_read)
+			udelay(phy->guard_time);
+		break;
+		}
+	break;
+	case TPM_I2C_SEND:
+		switch (phy->last_i2c_ops) {
+		case TPM_I2C_RECV:
+		if (phy->read_write)
+			udelay(phy->guard_time);
+		break;
+		case TPM_I2C_SEND:
+		if (phy->write_write)
+			udelay(phy->guard_time);
+		break;
+		}
+	break;
+	}
+	phy->last_i2c_ops = i2c_operation;
+
+}
+
+static int tpm_tis_i2c_read_bytes(struct tpm_tis_data *data, u32 addr,
+				  u16 size, u8 *result)
+{
+	struct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);
+	int i=0;
+	int ret = 0;
+	u8 i2c_reg;
+	mutex_lock(&phy->phy_lock);
+	ret = tpm_tis_i2c_ptp_register_mapper(addr, &i2c_reg);
+	if (ret < 0) {
+		/* If we don't have any register equivalence in i2c
+		 * ignore the sequence.
+		 */
+		ret = size;
+		goto exit;
+	}
+	ret = -1;
+
+	for (i = 0; (i < TPM_RETRY) && (ret < 0); i++) {
+		tpm_tis_i2c_sleep_guard_time(phy, TPM_I2C_SEND);
+		ret = i2c_master_send(phy->client, &i2c_reg, 1);
+		mod_timer(&phy->guard_timer, phy->guard_time);
+	}
+
+	if (ret < 0)
+	{
+		sprintf(phy->buf, " read 1 %x\n", phy->guard_time);
+		goto exit;
+	}
+	ret = -1;
+	for (i = 0; (i < TPM_RETRY) && (ret < 0); i++) {
+		tpm_tis_i2c_sleep_guard_time(phy, TPM_I2C_RECV);
+		ret = i2c_master_recv(phy->client, result, size);
+		mod_timer(&phy->guard_timer, phy->guard_time);
+	}
+	if (ret < 0)
+	{
+		sprintf(phy->buf, " read 2 %x\n", phy->guard_time);
+		goto exit;
+	}
+exit:
+	mutex_unlock(&phy->phy_lock);
+	return ret;
+}
+
+static int tpm_tis_i2c_write_bytes(struct tpm_tis_data *data, u32 addr,
+				   u16 size, const u8 *value)
+{
+	struct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);
+	int ret = 0;
+	int i;
+	u8 i2c_reg;
+
+	mutex_lock(&phy->phy_lock);
+	ret = tpm_tis_i2c_ptp_register_mapper(addr, &i2c_reg);
+	if (ret < 0) {
+		/* If we don't have any register equivalence in i2c
+		 * ignore the sequence.
+		 */
+		ret = size;
+		goto exit;
+	}
+
+	ret = -1;
+	phy->buf[0] = i2c_reg;
+	memcpy(phy->buf + 1, value, size);
+
+	for (i = 0; (i < TPM_RETRY) && ((ret < 0 || ret < size + 1)); i++) {
+		tpm_tis_i2c_sleep_guard_time(phy, TPM_I2C_SEND);
+		ret = i2c_master_send(phy->client, phy->buf, size + 1);
+		mod_timer(&phy->guard_timer, phy->guard_time);
+	}
+		if (ret < 0)
+	{
+		sprintf(phy->buf, " WRITE 1 %x\n", phy->guard_time);
+		goto exit;
+	}
+exit:
+	mutex_unlock(&phy->phy_lock);
+	return ret;
+}
+
+static int tpm_tis_i2c_read16(struct tpm_tis_data *data, u32 addr, u16 *result)
+{
+	int rc;
+
+	rc = data->phy_ops->read_bytes(data, addr, sizeof(u16), (u8 *)result);
+	if (!rc)
+		*result = le16_to_cpu(*result);
+	return rc;
+}
+
+static int tpm_tis_i2c_read32(struct tpm_tis_data *data, u32 addr, u32 *result)
+{
+	int rc;
+
+	rc = data->phy_ops->read_bytes(data, addr, sizeof(u32), (u8 *)result);
+	if (!rc)
+		*result = le32_to_cpu(*result);
+	return rc;
+}
+
+static int tpm_tis_i2c_write32(struct tpm_tis_data *data, u32 addr, u32 value)
+{
+	value = cpu_to_le32(value);
+	return data->phy_ops->write_bytes(data, addr, sizeof(u32),
+					   (u8 *)&value);
+}
+
+static bool tpm_tis_i2c_check_data(struct tpm_tis_data *data, u8 *buf, size_t len)
+{
+	struct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);
+	u16 crc, crc_tpm;
+	if (phy->data_csum==1) {
+		crc = crc_ccitt(0x0000, buf, len);
+
+		crc_tpm = tpm_tis_read16(data, TPM_DATA_CSUM, &crc_tpm);
+		crc_tpm = be16_to_cpu(crc_tpm);
+
+		return crc == crc_tpm;
+	}
+	return true;
+}
+
+static const struct tpm_tis_phy_ops tpm_tis = {
+	.read_bytes = tpm_tis_i2c_read_bytes,
+	.write_bytes = tpm_tis_i2c_write_bytes,
+	.read16 = tpm_tis_i2c_read16,
+	.read32 = tpm_tis_i2c_read32,
+	.write32 = tpm_tis_i2c_write32,
+};
+
+static SIMPLE_DEV_PM_OPS(tpm_tis_i2c_pm, tpm_pm_suspend, tpm_tis_resume);
+
+static ssize_t i2c_addr_show(struct device *dev,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	if (client)
+		return sprintf(buf, "0x%.2x\n", client->addr);
+
+	return 0;
+}
+
+static ssize_t i2c_addr_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct tpm_tis_data *data = dev_get_drvdata(dev);
+	struct tpm_tis_i2c_phy *phy;
+	long new_addr;
+	u16 cur_addr;
+	int ret = 0;
+	if (!data)
+		goto exit;
+
+	phy = to_tpm_tis_i2c_phy(data);
+	if (!phy || !phy->client || !phy->devadrchange)
+		goto exit;
+
+	/* Base string automatically detected */
+	ret = kstrtol(buf, 0, &new_addr);
+	if (ret < 0)
+		goto exit;
+
+	ret = tpm_tis_i2c_write32(data, TPM_I2C_DEVICE_ADDRESS,(u32) new_addr);
+	if (ret < 0)
+		goto exit;
+
+	tpm_tis_i2c_read16(data, TPM_I2C_DEVICE_ADDRESS,&cur_addr);
+	if (cur_addr == new_addr) {
+		phy->client->addr = new_addr & 0x00ff;
+		return count;
+	}
+
+	return -EINVAL;
+exit:
+	return ret;
+}
+static DEVICE_ATTR_RW(i2c_addr);
+
+static ssize_t csum_state_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct tpm_tis_data *data = dev_get_drvdata(dev);
+	struct tpm_tis_i2c_phy *phy;
+
+	if (!data)
+		goto exit;
+
+	phy = to_tpm_tis_i2c_phy(data);
+	if (!phy || !phy->client)
+		goto exit;
+
+	return sprintf(buf, "%x\n", phy->data_csum);
+exit:
+	return 0;
+}
+
+static ssize_t csum_state_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct tpm_tis_data *data = dev_get_drvdata(dev);
+	struct tpm_tis_i2c_phy *phy;
+	long new_state;
+	u8 cur_state;
+	int ret = 0;
+
+	if (!data)
+		goto exit;
+
+	phy = to_tpm_tis_i2c_phy(data);
+	if (!phy || !phy->client)
+		goto exit;
+
+	ret = kstrtol(buf, 2, &new_state);
+	if (ret < 0)
+		goto exit;
+
+	ret = tpm_tis_i2c_write32(data, TPM_DATA_CSUM_ENABLE, new_state);
+	if (ret < 0)
+		goto exit;
+
+	tpm_tis_read_bytes(data, TPM_DATA_CSUM_ENABLE,sizeof(u16),&cur_state);
+	if (new_state == cur_state) {
+		phy->data_csum = cur_state;
+		return count;
+	}
+
+	return -EINVAL;
+exit:
+	return ret;
+}
+static DEVICE_ATTR_RW(csum_state);
+
+static struct attribute *tpm_tis_i2c_attrs[] = {
+	&dev_attr_i2c_addr.attr,
+	&dev_attr_csum_state.attr,
+	NULL,
+};
+
+static struct attribute_group tpm_tis_i2c_attr_group = {
+	.attrs = tpm_tis_i2c_attrs,
+};
+
+static int tpm_tis_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct tpm_tis_i2c_phy *phy;
+	int rst_gpio,reset_time,retval;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "client not i2c capable\n");
+		return -ENODEV;
+	}
+
+	phy = devm_kzalloc(&client->dev, sizeof(struct tpm_tis_i2c_phy),
+			   GFP_KERNEL);
+
+	if (!phy)
+		{ dev_err(&client->dev,"%s:devm_kzalloc failed.\n",
+				__func__);
+		return -ENOMEM;
+		}
+
+	/* request reset pin */
+	rst_gpio = of_get_named_gpio(dev->of_node, "tpm-reset", 0);
+	if (!gpio_is_valid(rst_gpio)){
+		dev_warn(dev, "No TPM reset pin available");
+		return -ENODEV;
+	} else {
+		retval = devm_gpio_request_one(dev, rst_gpio,GPIOF_OUT_INIT_HIGH, "tpm_reset");
+		if (retval < 0) {
+			dev_warn(dev, "Failed to set tpm reset pin\n");
+			return retval;
+		}
+	}
+	/* request reset time */
+	reset_time = of_get_named_gpio(dev->of_node, "reset-assert-us", 0);
+	if(reset_time<=0)
+		reset_time=100000;
+
+	/* reset tpm */
+	gpio_set_value(rst_gpio, 0);
+	usleep_range(reset_time, reset_time);
+	gpio_set_value(rst_gpio, 1);
+
+	phy->client = client;
+
+	mutex_init(&phy->phy_lock);
+
+	phy->guard_time = TPM_I2C_DEFAULT_GUARD_TIME;
+
+	phy->read_read = false;
+	phy->read_write = false;
+	phy->write_read = false;
+	phy->write_write = false;
+
+	/* initialize timer */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	timer_setup(&phy->guard_timer, tpm_tis_i2c_guard_time_timeout, 0);
+#else
+	init_timer(&phy->guard_timer);
+	phy->guard_timer.data = (unsigned long)phy;
+#endif
+	phy->guard_timer.function = tpm_tis_i2c_guard_time_timeout;
+
+
+	return tpm_tis_core_init(&client->dev, &phy->priv, -1, &tpm_tis,
+				 NULL);
+
+
+}
+
+static int tpm_tis_i2c_remove(struct i2c_client *client)
+{
+
+	struct tpm_chip *data = i2c_get_clientdata(client);
+	tpm_chip_unregister(data);
+	return 0;
+}
+
+static const struct i2c_device_id tpm_tis_i2c_id[] = {
+	{"tpm_tis_i2c", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, tpm_tis_i2c_id);
+
+static const struct of_device_id of_tis_i2c_match[] = {
+	{ .compatible = "st,st33htpm-i2c", },
+	{ .compatible = "tcg,tpm_tis-i2c", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, of_tis_i2c_match);
+
+static const struct acpi_device_id acpi_tis_i2c_match[] = {
+	{"SMO0768", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(acpi, acpi_tis_i2c_match);
+
+static struct i2c_driver tpm_tis_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "tpm_tis_i2c",
+		.pm = &tpm_tis_i2c_pm,
+		.of_match_table = of_match_ptr(of_tis_i2c_match),
+		.acpi_match_table = ACPI_PTR(acpi_tis_i2c_match),
+	},
+	.probe = tpm_tis_i2c_probe,
+	.remove = tpm_tis_i2c_remove,
+	.id_table = tpm_tis_i2c_id,
+};
+
+module_i2c_driver(tpm_tis_i2c_driver);
+
+MODULE_DESCRIPTION("TPM Driver for native I2C access");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/tpm/tpm_tis_spi.c b/drivers/char/tpm/tpm_tis_spi.c
new file mode 100755
index 000000000000..b32b0673c110
--- /dev/null
+++ b/drivers/char/tpm/tpm_tis_spi.c
@@ -0,0 +1,237 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2015 Infineon Technologies AG
+ * Copyright (C) 2016 STMicroelectronics SAS
+ *
+ * Authors:
+ * Peter Huewe <peter.huewe@infineon.com>
+ * Christophe Ricard <christophe-h.ricard@st.com>
+ *
+ * Maintained by: <tpmdd-devel@lists.sourceforge.net>
+ *
+ * Device driver for TCG/TCPA TPM (trusted platform module).
+ * Specifications at www.trustedcomputinggroup.org
+ *
+ * This device driver implements the TPM interface as defined in
+ * the TCG TPM Interface Spec version 1.3, revision 27 via _raw/native
+ * SPI access_.
+ *
+ * It is based on the original tpm_tis device driver from Leendert van
+ * Dorn and Kyleen Hall and Jarko Sakkinnen.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/acpi.h>
+#include <linux/freezer.h>
+
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/tpm.h>
+#include "tpm.h"
+#include "tpm_tis_core.h"
+
+#define MAX_SPI_FRAMESIZE 64
+
+struct tpm_tis_spi_phy {
+	struct tpm_tis_data priv;
+	struct spi_device *spi_device;
+	u8 *iobuf;
+};
+
+static inline struct tpm_tis_spi_phy *to_tpm_tis_spi_phy(struct tpm_tis_data *data)
+{
+	return container_of(data, struct tpm_tis_spi_phy, priv);
+}
+
+static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,
+				u8 *in, const u8 *out)
+{
+	struct tpm_tis_spi_phy *phy = to_tpm_tis_spi_phy(data);
+	int ret = 0;
+	int i;
+	struct spi_message m;
+	struct spi_transfer spi_xfer;
+	u8 transfer_len;
+
+	spi_bus_lock(phy->spi_device->master);
+
+	while (len) {
+		transfer_len = min_t(u16, len, MAX_SPI_FRAMESIZE);
+
+		phy->iobuf[0] = (in ? 0x80 : 0) | (transfer_len - 1);
+		phy->iobuf[1] = 0xd4;
+		phy->iobuf[2] = addr >> 8;
+		phy->iobuf[3] = addr;
+#ifdef CONFIG_TCG_TIS_I2C
+		phy->iobuf[4] = 0x00;
+#endif
+
+		memset(&spi_xfer, 0, sizeof(spi_xfer));
+		spi_xfer.tx_buf = phy->iobuf;
+		spi_xfer.rx_buf = phy->iobuf;
+#ifdef CONFIG_TCG_TIS_I2C
+		spi_xfer.len = 5;
+#else
+		spi_xfer.len = 4;
+#endif
+		spi_xfer.cs_change = 1;
+
+		spi_message_init(&m);
+		spi_message_add_tail(&spi_xfer, &m);
+		ret = spi_sync_locked(phy->spi_device, &m);
+		if (ret < 0)
+			goto exit;
+
+#ifdef CONFIG_TCG_TIS_I2C
+		if ((phy->iobuf[4] & 0x01) == 0) {
+#else
+		if ((phy->iobuf[3] & 0x01) == 0) {
+#endif
+			// handle SPI wait states
+			phy->iobuf[0] = 0;
+
+			for (i = 0; i < TPM_RETRY; i++) {
+				spi_xfer.len = 1;
+				spi_message_init(&m);
+				spi_message_add_tail(&spi_xfer, &m);
+				ret = spi_sync_locked(phy->spi_device, &m);
+				if (ret < 0)
+					goto exit;
+				if (phy->iobuf[0] & 0x01)
+					break;
+			}
+
+			if (i == TPM_RETRY) {
+				ret = -ETIMEDOUT;
+				goto exit;
+			}
+		}
+
+		spi_xfer.cs_change = 0;
+		spi_xfer.len = transfer_len;
+		spi_xfer.delay_usecs = 5;
+
+		if (in) {
+			spi_xfer.tx_buf = NULL;
+		} else if (out) {
+			spi_xfer.rx_buf = NULL;
+			memcpy(phy->iobuf, out, transfer_len);
+			out += transfer_len;
+		}
+
+		spi_message_init(&m);
+		spi_message_add_tail(&spi_xfer, &m);
+		ret = spi_sync_locked(phy->spi_device, &m);
+		if (ret < 0)
+			goto exit;
+
+		if (in) {
+			memcpy(in, phy->iobuf, transfer_len);
+			in += transfer_len;
+		}
+
+		len -= transfer_len;
+	}
+
+exit:
+	spi_bus_unlock(phy->spi_device->master);
+	return ret;
+}
+
+static int tpm_tis_spi_read_bytes(struct tpm_tis_data *data, u32 addr,
+				  u16 len, u8 *result)
+{
+	return tpm_tis_spi_transfer(data, addr, len, result, NULL);
+}
+
+static int tpm_tis_spi_write_bytes(struct tpm_tis_data *data, u32 addr,
+				   u16 len, const u8 *value)
+{
+	return tpm_tis_spi_transfer(data, addr, len, NULL, value);
+}
+
+static const struct tpm_tis_phy_ops tpm_spi_phy_ops = {
+	.read_bytes = tpm_tis_spi_read_bytes,
+	.write_bytes = tpm_tis_spi_write_bytes,
+};
+
+static int tpm_tis_spi_probe(struct spi_device *dev)
+{
+	struct tpm_tis_spi_phy *phy;
+	int irq;
+
+	phy = devm_kzalloc(&dev->dev, sizeof(struct tpm_tis_spi_phy),
+			   GFP_KERNEL);
+	if (!phy)
+		return -ENOMEM;
+
+	phy->spi_device = dev;
+
+	phy->iobuf = devm_kmalloc(&dev->dev, MAX_SPI_FRAMESIZE, GFP_KERNEL);
+	if (!phy->iobuf)
+		return -ENOMEM;
+
+	/* If the SPI device has an IRQ then use that */
+	if (dev->irq > 0)
+		irq = dev->irq;
+	else
+		irq = -1;
+
+	return tpm_tis_core_init(&dev->dev, &phy->priv, irq, &tpm_spi_phy_ops,
+				 NULL);
+}
+
+static SIMPLE_DEV_PM_OPS(tpm_tis_pm, tpm_pm_suspend, tpm_tis_resume);
+
+static int tpm_tis_spi_remove(struct spi_device *dev)
+{
+	struct tpm_chip *chip = spi_get_drvdata(dev);
+
+	tpm_chip_unregister(chip);
+	tpm_tis_remove(chip);
+	return 0;
+}
+
+static const struct spi_device_id tpm_tis_spi_id[] = {
+	{"tpm_tis_spi", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(spi, tpm_tis_spi_id);
+
+static const struct of_device_id of_tis_spi_match[] = {
+	{ .compatible = "st,st33htpm-spi", },
+	{ .compatible = "infineon,slb9670", },
+	{ .compatible = "tcg,tpm_tis-spi", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, of_tis_spi_match);
+
+static const struct acpi_device_id acpi_tis_spi_match[] = {
+	{"SMO0768", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(acpi, acpi_tis_spi_match);
+
+static struct spi_driver tpm_tis_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "tpm_tis_spi",
+		.pm = &tpm_tis_pm,
+		.of_match_table = of_match_ptr(of_tis_spi_match),
+		.acpi_match_table = ACPI_PTR(acpi_tis_spi_match),
+	},
+	.probe = tpm_tis_spi_probe,
+	.remove = tpm_tis_spi_remove,
+	.id_table = tpm_tis_spi_id,
+};
+module_spi_driver(tpm_tis_spi_driver);
+
+MODULE_DESCRIPTION("TPM Driver for native SPI access");
+MODULE_LICENSE("GPL");
-- 
2.25.1

