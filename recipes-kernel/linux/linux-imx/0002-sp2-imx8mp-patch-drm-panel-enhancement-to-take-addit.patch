From 3754727b0d74355beb13f18840b8604ab9be063d Mon Sep 17 00:00:00 2001
From: Po Cheng <po.cheng@technexion.com>
Date: Mon, 19 Oct 2020 11:42:07 +0800
Subject: [PATCH 02/16] sp2-imx8mp: patch: drm: panel: enhancement to take
 additional settings from device tree for panel-simple

- parse additional device tree settings for panel desc override

Example:
    panel@0 {
            reg = <0>;
            compatible = "tn,dsi2lvds-panel";
            backlight = <&backlight>;

            panel-width-mm  = <153>;
            panel-height-mm = <90>;
            bits-per-color = <8>;
            bus-format = <1>;
            bus-flags = <1>;
            refresh-rate = <60>;
            rotate = <90>;
            horz-flip; /* enable horz-flip */
            vert-flip; /* enable verz-flip */

            /* for dsi panel only */
            dsi,flags = <0x0007>; /* MIPI_DSI_MODE_VIDEO |
                                     MIPI_DSI_MODE_VIDEO_BURST |
                                     MIPI_DSI_MODE_VIDEO_SYNC_PULSE */
            dsi,format = <0>; /* MIPI_DSI_FMT_RGB888 */
            dsi,lanes = <4>;

            /* panel-timing override */
            panel-timing {
                    clock-frequency = <51000000>;
                    hactive = <1024>;
                    vactive = <600>;
                    hfront-porch = <120>;
                    hsync-len = <100>;
                    hback-porch = <80>;
                    vfront-porch = <1>;
                    vsync-len = <33>;
                    vback-porch = <1>;
                    /* flags */
                    vsync-active = <1/0>;    /* DISPLAY_FLAGS_VSYNC_HIGH/LOW */
                    hsync-active = <1/0>;    /* DISPLAY_FLAGS_HSYNC_HIGH/LOW */
                    de-active = <1/0>;       /* DISPLAY_FLAGS_DE_HIGH/LOW */
                    pixelclk-active = <1/0>; /* DISPLAY_FLAGS_PIXDATA_POSEDGE/NEGEDGE */
                    syncclk-active = <1/0>;  /* DISPLAY_FLAGS_SYNC_POSEDGE/NEGEDGE */
                    interlaced;              /* DISPLAY_FLAGS_INTERLACED */
                    doublescan;              /* DISPLAY_FLAGS_DOUBLESCAN */
                    doubleclk;               /* DISPLAY_FLAGS_DOUBLECLK */
            };
    };

Signed-off-by: Po Cheng <po.cheng@technexion.com>

arm: drm: panel: remove dsi-to-lvds specific timing setting from panel-simple

Signed-off-by: po.cheng <po.cheng@adlinktech.com>
---
 drivers/gpu/drm/panel/panel-simple.c | 109 +++++++++++++++++++++++++--
 1 file changed, 103 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 47e1a2a60eba..1afcf6f6f55a 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -171,6 +171,12 @@ struct panel_desc {
 
 	/** @connector_type: LVDS, eDP, DSI, DPI, etc. */
 	int connector_type;
+
+	/* additional device tree settings for this panel */
+	u32 refresh_rate;
+	u32 rotate;
+	bool hflip;
+	bool vflip;
 };
 
 struct panel_simple {
@@ -229,6 +235,8 @@ static unsigned int panel_simple_get_timings_modes(struct panel_simple *panel,
 		if (panel->desc->num_timings == 1)
 			mode->type |= DRM_MODE_TYPE_PREFERRED;
 
+		drm_mode_debug_printmodeline(mode);
+
 		drm_mode_probed_add(connector, mode);
 		num++;
 	}
@@ -260,6 +268,8 @@ static unsigned int panel_simple_get_display_modes(struct panel_simple *panel,
 
 		drm_mode_set_name(mode);
 
+		drm_mode_debug_printmodeline(mode);
+
 		drm_mode_probed_add(connector, mode);
 		num++;
 	}
@@ -643,16 +653,21 @@ static void panel_simple_parse_panel_timing_node(struct device *dev,
 		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vactive) ||
 		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vfront_porch) ||
 		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vback_porch) ||
-		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vsync_len))
+		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vsync_len)) {
+		        dev_warn(dev, "BOUNDS CHECK failed\n");
 			continue;
+		}
 
-		if (ot->flags != dt->flags)
+		if (ot->flags != dt->flags) {
+			dev_warn(dev, "FLAGS CHECK failed. ot: 0x%x dt:0x%x\n", ot->flags, dt->flags);
 			continue;
+		}
 
 		videomode_from_timing(ot, &vm);
 		drm_display_mode_from_videomode(&vm, &panel->override_mode);
 		panel->override_mode.type |= DRM_MODE_TYPE_DRIVER |
 					     DRM_MODE_TYPE_PREFERRED;
+		dev_warn(dev, "Found suitable override.\n");
 		break;
 	}
 
@@ -660,6 +675,53 @@ static void panel_simple_parse_panel_timing_node(struct device *dev,
 		dev_err(dev, "Reject override mode: No display_timing found\n");
 }
 
+static int panel_simple_parse_dt_settings (struct device *dev, struct panel_simple *panel, const struct panel_desc *desc)
+{
+	struct device_node *np = dev->of_node;
+	struct panel_desc *pd = (struct panel_desc *)desc;
+	int ret = 0;
+
+	/* if other panel node attributes exists, parse them from device tree, and force override */
+	if (of_property_read_bool(np, "panel-width-mm")) {
+		of_property_read_u32(np, "panel-width-mm", &pd->size.width);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "panel-height-mm")) {
+		of_property_read_u32(np, "panel-height-mm", &pd->size.height);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "refresh-rate")) {
+		of_property_read_u32(np, "refresh-rate", &pd->refresh_rate);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "bits-per-color")) {
+		of_property_read_u32(np, "bits-per-color", &pd->bpc);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "bus-format")) {
+		of_property_read_u32(np, "bus-format", &pd->bus_format);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "bus-flags")) {
+		of_property_read_u32(np, "bus-flags", &pd->bus_flags);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "rotate")) {
+		of_property_read_u32(np, "rotate", &pd->rotate);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "horz-flip")) {
+		pd->hflip = true;
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "vert-flip")) {
+		pd->vflip = true;
+		ret = -1;
+	}
+
+	return ret;
+}
+
 static int panel_simple_probe(struct device *dev, const struct panel_desc *desc,
 			      struct drm_dp_aux *aux)
 {
@@ -674,6 +736,11 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc,
 	if (!panel)
 		return -ENOMEM;
 
+	/* force override panel_desc panel settings from dt */
+	err = panel_simple_parse_dt_settings(dev, panel, desc);
+	if (err)
+		dev_warn(dev, "panel-desc setting overridden from dt\n");
+
 	panel->enabled = false;
 	panel->prepared_time = 0;
 	panel->desc = desc;
@@ -5264,23 +5331,53 @@ MODULE_DEVICE_TABLE(of, dsi_of_match);
 
 static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)
 {
+	struct device_node *np;
 	const struct panel_desc_dsi *desc;
 	const struct of_device_id *id;
+	u32 dsi_flags;
+	u32 dsi_format;
+	u32 dsi_lanes;
 	int err;
 
-	id = of_match_node(dsi_of_match, dsi->dev.of_node);
+	np = dsi->dev.of_node;
+	id = of_match_node(dsi_of_match, np);
 	if (!id)
 		return -ENODEV;
 
 	desc = id->data;
 
+	/* if no drm_display_mode from device tree then use the (default) desc (i.e. id->data) */
+	if (!desc) {
+		dsi_flags = desc->flags;
+		dsi_format = desc->format;
+		dsi_lanes = desc->lanes;
+		dev_warn(&dsi->dev, "panel-desc-dsi use default setting\n");
+	} else {
+		/* parse the dsi,flags, format, and lanes setting if set in dt */
+		/* and force override the const static panel_desc_dsi data struct */
+		if (of_property_read_bool(np, "dsi,flags"))
+			of_property_read_u32(np, "dsi,flags", &dsi_flags);
+		if (of_property_read_bool(np, "dsi,format"))
+			of_property_read_u32(np, "dsi,format", &dsi_format);
+		if (of_property_read_bool(np, "dsi,lanes"))
+			of_property_read_u32(np, "dsi,lanes", &dsi_lanes);
+		if (dsi_flags != desc->flags || \
+		    dsi_format != desc->format || \
+		    dsi_lanes !=  desc->lanes) {
+			((struct panel_desc_dsi*)desc)->flags = dsi_flags;
+			((struct panel_desc_dsi*)desc)->format = dsi_format;
+			((struct panel_desc_dsi*)desc)->lanes = dsi_lanes;
+			dev_warn(&dsi->dev, "panel-desc-dsi setting overridden from dt\n");
+		}
+	}
+
 	err = panel_simple_probe(&dsi->dev, &desc->desc, NULL);
 	if (err < 0)
 		return err;
 
-	dsi->mode_flags = desc->flags;
-	dsi->format = desc->format;
-	dsi->lanes = desc->lanes;
+	dsi->mode_flags = dsi_flags;
+	dsi->format = dsi_format;
+	dsi->lanes = dsi_lanes;
 
 	err = mipi_dsi_attach(dsi);
 	if (err) {
-- 
2.25.1

