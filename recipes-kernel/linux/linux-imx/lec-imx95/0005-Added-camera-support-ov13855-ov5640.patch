From 9e19f00447472bdb108691d4f96e662540e4f545 Mon Sep 17 00:00:00 2001
From: Dinesh kumar <dinesh.v@adlinktech.com>
Date: Mon, 11 Nov 2024 22:56:16 +0530
Subject: [PATCH 5/5] Added camera support ov13855,ov5640

---
 drivers/media/i2c/Kconfig   |   10 +
 drivers/media/i2c/Makefile  |    1 +
 drivers/media/i2c/ov13855.c | 1997 +++++++++++++++++++++++++++++++++++
 drivers/media/i2c/ov5640.c  |  134 ++-
 4 files changed, 2092 insertions(+), 50 deletions(-)
 create mode 100644 drivers/media/i2c/ov13855.c

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 1e8141876073..0f4c210980d6 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -300,6 +300,16 @@ config VIDEO_OV08X40
 	  To compile this driver as a module, choose M here: the
 	  module will be called ov08x40.
 
+config VIDEO_OV13855
+       tristate "OmniVision OV13855 sensor support"
+       depends on VIDEO_V4L2_I2C && VIDEO_V4L2_SUBDEV_API
+       depends on MEDIA_CAMERA_SUPPORT
+       depends on GPIOLIB
+       select V4L2_FWNODE
+       help
+         This is a Video4Linux2 sensor driver for the OmniVision
+         OV13855 camera.
+
 config VIDEO_OV13858
 	tristate "OmniVision OV13858 sensor support"
 	help
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 04d29000427f..5c2fc8fa6fb3 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -78,6 +78,7 @@ obj-$(CONFIG_VIDEO_OV01A10) += ov01a10.o
 obj-$(CONFIG_VIDEO_OV02A10) += ov02a10.o
 obj-$(CONFIG_VIDEO_OV08D10) += ov08d10.o
 obj-$(CONFIG_VIDEO_OV08X40) += ov08x40.o
+obj-$(CONFIG_VIDEO_OV13855) += ov13855.o
 obj-$(CONFIG_VIDEO_OV13858) += ov13858.o
 obj-$(CONFIG_VIDEO_OV13B10) += ov13b10.o
 obj-$(CONFIG_VIDEO_OV2640) += ov2640.o
diff --git a/drivers/media/i2c/ov13855.c b/drivers/media/i2c/ov13855.c
new file mode 100644
index 000000000000..8954b33051e0
--- /dev/null
+++ b/drivers/media/i2c/ov13855.c
@@ -0,0 +1,1997 @@
+/*
+ * ov13855 sensor level driver
+ * This driver used to capture raw BGGR data
+ * 4 lanes, 2112x1568, 4224x3136
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+//#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/i2c.h>
+//#include <linux/of_gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/kobject.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include <media/mipi-csi2.h>
+
+#define OV13855_XVCLK_FREQ		24000000
+
+#define CHIP_ID				0x00d855
+#define OV13855_REG_CHIP_ID		0x300a
+
+#define OV13855_REG_CTRL_MODE		0x0100
+#define OV13855_MODE_SW_STANDBY		0x0
+#define OV13855_MODE_STREAMING		BIT(0)
+
+#define OV13855_REG_EXPOSURE		0x3500
+#define	OV13855_EXPOSURE_MIN		4
+#define	OV13855_EXPOSURE_STEP		1
+#define OV13855_VTS_MAX			0x7fff
+
+#define OV13855_REG_TEST_PATTERN	0x4503
+#define ENABLE_TEST_PATTERN		0
+
+#define REG_NULL			0xFFFF
+
+#define OV13855_REG_VALUE_08BIT		1
+#define OV13855_REG_VALUE_16BIT		2
+#define OV13855_REG_VALUE_24BIT		3
+
+#define OV13855_LANES			4
+#define OV13855_BITS_PER_SAMPLE		10
+
+#define OF_CAMERA_PINCTRL_STATE_DEFAULT	"ov13855_camera_default"
+#define OF_CAMERA_PINCTRL_STATE_SLEEP	"ov13855_camera_sleep"
+
+#define OV13855_NAME			"ov13855_mipi_raw"
+#define OV13855_VCHANNEL	0x4813
+
+#define OV13855_RES_HIGH_WIDTH		4096
+#define OV13855_RES_HIGH_HEIGHT		3136
+#define OV13855_RES_LOW_WIDTH		2112
+#define OV13855_RES_LOW_HEIGHT		1568
+
+#define DEFAULT_FPS	15
+
+#define OV13855_SENS_PAD_SOURCE	0
+#define OV13855_SENS_PADS_NUM	1
+
+static const struct regval *ov13855_regs;
+
+struct regval {
+	u16 addr;
+	u8 val;
+};
+
+struct ov13855_mode {
+	u32 width;
+	u32 height;
+	const struct regval *reg_list;
+};
+
+struct os08a20_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *link_freq;
+};
+
+struct ov13855 {
+	struct v4l2_subdev		subdev;
+	struct i2c_client *i2c_client;
+	struct v4l2_pix_format pix;
+	const struct ov13855_datafmt	*fmt;
+	struct v4l2_captureparm streamcap;
+	bool on;
+
+	u32 mclk;
+	u8 mclk_source;
+	struct clk *sensor_clk;
+	int csi_vc;
+
+
+	struct gpio_desc *rst_gpio;
+	struct gpio_desc *pwn_gpio;
+	struct media_pad pads[OV13855_SENS_PADS_NUM];
+
+	bool streaming;
+	int mode;
+	struct mutex lock; /* sensor lock */
+	struct os08a20_ctrls ctrls;
+
+};
+
+
+struct ov13855_datafmt {
+	u32	code;
+	enum v4l2_colorspace		colorspace;
+};
+
+static const struct ov13855_datafmt ov13855_colour_fmts[] = {
+	{MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_COLORSPACE_RAW},
+};
+
+
+
+static struct regval ov13855_1920x1080[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x02},
+	{0x0301, 0x00},
+	{0x0302, 0x5a},
+	{0x0303, 0x01},
+	{0x0304, 0x00},
+	{0x0305, 0x01},
+	{0x030b, 0x06},
+	{0x030c, 0x02},
+	{0x030d, 0x88},
+	{0x0312, 0x11},
+	{0x3022, 0x41},
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x3016, 0x72},
+	{0x301b, 0xF0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x40},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x10},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x28},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x38},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x4f},
+	{0x3808, 0x07},//1920
+	{0x3809, 0x80},
+	{0x380a, 0x04},//1080
+	{0x380b, 0x38},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x06},
+	{0x380f, 0x48},
+	{0x3811, 0x08},
+	{0x3813, 0x02},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x03},
+	{0x3817, 0x01},
+	{0x3820, 0xab},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x90},
+	{0x3829, 0x07},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x00},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4800, 0x60},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xff},
+	{0x5001, 0x07},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0C},
+	{0x5302, 0x0C},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+	{REG_NULL, 0x00},
+};
+static const struct regval ov13855_4096x3136[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x02},
+	{0x0301, 0x00},
+	{0x0302, 0x5a},
+	{0x0303, 0x01},
+	{0x0303, 0x00},
+	{0x0304, 0x00},
+	{0x0305, 0x01},
+	{0x030b, 0x06},
+	{0x030c, 0x02},
+	{0x030d, 0x88},
+	{0x0312, 0x11},
+	{0x3022, 0x41},
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x3016, 0x72},
+	{0x301b, 0xF0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x12},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3737, 0x04},
+	{0x3738, 0xcc},
+	{0x3739, 0x12},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x04},
+	{0x37e4, 0x2A},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x57},
+	{0x3808, 0x10},//4096
+	{0x3809, 0x00},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x08},
+	{0x380c, 0x04},
+	{0x380d, 0xc4},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x10},
+	{0x3813, 0x08},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x11},
+	{0x3827, 0x1c},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0f},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x00},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4800, 0x60},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4837, 0x0e},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xff},
+	{0x5001, 0x07},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0C},
+	{0x5302, 0x0C},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+
+	{REG_NULL, 0x00},
+};
+
+/*Init settings for 3.3MP resolution*/
+static struct regval ov13855_2112x1568[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x02},
+	{0x0301, 0x00},
+	{0x0302, 0x5a},
+	{0x0303, 0x01},
+	{0x0304, 0x00},
+	{0x0305, 0x01},
+	{0x030b, 0x06},
+	{0x030c, 0x02},
+	{0x030d, 0x88},
+	{0x0312, 0x11},
+	{0x3022, 0x41},
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x3016, 0x72},
+	{0x301b, 0xF0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x40},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x10},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x28},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x38},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x4f},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x06},
+	{0x380f, 0x48},
+	{0x3811, 0x08},
+	{0x3813, 0x02},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x03},
+	{0x3817, 0x01},
+	{0x3820, 0xab},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x90},
+	{0x3829, 0x07},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x00},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4800, 0x60},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xff},
+	{0x5001, 0x07},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0C},
+	{0x5302, 0x0C},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+	{REG_NULL, 0x00},
+};
+
+/*Init settings for 13MP resolution*/
+static const struct regval ov13855_4224x3136[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x02},
+	{0x0301, 0x00},
+	{0x0302, 0x5a},
+	{0x0303, 0x01},
+	{0x0303, 0x00},
+	{0x0304, 0x00},
+	{0x0305, 0x01},
+	{0x030b, 0x06},
+	{0x030c, 0x02},
+	{0x030d, 0x88},
+	{0x0312, 0x11},
+	{0x3022, 0x41},
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x3016, 0x72},
+	{0x301b, 0xF0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x12},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3737, 0x04},
+	{0x3738, 0xcc},
+	{0x3739, 0x12},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x04},
+	{0x37e4, 0x2A},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x57},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x08},
+	{0x380c, 0x04},
+	{0x380d, 0xc4},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x10},
+	{0x3813, 0x08},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x11},
+	{0x3827, 0x1c},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0f},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x00},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4800, 0x60},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4837, 0x0e},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xff},
+	{0x5001, 0x07},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0C},
+	{0x5302, 0x0C},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+
+	{REG_NULL, 0x00},
+};
+
+static const struct ov13855_mode supported_modes[] = {
+	{
+		.width = 2112,
+		.height = 1568,
+		.reg_list = ov13855_2112x1568,
+	},{
+		.width = 4096,
+		.height = 3136,
+		.reg_list = ov13855_4096x3136,
+	},
+};
+
+#ifdef OV13855_SYS_DEBUG
+
+#define MAXENTRIES 20
+
+struct kobject *kobj_ov13855;
+int sysregaddr = 0, sysregvalue = 0, countreg=0;
+struct regval dumpvalues[MAXENTRIES+2];
+
+static ssize_t  sysfs_reg_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf);
+static ssize_t  sysfs_reg_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count);
+static ssize_t  sysfs_regvalue_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf);
+static ssize_t  sysfs_regvalue_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count);
+
+struct kobj_attribute ov13855_reg_write = __ATTR(sysregaddr, 0660, sysfs_reg_show, sysfs_reg_store);
+struct kobj_attribute ov13855_regvalue_write = __ATTR(sysregvalue, 0660, sysfs_regvalue_show, sysfs_regvalue_store);
+
+static ssize_t sysfs_regvalue_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	pr_info("ov13855 sysfs read\n");
+	return sprintf(buf, "%x", sysregvalue);
+}
+
+static ssize_t sysfs_regvalue_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count)
+{
+	int i=0, flag = 1;
+
+	pr_info("ov13855 sysfs write\n");
+	sscanf(buf,"%x",&sysregvalue);
+
+	if(countreg < MAXENTRIES) {
+		dumpvalues[countreg].addr = sysregaddr;
+		dumpvalues[countreg].val = sysregvalue;
+		countreg++;
+	}
+
+	return count;
+}
+
+
+static ssize_t sysfs_reg_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	pr_info("Sysfs - Read!!!\n");
+	return sprintf(buf, "%x", sysregaddr);
+}
+
+static ssize_t sysfs_reg_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count)
+{
+	pr_info("Sysfs - reg Write!!!\n");
+	sscanf(buf,"%x",&sysregaddr);
+	return count;
+}
+
+#endif
+
+/* Write registers up to 4 at a time */
+static int ov13855_write_reg(struct i2c_client *client, u16 reg,
+			     u32 len, u32 val)
+{
+	u32 buf_i, val_i;
+	u8 buf[6];
+	u8 *val_p;
+	__be32 val_be;
+//printk("jimmy ov13855_write_reg reg:0x%x\n",reg);
+	if (len > 4)
+		return -EINVAL;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	val_be = cpu_to_be32(val);
+	val_p = (u8 *)&val_be;
+	buf_i = 2;
+	val_i = 4 - len;
+
+	while (val_i < 4)
+		buf[buf_i++] = val_p[val_i++];
+
+
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+	{
+		printk("jimmy ov13855_write_reg failed reg:0x%x\n",reg);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int ov13855_write_array(struct i2c_client *client,
+			       const struct regval *regs)
+{
+	u32 i;
+	int ret = 0;
+
+	for (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)
+		ret = ov13855_write_reg(client, regs[i].addr,
+					OV13855_REG_VALUE_08BIT,
+					regs[i].val);
+
+	return ret;
+}
+
+/* Read registers up to 4 at a time */
+static int ov13855_read_reg(struct i2c_client *client, u16 reg,
+			    unsigned int len, u32 *val)
+{
+	struct i2c_msg msgs[2];
+	u8 *data_be_p;
+	__be32 data_be = 0;
+	__be16 reg_addr_be = cpu_to_be16(reg);
+	int ret;
+printk("jimmy ov13855_read_reg reg:0x%x\n",reg);
+	if (len > 4 || !len)
+		return -EINVAL;
+
+	data_be_p = (u8 *)&data_be;
+	/* Write register address */
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = 2;
+	msgs[0].buf = (u8 *)&reg_addr_be;
+
+	/* Read data from register */
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_be_p[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+	{
+		printk("jimmy ov13855_read_reg reg:0x%x failed\n",reg);
+		return -EIO;
+	}
+	*val = be32_to_cpu(data_be);
+
+	return 0;
+}
+
+static struct ov13855 *to_ov13855(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov13855, subdev);
+}
+
+/*@ov13855_enable_test_pattern - This enables the test pattern
+   Valid values for pattern are 1 - 4
+ Return value - 0 on success, negative on failure*/
+static int ov13855_enable_test_pattern(struct i2c_client *client, u32 pattern)
+{
+	u32 val;
+	val = (pattern - 1) | 0x80;
+
+	return ov13855_write_reg(client,
+				 OV13855_REG_TEST_PATTERN,
+				 OV13855_REG_VALUE_08BIT,
+				 val);
+}
+
+/*@ov13855_start_stream - writing mode register settings
+ and streaming register
+ Return value - 0 on success, negative on failure*/
+
+static int ov13855_start_stream(struct i2c_client *client)
+{
+	int ret = 0;
+	struct ov13855 *sensor = to_ov13855(client);
+	const struct regval *reg_list = supported_modes[sensor->mode].reg_list;
+printk("jimmy ov13855_start_stream +\n");
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	if(sensor->streaming)
+	{
+		pr_debug("OV13855: Already streaming \n");
+		return ret;
+	}
+	/*
+msleep(100);
+printk("jimmy ov13855_start_stream OV13855_MODE_STREAMING msleep 100\n");
+*/
+	ret = ov13855_write_reg(client,
+				 OV13855_REG_CTRL_MODE,
+				 OV13855_REG_VALUE_08BIT,
+				 OV13855_MODE_STREAMING);
+	if(!ret)
+	{
+		printk("jimmy ov13855_start_stream a\n");
+		pr_debug("%s: streaming started \n", __func__);
+		sensor->streaming = 1;
+		msleep(100);
+	}
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	printk("jimmy ov13855_start_stream - ret:0x%x\n",ret);
+	return ret;
+}
+
+static int ov13855_stop_stream(struct i2c_client *client)
+{
+	struct ov13855 *sensor = to_ov13855(client);
+	int ret = 0;
+
+	if(!sensor->streaming) {
+		return ret;
+	}
+	/*
+msleep(100);
+printk("jimmy ov13855_stop_stream OV13855_MODE_SW_STANDBY msleep 100\n");
+	ret = ov13855_write_reg(client,
+				 OV13855_REG_CTRL_MODE,
+				 OV13855_REG_VALUE_08BIT,
+				 OV13855_MODE_SW_STANDBY);
+	if(!ret)
+	*/
+	{
+		pr_debug("%s: streaming stopped fake\n", __func__);
+		sensor->streaming = 0;
+	}
+	return ret;
+
+}
+
+/* Calculate the delay in us by clock rate and clock cycles */
+static inline u32 ov13855_cal_delay(u32 cycles)
+{
+        return DIV_ROUND_UP(cycles, OV13855_XVCLK_FREQ / 1000 / 1000);
+}
+
+/*@ov13855_power_on - Control reset and power down lines */
+//static void ov13855_power_on(int rst_gpio, int pwn_gpio)
+static void ov13855_power_on(struct ov13855 *sensor)
+{
+	u32 delay_us;
+printk("jimmy ov13855_power_on \n");
+
+printk("jimmy ov13855_power_on  pwn_gpio 0\n");
+	gpiod_set_value_cansleep(sensor->pwn_gpio, 0);
+
+	usleep_range(3000, 5000);
+printk("jimmy ov13855_power_on  rst_gpio 1\n");
+	gpiod_set_value_cansleep(sensor->rst_gpio, 1);
+
+	usleep_range(3000, 5000);
+printk("jimmy ov13855_power_on  pwn_gpio 1\n");
+	gpiod_set_value_cansleep(sensor->pwn_gpio, 1);
+	usleep_range(3000, 5000);
+printk("jimmy ov13855_power_on  rst_gpio 0\n");
+	gpiod_set_value_cansleep(sensor->rst_gpio, 0);
+	usleep_range(3000, 5000);
+
+	/* 8192 cycles prior to first SCCB transaction */
+        delay_us = ov13855_cal_delay(8192);
+        usleep_range(delay_us, delay_us * 2);
+
+}
+
+//static void ov13855_power_off(int rst_gpio, int pwn_gpio)
+static void ov13855_power_off(struct ov13855 *sensor)
+{
+	printk("jimmy ov13855_power_off\n");
+	
+	msleep(10);
+	printk("jimmy ov13855_power_off  rst_gpio 1\n");
+	gpiod_set_value_cansleep(sensor->rst_gpio, 1);
+	usleep_range(3000, 5000);
+	printk("jimmy ov13855_power_off  pwn_gpio 0\n");
+	gpiod_set_value_cansleep(sensor->pwn_gpio, 0);
+	usleep_range(3000, 5000);
+	
+}
+
+static int ov13855_check_sensor_id(struct i2c_client *client)
+{
+	u32 id = 0;
+	int ret;
+
+	ret = ov13855_read_reg(client, OV13855_REG_CHIP_ID,
+			       OV13855_REG_VALUE_24BIT, &id);
+	printk(KERN_ALERT "OV13855, register 0x300A: 0x%x\n", id);
+	if (id != CHIP_ID) {
+		pr_err("Unexpected sensor id(%06x), ret(%d)\n", id, ret);
+		return -ENODEV;
+	}
+
+	ov13855_regs = ov13855_2112x1568;
+	pr_info("Detected OV13855: %06x sensor\n", CHIP_ID);
+
+	return 0;
+}
+
+
+
+static int ov13855_write_init_settings(struct i2c_client *client,
+					const struct regval *settings)
+{
+	int retval = 0;
+
+	retval = ov13855_write_array(client, settings);
+	if (retval) {
+		pr_err("OV13855 global settings failed !\n");
+		return retval;
+	}
+	msleep(5);
+	return retval;
+}
+
+static int ov13855_enum_framesizes(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_frame_size_enum *fse)
+{
+
+	printk("jimmy ov13855_enum_framesizes +\n");
+	if (fse->index > 2)
+                return -EINVAL;
+	fse->max_width = supported_modes[fse->index].width;
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_height = supported_modes[fse->index].height;
+	fse->min_height = supported_modes[fse->index].height;
+	return 0;
+}
+
+static int ov13855_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+printk("jimmy ov13855_get_fmt +\n");
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	memset(mf, 0, sizeof(struct v4l2_mbus_framefmt));
+printk("jimmy ov13855_get_fmt org code:0x%x colorspace:0x%x\n",mf->code,mf->colorspace);
+	mf->code = ov13855_colour_fmts[0].code;
+	mf->colorspace = ov13855_colour_fmts[0].colorspace;
+	printk("jimmy ov13855_get_fmt new code:0x%x colorspace:0x%x\n",mf->code,mf->colorspace);
+printk("jimmy ov13855_get_fmt pixelformat:0x%x\n",sensor->pix.pixelformat);
+	 
+	mf->width = sensor->pix.width;
+	mf->height = sensor->pix.height;
+	mf->field = V4L2_FIELD_NONE;
+printk("jimmy ov13855_get_fmt -\n");
+	return 0;
+}
+
+static int ov13855_sensor_suspend(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+ printk("jimmy ov13855_sensor_suspend ov13855_power_off\n");
+	clk_disable_unprepare(sensor->sensor_clk);
+	ov13855_power_off(sensor);
+	return 0;
+}
+
+static int  ov13855_sensor_resume(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+ printk("jimmy ov13855_sensor_resume ov13855_power_on\n");
+ 	clk_prepare_enable(sensor->sensor_clk);
+	ov13855_power_on(sensor);
+
+	return 0;
+ }
+/*
+static int ov13855_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+
+	pr_debug("%s: %d\n", __func__, on);
+	if (on) {
+		clk_prepare_enable(sensor->sensor_clk);
+		ov13855_power_on(sensor->rst_gpio, sensor->pwn_gpio);
+	} else if (!on) {
+		clk_disable_unprepare(sensor->sensor_clk);
+		ov13855_power_off(sensor->rst_gpio, sensor->pwn_gpio);
+	}
+
+	return 0;
+}
+*/
+
+static int ov13855_enum_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	printk("jimmy ov13855_enum_code +\n");
+	if (code->pad || code->index >= ARRAY_SIZE(ov13855_colour_fmts))
+		return -EINVAL;
+
+	code->code = ov13855_colour_fmts[code->index].code;
+	return 0;
+}
+
+static int ov13855_enum_frameintervals(struct v4l2_subdev *sd,
+		struct v4l2_subdev_state *sd_state,
+		struct v4l2_subdev_frame_interval_enum *fival)
+{
+	printk("jimmy ov13855_enum_frameintervals +\n");
+	if(fival->index > 2)
+		return -EINVAL;
+	fival->interval.numerator = 1;
+	fival->interval.denominator = DEFAULT_FPS;
+
+	return 0;
+}
+
+
+static int ov13855_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+	int ret = 0;
+printk("jimmy ov13855_g_parm +\n");
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	switch (a->type) {
+	/*Need to verify below settings further*/
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+		pr_debug("%s: %d\n", __func__, __LINE__);
+		memset(a, 0, sizeof(*a));
+		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cparm->capability = sensor->streamcap.capability;
+		cparm->timeperframe = sensor->streamcap.timeperframe;
+		cparm->capturemode = sensor->streamcap.capturemode;
+		ret = 0;
+		break;
+	/*These cases not applicable now*/
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		printk("jimmy ov13855_g_parm type is unknown\n");
+		ret = -EINVAL;
+		break;
+	}
+printk("jimmy ov13855_g_parm -\n");
+	return ret;
+}
+
+static int ov13855_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+printk("jimmy ov13855_s_parm +\n");
+	switch (a->type) {
+	/* This is the only case currently handled. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	/*Need to set fps as per request */
+		pr_debug("%s: %d\n", __func__, __LINE__);
+		sensor->streamcap.timeperframe = *timeperframe;
+		sensor->streamcap.capturemode =
+				(u32)a->parm.capture.capturemode;
+		break;
+	/* These cases not applicable for now*/
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		pr_debug("   type is not " \
+			"V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
+			a->type);
+			printk("jimmy ov13855_s_parm a\n");
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		printk("jimmy ov13855_s_parm b\n");
+		ret = -EINVAL;
+		break;
+	}
+printk("jimmy ov13855_s_parm -\n");
+	return ret;
+}
+
+
+static int os08a20_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops os08a20_ctrl_ops = {
+	.s_ctrl = os08a20_s_ctrl,
+};
+
+/*
+ * MIPI CSI-2 link frequencies.
+ * link_freq = (pixel_rate * bpp) / (2 * data_lanes)
+ */
+static const s64 os08a20_csi2_link_freqs[] = {
+	//540000000, //for 4k
+	270000000,
+};
+
+/* Link freq for default mode: 1080p RAW10, 4 data lanes 800 Mbps/lane. */
+#define OS08A20_DEFAULT_LINK_FREQ	0
+
+static int os08a20_init_controls(struct ov13855 *sensor)
+{
+	const struct v4l2_ctrl_ops *ops = &os08a20_ctrl_ops;
+	struct os08a20_ctrls *ctrls = &sensor->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+
+	v4l2_ctrl_handler_init(hdl, 5);
+
+	/* we can use our own mutex for the ctrl lock */
+	hdl->lock = &sensor->lock;
+
+	/* Clock related controls */
+	ctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops,
+					V4L2_CID_LINK_FREQ,
+					ARRAY_SIZE(os08a20_csi2_link_freqs) - 1,
+					OS08A20_DEFAULT_LINK_FREQ,
+					os08a20_csi2_link_freqs);
+
+	if (hdl->error) {
+		ret = hdl->error;
+		goto free_ctrls;
+	}
+
+	ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	sensor->subdev.ctrl_handler = hdl;
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+static int ov13855_s_stream_(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+	int retval;
+printk("jimmy ov13855_s_stream_ %d \n",enable);
+
+	if (enable) {
+		
+		retval = pm_runtime_resume_and_get(&client->dev);
+		if (retval < 0)
+			return retval;
+/*
+		retval = ov13855_start_stream(client);
+		if (retval) {
+			pr_err("OV13855 start stream failed !\n");
+			return retval;
+		}
+		*/
+
+	}
+	else {
+		/*
+		retval = ov13855_stop_stream(client);
+		if (retval) {
+			pr_err("OV13855 stop stream failed !\n");
+			return retval;
+		}
+		*/
+	}
+
+	return 0;
+}
+
+static int ov13855_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+	int retval;
+printk("jimmy ov13855_s_stream  + enable:%d \n",enable);
+	pr_info("s_stream: %d\n", enable);
+	if (enable) {
+		retval = pm_runtime_resume_and_get(&client->dev);
+		if (retval < 0)
+			return retval;
+	/*if valid pattern value then enable test pattern, else go for
+	 * normal streaming. Change ENABLE_TEST_PATTERN with value 1
+	 * to 4 to enable test pattern */
+		if(ENABLE_TEST_PATTERN > 0 && ENABLE_TEST_PATTERN <= 4)
+			ov13855_enable_test_pattern(client,
+						ENABLE_TEST_PATTERN);
+		retval = ov13855_start_stream(client);
+		if (retval) {
+			pr_err("OV13855 start stream failed !\n");
+			return retval;
+		}
+		retval = ov13855_write_reg(client, OV13855_VCHANNEL,
+					OV13855_REG_VALUE_08BIT, sensor->csi_vc);
+		if(retval) {
+			pr_err("%s: set virtual channel failed\n", __func__);
+			return retval;
+		}
+
+	}
+	else {
+		retval = ov13855_stop_stream(client);
+		if (retval) {
+			pr_err("OV13855 stop stream failed !\n");
+			return retval;
+		}
+	}
+printk("jimmy ov13855_s_stream  -\n");
+	return 0;
+}
+
+static int ov13855_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *format)
+{
+	int retval = 0, ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+	int i = 0;
+printk("jimmy ov13855_set_fmt +\n");
+	if(format->format.width == OV13855_RES_HIGH_WIDTH &&
+		format->format.height == OV13855_RES_HIGH_HEIGHT)
+	{
+		printk("jimmy ov13855_set_fmt ov13855_4096x3136\n");
+		sensor->mode = 1;
+		ov13855_regs = ov13855_4096x3136;
+		sensor->pix.width = OV13855_RES_HIGH_WIDTH;
+		sensor->pix.height = OV13855_RES_HIGH_HEIGHT;
+	}
+	else if(format->format.width == OV13855_RES_LOW_WIDTH &&
+		format->format.height == OV13855_RES_LOW_HEIGHT)
+	{
+		printk("jimmy ov13855_set_fmt ov13855_2112x1568\n");
+		sensor->mode = 0;
+		ov13855_regs = ov13855_2112x1568;
+		sensor->pix.width = OV13855_RES_LOW_WIDTH;
+		sensor->pix.height = OV13855_RES_LOW_HEIGHT;
+	}
+	else
+	{
+		printk("jimmy ov13855_set_fmt Unsupported\n");
+		printk(KERN_INFO "OV13855: Unsupported resolution passed\n");
+		return -1;
+	}
+	clk_prepare_enable(sensor->sensor_clk);
+	ov13855_power_on(sensor);
+	//pm_runtime_get_noresume(&sensor->i2c_client->dev);
+	pm_runtime_resume_and_get(&sensor->i2c_client->dev);
+//	ov13855_s_stream_(sd,1);
+
+	retval = ov13855_write_init_settings(client, ov13855_regs);
+
+	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
+	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
+
+#ifdef OV13855_SYS_DEBUG
+	printk(KERN_INFO "OV13855 sysfs reg dump\n");
+	dumpvalues[countreg].addr = REG_NULL;
+	dumpvalues[countreg].val = 0;
+
+	printk(KERN_INFO "countreg size: 0x%x\n", countreg);
+	for(; dumpvalues[i].addr != REG_NULL; i++)
+	{
+		printk(KERN_INFO "addr: 0x%x, val: 0x%x\n", dumpvalues[i].addr,
+				dumpvalues[i].val);
+	}
+
+	ret = ov13855_write_array(client, dumpvalues);
+        if(ret)
+        {
+		printk(KERN_INFO "failed to write sysfs reg\n");
+        }
+#endif
+printk("jimmy ov13855_set_fmt - %d\n",retval);
+	return retval;
+}
+
+
+static int ov13855_link_setup(struct media_entity *entity,
+                           const struct media_pad *local,
+                           const struct media_pad *remote, u32 flags)
+{
+        return 0;
+}
+
+static struct v4l2_subdev_video_ops ov13855_subdev_video_ops = {
+	.g_parm = ov13855_g_parm,
+	.s_parm = ov13855_s_parm,
+	.s_stream = ov13855_s_stream,
+};
+
+
+static int ov13855_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,
+				  struct v4l2_mbus_frame_desc *fd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+
+	fd->type = V4L2_MBUS_FRAME_DESC_TYPE_CSI2;
+	fd->num_entries = 1;
+
+	/* get sensor current code*/
+	mutex_lock(&sensor->lock);
+	fd->entry[0].pixelcode = MEDIA_BUS_FMT_SBGGR8_1X8;
+	mutex_unlock(&sensor->lock);
+
+	fd->entry[0].bus.csi2.vc = 0;
+	fd->entry[0].bus.csi2.dt = MIPI_CSI2_DT_RAW8;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ov13855_subdev_pad_ops = {
+	.enum_frame_size       = ov13855_enum_framesizes,
+	.enum_frame_interval   = ov13855_enum_frameintervals,
+	.enum_mbus_code        = ov13855_enum_code,
+	.set_fmt               = ov13855_set_fmt,
+	.get_fmt               = ov13855_get_fmt,
+	.get_frame_desc			= ov13855_get_frame_desc,
+};
+
+static struct v4l2_subdev_core_ops ov13855_subdev_core_ops = {
+//	.s_power	= ov13855_s_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static struct v4l2_subdev_ops ov13855_subdev_ops = {
+	.core	= &ov13855_subdev_core_ops,
+	.video	= &ov13855_subdev_video_ops,
+	.pad	= &ov13855_subdev_pad_ops,
+};
+
+static const struct media_entity_operations ov13855_sd_media_ops = {
+	.link_setup = ov13855_link_setup,
+};
+
+static int ov13855_probe(struct i2c_client *client)
+{
+	struct pinctrl *pinctrl;
+	struct device *dev = &client->dev;
+	struct v4l2_subdev *sd;
+	int ret ;
+	//int rst_gpio, pwn_gpio;
+	struct ov13855 *sensor;
+printk("jimmy ov13855_probe + \n");
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+
+	pr_info("OV13855: ov13855_probe called\n");
+
+	pinctrl = devm_pinctrl_get_select_default(dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(dev, "No pin available\n");
+
+	sensor->mode = 0;
+	sensor->streaming = 0;
+
+
+	/* request optional power down pin */
+	sensor->pwn_gpio = devm_gpiod_get_optional(dev, "pwn",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->pwn_gpio))
+		return PTR_ERR(sensor->pwn_gpio);
+
+	/* request optional reset pin */
+	sensor->rst_gpio = devm_gpiod_get_optional(dev, "rst",
+						     GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->rst_gpio))
+		return PTR_ERR(sensor->rst_gpio);
+
+/*
+	rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+	if (!gpio_is_valid(rst_gpio)) {
+		dev_err(dev, "no sensor reset pin available");
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request_one(dev, rst_gpio, GPIOF_OUT_INIT_LOW,
+					"ov13855_reset");
+	if (ret < 0) {
+		dev_err(dev, "failed to acquire sensor reset pin");
+		return ret;
+	}
+	sensor->rst_gpio = rst_gpio;
+
+	pwn_gpio = of_get_named_gpio(dev->of_node, "pwn-gpios", 0);
+	if (!gpio_is_valid(pwn_gpio)) {
+		dev_err(dev, "no sensor reset pin available");
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request_one(dev, pwn_gpio, GPIOF_OUT_INIT_LOW,
+					"ov13855_pwdn");
+	if (ret < 0) {
+		dev_err(dev, "failed to acquire sensor reset pin");
+		return ret;
+	}
+	sensor->pwn_gpio = pwn_gpio;
+*/
+	sensor->sensor_clk = devm_clk_get(dev, "csi_mclk");
+	if (IS_ERR(sensor->sensor_clk)) {
+                sensor->sensor_clk = NULL;
+                dev_err(dev, "clock-frequency missing or invalid\n");
+                return PTR_ERR(sensor->sensor_clk);
+        }
+
+	ret = of_property_read_u32(dev->of_node, "mclk",
+					&(sensor->mclk));
+	if (ret) {
+		dev_err(dev, "mclk missing or invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mclk_source",
+					(u32 *) &(sensor->mclk_source));
+	if (ret) {
+		dev_err(dev, "mclk_source missing or invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "virtual_channel",
+					&(sensor->csi_vc));
+	if (ret) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(sensor->sensor_clk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable xvclk\n");
+		return ret;
+	}
+
+	sensor->i2c_client = client;
+
+	/*Only can handle 8bit mode for now*/
+	sensor->pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	sensor->pix.width = OV13855_RES_LOW_WIDTH;
+        sensor->pix.height = OV13855_RES_LOW_HEIGHT;
+	sensor->streamcap.capability = V4L2_MODE_HIGHQUALITY |
+                                           V4L2_CAP_TIMEPERFRAME;
+        sensor->streamcap.capturemode = 0;
+        sensor->streamcap.timeperframe.denominator = DEFAULT_FPS;
+        sensor->streamcap.timeperframe.numerator = 1;
+		//printk("jimmy ov13855_probe usleep 3000000\n");
+//usleep_range(3000000, 5000000);
+printk("jimmy ov13855_probe ov13855_power_on\n");
+	mutex_init(&sensor->lock);
+
+	if (os08a20_init_controls(sensor))
+	{
+		clk_disable_unprepare(sensor->sensor_clk);
+		goto err_free_handler;
+	}
+	ov13855_power_on(sensor);
+
+	pm_runtime_set_active(dev);
+	pm_runtime_get_noresume(dev);
+	pm_runtime_enable(dev);
+
+
+	ret = ov13855_check_sensor_id(client);
+	if (ret)
+	{
+		dev_err(dev, "ov13855 mipi not found\n");
+		clk_disable_unprepare(sensor->sensor_clk);
+		goto err_free_handler;
+	}
+
+	sd = &sensor->subdev;
+	v4l2_i2c_subdev_init(sd, client, &ov13855_subdev_ops);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sensor->pads[OV13855_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&sd->entity, OV13855_SENS_PADS_NUM,
+							sensor->pads);
+	sd->entity.ops = &ov13855_sd_media_ops;
+	if (ret < 0)
+		return ret;
+
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0) {
+		dev_err(&client->dev,
+				"%s--Async register failed, ret=%d\n", __func__, ret);
+		media_entity_cleanup(&sd->entity);
+
+		goto err_pm_runtime;
+	}
+
+	pm_runtime_set_autosuspend_delay(dev, 1000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_put_autosuspend(dev);
+
+    //clk_disable_unprepare(sensor->sensor_clk);
+	//ov13855_power_off(sensor->rst_gpio, sensor->pwn_gpio);
+
+#ifdef OV13855_SYS_DEBUG
+	kobj_ov13855 = kobject_create_and_add("ov13855_debug", kernel_kobj);
+
+	/*Creating sysfs file for ov13855 register write*/
+	if(sysfs_create_file(kobj_ov13855, &ov13855_reg_write.attr)) {
+		pr_err("Cannot create sysfs file......\n");
+		kobject_put(kobj_ov13855);
+		sysfs_remove_file(kernel_kobj, &ov13855_reg_write.attr);
+	}
+
+	if(sysfs_create_file(kobj_ov13855, &ov13855_regvalue_write.attr)) {
+		pr_err("Cannot create sysfs file......\n");
+		kobject_put(kobj_ov13855);
+		sysfs_remove_file(kernel_kobj, &ov13855_regvalue_write.attr);
+	}
+	dumpvalues[countreg].addr = REG_NULL;
+	dumpvalues[countreg].val = 0;
+#endif
+
+	pr_info("OV13855: ov13855_probe successful\n");
+
+	return 0;
+
+err_pm_runtime:
+	pm_runtime_put_noidle(dev);
+	pm_runtime_disable(dev);
+
+
+err_free_handler:
+
+	return ret;
+}
+
+static void ov13855_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13855 *sensor = to_ov13855(client);
+	struct device *dev = &client->dev;
+
+	pm_runtime_disable(dev);
+	if (!pm_runtime_status_suspended(dev))
+		ov13855_sensor_suspend(dev);
+	pm_runtime_set_suspended(dev);
+
+
+	v4l2_async_unregister_subdev(sd);
+
+	clk_disable_unprepare(sensor->sensor_clk);
+
+	ov13855_power_off(sensor);
+	v4l2_async_unregister_subdev(sd);
+
+	clk_disable_unprepare(sensor->sensor_clk);
+	mutex_destroy(&sensor->lock);
+}
+
+static const struct dev_pm_ops ov13855_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov13855_sensor_suspend, ov13855_sensor_resume, NULL)
+};
+
+static const struct i2c_device_id ov13855_match_id[] = {
+        { "ov13855_mipi", 0 },
+        { },
+};
+
+static struct i2c_driver ov13855_i2c_driver = {
+        .driver = {
+                .name = OV13855_NAME,
+                //.of_match_table = of_match_ptr(ov13855_of_match),
+				.pm = &ov13855_pm_ops,
+        },
+        .probe          = ov13855_probe,
+        .remove         = ov13855_remove,
+        .id_table       = ov13855_match_id,
+};
+
+module_i2c_driver(ov13855_i2c_driver);
+
+MODULE_DESCRIPTION("ov13855 sensor driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index fe849465ee49..21134c9136c7 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -15,7 +15,7 @@
 #include <linux/init.h>
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
-#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 #include <linux/types.h>
@@ -449,8 +449,6 @@ struct ov5640_dev {
 	/* lock to protect all members below */
 	struct mutex lock;
 
-	int power_count;
-
 	struct v4l2_mbus_framefmt fmt;
 	bool pending_fmt_change;
 
@@ -2733,38 +2731,24 @@ static int ov5640_set_power(struct ov5640_dev *sensor, bool on)
 	return ret;
 }
 
-/* --------------- Subdev Operations --------------- */
-
-static int ov5640_s_power(struct v4l2_subdev *sd, int on)
+static int ov5640_sensor_suspend(struct device *dev)
 {
-	struct ov5640_dev *sensor = to_ov5640_dev(sd);
-	int ret = 0;
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct ov5640_dev *ov5640 = to_ov5640_dev(sd);
 
-	mutex_lock(&sensor->lock);
-
-	/*
-	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
-	 * update the power state.
-	 */
-	if (sensor->power_count == !on) {
-		ret = ov5640_set_power(sensor, !!on);
-		if (ret)
-			goto out;
-	}
-
-	/* Update the power count. */
-	sensor->power_count += on ? 1 : -1;
-	WARN_ON(sensor->power_count < 0);
-out:
-	mutex_unlock(&sensor->lock);
+	return ov5640_set_power(ov5640, false);
+}
 
-	if (on && !ret && sensor->power_count == 1) {
-		/* restore controls */
-		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
-	}
+static int ov5640_sensor_resume(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct ov5640_dev *ov5640 = to_ov5640_dev(sd);
+ 
 
-	return ret;
-}
+	return ov5640_set_power(ov5640, true);
+ }
+ 
+/* --------------- Subdev Operations --------------- */
 
 static int ov5640_try_frame_interval(struct ov5640_dev *sensor,
 				     struct v4l2_fract *fi,
@@ -3346,6 +3330,9 @@ static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 
 	/* v4l2_ctrl_lock() locks our own mutex */
 
+	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
+		return 0;
+
 	switch (ctrl->id) {
 	case V4L2_CID_AUTOGAIN:
 		val = ov5640_get_gain(sensor);
@@ -3361,6 +3348,9 @@ static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 		break;
 	}
 
+	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
+	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
+
 	return 0;
 }
 
@@ -3390,9 +3380,9 @@ static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
 	/*
 	 * If the device is not powered up by the host driver do
 	 * not apply any controls to H/W at this time. Instead
-	 * the controls will be restored right after power-up.
+	 * the controls will be restored at start streaming time.
 	 */
-	if (sensor->power_count == 0)
+	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
 		return 0;
 
 	switch (ctrl->id) {
@@ -3434,6 +3424,9 @@ static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
 		break;
 	}
 
+	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
+	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
+
 	return ret;
 }
 
@@ -3712,6 +3705,18 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 	int delay;
 	int ret = 0;
 
+	if (enable) {
+		ret = pm_runtime_resume_and_get(&sensor->i2c_client->dev);
+		if (ret < 0)
+			return ret;
+
+		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+		if (ret) {
+			pm_runtime_put(&sensor->i2c_client->dev);
+			return ret;
+		}
+	}
+
 	mutex_lock(&sensor->lock);
 
 	if (sensor->streaming == !enable) {
@@ -3740,8 +3745,15 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 		delay = (enable) ? 100 : 0;
 		msleep(delay);
 	}
+
 out:
 	mutex_unlock(&sensor->lock);
+
+	if (!enable || ret) {
+		pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
+		pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
+	}
+
 	return ret;
 }
 
@@ -3765,7 +3777,6 @@ static int ov5640_init_cfg(struct v4l2_subdev *sd,
 }
 
 static const struct v4l2_subdev_core_ops ov5640_core_ops = {
-	.s_power = ov5640_s_power,
 	.log_status = v4l2_ctrl_subdev_log_status,
 	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
 	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
@@ -3822,26 +3833,20 @@ static int ov5640_check_chip_id(struct ov5640_dev *sensor)
 	int ret = 0;
 	u16 chip_id;
 
-	ret = ov5640_set_power_on(sensor);
-	if (ret)
-		return ret;
-
 	ret = ov5640_read_reg16(sensor, OV5640_REG_CHIP_ID, &chip_id);
 	if (ret) {
 		dev_err(&client->dev, "%s: failed to read chip identifier\n",
 			__func__);
-		goto power_off;
+		return ret;
 	}
 
 	if (chip_id != 0x5640) {
 		dev_err(&client->dev, "%s: wrong chip identifier, expected 0x5640, got 0x%x\n",
 			__func__, chip_id);
-		ret = -ENXIO;
+		return -ENXIO;
 	}
 
-power_off:
-	ov5640_set_power_off(sensor);
-	return ret;
+	return 0;
 }
 
 static int ov5640_probe(struct i2c_client *client)
@@ -3936,26 +3941,44 @@ static int ov5640_probe(struct i2c_client *client)
 
 	ret = ov5640_get_regulators(sensor);
 	if (ret)
-		return ret;
+		goto entity_cleanup;
 
 	mutex_init(&sensor->lock);
 
-	ret = ov5640_check_chip_id(sensor);
+	ret = ov5640_init_controls(sensor);
 	if (ret)
 		goto entity_cleanup;
 
-	ret = ov5640_init_controls(sensor);
+	ret = ov5640_sensor_resume(dev);
+	if (ret) {
+		dev_err(dev, "failed to power on\n");
+ 		goto entity_cleanup;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_get_noresume(dev);
+	pm_runtime_enable(dev);
+
+	ret = ov5640_check_chip_id(sensor);
 	if (ret)
-		goto entity_cleanup;
+		goto err_pm_runtime;
 
 	ret = v4l2_async_register_subdev_sensor(&sensor->sd);
 	if (ret)
-		goto free_ctrls;
+		goto err_pm_runtime;
+
+	pm_runtime_set_autosuspend_delay(dev, 1000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
 
 	return 0;
 
-free_ctrls:
-	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+err_pm_runtime:
+	pm_runtime_put_noidle(dev);
+	pm_runtime_disable(dev);
+ 	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+	ov5640_sensor_suspend(dev);
 entity_cleanup:
 	media_entity_cleanup(&sensor->sd.entity);
 	mutex_destroy(&sensor->lock);
@@ -3966,6 +3989,12 @@ static void ov5640_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	struct device *dev = &client->dev;
+
+	pm_runtime_disable(dev);
+	if (!pm_runtime_status_suspended(dev))
+		ov5640_sensor_suspend(dev);
+	pm_runtime_set_suspended(dev);
 
 	v4l2_async_unregister_subdev(&sensor->sd);
 	media_entity_cleanup(&sensor->sd.entity);
@@ -3973,6 +4002,10 @@ static void ov5640_remove(struct i2c_client *client)
 	mutex_destroy(&sensor->lock);
 }
 
+static const struct dev_pm_ops ov5640_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov5640_sensor_suspend, ov5640_sensor_resume, NULL)
+};
+
 static const struct i2c_device_id ov5640_id[] = {
 	{"ov5640", 0},
 	{},
@@ -3989,6 +4022,7 @@ static struct i2c_driver ov5640_i2c_driver = {
 	.driver = {
 		.name  = "ov5640",
 		.of_match_table	= ov5640_dt_ids,
+		.pm = &ov5640_pm_ops,
 	},
 	.id_table = ov5640_id,
 	.probe    = ov5640_probe,
-- 
2.25.1

