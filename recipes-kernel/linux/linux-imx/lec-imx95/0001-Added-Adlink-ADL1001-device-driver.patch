From 253c725c5406828f0d5f2f13bacbe5605cf83242 Mon Sep 17 00:00:00 2001
From: "deepak.s" <deepak.s@adlinktech.com>
Date: Sun, 3 Nov 2024 11:54:37 +0530
Subject: [PATCH 1/5] Added Adlink ADL1001 device driver

---
 drivers/gpio/Kconfig         |   8 +
 drivers/gpio/Makefile        |   1 +
 drivers/gpio/gpio-adl1000.c  | 884 +++++++++++++++++++++++++++++++++++
 drivers/tty/serial/Kconfig   |   8 +
 drivers/tty/serial/Makefile  |   1 +
 drivers/tty/serial/adl1001.c | 754 ++++++++++++++++++++++++++++++
 6 files changed, 1656 insertions(+)
 create mode 100644 drivers/gpio/gpio-adl1000.c
 create mode 100644 drivers/tty/serial/adl1001.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 6dcd39a31a0b..7955bee2c693 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -1092,6 +1092,14 @@ config GPIO_MAX732X_IRQ
 	  Say yes here to enable the max732x to be used as an interrupt
 	  controller. It requires the driver to be built in the kernel.
 
+
+config GPIO_ADL1000
+	tristate "ADL1000 I/O ports"
+	select REGMAP_I2C
+	help
+	  Say yes here to provide access to the ADL1000 register-oriented
+	  SMBus I/O expanders
+
 config GPIO_PCA953X
 	tristate "PCA95[357]x, PCA9698, TCA64xx, and MAX7310 I/O ports"
 	select REGMAP_I2C
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index ce50e15974b7..062cd7884486 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -121,6 +121,7 @@ obj-$(CONFIG_GPIO_OCTEON)		+= gpio-octeon.o
 obj-$(CONFIG_GPIO_OMAP)			+= gpio-omap.o
 obj-$(CONFIG_GPIO_PALMAS)		+= gpio-palmas.o
 obj-$(CONFIG_GPIO_PCA953X)		+= gpio-pca953x.o
+obj-$(CONFIG_GPIO_ADL1000)		+= gpio-adl1000.o
 obj-$(CONFIG_GPIO_PCA9570)		+= gpio-pca9570.o
 obj-$(CONFIG_GPIO_PCF857X)		+= gpio-pcf857x.o
 obj-$(CONFIG_GPIO_PCH)			+= gpio-pch.o
diff --git a/drivers/gpio/gpio-adl1000.c b/drivers/gpio/gpio-adl1000.c
new file mode 100644
index 000000000000..255f8ad1d8e9
--- /dev/null
+++ b/drivers/gpio/gpio-adl1000.c
@@ -0,0 +1,884 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ *  ADLink 40 bit I/O ports
+ *
+ *
+ *  Derived from drivers/i2c/chips/pca953x.c
+ */
+
+#include <linux/bitmap.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio/driver.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/seq_file.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+
+#include <asm/unaligned.h>
+
+#include <linux/delay.h>
+#define REGMAP_BUCK 0
+#define REGMAP_BUCK_RETRY_CNT 3
+
+#define ADL1000_INPUT		0x06
+#define ADL1000_OUTPUT		0x0A
+//#define ADL1000_INVERT		0x08
+#define ADL1000_DIRECTION	0x00
+
+//#define ADL1000_IN_LATCH	0x48
+#define ADL1000_PULL_EN		0x20
+#define ADL1000_PULL_SEL	0x26
+#define ADL1000_INT_MASK	0x10
+#define ADL1000_INT_STAT	0x16
+#define ADL1000_INT_VER0	0x2e
+#define ADL1000_INT_VER1	0x2f
+
+#define ADL1000_NPIN		24
+
+
+static const struct i2c_device_id adl1000_id[] = {
+	{ "adl1000", ADL1000_NPIN , },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, adl1000_id);
+
+#define MAX_BANK 6
+#define BANK_SZ 8
+#define MAX_LINE	(MAX_BANK * BANK_SZ)
+
+#define NBANK(chip) DIV_ROUND_UP(chip->gpio_chip.ngpio, BANK_SZ)
+
+
+struct adl1000_platform_data {
+	/* number of the first GPIO */
+	unsigned	gpio_base;
+
+	/* initial polarity inversion setting */
+	u32		invert;
+
+	/* interrupt base */
+	int		irq_base;
+
+	void		*context;	/* param to setup/teardown */
+
+	int		(*setup)(struct i2c_client *client,
+				unsigned gpio, unsigned ngpio,
+				void *context);
+	void		(*teardown)(struct i2c_client *client,
+				unsigned gpio, unsigned ngpio,
+				void *context);
+	const char	*const *names;
+};
+
+struct adl1000_reg_config {
+	int direction;
+	int output;
+	int input;
+	//int invert;
+};
+
+static const struct adl1000_reg_config adl1000_regs = {
+	.direction = ADL1000_DIRECTION,
+	.output = ADL1000_OUTPUT,
+	.input = ADL1000_INPUT ,
+	//.invert = ADL1000_INVERT,
+};
+
+
+
+struct adl1000_chip {
+	unsigned gpio_start;
+	struct mutex i2c_lock;
+	struct regmap *regmap;
+
+
+	struct mutex irq_lock;
+	DECLARE_BITMAP(irq_mask, MAX_LINE);
+	DECLARE_BITMAP(irq_stat, MAX_LINE);
+	DECLARE_BITMAP(irq_trig_raise, MAX_LINE);
+	DECLARE_BITMAP(irq_trig_fall, MAX_LINE);
+
+	atomic_t wakeup_path;
+
+	struct i2c_client *client;
+	struct gpio_chip gpio_chip;
+	const char *const *names;
+	unsigned long driver_data;
+	struct regulator *regulator;
+
+	const struct adl1000_reg_config *regs;
+
+	u8 (*recalc_addr)(struct adl1000_chip *chip, int reg, int off);
+};
+
+static bool adl1000_readable_register(struct device *dev, unsigned int reg)
+{
+	struct adl1000_chip *chip = dev_get_drvdata(dev);
+	if(
+		(reg>=ADL1000_INPUT && reg<(ADL1000_INPUT+ NBANK(chip))) ||
+		(reg>=ADL1000_OUTPUT && reg<(ADL1000_OUTPUT+ NBANK(chip))) ||
+//		(reg>=ADL1000_INVERT && reg<(ADL1000_INVERT+ NBANK(chip))) ||
+		(reg>=ADL1000_DIRECTION && reg<(ADL1000_DIRECTION+ NBANK(chip))) ||
+//		(reg>=ADL1000_IN_LATCH && reg<(ADL1000_IN_LATCH+ NBANK(chip))) ||
+		(reg>=ADL1000_PULL_EN && reg<(ADL1000_PULL_EN+ NBANK(chip))) ||
+		(reg>=ADL1000_PULL_SEL && reg<(ADL1000_PULL_SEL+ NBANK(chip))) ||
+		(reg>=ADL1000_INT_MASK && reg<(ADL1000_INT_MASK+ NBANK(chip))) ||
+		(reg>=ADL1000_INT_STAT && reg<(ADL1000_INT_STAT+ NBANK(chip)))
+		)
+	{
+		return true;
+	}
+	else 
+	{
+		return false;
+	}
+}
+
+static bool adl1000_writeable_register(struct device *dev, unsigned int reg)
+{
+	struct adl1000_chip *chip = dev_get_drvdata(dev);
+	if(
+		(reg>=ADL1000_OUTPUT && reg<(ADL1000_OUTPUT+ NBANK(chip))) ||
+//		(reg>=ADL1000_INVERT && reg<(ADL1000_INVERT+ NBANK(chip))) ||
+		(reg>=ADL1000_DIRECTION && reg<(ADL1000_DIRECTION+ NBANK(chip))) ||
+//		(reg>=ADL1000_IN_LATCH && reg<(ADL1000_IN_LATCH+ NBANK(chip))) ||
+		(reg>=ADL1000_PULL_EN && reg<(ADL1000_PULL_EN+ NBANK(chip))) ||
+		(reg>=ADL1000_PULL_SEL && reg<(ADL1000_PULL_SEL+ NBANK(chip))) ||
+		(reg>=ADL1000_INT_MASK && reg<(ADL1000_INT_MASK+ NBANK(chip)))
+		)
+	{
+		return true;
+	}
+	else 
+	{
+		return false;
+	}
+}
+
+static bool adl1000_volatile_register(struct device *dev, unsigned int reg)
+{
+	struct adl1000_chip *chip = dev_get_drvdata(dev);
+	if(
+		(reg>=ADL1000_INPUT && reg<(ADL1000_INPUT+ NBANK(chip))) ||
+		(reg>=ADL1000_INT_STAT && reg<(ADL1000_INT_STAT+ NBANK(chip)))
+	)
+	{
+		return true;
+	}
+	else 
+	{
+		return false;
+	}
+}
+
+static const struct regmap_config adl1000_i2c_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.use_single_read = true,
+	.use_single_write = true,
+
+	.readable_reg = adl1000_readable_register,
+	.writeable_reg = adl1000_writeable_register,
+	.volatile_reg = adl1000_volatile_register,
+
+	.disable_locking = true,
+	.cache_type = REGCACHE_RBTREE,
+	.max_register = 0x7f,
+};
+
+
+static u8 adl1000_recalc_addr(struct adl1000_chip *chip, int reg, int off)
+{
+
+	u8 regaddr = reg + (off / BANK_SZ);
+
+	return regaddr;
+}
+
+static int adl1000_write_regs(struct adl1000_chip *chip, int reg, unsigned long *val)
+{
+	u8 regaddr = chip->recalc_addr(chip, reg, 0);
+	u8 value[MAX_BANK];
+	int i, ret;
+
+	for (i = 0; i < NBANK(chip); i++)
+		value[i] = bitmap_get_value8(val, i * BANK_SZ);
+
+#if REGMAP_BUCK
+	ret = regmap_bulk_write(chip->regmap, regaddr, value, NBANK(chip));
+	if (ret < 0) {
+		dev_err(&chip->client->dev, "failed writing register\n");
+		return ret;
+	}
+#else
+	for (i = 0; i < NBANK(chip); i++)
+	{
+		int retry = 0;
+
+		ret=1;
+		while(ret)
+		{
+			ret = regmap_write(chip->regmap, regaddr+i, (unsigned int)value[i]);
+			if(ret)
+			{
+				retry++;
+				dev_err(&chip->client->dev, "jimmy adl1000_write_regs regmap_write failed reg:0x%x ret:0x%x retry:%d\n",regaddr+i,ret,retry);
+				if(retry >= REGMAP_BUCK_RETRY_CNT)
+					break;
+				udelay(300);
+			}
+		}
+		if (ret < 0) {
+			dev_err(&chip->client->dev, "failed writing register\n");
+			return ret;
+		}
+	}
+	
+#endif
+	return 0;
+}
+
+static int adl1000_read_regs(struct adl1000_chip *chip, int reg, unsigned long *val)
+{
+	u8 regaddr = chip->recalc_addr(chip, reg, 0);
+	u8 value[MAX_BANK];
+	int i, ret;
+
+#if REGMAP_BUCK
+	ret = regmap_bulk_read(chip->regmap, regaddr, value, NBANK(chip));
+	printk("jimmy adl1000_read_regs  regaddr:%d ret:0x%x i:%d\n",regaddr,ret,i++);
+	if (ret < 0) {
+		dev_err(&chip->client->dev, "failed reading register\n");
+		return ret;
+	}
+#else
+	for (i = 0; i < NBANK(chip); i++)
+	{
+		int retry = 0;
+
+		ret=1;
+		while(ret)
+		{
+			ret = regmap_read(chip->regmap, regaddr+i, ( unsigned int *)&value[i]);
+			if(ret)
+			{
+				retry++;
+				dev_err(&chip->client->dev, "jimmy adl1000_read_regs regmap_read failed reg:0x%x ret:0x%x retry:%d\n",regaddr+i,ret,retry);
+				if(retry >= REGMAP_BUCK_RETRY_CNT)
+					break;
+				udelay(300);
+			}
+		}
+		if (ret < 0) {
+			dev_err(&chip->client->dev, "failed reading register\n");
+			return ret;
+		}
+	}
+#endif
+	for (i = 0; i < NBANK(chip); i++)
+	{
+		bitmap_set_value8(val, value[i], i * BANK_SZ);
+	}
+
+	return 0;
+}
+
+static int adl1000_gpio_direction_input(struct gpio_chip *gc, unsigned off)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 dirreg = chip->recalc_addr(chip, chip->regs->direction, off);
+	u8 bit = BIT(off % BANK_SZ);
+	int ret;
+
+	mutex_lock(&chip->i2c_lock);
+
+	ret = regmap_write_bits(chip->regmap, dirreg, bit, bit);
+	mutex_unlock(&chip->i2c_lock);
+	return ret;
+}
+
+static int adl1000_gpio_direction_output(struct gpio_chip *gc,
+		unsigned off, int val)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 dirreg = chip->recalc_addr(chip, chip->regs->direction, off);
+	u8 outreg = chip->recalc_addr(chip, chip->regs->output, off);
+	u8 bit = BIT(off % BANK_SZ);
+	int ret;
+
+	mutex_lock(&chip->i2c_lock);
+	/* set output level */
+	ret = regmap_write_bits(chip->regmap, outreg, bit, val ? bit : 0);
+	if (ret)
+		goto exit;
+
+	/* then direction */
+	ret = regmap_write_bits(chip->regmap, dirreg, bit, 0);
+exit:
+	mutex_unlock(&chip->i2c_lock);
+	return ret;
+}
+
+static int adl1000_gpio_get_value(struct gpio_chip *gc, unsigned off)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 inreg = chip->recalc_addr(chip, chip->regs->input, off);
+	u8 bit = BIT(off % BANK_SZ);
+	u32 reg_val;
+	int ret;
+
+	mutex_lock(&chip->i2c_lock);
+	ret = regmap_read(chip->regmap, inreg, &reg_val);
+
+	mutex_unlock(&chip->i2c_lock);
+	if (ret < 0)
+		return ret;
+
+	return !!(reg_val & bit);
+}
+
+static void adl1000_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 outreg = chip->recalc_addr(chip, chip->regs->output, off);
+	u8 bit = BIT(off % BANK_SZ);
+
+	mutex_lock(&chip->i2c_lock);
+
+	regmap_write_bits(chip->regmap, outreg, bit, val ? bit : 0);
+	mutex_unlock(&chip->i2c_lock);
+}
+
+static int adl1000_gpio_get_direction(struct gpio_chip *gc, unsigned off)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 dirreg = chip->recalc_addr(chip, chip->regs->direction, off);
+	u8 bit = BIT(off % BANK_SZ);
+	u32 reg_val;
+	int ret;
+
+	mutex_lock(&chip->i2c_lock);
+	ret = regmap_read(chip->regmap, dirreg, &reg_val);
+
+	mutex_unlock(&chip->i2c_lock);
+	if (ret < 0)
+		return ret;
+
+	if (reg_val & bit)
+		return GPIO_LINE_DIRECTION_IN;
+
+	return GPIO_LINE_DIRECTION_OUT;
+}
+
+static int adl1000_gpio_set_pull_up_down(struct adl1000_chip *chip,
+					 unsigned int offset,
+					 unsigned long config)
+{
+	enum pin_config_param param = pinconf_to_config_param(config);
+
+	u8 pull_en_reg = chip->recalc_addr(chip, ADL1000_PULL_EN, offset);
+	u8 pull_sel_reg = chip->recalc_addr(chip, ADL1000_PULL_SEL, offset);
+	u8 bit = BIT(offset % BANK_SZ);
+	int ret;
+
+	/*
+	 * pull-up/pull-down configuration requires PCAL extended
+	 * registers
+	 */
+
+	mutex_lock(&chip->i2c_lock);
+
+	/* Configure pull-up/pull-down */
+	if (param == PIN_CONFIG_BIAS_PULL_UP)
+	{
+		ret = regmap_write_bits(chip->regmap, pull_sel_reg, bit, bit);
+	}
+	else if (param == PIN_CONFIG_BIAS_PULL_DOWN)
+	{
+		ret = regmap_write_bits(chip->regmap, pull_sel_reg, bit, 0);
+	}
+	else
+		ret = 0;
+	if (ret)
+		goto exit;
+
+	/* Disable/Enable pull-up/pull-down */
+	if (param == PIN_CONFIG_BIAS_DISABLE)
+	{
+		ret = regmap_write_bits(chip->regmap, pull_en_reg, bit, 0);
+	}
+	else
+	{
+		ret = regmap_write_bits(chip->regmap, pull_en_reg, bit, bit);
+	}
+
+exit:
+	mutex_unlock(&chip->i2c_lock);
+	return ret;
+}
+
+static int adl1000_gpio_set_config(struct gpio_chip *gc, unsigned int offset,
+				   unsigned long config)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+
+	switch (pinconf_to_config_param(config)) {
+	case PIN_CONFIG_BIAS_PULL_UP:
+	case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+	case PIN_CONFIG_BIAS_DISABLE:
+		return adl1000_gpio_set_pull_up_down(chip, offset, config);
+	default:
+		return -ENOTSUPP;
+	}
+}
+
+static void adl1000_setup_gpio(struct adl1000_chip *chip, int gpios)
+{
+	struct gpio_chip *gc;
+
+	gc = &chip->gpio_chip;
+
+	gc->direction_input  = adl1000_gpio_direction_input;
+	gc->direction_output = adl1000_gpio_direction_output;
+	gc->get = adl1000_gpio_get_value;
+	gc->set = adl1000_gpio_set_value;
+	gc->get_direction = adl1000_gpio_get_direction;
+	gc->set_config = adl1000_gpio_set_config;
+	gc->can_sleep = true;
+
+	gc->base = chip->gpio_start;
+	gc->ngpio = gpios;
+	gc->label = dev_name(&chip->client->dev);
+	gc->parent = &chip->client->dev;
+	gc->owner = THIS_MODULE;
+	gc->names = chip->names;
+}
+
+
+static void adl1000_irq_mask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
+
+	clear_bit(hwirq, chip->irq_mask);
+	gpiochip_disable_irq(gc, hwirq);
+}
+
+static void adl1000_irq_unmask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
+
+	gpiochip_enable_irq(gc, hwirq);
+	set_bit(hwirq, chip->irq_mask);
+}
+
+static int adl1000_irq_set_wake(struct irq_data *d, unsigned int on)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+
+	if (on)
+		atomic_inc(&chip->wakeup_path);
+	else
+		atomic_dec(&chip->wakeup_path);
+
+	return irq_set_irq_wake(chip->client->irq, on);
+}
+
+static void adl1000_irq_bus_lock(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+
+	mutex_lock(&chip->irq_lock);
+}
+
+static void adl1000_irq_bus_sync_unlock(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	DECLARE_BITMAP(irq_mask, MAX_LINE);
+	DECLARE_BITMAP(reg_direction, MAX_LINE);
+	int level;
+
+	{
+		bitmap_complement(irq_mask, chip->irq_mask, gc->ngpio);
+
+		/* Unmask enabled interrupts */
+		adl1000_write_regs(chip, ADL1000_INT_MASK, irq_mask);
+	}
+
+	/* Switch direction to input if needed */
+	adl1000_read_regs(chip, chip->regs->direction, reg_direction);
+
+	bitmap_or(irq_mask, chip->irq_trig_fall, chip->irq_trig_raise, gc->ngpio);
+	bitmap_complement(reg_direction, reg_direction, gc->ngpio);
+	bitmap_and(irq_mask, irq_mask, reg_direction, gc->ngpio);
+
+	/* Look for any newly setup interrupt */
+	for_each_set_bit(level, irq_mask, gc->ngpio)
+		adl1000_gpio_direction_input(&chip->gpio_chip, level);
+
+	mutex_unlock(&chip->irq_lock);
+}
+
+static int adl1000_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
+
+	if (!(type & IRQ_TYPE_EDGE_BOTH)) {
+		dev_err(&chip->client->dev, "irq %d: unsupported type %d\n",
+			d->irq, type);
+		return -EINVAL;
+	}
+
+	assign_bit(hwirq, chip->irq_trig_fall, type & IRQ_TYPE_EDGE_FALLING);
+	assign_bit(hwirq, chip->irq_trig_raise, type & IRQ_TYPE_EDGE_RISING);
+
+	return 0;
+}
+
+static void adl1000_irq_shutdown(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
+
+	clear_bit(hwirq, chip->irq_trig_raise);
+	clear_bit(hwirq, chip->irq_trig_fall);
+}
+
+static void adl1000_irq_print_chip(struct irq_data *data, struct seq_file *p)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
+
+	seq_printf(p, dev_name(gc->parent));
+}
+
+static const struct irq_chip adl1000_irq_chip = {
+	.irq_mask		= adl1000_irq_mask,
+	.irq_unmask		= adl1000_irq_unmask,
+	.irq_set_wake		= adl1000_irq_set_wake,
+	.irq_bus_lock		= adl1000_irq_bus_lock,
+	.irq_bus_sync_unlock	= adl1000_irq_bus_sync_unlock,
+	.irq_set_type		= adl1000_irq_set_type,
+	.irq_shutdown		= adl1000_irq_shutdown,
+	.irq_print_chip		= adl1000_irq_print_chip,
+	.flags			= IRQCHIP_IMMUTABLE,
+	GPIOCHIP_IRQ_RESOURCE_HELPERS,
+};
+
+static bool adl1000_irq_pending(struct adl1000_chip *chip, unsigned long *pending)
+{
+	struct gpio_chip *gc = &chip->gpio_chip;
+	DECLARE_BITMAP(reg_direction, MAX_LINE);
+	DECLARE_BITMAP(old_stat, MAX_LINE);
+	DECLARE_BITMAP(cur_stat, MAX_LINE);
+	DECLARE_BITMAP(new_stat, MAX_LINE);
+	DECLARE_BITMAP(trigger, MAX_LINE);
+	int ret;
+
+	/* Read the current interrupt status from the device */
+	ret = adl1000_read_regs(chip, ADL1000_INT_STAT, trigger);
+	if (ret)
+		return false;
+
+	/* Apply filter for rising/falling edge selection */
+	bitmap_replace(new_stat, chip->irq_trig_fall, chip->irq_trig_raise, cur_stat, gc->ngpio);
+	bitmap_and(pending, new_stat, trigger, gc->ngpio);
+
+	return !bitmap_empty(pending, gc->ngpio);
+}
+
+static irqreturn_t adl1000_irq_handler(int irq, void *devid)
+{
+	struct adl1000_chip *chip = devid;
+	struct gpio_chip *gc = &chip->gpio_chip;
+	DECLARE_BITMAP(pending, MAX_LINE);
+	int level;
+	bool ret;
+
+	bitmap_zero(pending, MAX_LINE);
+
+	mutex_lock(&chip->i2c_lock);
+	ret = adl1000_irq_pending(chip, pending);
+
+	mutex_unlock(&chip->i2c_lock);
+
+	if (ret) {
+		ret = 0;
+
+		for_each_set_bit(level, pending, gc->ngpio) {
+			int nested_irq = irq_find_mapping(gc->irq.domain, level);
+
+			if (unlikely(nested_irq <= 0)) {
+				dev_warn_ratelimited(gc->parent, "unmapped interrupt %d\n", level);
+				continue;
+			}
+
+			handle_nested_irq(nested_irq);
+			ret = 1;
+		}
+	}
+	return IRQ_RETVAL(ret);
+}
+
+static int adl1000_irq_setup(struct adl1000_chip *chip, int irq_base)
+{
+	struct i2c_client *client = chip->client;
+	DECLARE_BITMAP(reg_direction, MAX_LINE);
+	DECLARE_BITMAP(irq_stat, MAX_LINE);
+	struct gpio_irq_chip *girq;
+	int ret;
+
+	if (!client->irq)
+		return 0;
+
+	if (irq_base == -1)
+		return 0;
+
+	ret = adl1000_read_regs(chip, chip->regs->input, irq_stat);
+	if (ret)
+		return ret;
+
+	/*
+	 * There is no way to know which GPIO line generated the
+	 * interrupt.  We have to rely on the previous read for
+	 * this purpose.
+	 */
+	adl1000_read_regs(chip, chip->regs->direction, reg_direction);
+	bitmap_and(chip->irq_stat, irq_stat, reg_direction, chip->gpio_chip.ngpio);
+	mutex_init(&chip->irq_lock);
+
+	girq = &chip->gpio_chip.irq;
+	gpio_irq_chip_set_chip(girq, &adl1000_irq_chip);
+	/* This will let us handle the parent IRQ in the driver */
+	girq->parent_handler = NULL;
+	girq->num_parents = 0;
+	girq->parents = NULL;
+	girq->default_type = IRQ_TYPE_NONE;
+	girq->handler = handle_simple_irq;
+	girq->threaded = true;
+	girq->first = irq_base; /* FIXME: get rid of this */
+
+	ret = devm_request_threaded_irq(&client->dev, client->irq,
+					NULL, adl1000_irq_handler,
+					IRQF_ONESHOT | IRQF_SHARED,
+					dev_name(&client->dev), chip);
+	if (ret) {
+		dev_err(&client->dev, "failed to request irq %d\n",
+			client->irq);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+
+static int device_pca95xx_init(struct adl1000_chip *chip, u32 invert)
+{
+	DECLARE_BITMAP(val, MAX_LINE);
+	u8 regaddr;
+	int ret;
+
+	regaddr = chip->recalc_addr(chip, chip->regs->output, 0);
+	ret = regcache_sync_region(chip->regmap, regaddr,
+				   regaddr + NBANK(chip) - 1);
+	if (ret)
+		goto out;
+
+	regaddr = chip->recalc_addr(chip, chip->regs->direction, 0);
+	ret = regcache_sync_region(chip->regmap, regaddr,
+				   regaddr + NBANK(chip) - 1);
+	if (ret)
+		goto out;
+
+out:
+	return ret;
+}
+
+
+
+static int adl1000_probe(struct i2c_client *client)
+{
+	struct adl1000_platform_data *pdata;
+	struct adl1000_chip *chip;
+	int irq_base = 0;
+	int ret;
+	u32 invert = 0;
+	struct regulator *reg;
+	const struct regmap_config *regmap_config;
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+
+	pdata = dev_get_platdata(&client->dev);
+	if (pdata) {
+		irq_base = pdata->irq_base;
+		chip->gpio_start = pdata->gpio_base;
+		invert = pdata->invert;
+		chip->names = pdata->names;
+	} else {
+		struct gpio_desc *reset_gpio;
+
+		chip->gpio_start = -1;
+		irq_base = 0;
+
+		reset_gpio = devm_gpiod_get_optional(&client->dev, "reset",
+						     GPIOD_OUT_LOW);
+		if (IS_ERR(reset_gpio))
+			return PTR_ERR(reset_gpio);
+	}
+
+	chip->client = client;
+	chip->driver_data = (uintptr_t)i2c_get_match_data(client);
+	if (!chip->driver_data)
+		return -ENODEV;
+
+	reg = devm_regulator_get(&client->dev, "vcc");
+	if (IS_ERR(reg))
+		return dev_err_probe(&client->dev, PTR_ERR(reg), "reg get err\n");
+
+	ret = regulator_enable(reg);
+	if (ret) {
+		dev_err(&client->dev, "reg en err: %d\n", ret);
+		return ret;
+	}
+	chip->regulator = reg;
+
+	i2c_set_clientdata(client, chip);
+	adl1000_setup_gpio(chip, chip->driver_data );
+
+	regmap_config = &adl1000_i2c_regmap;
+	chip->recalc_addr = adl1000_recalc_addr;
+
+	chip->regmap = devm_regmap_init_i2c(client, regmap_config);
+	if (IS_ERR(chip->regmap)) {
+		ret = PTR_ERR(chip->regmap);
+		goto err_exit;
+	}
+
+	regcache_mark_dirty(chip->regmap);
+
+	mutex_init(&chip->i2c_lock);
+	/*
+	 * In case we have an i2c-mux controlled by a GPIO provided by an
+	 * expander using the same driver higher on the device tree, read the
+	 * i2c adapter nesting depth and use the retrieved value as lockdep
+	 * subclass for chip->i2c_lock.
+	 *
+	 * REVISIT: This solution is not complete. It protects us from lockdep
+	 * false positives when the expander controlling the i2c-mux is on
+	 * a different level on the device tree, but not when it's on the same
+	 * level on a different branch (in which case the subclass number
+	 * would be the same).
+	 *
+	 * TODO: Once a correct solution is developed, a similar fix should be
+	 * applied to all other i2c-controlled GPIO expanders (and potentially
+	 * regmap-i2c).
+	 */
+	lockdep_set_subclass(&chip->i2c_lock,
+			     i2c_adapter_depth(client->adapter));
+
+	ret = device_reset(&client->dev);
+	if (ret == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
+	/* initialize cached registers from their original values.
+	 * we can't share this chip with another i2c master.
+	 */
+
+	chip->regs = &adl1000_regs;
+	ret = device_pca95xx_init(chip, invert);
+
+	if (ret)
+		goto err_exit;
+
+	ret = adl1000_irq_setup(chip, irq_base);
+	if (ret)
+		goto err_exit;
+
+	ret = devm_gpiochip_add_data(&client->dev, &chip->gpio_chip, chip);
+	if (ret)
+		goto err_exit;
+
+	if (pdata && pdata->setup) {
+		ret = pdata->setup(client, chip->gpio_chip.base,
+				   chip->gpio_chip.ngpio, pdata->context);
+		if (ret < 0)
+			dev_warn(&client->dev, "setup failed, %d\n", ret);
+	}
+
+	return 0;
+
+err_exit:
+	regulator_disable(chip->regulator);
+	return ret;
+}
+
+static void adl1000_remove(struct i2c_client *client)
+{
+	struct adl1000_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct adl1000_chip *chip = i2c_get_clientdata(client);
+
+	if (pdata && pdata->teardown) {
+		pdata->teardown(client, chip->gpio_chip.base,
+				chip->gpio_chip.ngpio, pdata->context);
+	}
+
+	regulator_disable(chip->regulator);
+}
+
+
+static const struct of_device_id adl1000_dt_ids[] = {
+	{ .compatible = "adlink,adl1000", },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, adl1000_dt_ids);
+
+
+static struct i2c_driver adl1000_driver = {
+	.driver = {
+		.name	= "adl1000",
+		.of_match_table = adl1000_dt_ids,
+	},
+	.probe		= adl1000_probe,
+	.remove		= adl1000_remove,
+	.id_table	= adl1000_id,
+};
+
+static int __init adl1000_init(void)
+{
+	return i2c_add_driver(&adl1000_driver);
+}
+/* register after i2c postcore initcall and before
+ * subsys initcalls that may rely on these GPIOs
+ */
+subsys_initcall(adl1000_init);
+
+static void __exit adl1000_exit(void)
+{
+	i2c_del_driver(&adl1000_driver);
+}
+module_exit(adl1000_exit);
+
+MODULE_AUTHOR("Jimmy Yu <jimmy.yu@adlinktech.com>");
+MODULE_DESCRIPTION("GPIO expander driver for PCA953x");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index bdc568a4ab66..127690e401d0 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -327,6 +327,14 @@ config SERIAL_MAX310X
 
 	  Say Y here if you want to support this ICs.
 
+config SERIAL_ADL1001
+	tristate "ADL1001 support"
+	depends on I2C
+	select SERIAL_CORE
+	select REGMAP_I2C if I2C
+	help
+	  ADL1001 chip support
+
 config SERIAL_DZ
 	bool "DECstation DZ serial driver"
 	depends on MACH_DECSTATION && 32BIT
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 138abbc89738..0b22cba471eb 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -33,6 +33,7 @@ obj-$(CONFIG_SERIAL_BCM63XX) += bcm63xx_uart.o
 obj-$(CONFIG_SERIAL_SAMSUNG) += samsung_tty.o
 obj-$(CONFIG_SERIAL_MAX3100) += max3100.o
 obj-$(CONFIG_SERIAL_MAX310X) += max310x.o
+obj-$(CONFIG_SERIAL_ADL1001) += adl1001.o
 obj-$(CONFIG_SERIAL_IP22_ZILOG) += ip22zilog.o
 obj-$(CONFIG_SERIAL_MUX) += mux.o
 obj-$(CONFIG_SERIAL_MCF) += mcf.o
diff --git a/drivers/tty/serial/adl1001.c b/drivers/tty/serial/adl1001.c
new file mode 100644
index 000000000000..5a7221f3c29c
--- /dev/null
+++ b/drivers/tty/serial/adl1001.c
@@ -0,0 +1,754 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ *  ADL1001 serial driver
+ *
+ *
+ *  Based on max310x.c, by Jimmy Yu <jimmy.yu@adlinktech.com>
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/driver.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/uaccess.h>
+
+#define CIRC_EMPTY_SLEEP	10
+#define TX_BUSY_SLEEP		10
+#define ADL1001_BAUD_MIN	4800
+#define ADL1001_BAUD_MAX	115200
+#define ADL1001_NAME			"adl1001"
+#define ADL1001_UART_NRMAX		1
+
+/* ADL1001 register definitions */
+#define ADL1001_BAUD			(0x1)
+#define ADL1001_RXFIFOLVL_REG	(0x2) /* RX FIFO level */
+#define ADL1001_RHR_REG			(0x03) /* RX FIFO */
+#define ADL1001_THR_REG			(0x04) /* TX FIFO */
+#define ADL1001_TX_BUSY			(0x05) /* TX BUSY */
+#define ADL1001_WORD_LENGTH		(0x06) 
+#define ADL1001_STOP_BITS		(0x07) 
+#define ADL1001_PARITY			(0x08) 
+#define ADL1001_HWCONTROL			(0x09) 
+
+#define ADL1001_HWCONTROL_RTS_CTS	(0x08)
+#define ADL1001_HWCONTROL_NONE		(0x01)
+
+#define ADL1001_BAUD_4800			(0x01)
+#define ADL1001_BAUD_9600			(0x02)
+#define ADL1001_BAUD_19200			(0x04)
+#define ADL1001_BAUD_38400			(0x08)
+#define ADL1001_BAUD_57600			(0x10)
+#define ADL1001_BAUD_115200			(0x20)
+
+#define ADL1001_WORD_LENGTH_7B		(0x01) 
+#define ADL1001_WORD_LENGTH_8B		(0x02) 
+
+#define ADL1001_STOP_BITS_1		(0x02)
+#define ADL1001_STOP_BITS_2		(0x08)
+
+#define ADL1001_PARITY_NONE			(0x01) 
+#define ADL1001_PARITY_EVEN			(0x02) 
+#define ADL1001_PARITY_ODD			(0x04)
+#define ADL1001_REG_1F			(0x1f)
+
+/* Global commands */
+
+/* Misc definitions */
+#define ADL1001_FIFO_SIZE		(128)
+
+struct adl1001_devtype {
+	char	name[9];
+	int	nr;
+	void	(*power)(struct uart_port *, int);
+};
+
+struct adl1001_one {
+	struct uart_port	port;
+	struct work_struct	tx_work;
+	struct regmap		*regmap;
+
+	u8 rx_buf[ADL1001_FIFO_SIZE];
+};
+#define to_adl1001_port(_port) \
+	container_of(_port, struct adl1001_one, port)
+
+struct adl1001_port {
+	const struct adl1001_devtype *devtype;
+	struct regmap		*regmap;
+	struct clk		*clk;
+	struct adl1001_one	p[];
+};
+
+static struct uart_driver adl1001_uart = {
+	.owner		= THIS_MODULE,
+	.driver_name	= ADL1001_NAME,
+	.dev_name	= "ttyADL",
+	.nr		= ADL1001_UART_NRMAX,
+};
+
+static DECLARE_BITMAP(adl1001_lines, ADL1001_UART_NRMAX);
+
+static u8 adl1001_port_read(struct uart_port *port, u8 reg)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+	unsigned int val = 0;
+
+	regmap_read(one->regmap, reg, &val);
+
+	return val;
+}
+
+static void adl1001_port_write(struct uart_port *port, u8 reg, u8 val)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+
+	regmap_write(one->regmap, reg, val);
+}
+
+static void adl1001_power(struct uart_port *port, int on)
+{
+
+}
+
+static const struct adl1001_devtype adl1001_devtype = {
+	.name	= "ADL1001",
+	.nr	= 1,
+	.power	= adl1001_power,
+};
+
+static bool adl1001_reg_writeable(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ADL1001_RXFIFOLVL_REG:
+	case ADL1001_TX_BUSY:
+		return false;
+	default:
+		break;
+	}
+
+	return true;
+
+}
+
+static bool adl1001_reg_volatile(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ADL1001_RHR_REG:
+	case ADL1001_THR_REG:
+	case ADL1001_RXFIFOLVL_REG:
+	case ADL1001_TX_BUSY:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static bool adl1001_reg_precious(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ADL1001_RHR_REG:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static bool adl1001_reg_noinc(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ADL1001_RHR_REG:
+	case ADL1001_THR_REG:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static int adl1001_set_baud(struct uart_port *port, int baud)
+{
+	u8 val;
+	switch (baud) {
+	case 115200:
+		val = ADL1001_BAUD_115200;
+		break;
+	case 57600:
+		val = ADL1001_BAUD_57600;
+		break;
+	case 38400:
+		val = ADL1001_BAUD_38400;
+		break;
+	case 19200:
+		val = ADL1001_BAUD_19200;
+		break;
+	case 9600:
+		val = ADL1001_BAUD_9600;
+		break;
+	case 4800:
+		val = ADL1001_BAUD_4800;
+		break;
+	default:
+		val = ADL1001_BAUD_115200;
+		baud = 115200;
+		break;
+	}
+	adl1001_port_write(port, ADL1001_BAUD, val);
+	/* Return the actual baud rate we just programmed */
+	return baud;
+}
+
+static void adl1001_batch_write(struct uart_port *port, u8 *txbuf, unsigned int len)
+{
+	u8 buf[ADL1001_FIFO_SIZE+1];
+	struct adl1001_one *one = to_adl1001_port(port);
+
+	buf[0]=len;
+	memcpy(buf+1,txbuf,len);
+
+	while (adl1001_port_read(port, ADL1001_TX_BUSY))
+	{
+		dev_dbg(port->dev, "TX Busy !!! sleep %dms\n",TX_BUSY_SLEEP);
+		msleep(TX_BUSY_SLEEP);
+	}
+
+	regmap_noinc_write(one->regmap, ADL1001_THR_REG, buf, len+1);
+}
+
+static void adl1001_batch_read(struct uart_port *port, u8 *rxbuf, unsigned int len)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+
+	regmap_noinc_read(one->regmap, ADL1001_RHR_REG, rxbuf, len);
+}
+
+static void adl1001_handle_rx(struct uart_port *port, unsigned int rxlen)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+	unsigned int sts, i;
+	u8 flag;
+
+	{
+		adl1001_batch_read(port, one->rx_buf, rxlen);
+
+		port->icount.rx += rxlen;
+		flag = TTY_NORMAL;
+
+		for (i = 0; i < rxlen; ++i)
+			uart_insert_char(port, sts, 0, one->rx_buf[i], flag);
+
+	} 
+
+	tty_flip_buffer_push(&port->state->port);
+}
+
+static void adl1001_handle_tx(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned int txlen, to_send, until_end;
+
+	while(1)
+	{
+		if (unlikely(port->x_char)) {
+			dev_dbg(port->dev, "send x_char\n");
+			adl1001_batch_write(port, &(port->x_char), 1);
+			port->icount.tx++;
+			port->x_char = 0;
+			continue;
+		}
+		
+		if (uart_tx_stopped(port))
+		{
+			dev_dbg(port->dev, "tx stop\n");
+			break;
+		}
+	
+		while (uart_circ_empty(xmit))
+		{
+			dev_dbg(port->dev, "TX CIRC EMPTY !!! sleep %dms\n",TX_BUSY_SLEEP);
+			msleep(CIRC_EMPTY_SLEEP);
+		}
+		/* Get length of data pending in circular buffer */
+		to_send = uart_circ_chars_pending(xmit);
+		until_end = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
+		
+		if (likely(to_send)) {
+			/* Limit to size of TX FIFO */
+			txlen = 0;
+			txlen = port->fifosize - txlen;
+			to_send = (to_send > txlen) ? txlen : to_send;
+
+			if (until_end < to_send) {
+				/* It's a circ buffer -- wrap around.
+			 	* We could do that in one SPI transaction, but meh. */
+				adl1001_batch_write(port, xmit->buf + xmit->tail, until_end);
+				adl1001_batch_write(port, xmit->buf, to_send - until_end);
+			} else {
+				adl1001_batch_write(port, xmit->buf + xmit->tail, to_send);
+			}
+			uart_xmit_advance(port, to_send);
+		}
+
+		if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+			uart_write_wakeup(port);
+	}
+}
+
+static void adl1001_start_tx(struct uart_port *port)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+
+	schedule_work(&one->tx_work);
+}
+
+static irqreturn_t adl1001_port_irq(struct adl1001_port *s, int portno)
+{
+	struct uart_port *port = &s->p[portno].port;
+	irqreturn_t res = IRQ_NONE;
+
+	{
+		unsigned int rxlen;
+
+		/* Read IRQ status & RX FIFO level */
+		rxlen = adl1001_port_read(port, ADL1001_RXFIFOLVL_REG);
+
+		res = IRQ_HANDLED;
+
+		if (rxlen)
+			adl1001_handle_rx(port, rxlen);
+	} 
+	return res;
+}
+
+static irqreturn_t adl1001_ist(int irq, void *dev_id)
+{
+	struct adl1001_port *s = (struct adl1001_port *)dev_id;
+	bool handled = false;
+#if 0
+	if (s->devtype->nr > 1) {
+		do {
+			unsigned int val = ~0;
+
+			//WARN_ON_ONCE(regmap_read(s->regmap,
+			//			 ADL1001_GLOBALIRQ_REG, &val));
+			val = ((1 << s->devtype->nr) - 1) & ~val;
+			if (!val)
+				break;
+			if (adl1001_port_irq(s, fls(val) - 1) == IRQ_HANDLED)
+				handled = true;
+		} while (1);
+	} else 
+#endif
+	{
+		if (adl1001_port_irq(s, 0) == IRQ_HANDLED)
+			handled = true;
+	}
+
+	return IRQ_RETVAL(handled);
+}
+
+static void adl1001_tx_proc(struct work_struct *ws)
+{
+	struct adl1001_one *one = container_of(ws, struct adl1001_one, tx_work);
+	
+	adl1001_handle_tx(&one->port);
+}
+
+static unsigned int adl1001_tx_empty(struct uart_port *port)
+{
+	u8 lvl = adl1001_port_read(port, ADL1001_TX_BUSY);
+
+	return lvl ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int adl1001_get_mctrl(struct uart_port *port)
+{
+	/* DCD and DSR are not wired and CTS/RTS is handled automatically
+	 * so just indicate DSR and CAR asserted
+	 */
+	return TIOCM_DSR | TIOCM_CAR;
+}
+
+static void adl1001_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+
+}
+
+static void adl1001_break_ctl(struct uart_port *port, int break_state)
+{
+
+}
+
+static void adl1001_set_termios(struct uart_port *port,
+				struct ktermios *termios,
+				const struct ktermios *old)
+{
+	int baud;
+
+	/* Mask termios capabilities we don't support */
+	termios->c_cflag &= ~CMSPAR;
+	termios->c_cflag &= ~(CMSPAR);
+
+	{
+		u8 val;
+		if (termios->c_cflag & CRTSCTS) {
+			/* Enable AUTORTS and AUTOCTS */
+			port->status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;
+			val = ADL1001_HWCONTROL_RTS_CTS;
+		}
+		else
+			val = ADL1001_HWCONTROL_NONE;
+		adl1001_port_write(port, ADL1001_HWCONTROL , val);
+	}
+
+	//only support CS7,CS8
+	if (((termios->c_cflag & CSIZE) == CS5 )||((termios->c_cflag & CSIZE) == CS6 ))
+	{
+		termios->c_cflag &= ~(CSIZE);
+		termios->c_cflag |= (CS8);
+	}
+
+	{
+		u8 val;
+		switch (termios->c_cflag & CSIZE) {
+		case CS7:
+			val = ADL1001_WORD_LENGTH_7B;
+			break;
+		case CS8:
+		default:
+			val = ADL1001_WORD_LENGTH_8B;
+			break;
+		}
+		adl1001_port_write(port, ADL1001_WORD_LENGTH, val);
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		adl1001_port_write(port, ADL1001_STOP_BITS, ADL1001_STOP_BITS_2); //2 stop bit
+	else
+		adl1001_port_write(port, ADL1001_STOP_BITS, ADL1001_STOP_BITS_1); //1 stop bit
+
+
+	if (termios->c_cflag & PARENB) {
+		if (termios->c_cflag & PARODD)
+			adl1001_port_write(port, ADL1001_PARITY, ADL1001_PARITY_ODD);
+		else
+			adl1001_port_write(port, ADL1001_PARITY, ADL1001_PARITY_EVEN);
+	}
+	else
+		adl1001_port_write(port, ADL1001_PARITY, ADL1001_PARITY_NONE);
+
+	/* Set status ignore mask */
+	port->ignore_status_mask = 0;
+
+	baud = uart_get_baud_rate(port, termios, old,ADL1001_BAUD_MIN,ADL1001_BAUD_MAX);
+
+	/* Setup baudrate generator */
+	baud = adl1001_set_baud(port, baud);
+
+	/* Update timeout according to new baud rate */
+	uart_update_timeout(port, termios->c_cflag, baud);
+}
+
+static int adl1001_startup(struct uart_port *port)
+{
+	return 0;
+}
+
+static void adl1001_shutdown(struct uart_port *port)
+{
+
+}
+
+static const char *adl1001_type(struct uart_port *port)
+{
+	struct adl1001_port *s = dev_get_drvdata(port->dev);
+
+	return (port->type == 124) ? s->devtype->name : NULL;
+}
+
+static int adl1001_request_port(struct uart_port *port)
+{
+	/* Do nothing */
+	return 0;
+}
+
+static void adl1001_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = 124;
+}
+
+static int adl1001_verify_port(struct uart_port *port, struct serial_struct *s)
+{
+	if ((s->type != PORT_UNKNOWN) && (s->type != 124))
+		return -EINVAL;
+	if (s->irq != port->irq)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void adl1001_null_void(struct uart_port *port)
+{
+	/* Do nothing */
+}
+
+static const struct uart_ops adl1001_ops = {
+	.tx_empty	= adl1001_tx_empty,
+	.set_mctrl	= adl1001_set_mctrl,
+	.get_mctrl	= adl1001_get_mctrl,
+	.stop_tx	= adl1001_null_void,
+	.start_tx	= adl1001_start_tx,
+	.stop_rx	= adl1001_null_void,
+	.break_ctl	= adl1001_break_ctl,
+	.startup	= adl1001_startup,
+	.shutdown	= adl1001_shutdown,
+	.set_termios	= adl1001_set_termios,
+	.type		= adl1001_type,
+	.request_port	= adl1001_request_port,
+	.release_port	= adl1001_null_void,
+	.config_port	= adl1001_config_port,
+	.verify_port	= adl1001_verify_port,
+};
+
+static int __maybe_unused adl1001_suspend(struct device *dev)
+{
+	struct adl1001_port *s = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < s->devtype->nr; i++) {
+		uart_suspend_port(&adl1001_uart, &s->p[i].port);
+		s->devtype->power(&s->p[i].port, 0);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused adl1001_resume(struct device *dev)
+{
+	struct adl1001_port *s = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < s->devtype->nr; i++) {
+		s->devtype->power(&s->p[i].port, 1);
+		uart_resume_port(&adl1001_uart, &s->p[i].port);
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(adl1001_pm_ops, adl1001_suspend, adl1001_resume);
+
+static int adl1001_probe(struct device *dev, const struct adl1001_devtype *devtype,
+//			 const struct adl1001_if_cfg *if_cfg,
+			 struct regmap *regmaps[], int irq)
+{
+	int i, ret;
+	struct adl1001_port *s;
+	u32 uartclk = 0;
+
+	for (i = 0; i < devtype->nr; i++)
+		if (IS_ERR(regmaps[i]))
+			return PTR_ERR(regmaps[i]);
+
+	/* Alloc port structure */
+	s = devm_kzalloc(dev, struct_size(s, p, devtype->nr), GFP_KERNEL);
+	if (!s) {
+		dev_err(dev, "Error allocating port structure\n");
+		return -ENOMEM;
+	}
+
+	s->regmap = regmaps[0];
+	s->devtype = devtype;
+	//s->if_cfg = if_cfg;
+	dev_set_drvdata(dev, s);
+
+	/* Check device to ensure we are talking to what we expect */
+
+	for (i = 0; i < devtype->nr; i++) {
+		unsigned int line;
+
+		line = find_first_zero_bit(adl1001_lines, ADL1001_UART_NRMAX);
+		if (line == ADL1001_UART_NRMAX) {
+			ret = -ERANGE;
+			goto out_uart;
+		}
+
+		/* Initialize port data */
+		s->p[i].port.line	= line;
+		s->p[i].port.dev	= dev;
+		s->p[i].port.irq	= irq;
+		s->p[i].port.type	= 124;
+		s->p[i].port.fifosize	= ADL1001_FIFO_SIZE;
+		s->p[i].port.flags	= UPF_FIXED_TYPE | UPF_LOW_LATENCY;
+		s->p[i].port.iotype	= UPIO_PORT;
+		s->p[i].port.iobase	= i;
+		/*
+		 * Use all ones as membase to make sure uart_configure_port() in
+		 * serial_core.c does not abort for SPI/I2C devices where the
+		 * membase address is not applicable.
+		 */
+		s->p[i].port.membase	= (void __iomem *)~0;
+		s->p[i].port.uartclk	= uartclk;
+		s->p[i].port.ops	= &adl1001_ops;
+		s->p[i].regmap		= regmaps[i];
+
+		INIT_WORK(&s->p[i].tx_work, adl1001_tx_proc);
+
+		/* Register port */
+		ret = uart_add_one_port(&adl1001_uart, &s->p[i].port);
+		if (ret) {
+			s->p[i].port.dev = NULL;
+			goto out_uart;
+		}
+		set_bit(line, adl1001_lines);
+
+		/* Go to suspend mode */
+		devtype->power(&s->p[i].port, 0);
+	}
+
+	/* Setup interrupt */
+	ret = devm_request_threaded_irq(dev, irq, NULL, adl1001_ist,
+					IRQF_ONESHOT | IRQF_SHARED, dev_name(dev), s);
+	if (!ret)
+	{
+		return 0;
+	}
+	dev_err(dev, "Unable to reguest IRQ %i\n", irq);
+
+out_uart:
+	for (i = 0; i < devtype->nr; i++) {
+		if (s->p[i].port.dev) {
+			uart_remove_one_port(&adl1001_uart, &s->p[i].port);
+			clear_bit(s->p[i].port.line, adl1001_lines);
+		}
+	}
+
+	clk_disable_unprepare(s->clk);
+
+	return ret;
+}
+
+static void adl1001_remove(struct device *dev)
+{
+	struct adl1001_port *s = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < s->devtype->nr; i++) {
+		cancel_work_sync(&s->p[i].tx_work);
+		uart_remove_one_port(&adl1001_uart, &s->p[i].port);
+		clear_bit(s->p[i].port.line, adl1001_lines);
+		s->devtype->power(&s->p[i].port, 0);
+	}
+
+	clk_disable_unprepare(s->clk);
+}
+
+static const struct of_device_id __maybe_unused adl1001_dt_ids[] = {
+	{ .compatible = "adlink,adl1001",	.data = &adl1001_devtype, },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, adl1001_dt_ids);
+
+#ifdef CONFIG_I2C
+
+static struct regmap_config regcfg_i2c = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+	.writeable_reg = adl1001_reg_writeable,
+	.volatile_reg = adl1001_reg_volatile,
+	.precious_reg = adl1001_reg_precious,
+	.max_register = ADL1001_REG_1F,
+	.writeable_noinc_reg = adl1001_reg_noinc,
+	.readable_noinc_reg = adl1001_reg_noinc,
+	.max_raw_read = ADL1001_FIFO_SIZE,
+	.max_raw_write = ADL1001_FIFO_SIZE,
+};
+
+static int adl1001_i2c_probe(struct i2c_client *client)
+{
+	const struct adl1001_devtype *devtype =
+			device_get_match_data(&client->dev);
+	struct i2c_client *port_client;
+	struct regmap *regmaps[4];
+	unsigned int i;
+	u8 port_addr;
+
+	dev_info(&client->dev, "adl1001_i2c_probe client->addr:0x%x\n",client->addr);
+
+	regmaps[0] = devm_regmap_init_i2c(client, &regcfg_i2c);
+
+	return adl1001_probe(&client->dev, devtype,
+			     regmaps, client->irq);
+}
+
+static void adl1001_i2c_remove(struct i2c_client *client)
+{
+	adl1001_remove(&client->dev);
+}
+
+static struct i2c_driver adl1001_i2c_driver = {
+	.driver = {
+		.name		= ADL1001_NAME,
+		.of_match_table	= adl1001_dt_ids,
+		.pm		= &adl1001_pm_ops,
+	},
+	.probe		= adl1001_i2c_probe,
+	.remove		= adl1001_i2c_remove,
+};
+#endif
+
+static int __init adl1001_uart_init(void)
+{
+	int ret;
+
+	bitmap_zero(adl1001_lines, ADL1001_UART_NRMAX);
+
+	ret = uart_register_driver(&adl1001_uart);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_I2C
+	ret = i2c_add_driver(&adl1001_i2c_driver);
+	if (ret)
+		goto err_i2c_register;
+#endif
+
+	return 0;
+#ifdef CONFIG_I2C
+err_i2c_register:
+	uart_unregister_driver(&adl1001_uart);
+
+	return ret;
+#endif
+}
+module_init(adl1001_uart_init);
+
+static void __exit adl1001_uart_exit(void)
+{
+#ifdef CONFIG_I2C
+	i2c_del_driver(&adl1001_i2c_driver);
+#endif
+
+	uart_unregister_driver(&adl1001_uart);
+}
+module_exit(adl1001_uart_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jimmy Yu <jimmy.yu@adlinktech.com>");
+MODULE_DESCRIPTION("ADL1001 serial driver");
-- 
2.25.1

