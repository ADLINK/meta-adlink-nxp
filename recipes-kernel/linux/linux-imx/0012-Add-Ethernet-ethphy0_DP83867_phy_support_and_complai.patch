From 93d8aba49558699a1694fca118598cbbc45691a9 Mon Sep 17 00:00:00 2001
From: Antony Abee Prakash XV <antonyabee.prakashxv@adlinktech.com>
Date: Wed, 27 May 2020 23:27:13 +0530
Subject: [PATCH 12/12] 
 Add-Ethernet-ethphy0_DP83867_phy_support_and_complaince_test_support

This patch will add DP83867 PHY layer support in ethphy0 and also adds
complaince test support driver for DP83867 Phy layer and Intel I210 adapters

Signed-off-by: Antony Abee Prakash XV <antonyabee.prakashxv@adlinktech.com>
---
 .../boot/dts/adlink/adlink-lec-imx8m.dts      |  24 +-
 arch/arm64/configs/lec_imx8m_defconfig        |   1 +
 drivers/net/ethernet/intel/Kconfig            |  10 +
 drivers/net/ethernet/intel/igb/Makefile       |   2 +-
 drivers/net/ethernet/intel/igb/igb.h          |   6 +
 .../net/ethernet/intel/igb/igb_ieee_test.c    | 684 ++++++++++++++++++
 drivers/net/ethernet/intel/igb/igb_main.c     |  12 +
 drivers/net/phy/Kconfig                       |   7 +
 drivers/net/phy/dp83867.c                     | 313 ++++++++
 9 files changed, 1046 insertions(+), 13 deletions(-)
 create mode 100644 drivers/net/ethernet/intel/igb/igb_ieee_test.c

diff --git a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
index 4061e2a80e29..e3c1b790a947 100755
--- a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
+++ b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
@@ -8,6 +8,7 @@
 
 #include <dt-bindings/usb/pd.h>
 #include "imx8mq.dtsi"
+#include <dt-bindings/net/ti-dp83867.h>
 #define sdslow 1
 
 / {
@@ -229,6 +230,8 @@
 	pinctrl-0 = <&pinctrl_fec1>;
 	phy-mode = "rgmii-id";
 	phy-handle = <&ethphy0>;
+        phy-reset-gpios = <&gpio3 17 0>;
+        phy-reset-active-low;
 	fsl,magic-packet;
 	status = "okay";
 
@@ -240,6 +243,11 @@
 			compatible = "ethernet-phy-ieee802.3-c22";
 			reg = <0>;
 			at803x,eee-disabled;
+                        interrupt-parent = <&gpio3>;
+                        interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+                        ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
+                        ti,tx-internal-delay = <DP83867_RGMIIDCTL_2_75_NS>;
+                        ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_4_B_NIB>;
 		};
 	};
 };
@@ -623,17 +631,6 @@
 
 &iomuxc {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_hog>;
-
-	pinctrl_hog: hoggrp {
-		fsl,pins = <
-			MX8MQ_IOMUXC_NAND_READY_B_GPIO3_IO16		0x19
-			MX8MQ_IOMUXC_NAND_WE_B_GPIO3_IO17		0x19
-			MX8MQ_IOMUXC_NAND_WP_B_GPIO3_IO18		0x19
-			MX8MQ_IOMUXC_GPIO1_IO08_GPIO1_IO8		0xd6
-			MX8MQ_IOMUXC_GPIO1_IO00_ANAMIX_REF_CLK_32K	0x16
-		>;
-	};
 
 	pinctrl_buck2: vddarmgrp {
 		fsl,pins = <
@@ -676,7 +673,10 @@
 			MX8MQ_IOMUXC_ENET_RXC_ENET1_RGMII_RXC		0x91
 			MX8MQ_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	0x91
 			MX8MQ_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	0x1f
-			MX8MQ_IOMUXC_GPIO1_IO09_GPIO1_IO9		0x19
+			MX8MQ_IOMUXC_GPIO1_IO09_ENET1_1588_EVENT0_OUT   0x40
+			MX8MQ_IOMUXC_GPIO1_IO08_ENET1_1588_EVENT0_IN    0x40
+			MX8MQ_IOMUXC_NAND_WE_B_GPIO3_IO17               0x19
+			MX8MQ_IOMUXC_NAND_WP_B_GPIO3_IO18               0x19
 		>;
 	};
 
diff --git a/arch/arm64/configs/lec_imx8m_defconfig b/arch/arm64/configs/lec_imx8m_defconfig
index 5b051ad51271..9afac6c2d7aa 100644
--- a/arch/arm64/configs/lec_imx8m_defconfig
+++ b/arch/arm64/configs/lec_imx8m_defconfig
@@ -278,6 +278,7 @@ CONFIG_MDIO_BITBANG=y
 CONFIG_MDIO_BUS_MUX_MULTIPLEXER=y
 CONFIG_AQUANTIA_PHY=y
 CONFIG_AT803X_PHY=y
+CONFIG_DP83867_PHY=y
 CONFIG_INPHI_PHY=y
 CONFIG_MARVELL_PHY=m
 CONFIG_MARVELL_10G_PHY=m
diff --git a/drivers/net/ethernet/intel/Kconfig b/drivers/net/ethernet/intel/Kconfig
index 154e2e818ec6..542d3657a2f9 100644
--- a/drivers/net/ethernet/intel/Kconfig
+++ b/drivers/net/ethernet/intel/Kconfig
@@ -103,6 +103,16 @@ config IGB
 	  To compile this driver as a module, choose M here. The module
 	  will be called igb.
 
+config I210_EEE
+        bool "Intel(R) I210 PCI-Express Gigabit Ethernet Compliance Test support"
+        default n
+        depends on IGB
+        ---help---
+          Say Y if you want to verify Compliance Test on Intel I210 adapters.
+
+          To do IEEE Testing, please refer the paper 1000BASE-T/100BASE-TX/10BASE-T
+          Physical Layer Compliance Tests Manual.
+
 config IGB_HWMON
 	bool "Intel(R) PCI-Express Gigabit adapters HWMON support"
 	default y
diff --git a/drivers/net/ethernet/intel/igb/Makefile b/drivers/net/ethernet/intel/igb/Makefile
index 394c1e0656b9..fcef6b57059b 100644
--- a/drivers/net/ethernet/intel/igb/Makefile
+++ b/drivers/net/ethernet/intel/igb/Makefile
@@ -8,4 +8,4 @@ obj-$(CONFIG_IGB) += igb.o
 
 igb-objs := igb_main.o igb_ethtool.o e1000_82575.o \
 	    e1000_mac.o e1000_nvm.o e1000_phy.o e1000_mbx.o \
-	    e1000_i210.o igb_ptp.o igb_hwmon.o
+	    e1000_i210.o igb_ptp.o igb_hwmon.o igb_ieee_test.o
diff --git a/drivers/net/ethernet/intel/igb/igb.h b/drivers/net/ethernet/intel/igb/igb.h
index ca54e268d157..5328d9ce4c60 100644
--- a/drivers/net/ethernet/intel/igb/igb.h
+++ b/drivers/net/ethernet/intel/igb/igb.h
@@ -685,6 +685,12 @@ unsigned int igb_get_max_rss_queues(struct igb_adapter *);
 void igb_sysfs_exit(struct igb_adapter *adapter);
 int igb_sysfs_init(struct igb_adapter *adapter);
 #endif
+
+#ifdef CONFIG_I210_EEE
+int ieee_sysfs_init(struct igb_adapter *adapter);
+int ieee_sysfs_exit(struct igb_adapter *adapter);
+#endif
+
 static inline s32 igb_reset_phy(struct e1000_hw *hw)
 {
 	if (hw->phy.ops.reset)
diff --git a/drivers/net/ethernet/intel/igb/igb_ieee_test.c b/drivers/net/ethernet/intel/igb/igb_ieee_test.c
new file mode 100644
index 000000000000..4c9f1e3266d5
--- /dev/null
+++ b/drivers/net/ethernet/intel/igb/igb_ieee_test.c
@@ -0,0 +1,684 @@
+/* Intel(R) Gigabit Ethernet Linux driver
+ * Copyright(c) 2007-2014 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ */
+
+#include "igb.h"
+#include "e1000_hw.h"
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sysfs.h>
+
+#ifdef CONFIG_I210_EEE
+struct igb_adapter *adapter;
+struct e1000_hw *hw;
+struct pci_dev *pdev;
+static int CASE = 1;
+static int speed = 1;
+static int trigger = 0;
+static u8 forced_speed_duplex, autoneg;
+static u16 autoneg_advertised;
+
+/*
+ * Register access macros
+ */
+#define REG_CLR(reg, x) (reg &= ~(x))
+#define REG_SET(reg, x) (reg |= (x))
+
+#define IEEE_DUBUG 1
+
+static ssize_t attr_case_get(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	dev_info(&pdev->dev, "IEEE Test Case %d", CASE);
+	return 0;
+}
+
+static ssize_t attr_case_set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (!strcmp(buf, "1\n"))
+		CASE = 1;
+	else if (!strcmp(buf, "2\n"))
+		CASE = 2;
+	else if (!strcmp(buf, "3\n"))
+		CASE = 3;
+	else if (!strcmp(buf, "4\n"))
+		CASE = 4;
+	else {
+		dev_info(&pdev->dev, "IEEE Test Case can't support this argument: %s", buf);
+		return -1;
+	}
+
+	dev_info(&pdev->dev, "Set IEEE Test Case: %d", CASE);
+	return count;
+}
+
+static ssize_t attr_speed_get(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	switch (speed) {
+	case 1:
+		dev_info(&pdev->dev, "IEEE Test Speed 10Mbps");
+		break;
+	case 2:
+		dev_info(&pdev->dev, "IEEE Test Speed 100Mbps");
+		break;
+	case 3:
+		dev_info(&pdev->dev, "IEEE Test Speed 1Gbps");
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t attr_speed_set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (!strcmp(buf, "1\n"))  {
+		speed = 1;
+		dev_info(&pdev->dev, "Set IEEE Test Speed: 10Mbps");
+	} else if (!strcmp(buf, "2\n")) {
+		speed = 2;
+		dev_info(&pdev->dev, "Set IEEE Test Speed: 100Mbps");
+	} else if (!strcmp(buf, "3\n")) {
+		speed = 3;
+		dev_info(&pdev->dev, "Set IEEE Test Speed: 1Gbps");
+	} else {
+		dev_info(&pdev->dev, "IEEE Test Speed can't support this argument: %s", buf);
+		return -1;
+	}
+
+	return count;
+}
+
+int do_ieee_test(struct device *dev)
+{
+	u16 data = 0;
+	s32 ret_val;
+
+	switch (speed) {
+	case 1:
+		// IEEE 10Mbps Tests:
+		dev_info(&pdev->dev, "Start 10Mbps IEEE Testing");
+		// Write MDIO Phy Register 0x10, Turn off bit 10
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x10, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x10 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x10 Control Reg = 0x%04X", data);
+
+		dev_info(&pdev->dev, "Disable 0x10 Control Reg: BIT(10)");
+#endif
+		REG_CLR(data, BIT(10));
+		dev_info(&pdev->dev, "Write 0x10 Control Reg: 0x%04X", data);
+		if (igb_write_phy_reg(hw, 0x10, data)) {
+			dev_err(&pdev->dev, "Error write 0x10 Control Reg");
+			return -1;
+		}
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x10, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x10 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x10 Control Reg = 0x%04X", data);
+#endif
+
+		// Write MDIO Phy Register 0x1A, Turn off bits 2 and 3
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x1A, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x1A Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x1A Control Reg = 0x%04X", data);
+
+		dev_info(&pdev->dev, "Disable 0x1A Control Reg: BIT(2) & BIT(3)");
+#endif
+		REG_CLR(data, BIT(2));
+		REG_CLR(data, BIT(3));
+		dev_info(&pdev->dev, "Write 0x1A Control Reg: 0x%04X", data);
+		if (igb_write_phy_reg(hw, 0x1A, data)) {
+			dev_err(&pdev->dev, "Error write 0x1A Control Reg");
+			return -1;
+		}
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x1A, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x1A Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x1A Control Reg = 0x%04X", data);
+#endif
+
+		// Write MAC Register 0xE14, Turn off bit 5
+		data = rd32(E1000_82580_PHY_POWER_MGMT);
+#ifdef IEEE_DUBUG
+		dev_info(&pdev->dev, "Direct read 0x0E14 MAC Reg = 0x%04X", data);
+		dev_info(&pdev->dev, "Disable 0x0E14 MAC Reg: BIT(5)");
+#endif
+		REG_CLR(data, BIT(5));
+#ifdef IEEE_DUBUG
+		dev_info(&pdev->dev, "Direct Write 0x0E14 MAC Reg: 0x%04X", data);
+#endif
+		wr32(E1000_82580_PHY_POWER_MGMT, data);
+#ifdef IEEE_DUBUG
+		data = rd32(E1000_82580_PHY_POWER_MGMT);
+		dev_info(&pdev->dev, "Direct read 0x0E14 MAC Reg = 0x%04X", data);
+#endif
+
+		// Write MDIO Phy Register 0x10, Turn on bit 10
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x10, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x10 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x10 Control Reg = 0x%04X", data);
+
+		dev_info(&pdev->dev, "Disable 0x10 Control Reg: BIT(10)");
+#endif
+		REG_SET(data, BIT(10));
+		dev_info(&pdev->dev, "Write 0x10 Control Reg: 0x%04X", data);
+		if (igb_write_phy_reg(hw, 0x10, data)) {
+			dev_err(&pdev->dev, "Error write 0x10 Control Reg");
+			return -1;
+		}
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x10, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x10 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x10 Control Reg = 0x%04X", data);
+#endif
+		// Write MDIO Phy Register 0x16, Set value to 0x6
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x16, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x16 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x16 Control Reg = 0x%04X", data);
+
+		dev_info(&pdev->dev, "Write 0x16 Control Reg: 0x0006");
+#endif
+		if (igb_write_phy_reg(hw, 0x16, 0x6)) {
+			dev_err(&pdev->dev, "Error write 0x16 Control Reg.");
+			return -1;
+		}
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x16, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x16 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x16 Control Reg = 0x%04X", data);
+#endif
+
+		// Write MDIO Phy Register 0x10, Set Value to 0x0
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x10, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x10 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x10 Control Reg = 0x%04X", data);
+
+		dev_info(&pdev->dev, "Write 0x10 Control Reg: 0x0000");
+#endif
+		if (igb_write_phy_reg(hw, 0x10, 0x0)) {
+			dev_err(&pdev->dev, "Error write 0x10 Control Reg.");
+			return -1;
+		}
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x10, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x10 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x10 Control Reg = 0x%04X", data);
+#endif
+
+		// Write MDIO Phy Register 0x16, Set Value to 0x0
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x16, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x16 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x16 Control Reg = 0x%04X", data);
+
+		dev_info(&pdev->dev, "Write 0x16 Control Reg: 0x0000");
+#endif
+		if (igb_write_phy_reg(hw, 0x16, 0x0)) {
+			dev_err(&pdev->dev, "Error write 0x16 Control Reg.");
+			return -1;
+		}
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, 0x16, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x16 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x16 Control Reg = 0x%04X", data);
+#endif
+
+		// Write MDIO Phy Register 0x0, Set Value to 0x0
+		if (CASE != 1) {
+#ifdef IEEE_DUBUG
+		ret_val = igb_read_phy_reg(hw, PHY_CONTROL, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read MDIO PHY Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read MDIO PHY Control Reg = 0x%04X", data);
+
+		dev_info(&pdev->dev, "Write MDIO PHY Control Reg: 0x0000");
+#endif
+		if (igb_write_phy_reg(hw, PHY_CONTROL, 0x0)) {
+			dev_err(&pdev->dev, "Error write MDIO PHY Control Reg.");
+			return -1;
+		}
+#ifdef IEEE_DUBUG
+
+		ret_val = igb_read_phy_reg(hw, PHY_CONTROL, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read MDIO PHY Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read MDIO PHY Control Reg = 0x%04X", data);
+#endif
+		}
+
+		if (CASE == 1) {
+		dev_info(&pdev->dev, "14.3.1.2.1 - Peak Differential Output Voltage on TD Circuit (Amp 5MHz) – Send 1500 Byte Packets containing AA pattern as the packet payload.");
+		dev_info(&pdev->dev, "14.3.1.2.1 - Peak Differential Output Voltage on TD Circuit (Amp 10MHz) - Send 1500 Byte Packets containing FF pattern as the packet payload.");
+		dev_info(&pdev->dev, "14.3.1.2.1 - Harmonic Content, All Ones Signal - Send 1500 Byte Packets containing FF pattern as the packet payload.");
+		dev_info(&pdev->dev, "14.3.1.2.1 - Differential Output Voltage Template - Send 1500 Byte Packets containing Random data as the packet payload.");
+		dev_info(&pdev->dev, "14.3.1.2.5 - TD Circuit Common-Mode Output Voltage - Send 512 Byte Packets containing Random data as the packet payload.");
+		dev_info(&pdev->dev, "14.3.1.2.3 - Transmitter Output Timing Jitter with Cable Model - Send 1500 Byte Packets containing Random data as the packet payload.");
+		dev_info(&pdev->dev, "14.3.1.2.3 - Transmitter Output Timing Jitter without Cable Model - Send 1500 Byte Packets containing Random data as the packet payload.");
+		} else {
+		dev_info(&pdev->dev, "14.3.1.2.1 - TP_IDL Waveform Output – Perform setup, do not send any packets. There should be an idle pulse always on after setting register 0x0 to 0x0.");
+		dev_info(&pdev->dev, "14.2.1.4 - RD Circuit Differential Input Impedance (Rx Return Loss) – Perform setup, do not send any packets. There should be an idle pulse always on after setting register 0x0 to 0x0.");
+		dev_info(&pdev->dev, "14.3.1.2.2 - TD Circuit differential Output Impedance (Tx Return Loss) – Perform setup, do not send any packets. There should be an idle pulse always on after setting register 0x0 to 0x0.");
+		}
+		break;
+	case 2:
+		// IEEE 100Mbps Tests:
+		dev_info(&pdev->dev, "Start 100Mbps IEEE Testing");
+		// Write MDIO Phy Register 0x10, Turn off bit 10
+#ifdef IEEE_DUBUG
+		ret_val = hw->phy.ops.read_reg(hw, 0x10, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x10 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x10 Control Reg = 0x%02X", data);
+
+		dev_info(&pdev->dev, "Disable 0x10 Control Reg: BIT(10)");
+#endif
+		REG_CLR(data, BIT(10));
+		if (hw->phy.ops.write_reg(hw, 0x10, data)) {
+			dev_err(&pdev->dev, "Error write 0x10 Control Reg");
+			return -1;
+		}
+#ifdef IEEE_DUBUG
+		ret_val = hw->phy.ops.read_reg(hw, 0x10, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x10 Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x10 Control Reg = 0x%02X", data);
+#endif
+
+		// Write MDIO Phy Register 0x1A, Turn off bits 2 and 3
+#ifdef IEEE_DUBUG
+		ret_val = hw->phy.ops.read_reg(hw, 0x1A, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x1A Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x1A Control Reg = 0x%02X", data);
+
+		dev_info(&pdev->dev, "Disable 0x1A Control Reg: BIT(2) & BIT(3)");
+#endif
+		REG_CLR(data, BIT(2));
+		REG_CLR(data, BIT(3));
+		if (hw->phy.ops.write_reg(hw, 0x1A, data)) {
+			dev_err(&pdev->dev, "Error write 0x1A Control Reg");
+			return -1;
+		}
+#ifdef IEEE_DUBUG
+		ret_val = hw->phy.ops.read_reg(hw, 0x1A, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x1A Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x1A Control Reg = 0x%02X", data);
+#endif
+
+		// Write MAC Register 0xE14, Turn off bit 5
+		data = rd32(E1000_82580_PHY_POWER_MGMT);
+#ifdef IEEE_DUBUG
+		dev_info(&pdev->dev, "Direct read 0x0E14 MAC Reg = 0x%02X", data);
+		dev_info(&pdev->dev, "Disable 0x0E14 MAC Reg: BIT(5)");
+#endif
+		REG_CLR(data, BIT(5));
+#ifdef IEEE_DUBUG
+		dev_info(&pdev->dev, "Direct Write 0x0E14 MAC Reg: 0x%02X", data);
+#endif
+		wr32(E1000_82580_PHY_POWER_MGMT, data);
+#ifdef IEEE_DUBUG
+		data = rd32(E1000_82580_PHY_POWER_MGMT);
+		dev_info(&pdev->dev, "Direct read 0x0E14 MAC Reg = 0x%02X", data);
+#endif
+
+		// Write MDIO Phy Register 0x00, Set value to 0xA000
+#ifdef IEEE_DUBUG
+		ret_val = hw->phy.ops.read_reg(hw, PHY_CONTROL, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read MDIO PHY Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read MDIO PHY Control Reg = 0x%02X", data);
+
+		dev_info(&pdev->dev, "Write MDIO PHY Control Reg: 0xA000");
+#endif
+		if (hw->phy.ops.write_reg(hw, PHY_CONTROL, 0xA000)) {
+			dev_err(&pdev->dev, "Error write MDIO PHY Control Reg.");
+			return -1;
+		}
+		udelay(1);
+#ifdef IEEE_DUBUG
+		ret_val = hw->phy.ops.read_reg(hw, PHY_CONTROL, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read MDIO PHY Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read MDIO PHY Control Reg = 0x%02X", data);
+
+		ret_val = hw->phy.ops.read_reg(hw, 0x1A, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x1A Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x1A Control Reg = 0x%02X", data);
+#endif
+
+		switch (CASE) {
+		case 1:
+			// 9.1.2.2 - UTP Differential Output Voltage – Should see 112ns wide pulses
+			// 9.1.4 - Signal Amplitude Symmetry
+			// 9.1.6 - Rise / Fall Times
+			dev_info(&pdev->dev, "9.1.2.2 - UTP Differential Output Voltage – Should see 112ns wide pulses");
+			dev_info(&pdev->dev, "9.1.4 - Signal Amplitude Symmetry");
+			dev_info(&pdev->dev, "9.1.6 - Rise / Fall Times");
+			REG_SET(data, BIT(3));
+			ret_val = hw->phy.ops.write_reg(hw, 0x1A, data);
+			break;
+		case 2:
+			// 9.1.5 - Transmit Return Loss – Should see random idles data
+			// 9.1.9 - Transmit Jitter
+			// 9.2.2 - Receiver Return Loss
+			dev_info(&pdev->dev, "9.1.5 - Transmit Return Loss – Should see random idles data");
+			dev_info(&pdev->dev, "9.1.9 - Transmit Jitter");
+			dev_info(&pdev->dev, "9.2.2 - Receiver Return Loss");
+			ret_val = hw->phy.ops.write_reg(hw, 0x1A, 0x0);
+			break;
+		case 3:
+			// 9.1.8 - Duty Cycle Distortion (DCD) – Should see 16ns pulses
+			dev_info(&pdev->dev, "9.1.8 - Duty Cycle Distortion (DCD) – Should see 16ns pulses");
+			REG_SET(data, BIT(2));
+			REG_SET(data, BIT(3));
+			ret_val = hw->phy.ops.write_reg(hw, 0x1A, data);
+			break;
+		case 4:
+			dev_info(&pdev->dev, "IEEE 100Mbps doesn't have Test Case 4");
+			return -1;
+			break;
+		}
+
+#ifdef IEEE_DUBUG
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error write 0x1A Control Reg.");
+			return -1;
+		}
+
+		ret_val = hw->phy.ops.read_reg(hw, 0x1A, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 0x1A Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 0x1A Control Reg = 0x%02X", data);
+#endif
+		break;
+	case 3:
+		// IEEE 1Gbps Tests:
+		dev_info(&pdev->dev, "Start 1Gbps IEEE Testing");
+		// Setup for all patterns
+		// Write MDIO Phy Register 0x00, set value 0x9140 – Set it to Gigabit and reset PHY BIT(15).
+#ifdef IEEE_DUBUG
+		ret_val = hw->phy.ops.read_reg(hw, PHY_CONTROL, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read MDIO PHY Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read MDIO PHY Control Reg = 0x%02X", data);
+
+		dev_info(&pdev->dev, "Write MDIO PHY Control Reg: 0x9140");
+#endif
+		if (hw->phy.ops.write_reg(hw, PHY_CONTROL, 0x9140)) {
+			dev_err(&pdev->dev, "Error write MDIO PHY Control Reg.");
+			return -1;
+		}
+		udelay(1);
+#ifdef IEEE_DUBUG
+		ret_val = hw->phy.ops.read_reg(hw, PHY_CONTROL, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read MDIO PHY Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read MDIO PHY Control Reg = 0x%02X", data);
+
+		ret_val = hw->phy.ops.read_reg(hw, PHY_1000T_CTRL, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 1000Base-T Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 1000Base-T Control Reg = 0x%02X", data);
+#endif
+
+		switch (CASE) {
+		case 1:
+			// 40.6.1.2.1 - Peak Differential Output Voltage (Test Mode 1)
+			// 40.6.1.2.2 - Maximum Output Droop (Test Mode 1)
+			dev_info(&pdev->dev, "40.6.1.2.1 - Peak Differential Output Voltage (Test Mode 1)");
+			dev_info(&pdev->dev, "40.6.1.2.2 - Maximum Output Droop (Test Mode 1)");
+			ret_val = hw->phy.ops.write_reg(hw, PHY_1000T_CTRL, 0x3B00);
+			break;
+		case 2:
+			// 40.6.1.2.5 - Transmitter Timing Jitter (Test Mode 2)
+			dev_info(&pdev->dev, "40.6.1.2.5 - Transmitter Timing Jitter (Test Mode 2)");
+			ret_val = hw->phy.ops.write_reg(hw, PHY_1000T_CTRL, 0x5B00);
+			break;
+		case 3:
+			// 40.6.1.2.5 - Transmitter Timing Jitter (Test Mode 3)
+			dev_info(&pdev->dev, "40.6.1.2.5 - Transmitter Timing Jitter (Test Mode 3)");
+			ret_val = hw->phy.ops.write_reg(hw, PHY_1000T_CTRL, 0x7300);
+			break;
+		case 4:
+			// 40.6.1.2.4 - Transmitter Distortion (Test Mode 4)
+			// 40.8.3.1 - MDI Return Loss (Test Mode 4)
+			// 40.8.3.3 - MDI Common-Mode Output Voltage (Test Mode 4)
+			dev_info(&pdev->dev, "40.6.1.2.4 - Transmitter Distortion (Test Mode 4)");
+			dev_info(&pdev->dev, "40.8.3.1 - MDI Return Loss (Test Mode 4)");
+			dev_info(&pdev->dev, "40.8.3.3 - MDI Common-Mode Output Voltage (Test Mode 4)");
+			ret_val = hw->phy.ops.write_reg(hw, PHY_1000T_CTRL, 0x9B00);
+			break;
+		}
+
+#ifdef IEEE_DUBUG
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error write 1000Base-T Control Reg.");
+			return -1;
+		}
+
+		ret_val = hw->phy.ops.read_reg(hw, PHY_1000T_CTRL, &data);
+		if (ret_val) {
+			dev_err(&pdev->dev, "Error read 1000Base-T Control Reg.");
+			return -1;
+		}
+		dev_info(&pdev->dev, "Read 1000Base-T Control Reg = 0x%02X", data);
+#endif
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t attr_trigger_get(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	switch (trigger) {
+	case 0:
+		dev_info(&pdev->dev, "IEEE Test stop");
+		break;
+	case 1:
+		dev_info(&pdev->dev, "IEEE Test is running");
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t attr_trigger_set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	s32 ret_val;
+
+	if (!strcmp(buf, "0\n")) {
+		if (!trigger) {
+			dev_info(&pdev->dev, "IEEE Testing is stoping.");
+			return -1;
+		}
+
+		/* restore speed, duplex, autoneg settings */
+		adapter->hw.phy.autoneg_advertised = autoneg_advertised;
+		adapter->hw.mac.forced_speed_duplex = forced_speed_duplex;
+		adapter->hw.mac.autoneg = autoneg;
+
+		/* force this routine to wait until autoneg complete/timeout */
+		adapter->hw.phy.autoneg_wait_to_complete = true;
+		igb_reset(adapter);
+		adapter->hw.phy.autoneg_wait_to_complete = false;
+
+		clear_bit(__IGB_TESTING, &adapter->state);
+		if (netif_running(adapter->netdev)) {
+			igb_open(adapter->netdev);
+		}
+
+		trigger = 0;
+		dev_info(&pdev->dev, "Stop IEEE Testing");
+	} else if (!strcmp(buf, "1\n")) {
+		if (trigger) {
+			dev_info(&pdev->dev, "IEEE Testing is running.");
+			return -1;
+		}
+
+		/* reset link */
+		if (netif_running(adapter->netdev))
+			igb_reinit_locked(adapter);
+		else
+			igb_reset(adapter);
+
+		/* save speed, duplex, autoneg settings */
+		autoneg_advertised = adapter->hw.phy.autoneg_advertised;
+		forced_speed_duplex = adapter->hw.mac.forced_speed_duplex;
+		autoneg = adapter->hw.mac.autoneg;
+
+		set_bit(__IGB_TESTING, &adapter->state);
+		if (netif_running(adapter->netdev)) {
+			/* indicate we're in test mode */
+			igb_close(adapter->netdev);
+		} else
+			igb_reset(adapter);
+
+		trigger = 1;
+		ret_val = do_ieee_test(dev);
+		if (ret_val) {
+			dev_info(&pdev->dev, "Error reading the PHY.\n");
+			return -2;
+		}
+	} else {
+		dev_info(&pdev->dev, "IEEE Test Trigger can't support this argument: %s", buf);
+		return -1;
+	}
+
+	msleep_interruptible(2 * 1000);
+	return count;
+}
+
+static struct device_attribute attributes[] = {
+	__ATTR(ieee_case, 0644, attr_case_get, attr_case_set),
+	__ATTR(ieee_speed, 0644, attr_speed_get, attr_speed_set),
+	__ATTR(ieee_trigger, 0644, attr_trigger_get, attr_trigger_set),
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+        return 0;
+
+error:
+	dev_info(&pdev->dev, "%s error, i = %d\n", __func__, i );
+	for (i = i ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+int ieee_sysfs_init(struct igb_adapter *Adapter)
+{
+	hw = &Adapter->hw;
+	pdev = Adapter->pdev;
+	adapter = netdev_priv(Adapter->netdev);
+	hw->phy.media_type = e1000_media_type_copper;
+	return create_sysfs_interfaces(&Adapter->netdev->dev);
+}
+
+int ieee_sysfs_exit(struct igb_adapter *Adapter)
+{
+	hw->phy.media_type = e1000_media_type_unknown;
+	return remove_sysfs_interfaces(&Adapter->netdev->dev);
+}
+#endif
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index ed7e667d7eb2..0ab86e345c64 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -3445,6 +3445,14 @@ static int igb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	dev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_NEVER_SKIP);
 
+#ifdef CONFIG_I210_EEE
+        if (hw->mac.type == e1000_i210) {
+                dev_info(&pdev->dev, "Adapter enable IEEE Testing");
+                ieee_sysfs_init(adapter);
+        } else {
+                dev_info(&pdev->dev, "Adapter can not support IEEE Testing");
+        }
+#endif
 	pm_runtime_put_noidle(&pdev->dev);
 	return 0;
 
@@ -3631,6 +3639,10 @@ static void igb_remove(struct pci_dev *pdev)
 #ifdef CONFIG_IGB_HWMON
 	igb_sysfs_exit(adapter);
 #endif
+
+#ifdef CONFIG_I210_EEE
+        ieee_sysfs_exit(adapter);
+#endif	
 	igb_remove_i2c(adapter);
 	igb_ptp_stop(adapter);
 	/* The watchdog timer may be rescheduled, so explicitly
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 5852f8f5454e..6f2abbea8224 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -374,6 +374,13 @@ config DP83867_PHY
 	---help---
 	  Currently supports the DP83867 PHY.
 
+config DP83867_ETH_TEST
+        bool "Texas Instruments DP83867 Gigabit PHY Layer Compliance Tests"
+        default n
+        depends on DP83867_PHY
+        ---help---
+          Enable DP83867 to support 1000BASE-T/100BASE-TX/10BASE-T Physical Layer Compliance Tests.
+
 config FIXED_PHY
 	tristate "MDIO Bus/PHY emulation with fixed speed/link PHYs"
 	depends on PHYLIB
diff --git a/drivers/net/phy/dp83867.c b/drivers/net/phy/dp83867.c
index 37fceaf9fa10..41d04598aac0 100644
--- a/drivers/net/phy/dp83867.c
+++ b/drivers/net/phy/dp83867.c
@@ -14,6 +14,12 @@
 #include <linux/delay.h>
 
 #include <dt-bindings/net/ti-dp83867.h>
+#if defined(CONFIG_DP83867_ETH_TEST)
+#include <linux/delay.h>
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#endif
 
 #define DP83867_PHY_ID		0x2000a231
 #define DP83867_DEVADDR		0x1f
@@ -44,6 +50,12 @@
 #define DP83867_SW_RESET	BIT(15)
 #define DP83867_SW_RESTART	BIT(14)
 
+/* Extended LED Registers */
+#if defined(CONFIG_ARCH_LEC_IMX8M)
+#define DP83867_LEDCR1         0x0018
+#define DP83867_LEDCR2         0x0019
+#endif
+
 /* MICR Interrupt bits */
 #define MII_DP83867_MICR_AN_ERR_INT_EN		BIT(15)
 #define MII_DP83867_MICR_SPEED_CHNG_INT_EN	BIT(14)
@@ -116,6 +128,254 @@ struct dp83867_private {
 	bool sgmii_ref_clk_en;
 };
 
+#if defined(CONFIG_DP83867_ETH_TEST)
+static int pattern = 0;
+static int channel = 0;
+static bool init_fs = 0;
+struct phy_device* myDev = NULL;
+static int set_pattern(int type)
+{
+	int rd_val = 0;
+	int retval = -1;
+
+	switch(type) {
+	case 0: //Reset Phy
+		phy_write(myDev, 0x001F, 0x8000);
+		printk(KERN_INFO "Reset Phy\n");
+		break;
+	case 1: //1000 Base Test Mode 1
+		if (channel == 0) {
+			printk(KERN_INFO "1000 Base Test Mode 1: channel=0 will output all channel\n");
+			printk(KERN_INFO "You also can set channel=1-4 to only output 1 channel\n");
+		} else if (channel > 4) {
+			printk(KERN_INFO "1000 Base Test Mode 1 channel didn't set correctly\n");
+			break;
+		}
+
+		retval = phy_write(myDev, 0x001F, 0x8000);
+		if(retval < 0)
+			printk(KERN_INFO "0x001F write fail\n");
+		retval = phy_write(myDev, 0x0000, 0x0140);
+		if(retval < 0)
+			printk(KERN_INFO "0x0000 write fail\n");
+		retval = phy_write(myDev, 0x0010, 0x5008);
+		if(retval < 0)
+			printk(KERN_INFO "0x0010 write fail\n");
+		retval = phy_write(myDev, 0x0009, 0x3B00);
+		if(retval < 0)
+			printk(KERN_INFO "0x0009 write fail\n");
+		printk(KERN_INFO "1000 Base Test Mode 1, Channel=%d\n", channel);
+
+		rd_val = phy_read(myDev, 0x0000); printk(KERN_INFO "Read phyaddr 0x0000=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0010); printk(KERN_INFO "Read phyaddr 0x0010=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0009); printk(KERN_INFO "Read phyaddr 0x0009=0x%08x\n", rd_val);
+
+		switch(channel) {
+		case 0:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+			break;
+		case 1:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0400);
+			break;
+		case 2:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0420);
+			break;
+		case 3:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0440);
+			break;
+		case 4:
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0460);
+			break;
+		default:
+			printk(KERN_INFO "\n1000 Base Test Mode 1 channel didn't set correctly\n");
+			break;
+		}
+
+		phy_write_mmd_indirect(myDev, 0x01D5, DP83867_DEVADDR, 0xF508);
+		rd_val = phy_read_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR); printk(KERN_INFO "Channel=%d Read phyaddr 0x0025=0x%08x\n", channel, rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x01D5, DP83867_DEVADDR); printk(KERN_INFO "Read phyaddr 0x01D5=0x%08x\n", rd_val);
+		break;
+	case 2: //1000 Base Test Mode 2
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0140);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0x5B00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		printk(KERN_INFO "1000 Base Test Mode 2\n");
+		break;
+	case 3: //1000 Base Test Mode 2 with TX_TCLK
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0140);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0x5B00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		//phy_write(myDev, 0x0170, 0x081F);
+		//phy_write(myDev, 0x00C6, 0x0010);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0170, DP83867_DEVADDR, 0x081F);
+		phy_write_mmd_indirect(myDev, 0x00C6, DP83867_DEVADDR, 0x0010);
+		printk(KERN_INFO "1000 Base Test Mode 2 with TX_TCLK\n");
+		rd_val = phy_read(myDev, 0x0000); printk(KERN_INFO "Read phyaddr 0x0000=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0010); printk(KERN_INFO "Read phyaddr 0x0010=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0009); printk(KERN_INFO "Read phyaddr 0x0009=0x%08x\n", rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR); printk(KERN_INFO "Read phyaddr 0x0025=0x%08x\n", rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x0170, DP83867_DEVADDR); printk(KERN_INFO "Read phyaddr 0x0170=0x%08x\n", rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x00C6, DP83867_DEVADDR); printk(KERN_INFO "Read phyaddr 0x00C6=0x%08x\n", rd_val);
+		break;
+	case 4: //1000 Base Test Mode 3
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0140);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0x7B00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		printk(KERN_INFO "1000 Base Test Mode 3\n");
+		break;
+	case 5: //1000 Base Test Mode 3 with TX_TCLK
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0140);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0x7B00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		//phy_write(myDev, 0x0170, 0x081F);
+		//phy_write(myDev, 0x00C6, 0x0010);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0170, DP83867_DEVADDR, 0x081F);
+		phy_write_mmd_indirect(myDev, 0x00C6, DP83867_DEVADDR, 0x0010);
+		printk(KERN_INFO "1000 Base Test Mode 3 with TX_TCLK\n");
+		break;
+	case 6: //1000 Base Test Mode 4
+		if(channel == 0) {
+			printk(KERN_INFO "1000 Base Test Mode 4 channel has not been set\n");
+			break;
+		}
+
+		retval = phy_write(myDev, 0x001F, 0x8000);
+		if(retval < 0)
+			printk(KERN_INFO "0x001F write fail\n");
+		retval = phy_write(myDev, 0x0000, 0x0140);
+		if(retval < 0)
+			printk(KERN_INFO "0x0000 write fail\n");
+		retval = phy_write(myDev, 0x0010, 0x5008);
+		if(retval < 0)
+			printk(KERN_INFO "0x0010 write fail\n");
+		retval = phy_write(myDev, 0x0009, 0x9B00);
+		if(retval < 0)
+			printk(KERN_INFO "0x0009 write fail\n");
+		printk(KERN_INFO "1000 Base Test Mode 4, Channel=%d\n", channel);
+
+		rd_val = phy_read(myDev, 0x0000); printk(KERN_INFO "Read phyaddr 0x0000=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0010); printk(KERN_INFO "Read phyaddr 0x0010=0x%08x\n", rd_val);
+		rd_val = phy_read(myDev, 0x0009); printk(KERN_INFO "Read phyaddr 0x0009=0x%08x\n", rd_val);
+
+		switch(channel) {
+		case 1:
+			//retval = phy_write(myDev, 0x0025, 0x0400);
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0400);
+			break;
+		case 2:
+			//retval = phy_write(myDev, 0x0025, 0x0420);
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0420);
+			break;
+		case 3:
+			//retval = phy_write(myDev, 0x0025, 0x0440);
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0440);
+			break;
+		case 4:
+			//retval = phy_write(myDev, 0x0025, 0x0460);
+			phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0460);
+			break;
+		default:
+			printk(KERN_INFO "\n1000 Base Test Mode 4 channel has not been set\n");
+			break;
+		}
+		//if(retval < 0)
+		//	printk(KERN_INFO "0x0025 write fail\n");
+
+		//rd_val = phy_read(myDev, 0x0025); printk(KERN_INFO "Channel=%d Read phyaddr 0x0025=0x%08x\n", channel, rd_val);
+		rd_val = phy_read_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR); printk(KERN_INFO "Channel=%d Read phyaddr 0x0025=0x%08x\n", channel, rd_val);
+		break;
+	case 7: //100 Base Standard MDI (Test Mode 5)
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0210);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0009, 0xBB00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		printk(KERN_INFO "100 Base Standard MDI (Test Mode 5)\n");
+		break;
+	case 8: //100 Base Standard MDIX (Test Mode 5):
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x2100);
+		phy_write(myDev, 0x0010, 0x5028);
+		phy_write(myDev, 0x0009, 0xBB00);
+		//phy_write(myDev, 0x0025, 0x0480);
+		phy_write_mmd_indirect(myDev, 0x0025, DP83867_DEVADDR, 0x0480);
+		printk(KERN_INFO "100 Base Standard MDIX (Test Mode 5)\n");
+		break;
+	case 9: //10 Base Link Pulse
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x0100);
+		phy_write(myDev, 0x0010, 0x5008);
+		printk(KERN_INFO "10 Base Link Pulse\n");
+		printk(KERN_INFO "pattern phyAddr->\n0x0000=0x%04x\n0x0010=0x%04x\n",\
+			phy_read(myDev, 0x0000),\
+			phy_read(myDev, 0x0010));
+		break;
+	case 10: //10 Base Standard
+		phy_write(myDev, 0x001F, 0x8000);
+		phy_write(myDev, 0x0000, 0x1000);
+		phy_write(myDev, 0x0010, 0x5008);
+		phy_write(myDev, 0x0016, 0x0020);
+		printk(KERN_INFO "10 Base Standard\n");
+		printk(KERN_INFO "pattern phyAddr->\n0x0000=0x%04x\n0x0010=0x%04x\n0x0016=0x%04x\n",\
+			phy_read(myDev, 0x0000),\
+			phy_read(myDev, 0x0010),\
+			phy_read(myDev, 0x0016));
+		break;
+	}
+	return 0;
+}
+
+static ssize_t pattern_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", pattern);
+}
+
+static ssize_t pattern_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	sscanf(buf, "%du", &pattern);
+	set_pattern(pattern);
+	return count;
+}
+
+static ssize_t channel_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", channel);
+}
+
+static ssize_t channel_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	sscanf(buf, "%du", &channel);
+	return count;
+}
+
+static struct kobject *test_pattern_kobj = NULL;
+static struct kobj_attribute pattern_attribute = __ATTR(pattern, 0600, pattern_show, pattern_store);
+static struct kobj_attribute channel_attribute = __ATTR(channel, 0600, channel_show, channel_store);
+
+static struct attribute *attrs[] = {
+        &pattern_attribute.attr,
+        &channel_attribute.attr,
+        NULL,
+};
+
+static struct attribute_group attr_group = {
+        .attrs = attrs,
+};
+#endif
+
 static int dp83867_ack_interrupt(struct phy_device *phydev)
 {
 	int err = phy_read(phydev, MII_DP83867_ISR);
@@ -303,6 +563,9 @@ static int dp83867_config_init(struct phy_device *phydev)
 	struct dp83867_private *dp83867 = phydev->priv;
 	int ret, val, bs;
 	u16 delay;
+#if defined(CONFIG_DP83867_ETH_TEST)
+	int retval;
+#endif	
 
 	ret = dp83867_of_init(phydev);
 	if (ret)
@@ -420,6 +683,56 @@ static int dp83867_config_init(struct phy_device *phydev)
 	if (dp83867->port_mirroring != DP83867_PORT_MIRROING_KEEP)
 		dp83867_config_port_mirroring(phydev);
 
+#if defined(CONFIG_ARCH_LEC_IMX8M)
+	/* LED Configuration for LEC-BASE 2.0 Board */
+	/* Set LED pins' function - set LED_0 1011, LED_1 0110, LED_2 0101, LED_GPIO 1111 */
+	/* LED_0    1011: Link established, blink for transmit or receive activity */
+	/* LED_1    0110: 100 BTX link established */
+	/* LED_2    0101: 1000BT link established */
+	/* LED_GPIO 1111: Reserved */
+	val = phy_read(phydev, DP83867_LEDCR1);
+	if (val < 0)
+		return val;
+
+	if ((val & 0xFFFF) != 0xF56B) {
+		val &= ~0xFFFF;
+		val |= 0xF56B;
+		ret = phy_write(phydev, DP83867_LEDCR1, val);
+		if (ret)
+			return ret;
+	}
+
+	/* Control LED outputs' ability - set LED_0, LED_1, LED_2 active low, LED_GPIO reserve */
+	val = phy_read(phydev, DP83867_LEDCR2);
+	if (val < 0)
+		return val;
+
+	if ((val & 0xFFFF) != 0x0000) {
+		val &= ~0xFFFF;
+		val |= 0x0000;
+		ret = phy_write(phydev, DP83867_LEDCR2, val);
+		if (ret)
+			return ret;
+	}
+#endif
+#if defined(CONFIG_DP83867_ETH_TEST)
+	// Enable PHY compliance test function.
+	if(!init_fs) {
+		test_pattern_kobj = kobject_create_and_add("phy_debug", kernel_kobj);
+		if (!test_pattern_kobj)
+			return -ENOMEM;
+
+	        /* Create the files associated with this kobject */
+	        retval = sysfs_create_group(test_pattern_kobj, &attr_group);
+		if (retval) {
+			kobject_put(test_pattern_kobj);
+			printk(KERN_INFO "%s=>crate sysfs fail...\n", __func__);
+		}
+		init_fs = 1;
+	}
+	myDev = phydev;
+#endif	
+	
 	/* Clock output selection if muxing property is set */
 	if (dp83867->set_clk_output) {
 		u16 mask = DP83867_IO_MUX_CFG_CLK_O_DISABLE;
-- 
2.17.1

