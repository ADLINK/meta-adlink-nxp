From ae1e4858633472ef2d92482d627e24ff34e763dc Mon Sep 17 00:00:00 2001
From: Arun Kumar EV <arunkumar.ev@adlinktech.com>
Date: Wed, 3 Mar 2021 14:39:09 +0530
Subject: [PATCH 13/13] LEC-iMX8MP: Adding OV13850 sensor support.

 * Add sensor driver code for ov13850
 * Add BGGR format in isi capture driver
 * defer sensor subdev stream_on call for ov13850,
   as we are observing a timeout issue.
 * add sysfs debug into sensor driver
 * modify csi get format function to update format
   based on format received from sensor

Signed-off-by: Arun Kumar EV <arunkumar.ev@adlinktech.com>
---
 arch/arm64/boot/dts/adlink/lec-imx8mp.dts     |   49 +-
 arch/arm64/configs/lec-imx8mp_defconfig       |    3 +-
 drivers/media/i2c/Kconfig                     |    9 +
 drivers/media/i2c/Makefile                    |    1 +
 drivers/media/i2c/ov13850.c                   | 1940 +++++++++++++++++
 drivers/staging/media/imx/imx8-isi-cap.c      |   63 +-
 drivers/staging/media/imx/imx8-isi-hw.c       |    4 +
 .../staging/media/imx/imx8-mipi-csi2-sam.c    |   13 +
 8 files changed, 2070 insertions(+), 12 deletions(-)
 create mode 100644 drivers/media/i2c/ov13850.c

diff --git a/arch/arm64/boot/dts/adlink/lec-imx8mp.dts b/arch/arm64/boot/dts/adlink/lec-imx8mp.dts
index 54ab7d9cb8b6..8d862b515154 100644
--- a/arch/arm64/boot/dts/adlink/lec-imx8mp.dts
+++ b/arch/arm64/boot/dts/adlink/lec-imx8mp.dts
@@ -488,6 +488,32 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_i2c5>;
 	status = "okay";
+
+	ov13850_mipi: ov13850_mipi@10  {
+		compatible = "ov13850_mipi";
+		reg = <0x10>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi1_pwn>, <&pinctrl_csi1_rst>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		clocks = <&clk IMX8MP_CLK_IPP_DO_CLKO2>;
+		clock-names = "csi_mclk";
+		assigned-clocks = <&clk IMX8MP_CLK_IPP_DO_CLKO2>;
+		assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
+		assigned-clock-rates = <24000000>;
+
+		pwn-gpios = <&gpio3 7 GPIO_ACTIVE_HIGH>;
+		rst-gpios = <&gpio1 7 GPIO_ACTIVE_LOW>;
+		/*virtual_channel = <1>;*/
+		virtual_channel = <0>;
+		mipi_csi;
+
+		port@0 {
+			ov13850_mipi_1_ep: endpoint {
+				remote-endpoint = <&mipi_csi1_ep>;
+			};
+		};
+	};
 };
 
 &i2c6{
@@ -1349,7 +1375,7 @@
 &mipi_csi_0 {
 	#address-cells = <1>;
 	#size-cells = <0>;
-	status = "okay";
+	status = "disabled";
 
 	port@0 {
 		reg = <0>;
@@ -1366,7 +1392,18 @@
 &mipi_csi_1 {
 	#address-cells = <1>;
 	#size-cells = <0>;
-	status = "disabled";
+	status = "okay";
+
+	port@1 {
+		reg = <1>;
+		mipi_csi1_ep: endpoint {
+			remote-endpoint = <&ov13850_mipi_1_ep>;
+			data-lanes = <4>;
+			csis-hs-settle = <13>;
+			/*csis-clk-settle = <2>;*/
+			csis-wclk;
+		};
+	};
 };
 
 &cameradev {
@@ -1375,6 +1412,7 @@
 
 &isi_0 {
 	status = "okay";
+	interface = <3 0 2>;
 
 	cap_device {
 		status = "okay";
@@ -1386,11 +1424,16 @@
 };
 
 &isi_1 {
-	status = "disabled";
+	status = "okay";
+	interface = <2 0 2>;
 
 	cap_device {
 		status = "okay";
 	};
+
+	m2m_device {
+		status = "okay";
+	};
 };
 
 &dsp {
diff --git a/arch/arm64/configs/lec-imx8mp_defconfig b/arch/arm64/configs/lec-imx8mp_defconfig
index 83e81ffac8fa..93e93f3c7f83 100644
--- a/arch/arm64/configs/lec-imx8mp_defconfig
+++ b/arch/arm64/configs/lec-imx8mp_defconfig
@@ -500,6 +500,7 @@ CONFIG_MXC_MIPI_CSI=y
 CONFIG_MXC_CAMERA_OV5640_MIPI_V2=y
 CONFIG_V4L_MEM2MEM_DRIVERS=y
 CONFIG_VIDEO_OV5640=y
+CONFIG_VIDEO_OV13850=y
 CONFIG_IMX_DPU_CORE=y
 CONFIG_IMX_LCDIF_CORE=y
 CONFIG_IMX_LCDIFV3_CORE=y
@@ -723,7 +724,7 @@ CONFIG_XEN_GRANT_DEV_ALLOC=y
 CONFIG_STAGING=y
 CONFIG_STAGING_MEDIA=y
 CONFIG_VIDEO_IMX_CAPTURE=y
-CONFIG_IMX8_MEDIA_DEVICE=m
+CONFIG_IMX8_MEDIA_DEVICE=y
 CONFIG_ION=y
 CONFIG_ION_SYSTEM_HEAP=y
 CONFIG_ION_CMA_HEAP=y
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index fcffcc31d168..c891e5bc76aa 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -947,6 +947,15 @@ config VIDEO_NOON010PC30
 	help
 	  This driver supports NOON010PC30 CIF camera from Siliconfile
 
+config VIDEO_OV13850
+	tristate "OmniVision OV13850 sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CAMERA_SUPPORT
+	select V4L2_FWNODE
+	help
+	  This is a Video4Linux2 sensor driver for the OmniVision
+	  OV13850 camera.
+
 source "drivers/media/i2c/m5mols/Kconfig"
 
 config VIDEO_RJ54N1
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index beb170b002dc..52bf83365e7f 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -115,5 +115,6 @@ obj-$(CONFIG_VIDEO_IMX274)	+= imx274.o
 obj-$(CONFIG_VIDEO_IMX319)	+= imx319.o
 obj-$(CONFIG_VIDEO_IMX355)	+= imx355.o
 obj-$(CONFIG_VIDEO_ST_MIPID02) += st-mipid02.o
+obj-$(CONFIG_VIDEO_OV13850) += ov13850.o
 
 obj-$(CONFIG_SDR_MAX2175) += max2175.o
diff --git a/drivers/media/i2c/ov13850.c b/drivers/media/i2c/ov13850.c
new file mode 100644
index 000000000000..05de7a47ecd6
--- /dev/null
+++ b/drivers/media/i2c/ov13850.c
@@ -0,0 +1,1940 @@
+/*
+ * ov13850 sensor level driver
+ * This driver used to capture raw BGGR data
+ * 4 lanes, 2112x1568, 4224x3136
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/of_device.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/kobject.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+
+#define OV13850_XVCLK_FREQ		24000000
+
+#define CHIP_ID				0x00d850
+#define OV13850_REG_CHIP_ID		0x300a
+
+#define OV13850_REG_CTRL_MODE		0x0100
+#define OV13850_MODE_SW_STANDBY		0x0
+#define OV13850_MODE_STREAMING		BIT(0)
+
+#define OV13850_REG_EXPOSURE		0x3500
+#define	OV13850_EXPOSURE_MIN		4
+#define	OV13850_EXPOSURE_STEP		1
+#define OV13850_VTS_MAX			0x7fff
+
+#define OV13850_REG_GAIN_H		0x350a
+#define OV13850_REG_GAIN_L		0x350b
+#define OV13850_GAIN_H_MASK		0x07
+#define OV13850_GAIN_H_SHIFT		8
+#define OV13850_GAIN_L_MASK		0xff
+#define OV13850_GAIN_MIN		0x10
+#define OV13850_GAIN_MAX		0xf8
+#define OV13850_GAIN_STEP		1
+#define OV13850_GAIN_DEFAULT		0x10
+
+#define OV13850_REG_TEST_PATTERN	0x5e00
+#define ENABLE_TEST_PATTERN		0
+
+#define OV13850_REG_VTS			0x380e
+
+#define REG_NULL			0xFFFF
+
+#define OV13850_REG_VALUE_08BIT		1
+#define OV13850_REG_VALUE_16BIT		2
+#define OV13850_REG_VALUE_24BIT		3
+
+#define OV13850_LANES			4
+#define OV13850_BITS_PER_SAMPLE		10
+
+#define OV13850_CHIP_REVISION_REG	0x302A
+#define OV13850_R1A			0xb1
+#define OV13850_R2A			0xb2
+
+#define OF_CAMERA_PINCTRL_STATE_DEFAULT	"ov13850_camera_default"
+#define OF_CAMERA_PINCTRL_STATE_SLEEP	"ov13850_camera_sleep"
+
+#define OV13850_NAME			"ov13850_mipi_raw"
+#define OV13850_VCHANNEL	0x4813
+
+#define OV13850_RES_HIGH_WIDTH		4224
+#define OV13850_RES_HIGH_HEIGHT		3136
+#define OV13850_RES_LOW_WIDTH		2112
+#define OV13850_RES_LOW_HEIGHT		1568
+
+#define DEFAULT_FPS	15
+
+#define OV13850_SENS_PAD_SOURCE	0
+#define OV13850_SENS_PADS_NUM	1
+
+//only running 8 bit settings, 10 bit need to validate
+#define OV13850_8BIT 1
+
+struct kobject *kobj_ref;
+static u32 ov13850_revid;
+
+static const struct regval *ov13850_global_regs;
+
+struct regval {
+	u16 addr;
+	u8 val;
+};
+
+struct ov13850_mode {
+	u32 width;
+	u32 height;
+	const struct regval *reg_list;
+};
+
+struct ov13850 {
+	struct v4l2_subdev		subdev;
+	struct i2c_client *i2c_client;
+	struct v4l2_pix_format pix;
+	const struct ov13850_datafmt	*fmt;
+	struct v4l2_captureparm streamcap;
+	bool on;
+
+	u32 mclk;
+	u8 mclk_source;
+	struct clk *sensor_clk;
+	int csi_vc;
+
+	int pwn_gpio;
+	int rst_gpio;
+	struct media_pad pads[OV13850_SENS_PADS_NUM];
+
+	bool streaming;
+	int mode;
+};
+
+
+struct ov13850_datafmt {
+	u32	code;
+	enum v4l2_colorspace		colorspace;
+};
+
+static const struct ov13850_datafmt ov13850_colour_fmts[] = {
+#ifdef OV13850_10BIT
+	{MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_COLORSPACE_RAW},
+#endif
+#ifdef OV13850_8BIT
+	{MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_COLORSPACE_RAW},
+#endif
+};
+
+
+/*Init settings for 3.3MP resolution*/
+static struct regval ov13850_init_2112x1568_r2a[] = {
+#ifdef OV13850_10BIT
+	{0x0103, 0x01},
+	{0x0300, 0x01},
+	{0x0301, 0x00},
+	{0x0302, 0x28},
+	{0x0303, 0x00},
+	{0x030a, 0x00},
+	{0x300f, 0x11},
+	{0x3010, 0x01},
+	{0x3011, 0x76},
+	{0x3012, 0x41},
+	{0x3013, 0x12},
+	{0x3014, 0x11},
+	{0x301f, 0x03},
+	{0x3106, 0x00},
+	{0x3210, 0x47},
+	{0x3500, 0x00},
+	{0x3501, 0x60},
+	{0x3502, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x350a, 0x00},
+	{0x350b, 0x80},
+	{0x350e, 0x00},
+	{0x350f, 0x10},
+	{0x351a, 0x00},
+	{0x351b, 0x10},
+	{0x351c, 0x00},
+	{0x351d, 0x20},
+	{0x351e, 0x00},
+	{0x351f, 0x40},
+	{0x3520, 0x00},
+	{0x3521, 0x80},
+	{0x3600, 0xc0},
+	{0x3601, 0xfc},
+	{0x3602, 0x02},
+	{0x3603, 0x78},
+	{0x3604, 0xb1},
+	{0x3605, 0x95},
+	{0x3606, 0x73},
+	{0x3607, 0x07},
+	{0x3609, 0x40},
+	{0x360a, 0x30},
+	{0x360b, 0x91},
+	{0x360C, 0x09},
+	{0x360f, 0x02},
+	{0x3611, 0x10},
+	{0x3612, 0x27},
+	{0x3613, 0x33},
+	{0x3615, 0x0c},
+	{0x3616, 0x0e},
+	{0x3641, 0x02},
+	{0x3660, 0x82},
+	{0x3668, 0x54},
+	{0x3669, 0x00},
+	{0x366a, 0x3f},
+	{0x3667, 0xa0},
+	{0x3702, 0x40},
+	{0x3703, 0x44},
+	{0x3704, 0x2c},
+	{0x3705, 0x01},
+	{0x3706, 0x15},
+	{0x3707, 0x44},
+	{0x3708, 0x3c},
+	{0x3709, 0x1f},
+	{0x370a, 0x27},
+	{0x370b, 0x3c},
+	{0x3720, 0x55},
+	{0x3722, 0x84},
+	{0x3728, 0x40},
+	{0x372a, 0x00},
+	{0x372b, 0x02},
+	{0x372e, 0x22},
+	{0x372f, 0x90},
+	{0x3730, 0x00},
+	{0x3731, 0x00},
+	{0x3732, 0x00},
+	{0x3733, 0x00},
+	{0x3710, 0x28},
+	{0x3716, 0x03},
+	{0x3718, 0x10},
+	{0x3719, 0x0c},
+	{0x371a, 0x08},
+	{0x371c, 0xfc},
+	{0x3748, 0x00},
+	{0x3760, 0x13},
+	{0x3761, 0x33},
+	{0x3762, 0x86},
+	{0x3763, 0x16},
+	{0x3767, 0x24},
+	{0x3768, 0x06},
+	{0x3769, 0x45},
+	{0x376c, 0x23},
+	{0x376f, 0x80},
+	{0x3773, 0x06},
+	{0x3d84, 0x00},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xbf},
+	{0x3800, 0x00},
+	{0x3801, 0x08},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x97},
+	{0x3806, 0x0c},
+	{0x3807, 0x4b},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x09},
+	{0x380d, 0x60},
+	{0x380e, 0x06},
+	{0x380f, 0x80},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x02},
+	{0x3821, 0x06},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x08},
+	{0x3837, 0x02},
+	{0x4000, 0xf1},
+	{0x4001, 0x00},
+	{0x400b, 0x0c},
+	{0x4011, 0x00},
+	{0x401a, 0x00},
+	{0x401b, 0x00},
+	{0x401c, 0x00},
+	{0x401d, 0x00},
+	{0x4020, 0x00},
+	{0x4021, 0xe4},
+	{0x4022, 0x04},
+	{0x4023, 0xd7},
+	{0x4024, 0x05},
+	{0x4025, 0xbc},
+	{0x4026, 0x05},
+	{0x4027, 0xbf},
+	{0x4028, 0x00},
+	{0x4029, 0x02},
+	{0x402a, 0x04},
+	{0x402b, 0x08},
+	{0x402c, 0x02},
+	{0x402d, 0x02},
+	{0x402e, 0x0c},
+	{0x402f, 0x08},
+	{0x403d, 0x2c},
+	{0x403f, 0x40},
+	{0x4041, 0x07},
+	{0x4500, 0x82},
+	{0x4501, 0x3c},
+	{0x458b, 0x00},
+	{0x459c, 0x00},
+	{0x459d, 0x00},
+	{0x459e, 0x00},
+	{0x4601, 0x83},
+	{0x4602, 0x22},
+	{0x4603, 0x01},
+	{0x4837, 0x19},
+	{0x4d00, 0x04},
+	{0x4d01, 0x42},
+	{0x4d02, 0xd1},
+	{0x4d03, 0x90},
+	{0x4d04, 0x66},
+	{0x4d05, 0x65},
+	{0x4d0b, 0x00},
+	{0x5000, 0x0e},
+	{0x5001, 0x01},
+	{0x5002, 0x07},
+	{0x5003, 0x4f},
+	{0x5013, 0x40},
+	{0x501c, 0x00},
+	{0x501d, 0x10},
+	{0x5100, 0x30},
+	{0x5101, 0x02},
+	{0x5102, 0x01},
+	{0x5103, 0x01},
+	{0x5104, 0x02},
+	{0x5105, 0x01},
+	{0x5106, 0x01},
+	{0x5107, 0x00},
+	{0x5108, 0x00},
+	{0x5109, 0x00},
+	{0x510f, 0xfc},
+	{0x5110, 0xf0},
+	{0x5111, 0x10},
+	{0x536d, 0x02},
+	{0x536e, 0x67},
+	{0x536f, 0x01},
+	{0x5370, 0x4c},
+	{0x5400, 0x00},
+	{0x5400, 0x00},
+	{0x5401, 0x61},
+	{0x5402, 0x00},
+	{0x5403, 0x00},
+	{0x5404, 0x00},
+	{0x5405, 0x40},
+	{0x540c, 0x05},
+	{0x5501, 0x00},
+	{0x5b00, 0x00},
+	{0x5b01, 0x00},
+	{0x5b02, 0x01},
+	{0x5b03, 0xff},
+	{0x5b04, 0x02},
+	{0x5b05, 0x6c},
+	{0x5b09, 0x02},
+	{0x5e00, 0x00},
+	{0x5e10, 0x1c},
+#endif
+#ifdef OV13850_8BIT
+	{0x0103, 0x01},
+	{0x0300, 0x01},
+	{0x0301, 0x00},
+	{0x0302, 0x28},
+	{0x0303, 0x00},
+	{0x030a, 0x00},
+	{0x300f, 0x10},
+	{0x3010, 0x01},
+	{0x3011, 0x76},
+	{0x3012, 0x41},
+	{0x3013, 0x12},
+	{0x3014, 0x11},
+	{0x301f, 0x03},
+	{0x3106, 0x00},
+	{0x3210, 0x47},
+	{0x3500, 0x00},
+	{0x3501, 0xc0},
+	{0x3502, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x350a, 0x00},
+	{0x350b, 0x80},
+	{0x350e, 0x00},
+	{0x350f, 0x10},
+	{0x351a, 0x00},
+	{0x351b, 0x10},
+	{0x351c, 0x00},
+	{0x351d, 0x20},
+	{0x351e, 0x00},
+	{0x351f, 0x40},
+	{0x3520, 0x00},
+	{0x3521, 0x80},
+	{0x3600, 0xc0},
+	{0x3601, 0xfc},
+	{0x3602, 0x02},
+	{0x3603, 0x78},
+	{0x3604, 0xb1},
+	{0x3605, 0x95},
+	{0x3606, 0x73},
+	{0x3607, 0x07},
+	{0x3609, 0x40},
+	{0x360a, 0x30},
+	{0x360b, 0x91},
+	{0x360C, 0x09},
+	{0x360f, 0x02},
+	{0x3611, 0x10},
+	{0x3612, 0x27},
+	{0x3613, 0x33},
+	{0x3615, 0x0c},
+	{0x3616, 0x0e},
+	{0x3641, 0x02},
+	{0x3660, 0x82},
+	{0x3668, 0x54},
+	{0x3669, 0x00},
+	{0x366a, 0x3f},
+	{0x3667, 0xa0},
+	{0x3702, 0x40},
+	{0x3703, 0x44},
+	{0x3704, 0x2c},
+	{0x3705, 0x01},
+	{0x3706, 0x15},
+	{0x3707, 0x44},
+	{0x3708, 0x3c},
+	{0x3709, 0x1f},
+	{0x370a, 0x27},
+	{0x370b, 0x3c},
+	{0x3720, 0x55},
+	{0x3722, 0x84},
+	{0x3728, 0x40},
+	{0x372a, 0x00},
+	{0x372b, 0x02},
+	{0x372e, 0x22},
+	{0x372f, 0xa0},
+	{0x3730, 0x00},
+	{0x3731, 0x00},
+	{0x3732, 0x00},
+	{0x3733, 0x00},
+	{0x3710, 0x28},
+	{0x3716, 0x03},
+	{0x3718, 0x1c},
+	{0x3719, 0x0c},
+	{0x371a, 0x08},
+	{0x371c, 0xfc},
+	{0x3748, 0x00},
+	{0x3760, 0x13},
+	{0x3761, 0x33},
+	{0x3762, 0x86},
+	{0x3763, 0x16},
+	{0x3767, 0x24},
+	{0x3768, 0x06},
+	{0x3769, 0x45},
+	{0x376c, 0x23},
+	{0x376f, 0x80},
+	{0x3773, 0x06},
+	{0x3d84, 0x00},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xbf},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x4b},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x11},
+	{0x380d, 0xa0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x01},
+	{0x3821, 0x06},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x08},
+	{0x3837, 0x02},
+	{0x4000, 0xf1},
+	{0x4001, 0x00},
+	{0x400b, 0x0c},
+	{0x4011, 0x00},
+	{0x401a, 0x00},
+	{0x401b, 0x00},
+	{0x401c, 0x00},
+	{0x401d, 0x00},
+	{0x4020, 0x00},
+	{0x4021, 0xe4},
+	{0x4022, 0x04},
+	{0x4023, 0xd7},
+	{0x4024, 0x05},
+	{0x4025, 0xbc},
+	{0x4026, 0x05},
+	{0x4027, 0xbf},
+	{0x4028, 0x00},
+	{0x4029, 0x02},
+	{0x402a, 0x04},
+	{0x402b, 0x08},
+	{0x402c, 0x02},
+	{0x402d, 0x02},
+	{0x402e, 0x0c},
+	{0x402f, 0x08},
+	{0x403d, 0x2c},
+	{0x403f, 0x7F},
+	{0x4041, 0x07},
+	{0x4500, 0x82},
+	{0x4501, 0x3c},
+	{0x458b, 0x00},
+	{0x459c, 0x00},
+	{0x459d, 0x00},
+	{0x459e, 0x00},
+	{0x4601, 0x83},
+	{0x4602, 0x22},
+	{0x4603, 0x01},
+	{0x4837, 0x19},
+	{0x4d00, 0x04},
+	{0x4d01, 0x42},
+	{0x4d02, 0xd1},
+	{0x4d03, 0x90},
+	{0x4d04, 0x66},
+	{0x4d05, 0x65},
+	{0x4d0b, 0x00},
+	{0x5000, 0x0e},
+	{0x5001, 0x01},
+	{0x5002, 0x07},
+	{0x5003, 0x4f},
+	{0x5013, 0x40},
+	{0x501c, 0x00},
+	{0x501d, 0x10},
+	{0x5100, 0x30},
+	{0x5101, 0x02},
+	{0x5102, 0x01},
+	{0x5103, 0x01},
+	{0x5104, 0x02},
+	{0x5105, 0x01},
+	{0x5106, 0x01},
+	{0x5107, 0x00},
+	{0x5108, 0x00},
+	{0x5109, 0x00},
+	{0x510f, 0xfc},
+	{0x5110, 0xf0},
+	{0x5111, 0x10},
+	{0x536d, 0x02},
+	{0x536e, 0x67},
+	{0x536f, 0x01},
+	{0x5370, 0x4c},
+	{0x5400, 0x00},
+	{0x5400, 0x00},
+	{0x5401, 0x61},
+	{0x5402, 0x00},
+	{0x5403, 0x00},
+	{0x5404, 0x00},
+	{0x5405, 0x40},
+	{0x540c, 0x05},
+	{0x5501, 0x00},
+	{0x5b00, 0x00},
+	{0x5b01, 0x00},
+	{0x5b02, 0x01},
+	{0x5b03, 0xff},
+	{0x5b04, 0x02},
+	{0x5b05, 0x6c},
+	{0x5b09, 0x02},
+	{0x5e10, 0x1c},
+#endif
+	{REG_NULL, 0x00},
+};
+
+/*Init settings for 13MP resolution*/
+static const struct regval ov13850_init_4224x3136_r2a[] = {
+#ifdef OV13850_10BIT
+	{0x0103, 0x01},
+	{0x0300, 0x00},
+	{0x0301, 0x00},
+	{0x0302, 0x32},
+	{0x0303, 0x01},
+	{0x030a, 0x00},
+	{0x300f, 0x11},
+	{0x3010, 0x01},
+	{0x3011, 0x76},
+	{0x3012, 0x41},
+	{0x3013, 0x12},
+	{0x3014, 0x11},
+	{0x301f, 0x03},
+	{0x3106, 0x00},
+	{0x3210, 0x47},
+	{0x3500, 0x00},
+	{0x3501, 0xc0},
+	{0x3502, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x350a, 0x00},
+	{0x350b, 0x80},
+	{0x350e, 0x00},
+	{0x350f, 0x10},
+	{0x3600, 0x40},
+	{0x3601, 0xfc},
+	{0x3602, 0x02},
+	{0x3603, 0x48},
+	{0x3604, 0xa5},
+	{0x3605, 0x9f},
+	{0x3607, 0x00},
+	{0x360a, 0x40},
+	{0x360b, 0x91},
+	{0x360c, 0x49},
+	{0x360f, 0x8a},
+	{0x3611, 0x10},
+	{0x3612, 0x27},
+	{0x3613, 0x33},
+	{0x3615, 0x08},
+	{0x3641, 0x02},
+	{0x3660, 0x82},
+	{0x3668, 0x54},
+	{0x3669, 0x00},
+	{0x3667, 0xa0},
+	{0x3702, 0x40},
+	{0x3703, 0x44},
+	{0x3704, 0x2c},
+	{0x3705, 0x24},
+	{0x3706, 0x50},
+	{0x3707, 0x44},
+	{0x3708, 0x3c},
+	{0x3709, 0x1f},
+	{0x370a, 0x24},
+	{0x370b, 0x3c},
+	{0x3720, 0x66},
+	{0x3722, 0x84},
+	{0x3728, 0x40},
+	{0x372a, 0x04},
+	{0x372e, 0x22},
+	{0x372f, 0xa0},
+	{0x3730, 0x00},
+	{0x3731, 0x00},
+	{0x3732, 0x00},
+	{0x3733, 0x00},
+	{0x3748, 0x00},
+	{0x3710, 0x28},
+	{0x3716, 0x03},
+	{0x3718, 0x10},
+	{0x3719, 0x08},
+	{0x371c, 0xfc},
+	{0x3760, 0x13},
+	{0x3761, 0x34},
+	{0x3762, 0x86},
+	{0x3763, 0x16},
+	{0x3767, 0x24},
+	{0x3768, 0x06},
+	{0x3769, 0x45},
+	{0x376c, 0x23},
+	{0x3d84, 0x00},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xbf},
+	{0x3800, 0x00},
+	{0x3801, 0x0C},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x93},
+	{0x3806, 0x0c},
+	{0x3807, 0x4B},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x12},
+	{0x380d, 0xc0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x04},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x04},
+	{0x3837, 0x01},
+	{0x4000, 0xf1},
+	{0x4001, 0x00},
+	{0x400b, 0x0c},
+	{0x4011, 0x00},
+	{0x401a, 0x00},
+	{0x401b, 0x00},
+	{0x401c, 0x00},
+	{0x401d, 0x00},
+	{0x4020, 0x02},
+	{0x4021, 0x4C},
+	{0x4022, 0x0E},
+	{0x4023, 0x37},
+	{0x4024, 0x0F},
+	{0x4025, 0x1C},
+	{0x4026, 0x0F},
+	{0x4027, 0x1F},
+	{0x4028, 0x00},
+	{0x4029, 0x02},
+	{0x402a, 0x04},
+	{0x402b, 0x08},
+	{0x402c, 0x02},
+	{0x402d, 0x02},
+	{0x402e, 0x0c},
+	{0x402f, 0x08},
+	{0x403d, 0x2c},
+	{0x403f, 0x7f},
+	{0x4500, 0x82},
+	{0x4501, 0x38},
+	{0x4601, 0x04},
+	{0x4602, 0x22},
+	{0x4603, 0x00},
+	{0x4837, 0x1b},
+	{0x4d00, 0x04},
+	{0x4d01, 0x42},
+	{0x4d02, 0xd1},
+	{0x4d03, 0x90},
+	{0x4d04, 0x66},
+	{0x4d05, 0x65},
+	{0x5000, 0x0e},
+	{0x5001, 0x01},
+	{0x5002, 0x07},
+	{0x5013, 0x40},
+	{0x501c, 0x00},
+	{0x501d, 0x10},
+	{0x5242, 0x00},
+	{0x5243, 0xb8},
+	{0x5244, 0x00},
+	{0x5245, 0xf9},
+	{0x5246, 0x00},
+	{0x5247, 0xf6},
+	{0x5248, 0x00},
+	{0x5249, 0xa6},
+	{0x5300, 0xfc},
+	{0x5301, 0xdf},
+	{0x5302, 0x3f},
+	{0x5303, 0x08},
+	{0x5304, 0x0c},
+	{0x5305, 0x10},
+	{0x5306, 0x20},
+	{0x5307, 0x40},
+	{0x5308, 0x08},
+	{0x5309, 0x08},
+	{0x530a, 0x02},
+	{0x530b, 0x01},
+	{0x530c, 0x01},
+	{0x530d, 0x0c},
+	{0x530e, 0x02},
+	{0x530f, 0x01},
+	{0x5310, 0x01},
+	{0x5400, 0x00},
+	{0x5401, 0x71},
+	{0x5402, 0x00},
+	{0x5403, 0x00},
+	{0x5404, 0x00},
+	{0x5405, 0x80},
+	{0x540c, 0x05},
+	{0x5b00, 0x00},
+	{0x5b01, 0x00},
+	{0x5b02, 0x01},
+	{0x5b03, 0xff},
+	{0x5b04, 0x02},
+	{0x5b05, 0x6c},
+	{0x5b09, 0x02},
+	{0x5e00, 0x00},
+	{0x5e10, 0x1c},
+#endif
+#ifdef OV13850_8BIT
+	{0x0103, 0x01},
+	{0x0300, 0x00},
+	{0x0301, 0x00},
+	{0x0302, 0x32},
+	{0x0303, 0x01},
+	{0x030a, 0x00},
+	{0x300f, 0x10},
+	{0x3010, 0x01},
+	{0x3011, 0x76},
+	{0x3012, 0x41},
+	{0x3013, 0x12},
+	{0x3014, 0x11},
+	{0x301f, 0x03},
+	{0x3106, 0x00},
+	{0x3210, 0x47},
+	{0x3500, 0x00},
+	{0x3501, 0xc0},
+	{0x3502, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x350a, 0x00},
+	{0x350b, 0x80},
+	{0x350e, 0x00},
+	{0x350f, 0x10},
+	{0x351a, 0x00},
+	{0x351b, 0x10},
+	{0x351c, 0x00},
+	{0x351d, 0x20},
+	{0x351e, 0x00},
+	{0x351f, 0x40},
+	{0x3520, 0x00},
+	{0x3521, 0x80},
+	{0x3600, 0xc0},
+	{0x3601, 0xfc},
+	{0x3602, 0x02},
+	{0x3603, 0x78},
+	{0x3604, 0xb1},
+	{0x3605, 0x95},
+	{0x3606, 0x73},
+	{0x3607, 0x07},
+	{0x3609, 0x40},
+	{0x360a, 0x30},
+	{0x360b, 0x91},
+	{0x360C, 0x09},
+	{0x360f, 0x02},
+	{0x3611, 0x10},
+	{0x3612, 0x28},
+	{0x3613, 0x33},
+	{0x3614, 0x2a},
+	{0x3615, 0x0c},
+	{0x3616, 0x0e},
+	{0x3641, 0x02},
+	{0x3660, 0x82},
+	{0x3668, 0x54},
+	{0x3669, 0x00},
+	{0x366a, 0x3f},
+	{0x3667, 0xa0},
+	{0x3702, 0x40},
+	{0x3703, 0x44},
+	{0x3704, 0x2c},
+	{0x3705, 0x01},
+	{0x3706, 0x15},
+	{0x3707, 0x44},
+	{0x3708, 0x3c},
+	{0x3709, 0x1f},
+	{0x370a, 0x24},
+	{0x370b, 0x3c},
+	{0x3710, 0x28},
+	{0x3716, 0x03},
+	{0x3718, 0x10},
+	{0x3719, 0x0c},
+	{0x371a, 0x08},
+	{0x371b, 0x01},
+	{0x371c, 0xfc},
+	{0x3720, 0x55},
+	{0x3722, 0x84},
+	{0x3728, 0x40},
+	{0x372a, 0x05},
+	{0x372b, 0x02},
+	{0x372e, 0x22},
+	{0x372f, 0xa0},
+	{0x3730, 0x04},
+	{0x3731, 0xb8},
+	{0x3732, 0x04},
+	{0x3733, 0xcc},
+	{0x3738, 0x04},
+	{0x3739, 0xce},
+	{0x373a, 0x04},
+	{0x373b, 0xd0},
+	{0x3740, 0x01},
+	{0x3741, 0xd0},
+	{0x3742, 0x00},
+	{0x3743, 0x01},
+	{0x3748, 0x21},
+	{0x3749, 0x22},
+	{0x374a, 0x28},
+	{0x3760, 0x13},
+	{0x3761, 0x33},
+	{0x3762, 0x86},
+	{0x3763, 0x16},
+	{0x3767, 0x24},
+	{0x3768, 0x06},
+	{0x3769, 0x45},
+	{0x376c, 0x23},
+	{0x376f, 0x80},
+	{0x3773, 0x06},
+	{0x3780, 0x90},
+	{0x3781, 0x00},
+	{0x3782, 0x01},
+	{0x3d84, 0x00},
+	{0x3d85, 0x17},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xbf},
+	{0x3800, 0x00},
+	{0x3801, 0x0C},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x93},
+	{0x3806, 0x0c},
+	{0x3807, 0x4B},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x11},
+	{0x380d, 0xa0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x04},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x04},
+	{0x3837, 0x01},
+	{0x4000, 0xf1},
+	{0x4001, 0x00},
+	{0x400b, 0x0c},
+	{0x4011, 0x00},
+	{0x401a, 0x00},
+	{0x401b, 0x00},
+	{0x401c, 0x00},
+	{0x401d, 0x00},
+	{0x4020, 0x03},
+	{0x4021, 0x6C},
+	{0x4022, 0x0D},
+	{0x4023, 0x17},
+	{0x4024, 0x0D},
+	{0x4025, 0xFC},
+	{0x4026, 0x0D},
+	{0x4027, 0xFF},
+	{0x4028, 0x00},
+	{0x4029, 0x02},
+	{0x402a, 0x04},
+	{0x402b, 0x08},
+	{0x402c, 0x02},
+	{0x402d, 0x02},
+	{0x402e, 0x0c},
+	{0x402f, 0x08},
+	{0x403d, 0x2c},
+	{0x403f, 0x7F},
+	{0x4041, 0x07},
+	{0x4500, 0x82},
+	{0x4501, 0x38},
+	{0x458b, 0x00},
+	{0x459c, 0x00},
+	{0x459d, 0x00},
+	{0x459e, 0x00},
+	{0x4601, 0x04},
+	{0x4602, 0x22},
+	{0x4603, 0x00},
+	{0x4837, 0x1b},
+	{0x4d00, 0x04},
+	{0x4d01, 0x42},
+	{0x4d02, 0xd1},
+	{0x4d03, 0x90},
+	{0x4d04, 0x66},
+	{0x4d05, 0x65},
+	{0x4d0b, 0x00},
+	{0x5000, 0x0e},
+	{0x5001, 0x01},
+	{0x5002, 0x07},
+	{0x5003, 0x4f},
+	{0x5013, 0x40},
+	{0x501c, 0x00},
+	{0x501d, 0x10},
+	{0x5100, 0x30},
+	{0x5101, 0x02},
+	{0x5102, 0x01},
+	{0x5103, 0x01},
+	{0x5104, 0x02},
+	{0x5105, 0x01},
+	{0x5106, 0x01},
+	{0x5107, 0x00},
+	{0x5108, 0x00},
+	{0x5109, 0x00},
+	{0x510f, 0xfc},
+	{0x5110, 0xf0},
+	{0x5111, 0x10},
+	{0x536d, 0x02},
+	{0x536e, 0x67},
+	{0x536f, 0x01},
+	{0x5370, 0x4c},
+	{0x5400, 0x00},
+	{0x5400, 0x00},
+	{0x5401, 0x71},
+	{0x5402, 0x00},
+	{0x5403, 0x00},
+	{0x5404, 0x00},
+	{0x5405, 0x80},
+	{0x540c, 0x05},
+	{0x5501, 0x00},
+	{0x5b00, 0x00},
+	{0x5b01, 0x00},
+	{0x5b02, 0x01},
+	{0x5b03, 0xff},
+	{0x5b04, 0x02},
+	{0x5b05, 0x6c},
+	{0x5b09, 0x02},
+	{0x5e00, 0x00},
+	{0x5e10, 0x1c},
+#endif
+	{REG_NULL, 0x00},
+};
+
+static const struct regval ov13850_2112x1568_regs[] = {
+#ifdef OV13850_10BIT
+	{0x3800, 0x00},
+	{0x3801, 0x08},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x97},
+	{0x3806, 0x0c},
+	{0x3807, 0x4b},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x09},
+	{0x380d, 0x60},
+	{0x380e, 0x06},
+	{0x380f, 0x80},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x02},
+	{0x3821, 0x06},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x08},
+	{0x3837, 0x02},
+	{REG_NULL, 0x00},
+#endif
+#ifdef OV13850_8BIT
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x4b},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x11},
+	{0x380d, 0xa0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x01},
+	{0x3821, 0x06},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x08},
+	{0x3837, 0x02},
+#endif
+	{REG_NULL, 0x00},
+};
+
+static const struct regval ov13850_4224x3136_regs[] = {
+#ifdef OV13850_10BIT
+	{0x3800, 0x00},
+	{0x3801, 0x0C},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x93},
+	{0x3806, 0x0c},
+	{0x3807, 0x4B},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x12},
+	{0x380d, 0xc0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x04},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x04},
+	{0x3837, 0x01},
+#endif
+#ifdef OV13850_8BIT
+	{0x3800, 0x00},
+	{0x3801, 0x0C},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x10},
+	{0x3805, 0x93},
+	{0x3806, 0x0c},
+	{0x3807, 0x4B},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x11},
+	{0x380d, 0xa0},
+	{0x380e, 0x0d},
+	{0x380f, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x04},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x04},
+	{0x3823, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x02},
+	{0x3834, 0x00},
+	{0x3835, 0x1c},
+	{0x3836, 0x04},
+	{0x3837, 0x01},
+#endif
+	{REG_NULL, 0x00},
+};
+
+static const struct ov13850_mode supported_modes[] = {
+	{
+		.width = 2112,
+		.height = 1568,
+		.reg_list = ov13850_2112x1568_regs,
+	},{
+		.width = 4224,
+		.height = 3136,
+		.reg_list = ov13850_4224x3136_regs,
+	},
+};
+
+#ifdef OV13850_SYS_DEBUG
+
+#define MAXENTRIES 20
+
+struct kobject *kobj_ref;
+static u32 ov13850_revid;
+int sysregaddr = 0, sysregvalue = 0, countreg=0;
+struct regval dumpvalues[MAXENTRIES+2];
+
+static ssize_t  sysfs_reg_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf);
+static ssize_t  sysfs_reg_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count);
+static ssize_t  sysfs_regvalue_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf);
+static ssize_t  sysfs_regvalue_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count);
+
+struct kobj_attribute ov13850_reg_write = __ATTR(sysregaddr, 0660, sysfs_reg_show, sysfs_reg_store);
+struct kobj_attribute ov13850_regvalue_write = __ATTR(sysregvalue, 0660, sysfs_regvalue_show, sysfs_regvalue_store);
+
+static ssize_t sysfs_regvalue_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	pr_info("ov13850 sysfs read\n");
+	return sprintf(buf, "%x", sysregvalue);
+}
+
+static ssize_t sysfs_regvalue_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count)
+{
+	int i=0, flag = 1;
+
+	pr_info("ov13850 sysfs write\n");
+	sscanf(buf,"%x",&sysregvalue);
+
+	if(countreg < MAXENTRIES) {
+		dumpvalues[countreg].addr = sysregaddr;
+		dumpvalues[countreg].val = sysregvalue;
+		counttd++;
+	}
+
+	return count;
+}
+
+
+static ssize_t sysfs_reg_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	pr_info("Sysfs - Read!!!\n");
+	return sprintf(buf, "%x", sysregaddr);
+}
+
+static ssize_t sysfs_reg_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count)
+{
+	pr_info("Sysfs - reg Write!!!\n");
+	sscanf(buf,"%x",&sysregaddr);
+	return count;
+}
+
+#endif
+
+/* Write registers up to 4 at a time */
+static int ov13850_write_reg(struct i2c_client *client, u16 reg,
+			     u32 len, u32 val)
+{
+	u32 buf_i, val_i;
+	u8 buf[6];
+	u8 *val_p;
+	__be32 val_be;
+
+	if (len > 4)
+		return -EINVAL;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	val_be = cpu_to_be32(val);
+	val_p = (u8 *)&val_be;
+	buf_i = 2;
+	val_i = 4 - len;
+
+	while (val_i < 4)
+		buf[buf_i++] = val_p[val_i++];
+
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+static int ov13850_write_array(struct i2c_client *client,
+			       const struct regval *regs)
+{
+	u32 i;
+	int ret = 0;
+
+	for (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)
+		ret = ov13850_write_reg(client, regs[i].addr,
+					OV13850_REG_VALUE_08BIT,
+					regs[i].val);
+
+	return ret;
+}
+
+/* Read registers up to 4 at a time */
+static int ov13850_read_reg(struct i2c_client *client, u16 reg,
+			    unsigned int len, u32 *val)
+{
+	struct i2c_msg msgs[2];
+	u8 *data_be_p;
+	__be32 data_be = 0;
+	__be16 reg_addr_be = cpu_to_be16(reg);
+	int ret;
+
+	if (len > 4 || !len)
+		return -EINVAL;
+
+	data_be_p = (u8 *)&data_be;
+	/* Write register address */
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = 2;
+	msgs[0].buf = (u8 *)&reg_addr_be;
+
+	/* Read data from register */
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_be_p[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = be32_to_cpu(data_be);
+
+	return 0;
+}
+
+static struct ov13850 *to_ov13850(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov13850, subdev);
+}
+
+/*@ov13850_enable_test_pattern - This enables the test pattern
+   Valid values for pattern are 1 - 4
+ Return value - 0 on success, negative on failure*/
+static int ov13850_enable_test_pattern(struct i2c_client *client, u32 pattern)
+{
+	u32 val;
+	val = (pattern - 1) | 0x80;
+
+	return ov13850_write_reg(client,
+				 OV13850_REG_TEST_PATTERN,
+				 OV13850_REG_VALUE_08BIT,
+				 val);
+}
+
+/*@ov13850_start_stream - writing mode register settings
+ and streaming register
+ Return value - 0 on success, negative on failure*/
+
+static int ov13850_start_stream(struct i2c_client *client)
+{
+	int ret = 0;
+	struct ov13850 *sensor = to_ov13850(client);
+	const struct regval *reg_list = supported_modes[sensor->mode].reg_list;
+
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	if(sensor->streaming)
+	{
+		pr_debug("OV13850: Already streaming \n");
+		return ret;
+	}
+
+	ret = ov13850_write_array(client, reg_list);
+	if (ret)
+		return ret;
+	ret = ov13850_write_reg(client,
+				 OV13850_REG_CTRL_MODE,
+				 OV13850_REG_VALUE_08BIT,
+				 OV13850_MODE_STREAMING);
+	if(!ret)
+	{
+		pr_debug("%s: streaming started \n", __func__);
+		sensor->streaming = 1;
+		msleep(100);
+	}
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	return ret;
+}
+
+static int ov13850_stop_stream(struct i2c_client *client)
+{
+	struct ov13850 *sensor = to_ov13850(client);
+	int ret = 0;
+
+	if(!sensor->streaming) {
+		return ret;
+	}
+
+	ret = ov13850_write_reg(client,
+				 OV13850_REG_CTRL_MODE,
+				 OV13850_REG_VALUE_08BIT,
+				 OV13850_MODE_SW_STANDBY);
+	if(!ret)
+	{
+		pr_debug("%s: streaming stopped \n", __func__);
+		sensor->streaming = 0;
+	}
+	return ret;
+
+}
+
+/* Calculate the delay in us by clock rate and clock cycles */
+static inline u32 ov13850_cal_delay(u32 cycles)
+{
+        return DIV_ROUND_UP(cycles, OV13850_XVCLK_FREQ / 1000 / 1000);
+}
+
+/*@ov13850_power_on - Control reset and power down lines */
+static void ov13850_power_on(int rst_gpio, int pwn_gpio)
+{
+	u32 delay_us;
+
+	gpio_set_value(pwn_gpio, 0);
+	usleep_range(3000, 5000);
+
+	gpio_set_value(rst_gpio, 0);
+	usleep_range(3000, 5000);
+
+	gpio_set_value(pwn_gpio, 1);
+	usleep_range(3000, 5000);
+
+	gpio_set_value(rst_gpio, 1);
+	usleep_range(3000, 5000);
+
+	/* 8192 cycles prior to first SCCB transaction */
+        delay_us = ov13850_cal_delay(8192);
+        usleep_range(delay_us, delay_us * 2);
+
+}
+
+static void ov13850_power_off(int rst_gpio, int pwn_gpio)
+{
+	msleep(10);
+	gpio_set_value(rst_gpio, 0);
+	usleep_range(3000, 5000);
+	gpio_set_value(pwn_gpio, 0);
+	usleep_range(3000, 5000);
+}
+
+static int ov13850_check_sensor_id(struct i2c_client *client)
+{
+	u32 id = 0;
+	int ret;
+
+	ret = ov13850_read_reg(client, OV13850_REG_CHIP_ID,
+			       OV13850_REG_VALUE_16BIT, &id);
+	printk(KERN_ALERT "OV13850, register 0x300A: %d\n", id);
+	if (id != CHIP_ID) {
+		pr_err("Unexpected sensor id(%06x), ret(%d)\n", id, ret);
+		return -ENODEV;
+	}
+
+	ret = ov13850_read_reg(client, OV13850_CHIP_REVISION_REG,
+			       OV13850_REG_VALUE_08BIT, &id);
+	if (ret) {
+		pr_err("Read chip revision register error\n");
+		return ret;
+	}
+
+	/*We check revision above, but current driver only write settings
+	 for revision 0xb2 chips*/
+	ov13850_global_regs = ov13850_init_2112x1568_r2a;
+	ov13850_revid = id;
+	pr_info("Detected OV13850: %06x sensor, REVISION 0x%x\n", CHIP_ID, id);
+
+	return 0;
+}
+
+
+
+static int ov13850_write_init_settings(struct i2c_client *client,
+					const struct regval *settings)
+{
+	int retval = 0;
+
+	retval = ov13850_write_array(client, settings);
+	if (retval) {
+		pr_err("OV13850 global settings failed !\n");
+		return retval;
+	}
+	msleep(5);
+	return retval;
+}
+
+static int ov13850_enum_framesizes(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index > 2)
+                return -EINVAL;
+	fse->max_width = supported_modes[fse->index].width;
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_height = supported_modes[fse->index].height;
+	fse->min_height = supported_modes[fse->index].height;
+	return 0;
+}
+
+static int ov13850_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13850 *sensor = to_ov13850(client);
+
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	memset(mf, 0, sizeof(struct v4l2_mbus_framefmt));
+
+	mf->code = ov13850_colour_fmts[0].code;
+	mf->colorspace = ov13850_colour_fmts[0].colorspace;
+	mf->width = sensor->pix.width;
+	mf->height = sensor->pix.height;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov13850_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13850 *sensor = to_ov13850(client);
+
+	pr_debug("%s: %d\n", __func__, on);
+	if (on) {
+		clk_prepare_enable(sensor->sensor_clk);
+		ov13850_power_on(sensor->rst_gpio, sensor->pwn_gpio);
+	} else if (!on) {
+		clk_disable_unprepare(sensor->sensor_clk);
+		ov13850_power_off(sensor->rst_gpio, sensor->pwn_gpio);
+	}
+
+	return 0;
+}
+
+
+static int ov13850_enum_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index >= ARRAY_SIZE(ov13850_colour_fmts))
+		return -EINVAL;
+
+	code->code = ov13850_colour_fmts[code->index].code;
+	return 0;
+}
+
+static int ov13850_enum_frameintervals(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_interval_enum *fival)
+{
+	if(fival->index > 2)
+		return -EINVAL;
+	fival->interval.numerator = 1;
+	fival->interval.denominator = DEFAULT_FPS;
+
+	return 0;
+}
+
+
+static int ov13850_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13850 *sensor = to_ov13850(client);
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+	int ret = 0;
+
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	switch (a->type) {
+	/*Need to verify below settings further*/
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+		pr_debug("%s: %d\n", __func__, __LINE__);
+		memset(a, 0, sizeof(*a));
+		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cparm->capability = sensor->streamcap.capability;
+		cparm->timeperframe = sensor->streamcap.timeperframe;
+		cparm->capturemode = sensor->streamcap.capturemode;
+		ret = 0;
+		break;
+	/*These cases not applicable now*/
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int ov13850_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13850 *sensor = to_ov13850(client);
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+
+	switch (a->type) {
+	/* This is the only case currently handled. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	/*Need to set fps as per request */
+		pr_debug("%s: %d\n", __func__, __LINE__);
+		sensor->streamcap.timeperframe = *timeperframe;
+		sensor->streamcap.capturemode =
+				(u32)a->parm.capture.capturemode;
+		break;
+	/* These cases not applicable for now*/
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		pr_debug("   type is not " \
+			"V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
+			a->type);
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+
+static int ov13850_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13850 *sensor = to_ov13850(client);
+	int retval;
+
+	pr_info("s_stream: %d\n", enable);
+	if (enable) {
+	/*if valid pattern value then enable test pattern, else go for
+	 * normal streaming. Change ENABLE_TEST_PATTERN with value 1
+	 * to 4 to enable test pattern */
+		if(ENABLE_TEST_PATTERN > 0 && ENABLE_TEST_PATTERN <= 4)
+			ov13850_enable_test_pattern(client,
+						ENABLE_TEST_PATTERN);
+		retval = ov13850_start_stream(client);
+		if (retval) {
+			pr_err("OV13850 start stream failed !\n");
+			return retval;
+		}
+
+		retval = ov13850_write_reg(client, OV13850_VCHANNEL,
+					OV13850_REG_VALUE_08BIT, sensor->csi_vc);
+		if(retval) {
+			pr_err("%s: set virtual channel failed\n", __func__);
+			return retval;
+		}
+	}
+	else {
+		retval = ov13850_stop_stream(client);
+		if (retval) {
+			pr_err("OV13850 stop stream failed !\n");
+			return retval;
+		}
+	}
+
+	return 0;
+}
+
+static int ov13850_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	int retval = 0, ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13850 *sensor = to_ov13850(client);
+	
+	if(format->format.width == OV13850_RES_HIGH_WIDTH &&
+		format->format.height == OV13850_RES_HIGH_HEIGHT)
+	{
+		sensor->mode = 1;
+		ov13850_global_regs = ov13850_init_4224x3136_r2a;
+		sensor->pix.width = OV13850_RES_HIGH_WIDTH;
+		sensor->pix.height = OV13850_RES_HIGH_HEIGHT;
+	}
+	else if(format->format.width == OV13850_RES_LOW_WIDTH &&
+		format->format.height == OV13850_RES_LOW_HEIGHT)
+	{
+		sensor->mode = 0;
+		ov13850_global_regs = ov13850_init_2112x1568_r2a;
+		sensor->pix.width = OV13850_RES_LOW_WIDTH;
+		sensor->pix.height = OV13850_RES_LOW_HEIGHT;
+	}
+	else
+	{
+		printk(KERN_INFO "OV13850: Unsupported resolution passed\n");
+		return -1;
+	}
+
+	retval = ov13850_write_init_settings(client, ov13850_global_regs);
+
+#ifdef OV13850_SYS_DEBUG
+	printk(KERN_INFO "OV13850 sysfs reg dump\n");
+	dumpvalues[countreg].addr = REG_NULL;
+	dumpvalues[countreg].val = 0;
+
+	printk(KERN_INFO "countreg size: 0x%x\n", countreg);
+	for(int i=0; dumpvalues[i].addr != REG_NULL; i++)
+	{
+		printk(KERN_INFO "addr: 0x%x, val: 0x%x\n", dumpvalues[i].addr,
+				dumpvalues[i].val);
+	}
+
+	ret = ov13850_write_array(client, dumpvalues);
+        if(ret)
+        {
+		printk(KERN_INFO "failed to write sysfs reg\n");
+        }
+#endif
+
+	return retval;
+}
+
+
+static int ov13850_link_setup(struct media_entity *entity,
+                           const struct media_pad *local,
+                           const struct media_pad *remote, u32 flags)
+{
+        return 0;
+}
+
+static struct v4l2_subdev_video_ops ov13850_subdev_video_ops = {
+	.g_parm = ov13850_g_parm,
+	.s_parm = ov13850_s_parm,
+	.s_stream = ov13850_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov13850_subdev_pad_ops = {
+	.enum_frame_size       = ov13850_enum_framesizes,
+	.enum_frame_interval   = ov13850_enum_frameintervals,
+	.enum_mbus_code        = ov13850_enum_code,
+	.set_fmt               = ov13850_set_fmt,
+	.get_fmt               = ov13850_get_fmt,
+};
+
+static struct v4l2_subdev_core_ops ov13850_subdev_core_ops = {
+	.s_power	= ov13850_s_power,
+};
+
+static struct v4l2_subdev_ops ov13850_subdev_ops = {
+	.core	= &ov13850_subdev_core_ops,
+	.video	= &ov13850_subdev_video_ops,
+	.pad	= &ov13850_subdev_pad_ops,
+};
+
+static const struct media_entity_operations ov13850_sd_media_ops = {
+	.link_setup = ov13850_link_setup,
+};
+
+static int ov13850_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct pinctrl *pinctrl;
+	struct device *dev = &client->dev;
+	struct v4l2_subdev *sd;
+	int ret, rst_gpio, pwn_gpio;
+	struct ov13850 *sensor;
+
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+
+	pr_info("OV13850: ov13850_probe called\n");
+
+	pinctrl = devm_pinctrl_get_select_default(dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(dev, "No pin available\n");
+
+	sensor->mode = 0;
+	sensor->streaming = 0;
+
+	rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+	if (!gpio_is_valid(rst_gpio)) {
+		dev_err(dev, "no sensor reset pin available");
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request_one(dev, rst_gpio, GPIOF_OUT_INIT_LOW,
+					"ov13850_reset");
+	if (ret < 0) {
+		dev_err(dev, "failed to acquire sensor reset pin");
+		return ret;
+	}
+	sensor->rst_gpio = rst_gpio;
+
+	pwn_gpio = of_get_named_gpio(dev->of_node, "pwn-gpios", 0);
+	if (!gpio_is_valid(pwn_gpio)) {
+		dev_err(dev, "no sensor reset pin available");
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request_one(dev, pwn_gpio, GPIOF_OUT_INIT_LOW,
+					"ov13850_pwdn");
+	if (ret < 0) {
+		dev_err(dev, "failed to acquire sensor reset pin");
+		return ret;
+	}
+	sensor->pwn_gpio = pwn_gpio;
+
+	sensor->sensor_clk = devm_clk_get(dev, "csi_mclk");
+	if (IS_ERR(sensor->sensor_clk)) {
+                sensor->sensor_clk = NULL;
+                dev_err(dev, "clock-frequency missing or invalid\n");
+                return PTR_ERR(sensor->sensor_clk);
+        }
+
+	ret = of_property_read_u32(dev->of_node, "mclk",
+					&(sensor->mclk));
+	if (ret) {
+		dev_err(dev, "mclk missing or invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mclk_source",
+					(u32 *) &(sensor->mclk_source));
+	if (ret) {
+		dev_err(dev, "mclk_source missing or invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "virtual_channel",
+					&(sensor->csi_vc));
+	if (ret) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(sensor->sensor_clk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable xvclk\n");
+		return ret;
+	}
+
+	sensor->i2c_client = client;
+	/*Only can handle 8bit mode for now*/
+#ifdef OV13850_8BIT
+	sensor->pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+#endif
+#ifdef OV13850_10BIT
+	sensor->pix.pixelformat = V4L2_PIX_FMT_SBGGR10;
+#endif
+	sensor->pix.width = OV13850_RES_LOW_WIDTH;
+        sensor->pix.height = OV13850_RES_LOW_HEIGHT;
+	sensor->streamcap.capability = V4L2_MODE_HIGHQUALITY |
+                                           V4L2_CAP_TIMEPERFRAME;
+        sensor->streamcap.capturemode = 0;
+        sensor->streamcap.timeperframe.denominator = DEFAULT_FPS;
+        sensor->streamcap.timeperframe.numerator = 1;
+
+	ov13850_power_on(sensor->rst_gpio, sensor->pwn_gpio);
+
+	ret = ov13850_check_sensor_id(client);
+	if (ret)
+	{
+		dev_err(dev, "ov13850 mipi not found\n");
+		clk_disable_unprepare(sensor->sensor_clk);
+		goto err_free_handler;
+	}
+
+	sd = &sensor->subdev;
+	v4l2_i2c_subdev_init(sd, client, &ov13850_subdev_ops);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sensor->pads[OV13850_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&sd->entity, OV13850_SENS_PADS_NUM,
+							sensor->pads);
+	sd->entity.ops = &ov13850_sd_media_ops;
+	if (ret < 0)
+		return ret;
+
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0) {
+		dev_err(&client->dev,
+				"%s--Async register failed, ret=%d\n", __func__, ret);
+		media_entity_cleanup(&sd->entity);
+	}
+
+        clk_disable_unprepare(sensor->sensor_clk);
+	ov13850_power_off(sensor->rst_gpio, sensor->pwn_gpio);
+
+#ifdef OV13850_SYS_DEBUG
+	kobj_ref = kobject_create_and_add("ov13850_debug", kernel_kobj);
+
+	/*Creating sysfs file for ov13850 register write*/
+	if(sysfs_create_file(kobj_ref, &ov13850_reg_write.attr)) {
+		pr_err("Cannot create sysfs file......\n");
+		kobject_put(kobj_ref);
+		sysfs_remove_file(kernel_kobj, &ov13850_reg_write.attr);
+	}
+
+	if(sysfs_create_file(kobj_ref, &ov13850_regvalue_write.attr)) {
+		pr_err("Cannot create sysfs file......\n");
+		kobject_put(kobj_ref);
+		sysfs_remove_file(kernel_kobj, &ov13850_regvalue_write.attr);
+	}
+	dumpvalues[countreg].addr = REG_NULL;
+	dumpvalues[countreg].val = 0;
+#endif
+
+	pr_info("OV13850: ov13850_probe successful\n");
+
+	return 0;
+
+err_free_handler:
+
+	return ret;
+}
+
+static int ov13850_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13850 *sensor = to_ov13850(client);
+
+	v4l2_async_unregister_subdev(sd);
+
+	clk_disable_unprepare(sensor->sensor_clk);
+
+	ov13850_power_off(sensor->rst_gpio, sensor->pwn_gpio);
+	v4l2_async_unregister_subdev(sd);
+
+	clk_disable_unprepare(sensor->sensor_clk);
+
+	return 0;
+}
+
+
+static const struct i2c_device_id ov13850_match_id[] = {
+        { "ov13850_mipi", 0 },
+        { },
+};
+
+static struct i2c_driver ov13850_i2c_driver = {
+        .driver = {
+                .name = OV13850_NAME,
+                //.of_match_table = of_match_ptr(ov13850_of_match),
+        },
+        .probe          = ov13850_probe,
+        .remove         = ov13850_remove,
+        .id_table       = ov13850_match_id,
+};
+
+module_i2c_driver(ov13850_i2c_driver);
+
+MODULE_DESCRIPTION("ov13850 sensor driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/staging/media/imx/imx8-isi-cap.c b/drivers/staging/media/imx/imx8-isi-cap.c
index 6ba5b3a86f49..577a8b1116eb 100644
--- a/drivers/staging/media/imx/imx8-isi-cap.c
+++ b/drivers/staging/media/imx/imx8-isi-cap.c
@@ -105,7 +105,25 @@ struct mxc_isi_fmt mxc_isi_out_formats[] = {
 		.memplanes	= 1,
 		.colplanes	= 1,
 		.mbus_code	= MEDIA_BUS_FMT_RGB888_1X24,
-	}
+	},
+	{
+		.name		= "BGGR10",
+		.fourcc		= V4L2_PIX_FMT_SBGGR10,
+		.depth		= { 16 },
+		.color		= MXC_ISI_OUT_FMT_RAW10,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code	= MEDIA_BUS_FMT_SBGGR10_1X10,
+	},
+	{
+		.name		= "BGGR8",
+		.fourcc		= V4L2_PIX_FMT_SBGGR8,
+		.depth		= { 8 },
+		.color		= MXC_ISI_OUT_FMT_RAW8,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code	= MEDIA_BUS_FMT_SBGGR8_1X8,
+	},
 };
 
 /*
@@ -124,7 +142,21 @@ struct mxc_isi_fmt mxc_isi_src_formats[] = {
 		.depth		= { 32 },
 		.memplanes	= 1,
 		.colplanes	= 1,
-	}
+	},
+	{
+		.name		= "BGGR10",
+		.fourcc		= V4L2_PIX_FMT_SBGGR10,
+		.depth		= { 16 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+	},
+	{
+		.name		= "BGGR8",
+		.fourcc		= V4L2_PIX_FMT_SBGGR8,
+		.depth		= { 8 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+	},
 };
 
 struct mxc_isi_fmt *mxc_isi_get_format(unsigned int index)
@@ -169,8 +201,11 @@ struct mxc_isi_fmt *mxc_isi_get_src_fmt(struct v4l2_subdev_format *sd_fmt)
 	    sd_fmt->format.code == MEDIA_BUS_FMT_UYVY8_2X8 ||
 	    sd_fmt->format.code == MEDIA_BUS_FMT_YUYV8_2X8)
 		index = 1;
-	else
-		index = 0;
+	else if(sd_fmt->format.code == MEDIA_BUS_FMT_SBGGR10_1X10)
+		index = 2;
+	else if(sd_fmt->format.code == MEDIA_BUS_FMT_SBGGR8_1X8)
+		index = 3;
+	else	index = 0;
 	return &mxc_isi_src_formats[index];
 }
 
@@ -188,7 +223,7 @@ static int mxc_isi_pipeline_enable(struct mxc_isi_cap_dev *isi_cap, bool enable)
 	struct media_entity *entity = &isi_cap->vdev.entity;
 	struct media_device *mdev = entity->graph_obj.mdev;
 	struct media_graph graph;
-	struct v4l2_subdev *subdev;
+	struct v4l2_subdev *subdev, *subdev_defer = NULL;
 	int ret = 0;
 
 	mutex_lock(&mdev->graph_mutex);
@@ -217,12 +252,24 @@ static int mxc_isi_pipeline_enable(struct mxc_isi_cap_dev *isi_cap, bool enable)
 			continue;
 		}
 
-		ret = v4l2_subdev_call(subdev, video, s_stream, enable);
+		if(strstr(subdev->entity.name, "ov13850") != NULL) {
+			subdev_defer = subdev;
+		} else {
+			ret = v4l2_subdev_call(subdev, video, s_stream, enable);
+			if (ret < 0 && ret != -ENOIOCTLCMD) {
+				dev_err(dev, "subdev %s s_stream failed\n", subdev->name);
+				break;
+			}
+		}
+	}
+
+	if(subdev_defer) {
+		ret = v4l2_subdev_call(subdev_defer, video, s_stream, enable);
 		if (ret < 0 && ret != -ENOIOCTLCMD) {
-			dev_err(dev, "subdev %s s_stream failed\n", subdev->name);
-			break;
+			dev_err(dev, "subdev %s s_stream failed\n", subdev_defer->name);
 		}
 	}
+
 	mutex_unlock(&mdev->graph_mutex);
 	media_graph_walk_cleanup(&graph);
 
diff --git a/drivers/staging/media/imx/imx8-isi-hw.c b/drivers/staging/media/imx/imx8-isi-hw.c
index f8e804483a48..123ee53680ad 100644
--- a/drivers/staging/media/imx/imx8-isi-hw.c
+++ b/drivers/staging/media/imx/imx8-isi-hw.c
@@ -679,6 +679,10 @@ void mxc_isi_channel_config(struct mxc_isi_dev *mxc_isi,
 	/*  Bypass channel */
 	if (!mxc_isi->cscen && !mxc_isi->scale)
 		val |= (CHNL_CTRL_CHNL_BYPASS_ENABLE << CHNL_CTRL_CHNL_BYPASS_OFFSET);
+	if ((mxc_isi->isi_cap->pix.pixelformat == V4L2_PIX_FMT_SBGGR10) ||
+		(mxc_isi->isi_cap->pix.pixelformat == V4L2_PIX_FMT_SBGGR8)) {
+		val |= (CHNL_CTRL_CHNL_BYPASS_ENABLE << CHNL_CTRL_CHNL_BYPASS_OFFSET);
+	}
 
 	writel(val, mxc_isi->regs + CHNL_CTRL);
 }
diff --git a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
index 4d4896779753..42806213ef2b 100644
--- a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
+++ b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
@@ -1072,6 +1072,7 @@ static int mipi_csis_set_fmt(struct v4l2_subdev *mipi_sd,
 
 	format->pad = source_pad->index;
 	mf->code = MEDIA_BUS_FMT_UYVY8_2X8;
+
 	ret = v4l2_subdev_call(sen_sd, pad, set_fmt, NULL, format);
 	if (ret < 0) {
 		v4l2_err(&state->sd, "%s, set sensor format fail\n", __func__);
@@ -1095,6 +1096,7 @@ static int mipi_csis_get_fmt(struct v4l2_subdev *mipi_sd,
 	struct v4l2_mbus_framefmt *mf = &state->format;
 	struct media_pad *source_pad;
 	struct v4l2_subdev *sen_sd;
+	struct csis_pix_format const *csis_fmt;
 	int ret;
 
 	/* Get remote source pad */
@@ -1119,6 +1121,14 @@ static int mipi_csis_get_fmt(struct v4l2_subdev *mipi_sd,
 	}
 
 	memcpy(mf, &format->format, sizeof(struct v4l2_mbus_framefmt));
+
+	csis_fmt = find_csis_format(mf->code);
+	if (!csis_fmt) {
+		csis_fmt = &mipi_csis_formats[0];
+		mf->code = csis_fmt->code;
+	}
+	state->csis_fmt = csis_fmt;
+
 	return 0;
 }
 
@@ -1225,6 +1235,9 @@ static int csis_s_fmt(struct v4l2_subdev *sd, struct csi_sam_format *fmt)
 	struct csi_state *state = container_of(sd, struct csi_state, sd);
 
 	switch (fmt->format) {
+	case V4L2_PIX_FMT_SBGGR8:
+	    code = MEDIA_BUS_FMT_SBGGR8_1X8;
+	    break;
 	case V4L2_PIX_FMT_SBGGR10:
 	    code = MEDIA_BUS_FMT_SBGGR10_1X10;
 	    break;
-- 
2.17.1

