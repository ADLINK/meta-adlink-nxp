From a7c42dd024bf20b595baea4299b6ce470b029d51 Mon Sep 17 00:00:00 2001
From: Dinesh V <dinesh.v@adlinktech.com>
Date: Mon, 4 Sep 2023 15:48:53 +0530
Subject: [PATCH 8/8]  Based on CONFIG_IF,update Ethernet PHY register via DT

---
 drivers/net/phy/davicom.c | 93 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 91 insertions(+), 2 deletions(-)

diff --git a/drivers/net/phy/davicom.c b/drivers/net/phy/davicom.c
index 4ac4bce1bf32..e4e195943b58 100644
--- a/drivers/net/phy/davicom.c
+++ b/drivers/net/phy/davicom.c
@@ -24,6 +24,7 @@
 #include <linux/mii.h>
 #include <linux/ethtool.h>
 #include <linux/phy.h>
+#include <linux/of.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -170,6 +171,83 @@ static int dm9161_config_init(struct phy_device *phydev)
 	return phy_write(phydev, MII_BMCR, BMCR_ANENABLE);
 }
 
+/* Stone add for DM9119 */
+static int dm9119phy_config_init(struct phy_device *phydev)
+{
+	int ret;
+	int err;
+#ifdef CONFIG_OF	
+	int num_data = 2,dataLen,num_regs,i,offset;
+	int phyAddr[20]={0},phyValue[20]={0};
+	struct mdio_device *mdio = &phydev->mdio;
+	struct device *dev = &mdio->dev;
+
+	if (!of_get_property(dev->of_node, "reg-values", &dataLen)){
+		printk("Can not found reg-values property............\n");
+	    return -1;
+	}
+	
+	num_regs = dataLen / (sizeof(u32) * num_data);
+
+	for (i = 0; i < num_regs; i++) {
+	    offset = i * num_data;
+	    if (of_property_read_u32_index(dev->of_node, "reg-values", offset, &phyAddr[i]))
+	        return -1;
+	    if (of_property_read_u32_index(dev->of_node, "reg-values", offset + 1, &phyValue[i]))
+	        return -1;
+		printk("DAVICOM Ethernet PHY Set Index: %d, Offset: 0x%x, Value: 0x%x\n",i,phyAddr[i],phyValue[i]);
+		err = phy_write(phydev, 0x1f, phyAddr[i]);
+		if (err < 0)
+			ret = err;
+		err = phy_write(phydev, 0x1e, phyValue[i]);
+		if (err < 0) 
+			ret = err;
+	}
+#else
+	printk("DM9119 TX/RX setup. \r\n");
+	/* Stone add for TX/RX enhance */
+	/* 1. Unlock Extended registers */
+	err = phy_write(phydev, 0x1f, 0x168);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1e, 0x8040);
+	if (err < 0) ret = err;
+	/* 2. TX amplitude increase */
+	err = phy_write(phydev, 0x1f, 0x488A);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1e, 0x8030);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1f, 0x4009);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1e, 0x8031);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1f, 0x240A);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1e, 0x8032);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1f, 0x2B);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1e, 0x8034);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1f, 0x2B);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1e, 0x8037);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1f, 0x2B);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1e, 0x803A);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1f, 0x2B);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1e, 0x803D);
+	if (err < 0) ret = err;
+	/* 3. RX TAPs increase */
+	err = phy_write(phydev, 0x1f, 0x06);
+	if (err < 0) ret = err;
+	err = phy_write(phydev, 0x1e, 0x8021);
+	if (err < 0) ret = err;
+#endif
+	return ret;
+}
 static struct phy_driver dm91xx_driver[] = {
 {
 	.phy_id		= 0x0181b880,
@@ -204,8 +282,18 @@ static struct phy_driver dm91xx_driver[] = {
 	.phy_id_mask	= 0x0ffffff0,
 	/* PHY_BASIC_FEATURES */
 	.config_intr	= dm9161_config_intr,
-	.handle_interrupt = dm9161_handle_interrupt,
-} };
+}, {
+	.phy_id         = 0x006e3212,
+	.name           = "Davicom DM9119",
+	.phy_id_mask    = 0x00ffffff,
+	.config_init    = dm9119phy_config_init,
+/*	.features       = PHY_GBIT_FEATURES | SUPPORTED_MII | SUPPORTED_AUI | SUPPORTED_FIBRE | SUPPORTED_BNC, */
+	.config_aneg    = genphy_config_aneg,
+	.aneg_done      = genphy_aneg_done,
+	.suspend        = genphy_suspend,
+	.resume         = genphy_resume,
+} /* Stone add for DM9119 */
+};
 
 module_phy_driver(dm91xx_driver);
 
@@ -214,6 +302,7 @@ static struct mdio_device_id __maybe_unused davicom_tbl[] = {
 	{ 0x0181b8b0, 0x0ffffff0 },
 	{ 0x0181b8a0, 0x0ffffff0 },
 	{ 0x00181b80, 0x0ffffff0 },
+	{ 0x006e3212, 0x00ffffff },  /* Stone add for DM9119 */
 	{ }
 };
 
-- 
2.25.1

