From 6b1049fdcc8af8abbd0bbe4c3f71fef96a04171c Mon Sep 17 00:00:00 2001
From: "deepak.s" <deepak.s@adlinktech.com>
Date: Thu, 21 Mar 2024 11:49:48 +0530
Subject: [PATCH] Added-TPM2.0-Support-and-ADLINK-Config-macro

---
 drivers/char/tpm/tpm-interface.c | 17 ++++++-
 drivers/char/tpm/tpm.h           | 24 +++++++++
 drivers/char/tpm/tpm_tis_core.c  | 87 +++++++++++++++++++++++++++-----
 drivers/char/tpm/tpm_tis_core.h  | 15 ++++++
 drivers/char/tpm/tpm_tis_i2c.c   |  1 +
 init/Kconfig                     |  6 +++
 6 files changed, 135 insertions(+), 15 deletions(-)

diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c
index 0f941cb32eb1..b0a51918fdd9 100644
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -65,6 +65,7 @@ static ssize_t tpm_try_transmit(struct tpm_chip *chip, void *buf, size_t bufsiz)
 	ssize_t len = 0;
 	u32 count, ordinal;
 	unsigned long stop;
+       unsigned int delay_msec = TPM_TIMEOUT_POLL;
 
 	if (bufsiz < TPM_HEADER_SIZE)
 		return -EINVAL;
@@ -115,6 +116,11 @@ static ssize_t tpm_try_transmit(struct tpm_chip *chip, void *buf, size_t bufsiz)
 		}
 
 		tpm_msleep(TPM_TIMEOUT_POLL);
+               //change ST@2020.10.29
+               //tpm_msleep(TPM_TIMEOUT_POLL);
+               tpm_msleep(delay_msec);
+               delay_msec = delay_msec+delay_msec;
+
 		rmb();
 	} while (time_before(jiffies, stop));
 
@@ -157,6 +163,7 @@ ssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)
 	u8 save[TPM_HEADER_SIZE + 3*sizeof(u32)];
 	unsigned int delay_msec = TPM2_DURATION_SHORT;
 	u32 rc = 0;
+	u32 i = TPM_RETRY;
 	ssize_t ret;
 	const size_t save_size = min(sizeof(save), bufsiz);
 	/* the command code is where the return code will be */
@@ -172,7 +179,14 @@ ssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)
 	for (;;) {
 		ret = tpm_try_transmit(chip, buf, bufsiz);
 		if (ret < 0)
-			break;
+               {
+                       i--;
+                       if (i<=0)
+                               break;
+               }
+               else
+               {
+
 		rc = be32_to_cpu(header->return_code);
 		if (rc != TPM2_RC_RETRY && rc != TPM2_RC_TESTING)
 			break;
@@ -194,6 +208,7 @@ ssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)
 		tpm_msleep(delay_msec);
 		delay_msec *= 2;
 		memcpy(buf, save, save_size);
+	       }
 	}
 	return ret;
 }
diff --git a/drivers/char/tpm/tpm.h b/drivers/char/tpm/tpm.h
index f6c99b3f0045..bbf652f6a0df 100644
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@ -37,9 +37,16 @@
 #define TPM_RETRY		50
 
 enum tpm_timeout {
+#ifdef CONFIG_TCG_TIS_I2C
+       TPM_TIMEOUT = 1,        /* msecs */
+       TPM_TIMEOUT_RETRY = 2, /* msecs */
+       TPM_TIMEOUT_RANGE_US = 20,      /* usecs */
+#else
+
 	TPM_TIMEOUT = 5,	/* msecs */
 	TPM_TIMEOUT_RETRY = 100, /* msecs */
 	TPM_TIMEOUT_RANGE_US = 300,	/* usecs */
+#endif
 	TPM_TIMEOUT_POLL = 1,	/* msecs */
 	TPM_TIMEOUT_USECS_MIN = 100,      /* usecs */
 	TPM_TIMEOUT_USECS_MAX = 500      /* usecs */
@@ -57,6 +64,17 @@ enum tpm_addr {
 #define TPM_ERR_DISABLED        0x7
 #define TPM_ERR_FAILEDSELFTEST  0x1C
 #define TPM_ERR_INVALID_POSTINIT 38
+#define TPM_HEADER_SIZE                10
+
+/* Indicates from what layer of the software stack the error comes from */
+#define TSS2_RC_LAYER_SHIFT     16
+#define TSS2_RESMGR_TPM_RC_LAYER (11 << TSS2_RC_LAYER_SHIFT)
+
+#define TPM_VID_INTEL    0x8086
+#define TPM_VID_WINBOND  0x1050
+#define TPM_VID_STM      0x104A
+
+#define to_tpm_chip(d) container_of(d, struct tpm_chip, dev)
 
 #define TPM_TAG_RQU_COMMAND 193
 
@@ -259,8 +277,14 @@ int tpm_pm_resume(struct device *dev);
 
 static inline void tpm_msleep(unsigned int delay_msec)
 {
+#ifdef CONFIG_TCG_TIS_I2C
+       usleep_range(delay_msec * 1000,
+                       (delay_msec * 1000) + TPM_TIMEOUT_RANGE_US);
+#else
+
 	usleep_range((delay_msec * 1000) - TPM_TIMEOUT_RANGE_US,
 		     delay_msec * 1000);
+#endif
 };
 
 int tpm_chip_bootstrap(struct tpm_chip *chip);
diff --git a/drivers/char/tpm/tpm_tis_core.c b/drivers/char/tpm/tpm_tis_core.c
index 5889d9edaf94..df807ce2e807 100644
--- a/drivers/char/tpm/tpm_tis_core.c
+++ b/drivers/char/tpm/tpm_tis_core.c
@@ -213,7 +213,12 @@ static int __tpm_tis_request_locality(struct tpm_chip *chip, int l)
 		do {
 			if (check_locality(chip, l))
 				return l;
+#ifdef CONFIG_TCG_TIS_I2C
+                       tpm_msleep_opt(TPM_TIMEOUT);
+#else
+
 			tpm_msleep(TPM_TIMEOUT);
+#endif
 		} while (time_before(jiffies, stop));
 	}
 	return -1;
@@ -267,6 +272,13 @@ static u8 tpm_tis_status(struct tpm_chip *chip)
 
 	return status;
 }
+static bool tpm_tis_check_data(struct tpm_chip *chip, char *buf,size_t len) {
+       struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+
+       if (priv->phy_ops->check_data)
+               return priv->phy_ops->check_data(priv, buf, len);
+       return true;
+}
 
 static void tpm_tis_ready(struct tpm_chip *chip)
 {
@@ -275,7 +287,7 @@ static void tpm_tis_ready(struct tpm_chip *chip)
 	/* this causes the current command to be aborted */
 	tpm_tis_write8(priv, TPM_STS(priv->locality), TPM_STS_COMMAND_READY);
 }
-
+#ifndef CONFIG_TCG_TIS_I2C
 static int get_burstcount(struct tpm_chip *chip)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
@@ -300,13 +312,21 @@ static int get_burstcount(struct tpm_chip *chip)
 	} while (time_before(jiffies, stop));
 	return -EBUSY;
 }
-
+#endif
 static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	int size = 0, burstcnt, rc;
 
 	while (size < count) {
+#ifdef CONFIG_TCG_TIS_I2C
+               if (priv->interface_id) {
+                       burstcnt = 1280;
+               } else {
+                       burstcnt = 32;
+               }
+#else
+
 		rc = wait_for_tpm_stat(chip,
 				 TPM_STS_DATA_AVAIL | TPM_STS_VALID,
 				 chip->timeout_c,
@@ -318,6 +338,7 @@ static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)
 			dev_err(&chip->dev, "Unable to read burstcount\n");
 			return burstcnt;
 		}
+#endif
 		burstcnt = min_t(int, burstcnt, count - size);
 
 		rc = tpm_tis_read_bytes(priv, TPM_DATA_FIFO(priv->locality),
@@ -403,7 +424,8 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	int rc, status, burstcnt;
 	size_t count = 0;
-	bool itpm = test_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags);
+//	bool itpm = test_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags);
+	bool itpm = priv->flags & TPM_TIS_ITPM_WORKAROUND;
 
 	status = tpm_tis_status(chip);
 	if ((status & TPM_STS_COMMAND_READY) == 0) {
@@ -415,6 +437,16 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 			goto out_err;
 		}
 	}
+#ifdef CONFIG_TCG_TIS_I2C
+       while (count < len) {
+               if (priv->interface_id) {
+                       burstcnt = 1280;
+               } else {
+                       burstcnt = 32;
+               }
+
+               burstcnt = min_t(int, burstcnt, len - count);
+#else
 
 	while (count < len - 1) {
 		burstcnt = get_burstcount(chip);
@@ -424,13 +456,14 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 			goto out_err;
 		}
 		burstcnt = min_t(int, burstcnt, len - count - 1);
+#endif
 		rc = tpm_tis_write_bytes(priv, TPM_DATA_FIFO(priv->locality),
 					 burstcnt, buf + count);
 		if (rc < 0)
 			goto out_err;
 
 		count += burstcnt;
-
+#ifndef CONFIG_TCG_TIS_I2C
 		if (wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,
 					&priv->int_queue, false) < 0) {
 			rc = -ETIME;
@@ -441,7 +474,9 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 			rc = -EIO;
 			goto out_err;
 		}
+#endif
 	}
+#ifndef CONFIG_TCG_TIS_I2C
 
 	/* write last byte */
 	rc = tpm_tis_write8(priv, TPM_DATA_FIFO(priv->locality), buf[count]);
@@ -458,7 +493,7 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 		rc = -EIO;
 		goto out_err;
 	}
-
+#endif
 	return 0;
 
 out_err:
@@ -495,20 +530,28 @@ static void disable_interrupts(struct tpm_chip *chip)
 static int tpm_tis_send_main(struct tpm_chip *chip, const u8 *buf, size_t len)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
-	int rc;
+	int rc,i;
 	u32 ordinal;
 	unsigned long dur;
 	unsigned int try;
+	bool data_valid = false;
 
-	for (try = 0; try < TPM_RETRY; try++) {
-		rc = tpm_tis_send_data(chip, buf, len);
-		if (rc >= 0)
+//	for (try = 0; try < TPM_RETRY; try++) {
+//		rc = tpm_tis_send_data(chip, buf, len);
+//		if (rc >= 0)
 			/* Data transfer done successfully */
-			break;
-		else if (rc != -EIO)
+//			break;
+//		else if (rc != -EIO)
 			/* Data transfer failed, not recoverable */
-			return rc;
-	}
+//			return rc;
+//	}
+
+       for (i = 0; i < TPM_RETRY && !data_valid; i++) {
+               rc = tpm_tis_send_data(chip, buf, len);
+               if (rc < 0)
+                       return rc;
+               data_valid = tpm_tis_check_data(chip, buf, len);
+       }
 
 	rc = tpm_tis_verify_crc(priv, len, buf);
 	if (rc < 0) {
@@ -740,7 +783,7 @@ static int probe_itpm(struct tpm_chip *chip)
 
 static bool tpm_tis_req_canceled(struct tpm_chip *chip, u8 status)
 {
-	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+/*	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 
 	if (!test_bit(TPM_TIS_DEFAULT_CANCELLATION, &priv->flags)) {
 		switch (priv->manufacturer_id) {
@@ -755,6 +798,8 @@ static bool tpm_tis_req_canceled(struct tpm_chip *chip, u8 status)
 	}
 
 	return status == TPM_STS_COMMAND_READY;
+*/
+	return ((status & TPM_STS_COMMAND_READY) == TPM_STS_COMMAND_READY);
 }
 
 static irqreturn_t tis_int_handler(int dummy, void *dev_id)
@@ -763,6 +808,9 @@ static irqreturn_t tis_int_handler(int dummy, void *dev_id)
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	u32 interrupt;
 	int i, rc;
+#ifdef CONFIG_TCG_TIS_I2C
+       u32 BusInterface;
+#endif
 
 	rc = tpm_tis_read32(priv, TPM_INT_STATUS(priv->locality), &interrupt);
 	if (rc < 0)
@@ -1131,6 +1179,17 @@ int tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,
 	dev_info(dev, "%s TPM (device-id 0x%X, rev-id %d)\n",
 		 (chip->flags & TPM_CHIP_FLAG_TPM2) ? "2.0" : "1.2",
 		 vendor >> 16, rid);
+#ifdef CONFIG_TCG_TIS_I2C
+       rc = tpm_tis_read32(priv, TPM_INTF_CAPABILITY(0), &BusInterface);
+       if (rc < 0)
+               goto out_err;
+
+       priv->interface_id = BusInterface;
+
+       dev_info(dev, " TPM %s / Interface : %s)\n",
+               (chip->flags & TPM_CHIP_FLAG_TPM2) ? "2.0" : "1.2",
+               (priv->interface_id) ? "I2C" : "SPI" );
+#endif
 
 	probe = probe_itpm(chip);
 	if (probe < 0) {
diff --git a/drivers/char/tpm/tpm_tis_core.h b/drivers/char/tpm/tpm_tis_core.h
index 610bfadb6acf..44283ab6adf4 100644
--- a/drivers/char/tpm/tpm_tis_core.h
+++ b/drivers/char/tpm/tpm_tis_core.h
@@ -74,6 +74,11 @@ enum tis_defaults {
 #define	TPM_STS(l)			(0x0018 | ((l) << 12))
 #define	TPM_STS3(l)			(0x001b | ((l) << 12))
 #define	TPM_DATA_FIFO(l)		(0x0024 | ((l) << 12))
+#ifdef CONFIG_TCG_TIS_I2C
+/* fix BHO I2C implementation */
+#define        TPM_INTF_CAPABILITY(l)          (0x0030 | ((l) << 12))
+/* fix BHO I2C implementation */
+#endif
 
 #define	TPM_DID_VID(l)			(0x0F00 | ((l) << 12))
 #define	TPM_RID(l)			(0x0F04 | ((l) << 12))
@@ -92,6 +97,12 @@ enum tpm_tis_flags {
 
 struct tpm_tis_data {
 	u16 manufacturer_id;
+#ifdef CONFIG_TCG_TIS_I2C
+       /* fix BHO I2C implementation */
+       u8 interface_id;
+       /* fix BHO I2C implementation */
+#endif
+
 	struct mutex locality_count_mutex;
 	unsigned int locality_count;
 	int locality;
@@ -127,6 +138,8 @@ struct tpm_tis_phy_ops {
 			   const u8 *value, enum tpm_tis_io_mode mode);
 	int (*verify_crc)(struct tpm_tis_data *data, size_t len,
 			  const u8 *value);
+       bool (*check_data)(struct tpm_tis_data *data, u8 *buf, size_t len);
+
 };
 
 static inline int tpm_tis_read_bytes(struct tpm_tis_data *data, u32 addr,
@@ -147,6 +160,7 @@ static inline int tpm_tis_read16(struct tpm_tis_data *data, u32 addr,
 	__le16 result_le;
 	int rc;
 
+
 	rc = data->phy_ops->read_bytes(data, addr, sizeof(u16),
 				       (u8 *)&result_le, TPM_TIS_PHYS_16);
 	if (!rc)
@@ -161,6 +175,7 @@ static inline int tpm_tis_read32(struct tpm_tis_data *data, u32 addr,
 	__le32 result_le;
 	int rc;
 
+
 	rc = data->phy_ops->read_bytes(data, addr, sizeof(u32),
 				       (u8 *)&result_le, TPM_TIS_PHYS_32);
 	if (!rc)
diff --git a/drivers/char/tpm/tpm_tis_i2c.c b/drivers/char/tpm/tpm_tis_i2c.c
index 9586e0857a3e..c021e60be818 100644
--- a/drivers/char/tpm/tpm_tis_i2c.c
+++ b/drivers/char/tpm/tpm_tis_i2c.c
@@ -384,6 +384,7 @@ MODULE_DEVICE_TABLE(i2c, tpm_tis_i2c_id);
 #ifdef CONFIG_OF
 static const struct of_device_id of_tis_i2c_match[] = {
 	{ .compatible = "infineon,slb9673", },
+	{ .compatible = "st,st33htpm-i2c", },
 	{}
 };
 MODULE_DEVICE_TABLE(of, of_tis_i2c_match);
diff --git a/init/Kconfig b/init/Kconfig
index de255842f5d0..cafcb4fbadde 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -16,6 +16,12 @@ config CC_VERSION_TEXT
 	    auto-generated dependency. When the compiler is updated, syncconfig
 	    will touch it and then every file will be rebuilt.
 
+config ADLINK_LECIMX8MM
+        bool
+        help
+          Select this to enable ADLINK modified code block. 
+        default y
+
 config CC_IS_GCC
 	def_bool $(success,test "$(cc-name)" = GCC)
 
-- 
2.43.2

