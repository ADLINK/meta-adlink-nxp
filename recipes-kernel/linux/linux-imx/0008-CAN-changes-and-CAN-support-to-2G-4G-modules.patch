From 5daa8175a836781f32ce5d47b1c9b7bd5bf28fda Mon Sep 17 00:00:00 2001
From: Antony <antonyabee.prakashxv@adlinktech.com>
Date: Tue, 2 Jul 2019 18:35:08 +0530
Subject: [PATCH 2/2] CAN-changes-and-CAN-support-to-2G-4G-modules

---
 arch/arm64/boot/dts/adlink/Makefile                |    6 +-
 .../arm64/boot/dts/adlink/adlink-2gb-canfd-40M.dts |   18 +
 arch/arm64/boot/dts/adlink/adlink-2gb-canfd.dts    |   86 +
 .../arm64/boot/dts/adlink/adlink-4gb-canfd-40M.dts |   18 +
 arch/arm64/boot/dts/adlink/adlink-4gb-canfd.dts    |   83 +
 arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts    |   23 +-
 arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi         |   30 +-
 drivers/net/can/spi/Kconfig                        |    6 +
 drivers/net/can/spi/Makefile                       |    1 +
 drivers/net/can/spi/mcp2517fd.c                    | 4306 ++++++++++++++++++++
 drivers/net/can/spi/mcp251x.c                      |   85 +-
 drivers/spi/Kconfig                                |   85 +-
 drivers/spi/spi-imx.c                              |  747 +++-
 13 files changed, 5213 insertions(+), 281 deletions(-)
 create mode 100755 arch/arm64/boot/dts/adlink/adlink-2gb-canfd-40M.dts
 create mode 100755 arch/arm64/boot/dts/adlink/adlink-2gb-canfd.dts
 create mode 100755 arch/arm64/boot/dts/adlink/adlink-4gb-canfd-40M.dts
 create mode 100755 arch/arm64/boot/dts/adlink/adlink-4gb-canfd.dts
 create mode 100755 drivers/net/can/spi/mcp2517fd.c

diff --git a/arch/arm64/boot/dts/adlink/Makefile b/arch/arm64/boot/dts/adlink/Makefile
index b434400..f50f560 100644
--- a/arch/arm64/boot/dts/adlink/Makefile
+++ b/arch/arm64/boot/dts/adlink/Makefile
@@ -1,4 +1,8 @@
-dtb-$(CONFIG_ARCH_LEC_IMX8M) += adlink-lec-imx8m.dtb
+dtb-$(CONFIG_ARCH_LEC_IMX8M) += adlink-lec-imx8m.dtb \
+                                adlink-2gb-canfd.dtb \
+                                adlink-2gb-canfd-40M.dtb \
+                                adlink-4gb-canfd.dtb \
+                                adlink-4gb-canfd-40M.dtb
 
 always		:= $(dtb-y)
 subdir-y	:= $(dts-dirs)
diff --git a/arch/arm64/boot/dts/adlink/adlink-2gb-canfd-40M.dts b/arch/arm64/boot/dts/adlink/adlink-2gb-canfd-40M.dts
new file mode 100755
index 0000000..a4b463a
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-2gb-canfd-40M.dts
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2019 ADLINK
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define MCP2517FD_OSC1_HZ	40000000	//U49[6:5], X11,	
+
+#include "adlink-2gb-canfd.dts"
+
diff --git a/arch/arm64/boot/dts/adlink/adlink-2gb-canfd.dts b/arch/arm64/boot/dts/adlink/adlink-2gb-canfd.dts
new file mode 100755
index 0000000..3f36364
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-2gb-canfd.dts
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2019 ADLINK
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-lec-imx8m.dts"
+
+/delete-node/ &vpu_pd;
+/delete-node/ &vpu;
+
+#define ENABLE_MCP2517FD
+
+#ifdef ENABLE_MCP2517FD
+
+#ifndef MCP2517FD_OSC1_HZ
+#define MCP2517FD_OSC1_HZ	20000000	//U49[6:5], X11,	
+#endif
+
+/delete-node/ &can0;
+
+/ {
+	clocks {
+		fd_osc_fixed: fixed_clk_X11 {
+			compatible		= "fixed-clock";
+			#clock-cells	= <0>;
+			clock-frequency = <MCP2517FD_OSC1_HZ>;
+		};
+	};
+};
+
+&iomuxc {
+	lec-imx8m {	
+		pinctrl_mcp251x: mcp251xgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI1_RXC_GPIO4_IO1		0x56	//K1 ,U23[11],CAN0_INT-L
+				MX8MQ_IOMUXC_NAND_RE_B_GPIO3_IO15	0x56	//K19,U23[10],CAN0_RX0BF
+				MX8MQ_IOMUXC_NAND_DATA05_GPIO3_IO11	0x56	//J22,U23[ 9],CAN0_RX1BF
+			>;
+		};
+	};
+};
+
+//ky_note: If OSC=4M then SPI_HZ=(OSC1_HZ*10/2);
+#define MCP2517FD_SPI_HZ	(MCP2517FD_OSC1_HZ/2)	//Refer: TABLE7-6/Note3;
+
+&ecspi2 {//master_name=spi1 (by aliases)
+	can0: can@0 {//dev_name=spi1.0
+		reg					= <0>; //spi_device.chip_select;
+		compatible			= "microchip,mcp2517fd";
+		pinctrl-names		= "default";
+		pinctrl-0			= <&pinctrl_mcp251x>;
+		interrupt-parent	= <&gpio4>;
+		interrupts			= <1 IRQ_TYPE_EDGE_FALLING>;
+		
+//SPI Interface:		
+		clocks				= <&fd_osc_fixed>;
+		spi-max-frequency	= <MCP2517FD_SPI_HZ>; //spi_device.max_speed_hz;
+		spi-tx-bus-width	= <1>; //spi_device.mode, 2=DUAL, 4=QUAD;		
+		spi-rx-bus-width	= <1>;	
+		//spi-cpol;			//mode|=SPI_CPOL;
+		//spi-cpha;			//mode|=SPI_CPHA;
+		//spi-cs-high;		//mode|=SPI_CS_HIGH;
+		//spi-3wire;		//mode|=SPI_3WIRE;
+		//spi-lsb-first;	//mode|=SPI_LSB_FIRST;
+		
+//Mcp2517fd:		
+		//microchip,clock_div	= <1|2>; //priv->config.clock_div2,
+		//microchip,clock_out_div = <0|1|2|4|10>; //config.clock_odiv,
+		//microchip,gpio0_mode = <0~4>; //config.gpio0_mode,
+		//microchip,gpio1_mode = <0~3>; //config.gpio1_mode,
+		//microchip,gpio_opendrain; //config.gpio_opendrain,
+		//microchip,txcan_opendrain; //config.txcan_opendrain,
+		//microchip,int_opendrain; //config.int_opendrain,
+	};
+};
+
+#endif
diff --git a/arch/arm64/boot/dts/adlink/adlink-4gb-canfd-40M.dts b/arch/arm64/boot/dts/adlink/adlink-4gb-canfd-40M.dts
new file mode 100755
index 0000000..8759c33
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-4gb-canfd-40M.dts
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2019 ADLINK
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define MCP2517FD_OSC1_HZ	40000000	//U49[6:5], X11,	
+
+#include "adlink-4gb-canfd.dts"
+
diff --git a/arch/arm64/boot/dts/adlink/adlink-4gb-canfd.dts b/arch/arm64/boot/dts/adlink/adlink-4gb-canfd.dts
new file mode 100755
index 0000000..049c4b0
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-4gb-canfd.dts
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2019 ADLINK
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-lec-imx8m.dts"
+
+#define ENABLE_MCP2517FD
+
+#ifdef ENABLE_MCP2517FD
+
+#ifndef MCP2517FD_OSC1_HZ
+#define MCP2517FD_OSC1_HZ	20000000	//U49[6:5], X11,	
+#endif
+
+/delete-node/ &can0;
+
+/ {
+	clocks {
+		fd_osc_fixed: fixed_clk_X11 {
+			compatible		= "fixed-clock";
+			#clock-cells	= <0>;
+			clock-frequency = <MCP2517FD_OSC1_HZ>;
+		};
+	};
+};
+
+&iomuxc {
+	lec-imx8m {	
+		pinctrl_mcp251x: mcp251xgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SAI1_RXC_GPIO4_IO1		0x56	//K1 ,U23[11],CAN0_INT-L
+				MX8MQ_IOMUXC_NAND_RE_B_GPIO3_IO15	0x56	//K19,U23[10],CAN0_RX0BF
+				MX8MQ_IOMUXC_NAND_DATA05_GPIO3_IO11	0x56	//J22,U23[ 9],CAN0_RX1BF
+			>;
+		};
+	};
+};
+
+//ky_note: If OSC=4M then SPI_HZ=(OSC1_HZ*10/2);
+#define MCP2517FD_SPI_HZ	(MCP2517FD_OSC1_HZ/2)	//Refer: TABLE7-6/Note3;
+
+&ecspi2 {//master_name=spi1 (by aliases)
+	can0: can@0 {//dev_name=spi1.0
+		reg					= <0>; //spi_device.chip_select;
+		compatible			= "microchip,mcp2517fd";
+		pinctrl-names		= "default";
+		pinctrl-0			= <&pinctrl_mcp251x>;
+		interrupt-parent	= <&gpio4>;
+		interrupts			= <1 IRQ_TYPE_EDGE_FALLING>;
+		
+//SPI Interface:		
+		clocks				= <&fd_osc_fixed>;
+		spi-max-frequency	= <MCP2517FD_SPI_HZ>; //spi_device.max_speed_hz;
+		spi-tx-bus-width	= <1>; //spi_device.mode, 2=DUAL, 4=QUAD;		
+		spi-rx-bus-width	= <1>;	
+		//spi-cpol;			//mode|=SPI_CPOL;
+		//spi-cpha;			//mode|=SPI_CPHA;
+		//spi-cs-high;		//mode|=SPI_CS_HIGH;
+		//spi-3wire;		//mode|=SPI_3WIRE;
+		//spi-lsb-first;	//mode|=SPI_LSB_FIRST;
+		
+//Mcp2517fd:		
+		//microchip,clock_div	= <1|2>; //priv->config.clock_div2,
+		//microchip,clock_out_div = <0|1|2|4|10>; //config.clock_odiv,
+		//microchip,gpio0_mode = <0~4>; //config.gpio0_mode,
+		//microchip,gpio1_mode = <0~3>; //config.gpio1_mode,
+		//microchip,gpio_opendrain; //config.gpio_opendrain,
+		//microchip,txcan_opendrain; //config.txcan_opendrain,
+		//microchip,int_opendrain; //config.int_opendrain,
+	};
+};
+
+#endif
diff --git a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
index ad6184d..c242c63 100644
--- a/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
+++ b/arch/arm64/boot/dts/adlink/adlink-lec-imx8m.dts
@@ -57,7 +57,7 @@
 			regulator-max-microvolt = <1000000>;
 			regulator-name = "gpio_dvfs";
 			regulator-type = "voltage";
-			gpios = <&gpio5 4 GPIO_ACTIVE_HIGH>;
+			gpios = <&gpio1 13 GPIO_ACTIVE_HIGH>;
 			states = <900000 0x1 1000000 0x0>;
 		};
 	};
@@ -219,14 +219,6 @@
 			>;
 		};
 
-		pinctrl_mcp251x: mcp251xgrp {
-			fsl,pins = <
-				MX8MQ_IOMUXC_SAI1_RXC_GPIO4_IO1		0x56	//K1 ,U23[11],CAN0_INT-L
-				MX8MQ_IOMUXC_NAND_RE_B_GPIO3_IO15	0x56	//K19,U23[10],CAN0_RX0BF
-				MX8MQ_IOMUXC_NAND_DATA05_GPIO3_IO11	0x56	//J22,U23[ 9],CAN0_RX1BF
-			>;
-		};
-
 		pinctrl_i2c4: i2c4grp {
 			fsl,pins = <
 				MX8MQ_IOMUXC_I2C4_SCL_I2C4_SCL			0x4000007f
@@ -387,6 +379,15 @@
 			>;
 		};
 
+                pinctrl_ecspi2_1: ecspi2grp-1 {
+                        fsl,pins = <
+                                MX8MQ_IOMUXC_ECSPI2_SCLK_ECSPI2_SCLK 0x10b0
+                                MX8MQ_IOMUXC_ECSPI2_MOSI_ECSPI2_MOSI 0x10b0
+                                MX8MQ_IOMUXC_ECSPI2_MISO_ECSPI2_MISO 0x10b0
+                                MX8MQ_IOMUXC_ECSPI2_SS0_GPIO5_IO13  0x80000000
+                        >;
+                };
+
 		pinctrl_sai5: sai5grp {
 			fsl,pins = <
 				MX8MQ_IOMUXC_SAI5_MCLK_SAI5_MCLK	0xd6
@@ -689,16 +690,16 @@
 	//pinctrl-0 = <&pinctrl_ecspi2_1 >;
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_ecspi2>;
+        fsl,spi-rdy-drctl       = <0>; //ECSPIx_CONREG[17:16],0=SPI_RDY don't case,
 	status = "okay";
 
 	can0: can@0 {
 		compatible = "microchip,mcp2515";
 		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_mcp251x>;
 		reg = <0>;
 		clocks = <&clk20M>;
 		spi-max-frequency = <10000000>;
-		interrupt-parent = <&gpio4>;
+		interrupt-parent = <&gpio5>;
 		interrupts = <1 IRQ_TYPE_EDGE_FALLING>;		
 	};
 };
diff --git a/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi b/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
index 7885d25..79b8a90 100644
--- a/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
+++ b/arch/arm64/boot/dts/adlink/fsl-imx8mq.dtsi
@@ -35,6 +35,9 @@
 		serial1 = &uart2;
 		serial2 = &uart3;
 		serial3 = &uart4;
+                spi0 = &ecspi1;
+                spi1 = &ecspi2;
+                spi2 = &ecspi3;
 		mmc0 = &usdhc1;
 		mmc1 = &usdhc2;
 		gpio0 = &gpio1;
@@ -44,7 +47,6 @@
 		gpio4 = &gpio5;
 		dsi_phy0 = &mipi_dsi_phy;
 		mipi_dsi0 = &mipi_dsi;
-		spi2 = &ecspi2;
 	};
 
 	cpus {
@@ -789,10 +791,22 @@
 		status = "disabled";
 	};
 
+        ecspi1: ecspi@30820000 {
+                #address-cells = <1>;
+                #size-cells = <0>;
+                compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi";
+                reg = <0x0 0x30820000 0x0 0x10000>;
+                interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+                clocks = <&clk IMX8MQ_CLK_ECSPI1_ROOT>,
+                         <&clk IMX8MQ_CLK_ECSPI1_ROOT>;
+                clock-names = "ipg", "per";
+                status = "disabled";
+        };
+
 	ecspi2: ecspi@30830000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
-		compatible = "fsl,imx6ul-ecspi", "fsl,imx51-ecspi";
+		compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi";
 		reg = <0x0 0x30830000 0x0 0x10000>;
 		interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&clk IMX8MQ_CLK_ECSPI2_ROOT>,
@@ -801,6 +815,18 @@
 		status = "disabled";
 	};
 
+        ecspi3: ecspi@30840000 {
+                #address-cells = <1>;
+                #size-cells = <0>;
+                compatible = "fsl,imx8mq-ecspi", "fsl,imx51-ecspi";
+                reg = <0x0 0x30840000 0x0 0x10000>;
+                interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+                clocks = <&clk IMX8MQ_CLK_ECSPI3_ROOT>,
+                         <&clk IMX8MQ_CLK_ECSPI3_ROOT>;
+                clock-names = "ipg", "per";
+                status = "disabled";
+        };
+
 	uart1: serial@30860000 {
 		compatible = "fsl,imx8mq-uart",
 			     "fsl,imx6q-uart", "fsl,imx21-uart";
diff --git a/drivers/net/can/spi/Kconfig b/drivers/net/can/spi/Kconfig
index 8f2e0dd..cf10a5b 100644
--- a/drivers/net/can/spi/Kconfig
+++ b/drivers/net/can/spi/Kconfig
@@ -13,4 +13,10 @@ config CAN_MCP251X
 	---help---
 	  Driver for the Microchip MCP251x SPI CAN controllers.
 
+config CAN_MCP2517FD
+	tristate "Microchip MCP2517FD SPI CAN controller"
+	depends on HAS_DMA
+	---help---
+	Driver for Microchip MCP2517FD SPI CAN controller.
+
 endmenu
diff --git a/drivers/net/can/spi/Makefile b/drivers/net/can/spi/Makefile
index f59fa37..7a4ed19 100644
--- a/drivers/net/can/spi/Makefile
+++ b/drivers/net/can/spi/Makefile
@@ -5,3 +5,4 @@
 
 obj-$(CONFIG_CAN_HI311X)	+= hi311x.o
 obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
+obj-$(CONFIG_CAN_MCP2517FD)	+= mcp2517fd.o
diff --git a/drivers/net/can/spi/mcp2517fd.c b/drivers/net/can/spi/mcp2517fd.c
new file mode 100755
index 0000000..6b1d6cd
--- /dev/null
+++ b/drivers/net/can/spi/mcp2517fd.c
@@ -0,0 +1,4306 @@
+//#define CONFIG_SPI_IMX //Get this from autoconf.h
+#define ADLINK_PATCH
+#define ADLINK_PATCH_ECHO_SKB
+#define ADLINK_PATCH_OF_IRQ
+#define ADLINK_PATCH_FIFO_WRITE_PLSIZE//Workaround for send-stop(@res bit) issue;
+#define ADLINK_PATCH_ENABLE_TDCMOD//C1TDC[17:16]=0x11=Auto;
+#define ADLINK_PATCH_ADJUST_SJW//DS200005678B-3.4.8 -Bit Time config
+
+#define ADLINK_DEBUG
+
+#ifdef ADLINK_DEBUG
+#define ADLINK_DEBUG_ONE_SHOT//+CAN_CTRLMODE_ONE_SHOT
+#define ADLINK_DEBUG_DUMP_CUREENT_FIFO
+#define ADLINK_DEBUG_LOOPBACK //CAN_CTRLMODE_LOOPBACK: already support by ip;
+#define ADLINK_DEBUG_DUMP_FSR//For FAE Request;
+
+//#define ADLINK_DEBUG_ENABLE_PXEDIS//C1CON[6]
+//#define ADLINK_DEBUG_CHECK_TFNRFNIF//DS200005678B-4.2-Loading Message into TX FIFO
+
+#define ASSERT(x) BUG_ON(x)
+#else
+#define ASSERT(x) 
+#endif
+
+/*
+ * CAN bus driver for Microchip 2517FD CAN Controller with SPI Interface
+ *
+ * Copyright 2017 Martin Sperl <kernel@xxxxxxxxxxxxxxxx>
+ *
+ * SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
+ *
+ * Based on Microchip MCP251x CAN controller driver written by
+ * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/can/core.h>
+#include <linux/can/dev.h>
+#include <linux/can/led.h>
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/freezer.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include <linux/spi/spi.h>
+#include <linux/uaccess.h>
+#include <linux/regulator/consumer.h>
+
+#ifdef ADLINK_PATCH_OF_IRQ	
+#include <linux/irqdomain.h>
+#endif
+
+#define DEVICE_NAME "mcp2517fd"
+
+/* device description and rational:
+ *
+ * the mcp2517fd is a CanFD controller that also supports can2.0 only
+ * modes.
+ * It is connected via spi to the host and requires at minimum a single
+ * irq line in addition to the SPI lines - it is not mentioned explicitly
+ * in the documentation but in principle SPI 3-wire should be possible.
+ *
+ * The clock connected is typically 4MHz, 20MHz or 40MHz.
+ * For the 4MHz clock the controller contains 10x PLL circuitry.
+ *
+ * The controller itself has 2KB or ECC-SRAM for data.
+ * It also has 32 FIFOs (of up to 32 CAN-frames).
+ * There are 4 Fifo types which can get configured:
+ * * TEF - Transmission Event Fifo - which consumes FIFO 0
+ *   even if it is not configured
+ * * Tansmission Queue - for up to 32 Frames.
+ *   this queue reorders CAN frames to get transmitted following the
+ *   typical CAN dominant/recessive rules on the can bus itself.
+ *   This FIFO is optional.
+ * * TX FIFO: generic TX fifos that can contain arbitrary data
+ *   and which come with a configurable priority for transmission
+ *   It is also possible to have the Controller automatically trigger
+ *   a transfer when a Filter Rule for a RTR frame matches.
+ *   Each of these fifos in principle can get configured for distinct
+ *   dlc sizes (8 thru 64 bytes)
+ * * RX FIFO: generic RX fifo which is filled via filter-rules.
+ *   Each of these fifos in principle can get configured for distinct
+ *   dlc sizes (8 thru 64 bytes)
+ *   Unfortunately there is no filter rule that would allow triggering
+ *   on different frame sizes, so for all practical purposes the
+ *   RX fifos have to be of the same size (unless one wants to experience
+ *   lost data).
+ * When a Can Frame is transmitted fromthe TX Queue or an individual
+ * TX FIFO then a small TEF Frame can get added to the TEF FIFO queue
+ * to log the Transmission of the frame - this includes ID, Flags
+ * (including a custom identifier/index) .
+ *
+ * The controller provides an optional free running counter with a divider
+ * for timestamping of RX frames as well as for TEF entries.
+ *
+ * Driver Implementation details and rational:
+ * * The whole driver has been designed to give best performance
+ *   and as little packet loss as possible with 1MHZ Can frames with DLC=0
+ *   on small/slow devices like the Raspberry Pi 1
+ * * This means that some optimizations for full duplex communication
+ *   have been implemented to avoid CPU introduced latencies
+ *   (especially for spi_write_then_read cases) - this only applies to
+ *   4 wire SPI busses.
+ * * Due to the fact that the TXQ does reorder Can-Frames we do not make
+ *   use of it to avoid unexpected behaviour (say when running a
+ *   firmware upgrade via Can)
+ * * this means we use individual TX-fifos with a given priority and
+ *   we have to wait until all the TX fifos have been transmitted before
+ *   we can restart the networking queue to avoid reordering the frames on
+ *   the Can bus itself.
+ *   Still we can transmit a transmit only Duty-cycle of 66% to 90% on the
+ *   Can bus (at 1MHz).
+ *   The scaling factors here are:
+ *   * Can bus speed - lower Speeds increase Duty-cycle
+ *   * SPI Clock Rate - higher speeds increase duty-cycle
+ *   * CPU speed + SPI implementation - reduces latencies between transfers
+ * * There is a module parameter that allows the modification of the
+ *   number of tx_fifos, which is by default 7.
+ * * The driver offers some module parameters that allow to control the use
+ *   of some optimizations (prefer reading more data than necessary instead
+ *   of multiple SPI transfers - the idea here is that this way we may
+ *   allow the SPI-controller to use DMA instead of programmed IO to
+ *   limit latencies/number of interrupts)
+ *   When we have to read multiple RX frames in CanFD mode:
+ *   * we allow reading all 64 bytes of payload even if DLC <=8
+ *     this mode is used in Can2.0 only mode by default and can not get
+ *     disabled (SRAM Reads have to be a multiple of 4 bytes anyway)
+ *   * Releasing/freeing the RX queue requires writing of 1 byte per fifo.
+ *     unfortunately these 32-bit registers are not ajacent to each other,
+ *     so that for 2 consecutive RX Frames instead of writing 1 byte per
+ *     fifo (with protocol overhead of 2 bytes - so a total of 6 bytes in
+ *     2 transfers) we transmit 13 bytes (with a protocol overhead of 2 -
+ *     so a total of 15 bytes)
+ *     This optimization is only enabled by a module parameter.
+ * * we use TEF + time stamping to record the transmitted frames
+ *   including their timestamp - we use this to order TX and RX frames
+ *   when submitting them to the network stack.
+ * * due to the inability to "filter" based on DLC sizes we have to use
+ *   a common FIFO size. This is 8 bytes for Can2.0 and 64 bytes for CanFD.
+ * * the driver tries to detect the Controller only by reading registers,
+ *   but there are circumstances (e.g. after a crashed driver) where we
+ *   have to "blindly" configure the clock rate to get the controller to
+ *   respond correctly.
+ * * There is one situation where the controller will require a full POR
+ *   (total power off) to recover from a bad Clock configuration.
+ *   This happens when the wrong clock is configured in the device tree
+ *   (say 4MHz are configured, while 20 or 40MHz are used)
+ *   in such a situation the driver tries to enable the PLL, which will
+ *   never synchronize and the controller becomes unresponsive to further
+ *   spi requests until a POR.
+ */
+
+#define MCP2517FD_OST_DELAY_MS		3
+#define MCP2517FD_MIN_CLOCK_FREQUENCY	1000000
+#define MCP2517FD_MAX_CLOCK_FREQUENCY	40000000
+#define MCP2517FD_PLL_MULTIPLIER	10
+#define MCP2517FD_AUTO_PLL_MAX_CLOCK_FREQUENCY				\
+	(MCP2517FD_MAX_CLOCK_FREQUENCY / MCP2517FD_PLL_MULTIPLIER)
+#define MCP2517FD_SCLK_DIVIDER		2
+
+#define MCP2517FD_OSC_POLLING_JIFFIES	(HZ / 2)
+
+#define TX_ECHO_SKB_MAX	32
+
+#define INSTRUCTION_RESET		0x0000
+#define INSTRUCTION_READ		0x3000
+#define INSTRUCTION_WRITE		0x2000
+#define INSTRUCTION_READ_CRC		0xB000
+#define INSTRUCTION_WRITE_CRC		0xA000
+#define INSTRUCTION_WRITE_SAVE		0xC000
+
+#define ADDRESS_MASK			0x0fff
+
+#define MCP2517FD_SFR_BASE(x)		(0xE00 + (x))
+#define MCP2517FD_OSC			MCP2517FD_SFR_BASE(0x00)
+#  define MCP2517FD_OSC_PLLEN		BIT(0)
+#  define MCP2517FD_OSC_OSCDIS		BIT(2)
+#  define MCP2517FD_OSC_SCLKDIV		BIT(4)
+#  define MCP2517FD_OSC_CLKODIV_BITS	2
+#  define MCP2517FD_OSC_CLKODIV_SHIFT	5
+#  define MCP2517FD_OSC_CLKODIV_MASK			\
+	GENMASK(MCP2517FD_OSC_CLKODIV_SHIFT		\
+		+ MCP2517FD_OSC_CLKODIV_BITS - 1,	\
+		MCP2517FD_OSC_CLKODIV_SHIFT)
+#  define MCP2517FD_OSC_CLKODIV_10	3
+#  define MCP2517FD_OSC_CLKODIV_4	2
+#  define MCP2517FD_OSC_CLKODIV_2	1
+#  define MCP2517FD_OSC_CLKODIV_1	0
+#  define MCP2517FD_OSC_PLLRDY		BIT(8)
+#  define MCP2517FD_OSC_OSCRDY		BIT(10)
+#  define MCP2517FD_OSC_SCLKRDY		BIT(12)
+#define MCP2517FD_IOCON			MCP2517FD_SFR_BASE(0x04)
+#  define MCP2517FD_IOCON_TRIS0		BIT(0)
+#  define MCP2517FD_IOCON_TRIS1		BIT(1)
+#  define MCP2517FD_IOCON_XSTBYEN	BIT(6)
+#  define MCP2517FD_IOCON_LAT0		BIT(8)
+#  define MCP2517FD_IOCON_LAT1		BIT(9)
+#  define MCP2517FD_IOCON_GPIO0		BIT(16)
+#  define MCP2517FD_IOCON_GPIO1		BIT(17)
+#  define MCP2517FD_IOCON_PM0		BIT(24)
+#  define MCP2517FD_IOCON_PM1		BIT(25)
+#  define MCP2517FD_IOCON_TXCANOD	BIT(28)
+#  define MCP2517FD_IOCON_SOF		BIT(29)
+#  define MCP2517FD_IOCON_INTOD		BIT(29)
+#define MCP2517FD_CRC			MCP2517FD_SFR_BASE(0x08)
+#  define MCP2517FD_CRC_MASK		GENMASK(15, 0)
+#  define MCP2517FD_CRC_CRCERRIE	BIT(16)
+#  define MCP2517FD_CRC_FERRIE		BIT(17)
+#  define MCP2517FD_CRC_CRCERRIF	BIT(24)
+#  define MCP2517FD_CRC_FERRIF		BIT(25)
+#define MCP2517FD_ECCCON		MCP2517FD_SFR_BASE(0x0C)
+#  define MCP2517FD_ECCCON_ECCEN	BIT(0)
+#  define MCP2517FD_ECCCON_SECIE	BIT(1)
+#  define MCP2517FD_ECCCON_DEDIE	BIT(2)
+#  define MCP2517FD_ECCCON_PARITY_BITS 6
+#  define MCP2517FD_ECCCON_PARITY_SHIFT 8
+#  define MCP2517FD_ECCCON_PARITY_MASK			\
+	GENMASK(MCP2517FD_ECCCON_PARITY_SHIFT		\
+		+ MCP2517FD_ECCCON_PARITY_BITS - 1,	\
+		MCP2517FD_ECCCON_PARITY_SHIFT)
+#define MCP2517FD_ECCSTAT		MCP2517FD_SFR_BASE(0x10)
+#  define MCP2517FD_ECCSTAT_SECIF	BIT(1)
+#  define MCP2517FD_ECCSTAT_DEDIF	BIT(2)
+#  define MCP2517FD_ECCSTAT_ERRADDR_SHIFT 8
+#  define MCP2517FD_ECCSTAT_ERRADDR_MASK	      \
+	GENMASK(MCP2517FD_ECCSTAT_ERRADDR_SHIFT + 11, \
+		MCP2517FD_ECCSTAT_ERRADDR_SHIFT)
+
+#define CAN_SFR_BASE(x)			(0x000 + (x))
+#define CAN_CON				CAN_SFR_BASE(0x00)
+#  define CAN_CON_DNCNT_BITS		5
+#  define CAN_CON_DNCNT_SHIFT		0
+#  define CAN_CON_DNCNT_MASK					\
+	GENMASK(CAN_CON_DNCNT_SHIFT + CAN_CON_DNCNT_BITS - 1,	\
+		CAN_CON_DNCNT_SHIFT)
+#  define CAN_CON_ISOCRCEN		BIT(5)
+#  define CAN_CON_PXEDIS		BIT(6)
+#  define CAN_CON_WAKFIL		BIT(8)
+#  define CAN_CON_WFT_BITS		2
+#  define CAN_CON_WFT_SHIFT		9
+#  define CAN_CON_WFT_MASK					\
+	GENMASK(CAN_CON_WFT_SHIFT + CAN_CON_WFT_BITS - 1,	\
+		CAN_CON_WFT_SHIFT)
+#  define CAN_CON_BUSY			BIT(11)
+#  define CAN_CON_BRSDIS		BIT(12)
+#  define CAN_CON_RTXAT			BIT(16)
+#  define CAN_CON_ESIGM			BIT(17)
+#  define CAN_CON_SERR2LOM		BIT(18)
+#  define CAN_CON_STEF			BIT(19)
+#  define CAN_CON_TXQEN			BIT(20)
+#  define CAN_CON_OPMODE_BITS		3
+#  define CAN_CON_OPMOD_SHIFT		21
+#  define CAN_CON_OPMOD_MASK					\
+	GENMASK(CAN_CON_OPMOD_SHIFT + CAN_CON_OPMODE_BITS - 1,	\
+		CAN_CON_OPMOD_SHIFT)
+#  define CAN_CON_REQOP_BITS		3
+#  define CAN_CON_REQOP_SHIFT		24
+#  define CAN_CON_REQOP_MASK					\
+	GENMASK(CAN_CON_REQOP_SHIFT + CAN_CON_REQOP_BITS - 1,	\
+		CAN_CON_REQOP_SHIFT)
+#    define CAN_CON_MODE_MIXED			0
+#    define CAN_CON_MODE_SLEEP			1
+#    define CAN_CON_MODE_INTERNAL_LOOPBACK	2
+#    define CAN_CON_MODE_LISTENONLY		3
+#    define CAN_CON_MODE_CONFIG			4
+#    define CAN_CON_MODE_EXTERNAL_LOOPBACK	5
+#    define CAN_CON_MODE_CAN2_0			6
+#    define CAN_CON_MODE_RESTRICTED		7
+#  define CAN_CON_ABAT			BIT(27)
+#  define CAN_CON_TXBWS_BITS		3
+#  define CAN_CON_TXBWS_SHIFT		28
+#  define CAN_CON_TXBWS_MASK					\
+	GENMASK(CAN_CON_TXBWS_SHIFT + CAN_CON_TXBWS_BITS - 1,	\
+		CAN_CON_TXBWS_SHIFT)
+#  define CAN_CON_DEFAULT				\
+	(CAN_CON_ISOCRCEN |				\
+	 CAN_CON_PXEDIS |				\
+	 CAN_CON_WAKFIL |				\
+	 (3 << CAN_CON_WFT_SHIFT) |			\
+	 CAN_CON_STEF |					\
+	 CAN_CON_TXQEN |				\
+	 (CAN_CON_MODE_CONFIG << CAN_CON_OPMOD_SHIFT) |	\
+	 (CAN_CON_MODE_CONFIG << CAN_CON_REQOP_SHIFT))
+#  define CAN_CON_DEFAULT_MASK	\
+	(CAN_CON_DNCNT_MASK |	\
+	 CAN_CON_ISOCRCEN |	\
+	 CAN_CON_PXEDIS |	\
+	 CAN_CON_WAKFIL |	\
+	 CAN_CON_WFT_MASK |	\
+	 CAN_CON_BRSDIS |	\
+	 CAN_CON_RTXAT |	\
+	 CAN_CON_ESIGM |	\
+	 CAN_CON_SERR2LOM |	\
+	 CAN_CON_STEF |		\
+	 CAN_CON_TXQEN |	\
+	 CAN_CON_OPMOD_MASK |	\
+	 CAN_CON_REQOP_MASK |	\
+	 CAN_CON_ABAT |		\
+	 CAN_CON_TXBWS_MASK)
+#define CAN_NBTCFG			CAN_SFR_BASE(0x04)
+#  define CAN_NBTCFG_SJW_BITS		7
+#  define CAN_NBTCFG_SJW_SHIFT		0
+#  define CAN_NBTCFG_SJW_MASK					\
+	GENMASK(CAN_NBTCFG_SJW_SHIFT + CAN_NBTCFG_SJW_BITS - 1, \
+		CAN_NBTCFG_SJW_SHIFT)
+#  define CAN_NBTCFG_TSEG2_BITS		7
+#  define CAN_NBTCFG_TSEG2_SHIFT	8
+#  define CAN_NBTCFG_TSEG2_MASK					    \
+	GENMASK(CAN_NBTCFG_TSEG2_SHIFT + CAN_NBTCFG_TSEG2_BITS - 1, \
+		CAN_NBTCFG_TSEG2_SHIFT)
+#  define CAN_NBTCFG_TSEG1_BITS		8
+#  define CAN_NBTCFG_TSEG1_SHIFT	16
+#  define CAN_NBTCFG_TSEG1_MASK					    \
+	GENMASK(CAN_NBTCFG_TSEG1_SHIFT + CAN_NBTCFG_TSEG1_BITS - 1, \
+		CAN_NBTCFG_TSEG1_SHIFT)
+#  define CAN_NBTCFG_BRP_BITS		8
+#  define CAN_NBTCFG_BRP_SHIFT		24
+#  define CAN_NBTCFG_BRP_MASK					\
+	GENMASK(CAN_NBTCFG_BRP_SHIFT + CAN_NBTCFG_BRP_BITS - 1, \
+		CAN_NBTCFG_BRP_SHIFT)
+#define CAN_DBTCFG			CAN_SFR_BASE(0x08)
+#  define CAN_DBTCFG_SJW_BITS		4
+#  define CAN_DBTCFG_SJW_SHIFT		0
+#  define CAN_DBTCFG_SJW_MASK					\
+	GENMASK(CAN_DBTCFG_SJW_SHIFT + CAN_DBTCFG_SJW_BITS - 1, \
+		CAN_DBTCFG_SJW_SHIFT)
+#  define CAN_DBTCFG_TSEG2_BITS		4
+#  define CAN_DBTCFG_TSEG2_SHIFT	8
+#  define CAN_DBTCFG_TSEG2_MASK					    \
+	GENMASK(CAN_DBTCFG_TSEG2_SHIFT + CAN_DBTCFG_TSEG2_BITS - 1, \
+		CAN_DBTCFG_TSEG2_SHIFT)
+#  define CAN_DBTCFG_TSEG1_BITS		5
+#  define CAN_DBTCFG_TSEG1_SHIFT	16
+#  define CAN_DBTCFG_TSEG1_MASK					    \
+	GENMASK(CAN_DBTCFG_TSEG1_SHIFT + CAN_DBTCFG_TSEG1_BITS - 1, \
+		CAN_DBTCFG_TSEG1_SHIFT)
+#  define CAN_DBTCFG_BRP_BITS		8
+#  define CAN_DBTCFG_BRP_SHIFT		24
+#  define CAN_DBTCFG_BRP_MASK					\
+	GENMASK(CAN_DBTCFG_BRP_SHIFT + CAN_DBTCFG_BRP_BITS - 1, \
+		CAN_DBTCFG_BRP_SHIFT)
+#define CAN_TDC				CAN_SFR_BASE(0x0C)
+#  define CAN_TDC_TDCV_BITS		5
+#  define CAN_TDC_TDCV_SHIFT		0
+#  define CAN_TDC_TDCV_MASK					\
+	GENMASK(CAN_TDC_TDCV_SHIFT + CAN_TDC_TDCV_BITS - 1, \
+		CAN_TDC_TDCV_SHIFT)
+#  define CAN_TDC_TDCO_BITS		5
+#  define CAN_TDC_TDCO_SHIFT		8
+#  define CAN_TDC_TDCO_MASK					\
+	GENMASK(CAN_TDC_TDCO_SHIFT + CAN_TDC_TDCO_BITS - 1, \
+		CAN_TDC_TDCO_SHIFT)
+#  define CAN_TDC_TDCMOD_BITS		2
+#  define CAN_TDC_TDCMOD_SHIFT		16
+#  define CAN_TDC_TDCMOD_MASK					\
+	GENMASK(CAN_TDC_TDCMOD_SHIFT + CAN_TDC_TDCMOD_BITS - 1, \
+		CAN_TDC_TDCMOD_SHIFT)
+#  define CAN_TDC_SID11EN		BIT(24)
+#  define CAN_TDC_EDGFLTEN		BIT(25)
+#define CAN_TBC				CAN_SFR_BASE(0x10)
+#define CAN_TSCON			CAN_SFR_BASE(0x14)
+#  define CAN_TSCON_TBCPRE_BITS		10
+#  define CAN_TSCON_TBCPRE_SHIFT	0
+#  define CAN_TSCON_TBCPRE_MASK					    \
+	GENMASK(CAN_TSCON_TBCPRE_SHIFT + CAN_TSCON_TBCPRE_BITS - 1, \
+		CAN_TSCON_TBCPRE_SHIFT)
+#  define CAN_TSCON_TBCEN		BIT(16)
+#  define CAN_TSCON_TSEOF		BIT(17)
+#  define CAN_TSCON_TSRES		BIT(18)
+#define CAN_VEC				CAN_SFR_BASE(0x18)
+#  define CAN_VEC_ICODE_BITS		7
+#  define CAN_VEC_ICODE_SHIFT		0
+#  define CAN_VEC_ICODE_MASK					    \
+	GENMASK(CAN_VEC_ICODE_SHIFT + CAN_VEC_ICODE_BITS - 1,	    \
+		CAN_VEC_ICODE_SHIFT)
+#  define CAN_VEC_FILHIT_BITS		5
+#  define CAN_VEC_FILHIT_SHIFT		8
+#  define CAN_VEC_FILHIT_MASK					\
+	GENMASK(CAN_VEC_FILHIT_SHIFT + CAN_VEC_FILHIT_BITS - 1, \
+		CAN_VEC_FILHIT_SHIFT)
+#  define CAN_VEC_TXCODE_BITS		7
+#  define CAN_VEC_TXCODE_SHIFT		16
+#  define CAN_VEC_TXCODE_MASK					\
+	GENMASK(CAN_VEC_TXCODE_SHIFT + CAN_VEC_TXCODE_BITS - 1, \
+		CAN_VEC_TXCODE_SHIFT)
+#  define CAN_VEC_RXCODE_BITS		7
+#  define CAN_VEC_RXCODE_SHIFT		24
+#  define CAN_VEC_RXCODE_MASK					\
+	GENMASK(CAN_VEC_RXCODE_SHIFT + CAN_VEC_RXCODE_BITS - 1, \
+		CAN_VEC_RXCODE_SHIFT)
+#define CAN_INT				CAN_SFR_BASE(0x1C)
+#  define CAN_INT_IF_SHIFT		0
+#  define CAN_INT_TXIF			BIT(0)
+#  define CAN_INT_RXIF			BIT(1)
+#  define CAN_INT_TBCIF			BIT(2)
+#  define CAN_INT_MODIF			BIT(3)
+#  define CAN_INT_TEFIF			BIT(4)
+#  define CAN_INT_ECCIF			BIT(8)
+#  define CAN_INT_SPICRCIF		BIT(9)
+#  define CAN_INT_TXATIF		BIT(10)
+#  define CAN_INT_RXOVIF		BIT(11)
+#  define CAN_INT_SERRIF		BIT(12)
+#  define CAN_INT_CERRIF		BIT(13)
+#  define CAN_INT_WAKIF			BIT(14)
+#  define CAN_INT_IVMIF			BIT(15)
+#  define CAN_INT_IF_MASK		\
+	(CAN_INT_TXIF |			\
+	 CAN_INT_RXIF |			\
+	 CAN_INT_TBCIF	|		\
+	 CAN_INT_MODIF	|		\
+	 CAN_INT_TEFIF	|		\
+	 CAN_INT_ECCIF	|		\
+	 CAN_INT_SPICRCIF |		\
+	 CAN_INT_TXATIF |		\
+	 CAN_INT_RXOVIF |		\
+	 CAN_INT_CERRIF |		\
+	 CAN_INT_SERRIF |		\
+	 CAN_INT_WAKEIF |		\
+	 CAN_INT_IVMIF)
+#  define CAN_INT_IE_SHIFT		16
+#  define CAN_INT_TXIE			(CAN_INT_TXIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_RXIE			(CAN_INT_RXIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_TBCIE			(CAN_INT_TBCIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_MODIE			(CAN_INT_MODIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_TEFIE			(CAN_INT_TEFIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_ECCIE			(CAN_INT_ECCIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_SPICRCIE		\
+	(CAN_INT_SPICRCIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_TXATIE		(CAN_INT_TXATIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_RXOVIE		(CAN_INT_RXOVIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_CERRIE		(CAN_INT_CERRIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_SERRIE		(CAN_INT_SERRIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_WAKIE			(CAN_INT_WAKIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_IVMIE			(CAN_INT_IVMIF << CAN_INT_IE_SHIFT)
+#  define CAN_INT_IE_MASK		\
+	(CAN_INT_TXIE |			\
+	 CAN_INT_RXIE |			\
+	 CAN_INT_TBCIE	|		\
+	 CAN_INT_MODIE	|		\
+	 CAN_INT_TEFIE	|		\
+	 CAN_INT_ECCIE	|		\
+	 CAN_INT_SPICRCIE |		\
+	 CAN_INT_TXATIE |		\
+	 CAN_INT_RXOVIE |		\
+	 CAN_INT_CERRIE |		\
+	 CAN_INT_SERRIE |		\
+	 CAN_INT_WAKEIE |		\
+	 CAN_INT_IVMIE)
+#define CAN_RXIF			CAN_SFR_BASE(0x20)
+#define CAN_TXIF			CAN_SFR_BASE(0x24)
+#define CAN_RXOVIF			CAN_SFR_BASE(0x28)
+#define CAN_TXATIF			CAN_SFR_BASE(0x2C)
+#define CAN_TXREQ			CAN_SFR_BASE(0x30)
+#define CAN_TREC			CAN_SFR_BASE(0x34)
+#  define CAN_TREC_REC_BITS		8
+#  define CAN_TREC_REC_SHIFT		0
+#  define CAN_TREC_REC_MASK				    \
+	GENMASK(CAN_TREC_REC_SHIFT + CAN_TREC_REC_BITS - 1, \
+		CAN_TREC_REC_SHIFT)
+#  define CAN_TREC_TEC_BITS		8
+#  define CAN_TREC_TEC_SHIFT		8
+#  define CAN_TREC_TEC_MASK				    \
+	GENMASK(CAN_TREC_TEC_SHIFT + CAN_TREC_TEC_BITS - 1, \
+		CAN_TREC_TEC_SHIFT)
+#  define CAN_TREC_EWARN		BIT(16)
+#  define CAN_TREC_RXWARN		BIT(17)
+#  define CAN_TREC_TXWARN		BIT(18)
+#  define CAN_TREC_RXBP			BIT(19)
+#  define CAN_TREC_TXBP			BIT(20)
+#  define CAN_TREC_TXBO			BIT(21)
+#define CAN_BDIAG0			CAN_SFR_BASE(0x38)
+#  define CAN_BDIAG0_NRERRCNT_BITS	8
+#  define CAN_BDIAG0_NRERRCNT_SHIFT	0
+#  define CAN_BDIAG0_NRERRCNT_MASK				\
+	GENMASK(CAN_BDIAG0_NRERRCNT_SHIFT + CAN_BDIAG0_NRERRCNT_BITS - 1, \
+		CAN_BDIAG0_NRERRCNT_SHIFT)
+#  define CAN_BDIAG0_NTERRCNT_BITS	8
+#  define CAN_BDIAG0_NTERRCNT_SHIFT	8
+#  define CAN_BDIAG0_NTERRCNT_MASK					\
+	GENMASK(CAN_BDIAG0_NTERRCNT_SHIFT + CAN_BDIAG0_NTERRCNT_BITS - 1, \
+		CAN_BDIAG0_NTERRCNT_SHIFT)
+#  define CAN_BDIAG0_DRERRCNT_BITS	8
+#  define CAN_BDIAG0_DRERRCNT_SHIFT	16
+#  define CAN_BDIAG0_DRERRCNT_MASK					\
+	GENMASK(CAN_BDIAG0_DRERRCNT_SHIFT + CAN_BDIAG0_DRERRCNT_BITS - 1, \
+		CAN_BDIAG0_DRERRCNT_SHIFT)
+#  define CAN_BDIAG0_DTERRCNT_BITS	8
+#  define CAN_BDIAG0_DTERRCNT_SHIFT	24
+#  define CAN_BDIAG0_DTERRCNT_MASK					\
+	GENMASK(CAN_BDIAG0_DTERRCNT_SHIFT + CAN_BDIAG0_DTERRCNT_BITS - 1, \
+		CAN_BDIAG0_DTERRCNT_SHIFT)
+#define CAN_BDIAG1			CAN_SFR_BASE(0x3C)
+#  define CAN_BDIAG1_EFMSGCNT_BITS	16
+#  define CAN_BDIAG1_EFMSGCNT_SHIFT	0
+#  define CAN_BDIAG1_EFMSGCNT_MASK					\
+	GENMASK(CAN_BDIAG1_EFMSGCNT_SHIFT + CAN_BDIAG1_EFMSGCNT_BITS - 1, \
+		CAN_BDIAG1_EFMSGCNT_SHIFT)
+#  define CAN_BDIAG1_NBIT0ERR		BIT(16)
+#  define CAN_BDIAG1_NBIT1ERR		BIT(17)
+#  define CAN_BDIAG1_NACKERR		BIT(18)
+#  define CAN_BDIAG1_NSTUFERR		BIT(19)
+#  define CAN_BDIAG1_NFORMERR		BIT(20)
+#  define CAN_BDIAG1_NCRCERR		BIT(21)
+#  define CAN_BDIAG1_TXBOERR		BIT(23)
+#  define CAN_BDIAG1_DBIT0ERR		BIT(24)
+#  define CAN_BDIAG1_DBIT1ERR		BIT(25)
+#  define CAN_BDIAG1_DFORMERR		BIT(27)
+#  define CAN_BDIAG1_DSTUFERR		BIT(28)
+#  define CAN_BDIAG1_DCRCERR		BIT(29)
+#  define CAN_BDIAG1_ESI		BIT(30)
+#  define CAN_BDIAG1_DLCMM		BIT(31)
+#define CAN_TEFCON			CAN_SFR_BASE(0x40)
+#  define CAN_TEFCON_TEFNEIE		BIT(0)
+#  define CAN_TEFCON_TEFHIE		BIT(1)
+#  define CAN_TEFCON_TEFFIE		BIT(2)
+#  define CAN_TEFCON_TEFOVIE		BIT(3)
+#  define CAN_TEFCON_TEFTSEN		BIT(5)
+#  define CAN_TEFCON_UINC		BIT(8)
+#  define CAN_TEFCON_FRESET		BIT(10)
+#  define CAN_TEFCON_FSIZE_BITS		5
+#  define CAN_TEFCON_FSIZE_SHIFT	24
+#  define CAN_TEFCON_FSIZE_MASK					    \
+	GENMASK(CAN_TEFCON_FSIZE_SHIFT + CAN_TEFCON_FSIZE_BITS - 1, \
+		CAN_TEFCON_FSIZE_SHIFT)
+#define CAN_TEFSTA			CAN_SFR_BASE(0x44)
+#  define CAN_TEFSTA_TEFNEIF		BIT(0)
+#  define CAN_TEFSTA_TEFHIF		BIT(1)
+#  define CAN_TEFSTA_TEFFIF		BIT(2)
+#  define CAN_TEFSTA_TEVOVIF		BIT(3)
+#define CAN_TEFUA			CAN_SFR_BASE(0x48)
+#define CAN_RESERVED			CAN_SFR_BASE(0x4C)
+#define CAN_TXQCON			CAN_SFR_BASE(0x50)
+#  define CAN_TXQCON_TXQNIE		BIT(0)
+#  define CAN_TXQCON_TXQEIE		BIT(2)
+#  define CAN_TXQCON_TXATIE		BIT(4)
+#  define CAN_TXQCON_TXEN		BIT(7)
+#  define CAN_TXQCON_UINC		BIT(8)
+#  define CAN_TXQCON_TXREQ		BIT(9)
+#  define CAN_TXQCON_FRESET		BIT(10)
+#  define CAN_TXQCON_TXPRI_BITS		5
+#  define CAN_TXQCON_TXPRI_SHIFT	16
+#  define CAN_TXQCON_TXPRI_MASK					    \
+	GENMASK(CAN_TXQCON_TXPRI_SHIFT + CAN_TXQCON_TXPRI_BITS - 1, \
+		CAN_TXQCON_TXPRI_SHIFT)
+#  define CAN_TXQCON_TXAT_BITS		2
+#  define CAN_TXQCON_TXAT_SHIFT		21
+#  define CAN_TXQCON_TXAT_MASK					    \
+	GENMASK(CAN_TXQCON_TXAT_SHIFT + CAN_TXQCON_TXAT_BITS - 1, \
+		CAN_TXQCON_TXAT_SHIFT)
+#  define CAN_TXQCON_FSIZE_BITS		5
+#  define CAN_TXQCON_FSIZE_SHIFT	24
+#  define CAN_TXQCON_FSIZE_MASK					    \
+	GENMASK(CAN_TXQCON_FSIZE_SHIFT + CAN_TXQCON_FSIZE_BITS - 1, \
+		CAN_TXQCON_FSIZE_SHIFT)
+#  define CAN_TXQCON_PLSIZE_BITS	3
+#  define CAN_TXQCON_PLSIZE_SHIFT	29
+#  define CAN_TXQCON_PLSIZE_MASK				      \
+	GENMASK(CAN_TXQCON_PLSIZE_SHIFT + CAN_TXQCON_PLSIZE_BITS - 1, \
+		CAN_TXQCON_PLSIZE_SHIFT)
+#    define CAN_TXQCON_PLSIZE_8		0
+#    define CAN_TXQCON_PLSIZE_12	1
+#    define CAN_TXQCON_PLSIZE_16	2
+#    define CAN_TXQCON_PLSIZE_20	3
+#    define CAN_TXQCON_PLSIZE_24	4
+#    define CAN_TXQCON_PLSIZE_32	5
+#    define CAN_TXQCON_PLSIZE_48	6
+#    define CAN_TXQCON_PLSIZE_64	7
+
+#define CAN_TXQSTA			CAN_SFR_BASE(0x54)
+#  define CAN_TXQSTA_TXQNIF		BIT(0)
+#  define CAN_TXQSTA_TXQEIF		BIT(2)
+#  define CAN_TXQSTA_TXATIF		BIT(4)
+#  define CAN_TXQSTA_TXERR		BIT(5)
+#  define CAN_TXQSTA_TXLARB		BIT(6)
+#  define CAN_TXQSTA_TXABT		BIT(7)
+#  define CAN_TXQSTA_TXQCI_BITS		5
+#  define CAN_TXQSTA_TXQCI_SHIFT	8
+#  define CAN_TXQSTA_TXQCI_MASK					    \
+	GENMASK(CAN_TXQSTA_TXQCI_SHIFT + CAN_TXQSTA_TXQCI_BITS - 1, \
+		CAN_TXQSTA_TXQCI_SHIFT)
+
+#define CAN_TXQUA			CAN_SFR_BASE(0x58)
+#define CAN_FIFOCON(x)			CAN_SFR_BASE(0x5C + 12 * (x - 1))
+#define CAN_FIFOCON_TFNRFNIE		BIT(0)
+#define CAN_FIFOCON_TFHRFHIE		BIT(1)
+#define CAN_FIFOCON_TFERFFIE		BIT(2)
+#define CAN_FIFOCON_RXOVIE		BIT(3)
+#define CAN_FIFOCON_TXATIE		BIT(4)
+#define CAN_FIFOCON_RXTSEN		BIT(5)
+#define CAN_FIFOCON_RTREN		BIT(6)
+#define CAN_FIFOCON_TXEN		BIT(7)
+#define CAN_FIFOCON_UINC		BIT(8)
+#define CAN_FIFOCON_TXREQ		BIT(9)
+#define CAN_FIFOCON_FRESET		BIT(10)
+#  define CAN_FIFOCON_TXPRI_BITS	5
+#  define CAN_FIFOCON_TXPRI_SHIFT	16
+#  define CAN_FIFOCON_TXPRI_MASK					\
+	GENMASK(CAN_FIFOCON_TXPRI_SHIFT + CAN_FIFOCON_TXPRI_BITS - 1,	\
+		CAN_FIFOCON_TXPRI_SHIFT)
+#  define CAN_FIFOCON_TXAT_BITS		2
+#  define CAN_FIFOCON_TXAT_SHIFT	21
+#  define CAN_FIFOCON_TXAT_MASK					    \
+	GENMASK(CAN_FIFOCON_TXAT_SHIFT + CAN_FIFOCON_TXAT_BITS - 1, \
+		CAN_FIFOCON_TXAT_SHIFT)
+#  define CAN_FIFOCON_TXAT_ONE_SHOT	0
+#  define CAN_FIFOCON_TXAT_THREE_SHOT	1
+#  define CAN_FIFOCON_TXAT_UNLIMITED	2
+#  define CAN_FIFOCON_FSIZE_BITS	5
+#  define CAN_FIFOCON_FSIZE_SHIFT	24
+#  define CAN_FIFOCON_FSIZE_MASK					\
+	GENMASK(CAN_FIFOCON_FSIZE_SHIFT + CAN_FIFOCON_FSIZE_BITS - 1,	\
+		CAN_FIFOCON_FSIZE_SHIFT)
+#  define CAN_FIFOCON_PLSIZE_BITS	3
+#  define CAN_FIFOCON_PLSIZE_SHIFT	29
+#  define CAN_FIFOCON_PLSIZE_MASK					\
+	GENMASK(CAN_FIFOCON_PLSIZE_SHIFT + CAN_FIFOCON_PLSIZE_BITS - 1, \
+		CAN_FIFOCON_PLSIZE_SHIFT)
+#define CAN_FIFOSTA(x)			CAN_SFR_BASE(0x60 + 12 * (x - 1))
+#  define CAN_FIFOSTA_TFNRFNIF		BIT(0)
+#  define CAN_FIFOSTA_TFHRFHIF		BIT(1)
+#  define CAN_FIFOSTA_TFERFFIF		BIT(2)
+#  define CAN_FIFOSTA_RXOVIF		BIT(3)
+#  define CAN_FIFOSTA_TXATIF		BIT(4)
+#  define CAN_FIFOSTA_RXTSEN		BIT(5)
+#  define CAN_FIFOSTA_RTREN		BIT(6)
+#  define CAN_FIFOSTA_TXEN		BIT(7)
+#  define CAN_FIFOSTA_FIFOCI_BITS	5
+#  define CAN_FIFOSTA_FIFOCI_SHIFT	8
+#  define CAN_FIFOSTA_FIFOCI_MASK					\
+	GENMASK(CAN_FIFOSTA_FIFOCI_SHIFT + CAN_FIFOSTA_FIFOCI_BITS - 1, \
+		CAN_FIFOSTA_FIFOCI_SHIFT)
+#define CAN_FIFOUA(x)			CAN_SFR_BASE(0x64 + 12 * (x - 1))
+#define CAN_FLTCON(x)			CAN_SFR_BASE(0x1D0 + (x & 0x1c))
+#  define CAN_FILCON_SHIFT(x)		((x & 3) * 8)
+#  define CAN_FILCON_BITS(x)		4
+#  define CAN_FILCON_MASK(x)					\
+	GENMASK(CAN_FILCON_SHIFT(x) + CAN_FILCON_BITS(x) - 1,	\
+		CAN_FILCON_SHIFT(x))
+#  define CAN_FIFOCON_FLTEN(x)		BIT(7 + CAN_FILCON_SHIFT(x))
+#define CAN_FLTOBJ(x)			CAN_SFR_BASE(0x1F0 + 8 * x)
+#  define CAN_FILOBJ_SID_BITS		11
+#  define CAN_FILOBJ_SID_SHIFT		0
+#  define CAN_FILOBJ_SID_MASK					\
+	GENMASK(CAN_FILOBJ_SID_SHIFT + CAN_FILOBJ_SID_BITS - 1, \
+		CAN_FILOBJ_SID_SHIFT)
+#  define CAN_FILOBJ_EID_BITS		18
+#  define CAN_FILOBJ_EID_SHIFT		12
+#  define CAN_FILOBJ_EID_MASK					\
+	GENMASK(CAN_FILOBJ_EID_SHIFT + CAN_FILOBJ_EID_BITS - 1, \
+		CAN_FILOBJ_EID_SHIFT)
+#  define CAN_FILOBJ_SID11		BIT(29)
+#  define CAN_FILOBJ_EXIDE		BIT(30)
+#define CAN_FLTMASK(x)			CAN_SFR_BASE(0x1F4 + 8 * x)
+#  define CAN_FILMASK_MSID_BITS		11
+#  define CAN_FILMASK_MSID_SHIFT	0
+#  define CAN_FILMASK_MSID_MASK					\
+	GENMASK(CAN_FILMASK_MSID_SHIFT + CAN_FILMASK_MSID_BITS - 1, \
+		CAN_FILMASK_MSID_SHIFT)
+#  define CAN_FILMASK_MEID_BITS		18
+#  define CAN_FILMASK_MEID_SHIFT	12
+#  define CAN_FILMASK_MEID_MASK					\
+	GENMASK(CAN_FILMASK_MEID_SHIFT + CAN_FILMASK_MEID_BITS - 1, \
+		CAN_FILMASK_MEID_SHIFT)
+#  define CAN_FILMASK_MSID11		BIT(29)
+#  define CAN_FILMASK_MIDE		BIT(30)
+
+#define CAN_OBJ_ID_SID_BITS		11
+#define CAN_OBJ_ID_SID_SHIFT		0
+#define CAN_OBJ_ID_SID_MASK					\
+	GENMASK(CAN_OBJ_ID_SID_SHIFT + CAN_OBJ_ID_SID_BITS - 1, \
+		CAN_OBJ_ID_SID_SHIFT)
+#define CAN_OBJ_ID_EID_BITS		18
+#define CAN_OBJ_ID_EID_SHIFT		11
+#define CAN_OBJ_ID_EID_MASK					\
+	GENMASK(CAN_OBJ_ID_EID_SHIFT + CAN_OBJ_ID_EID_BITS - 1, \
+		CAN_OBJ_ID_EID_SHIFT)
+#define CAN_OBJ_ID_SID_BIT11		BIT(29)
+
+#define CAN_OBJ_FLAGS_DLC_BITS		4
+#define CAN_OBJ_FLAGS_DLC_SHIFT		0
+#define CAN_OBJ_FLAGS_DLC_MASK					      \
+	GENMASK(CAN_OBJ_FLAGS_DLC_SHIFT + CAN_OBJ_FLAGS_DLC_BITS - 1, \
+		CAN_OBJ_FLAGS_DLC_SHIFT)
+#define CAN_OBJ_FLAGS_IDE		BIT(4)
+#define CAN_OBJ_FLAGS_RTR		BIT(5)
+#define CAN_OBJ_FLAGS_BRS		BIT(6)
+#define CAN_OBJ_FLAGS_FDF		BIT(7)
+#define CAN_OBJ_FLAGS_ESI		BIT(8)
+#define CAN_OBJ_FLAGS_SEQ_BITS		7
+#define CAN_OBJ_FLAGS_SEQ_SHIFT		9
+#define CAN_OBJ_FLAGS_SEQ_MASK					      \
+	GENMASK(CAN_OBJ_FLAGS_SEQ_SHIFT + CAN_OBJ_FLAGS_SEQ_BITS - 1, \
+		CAN_OBJ_FLAGS_SEQ_SHIFT)
+#define CAN_OBJ_FLAGS_FILHIT_BITS	11
+#define CAN_OBJ_FLAGS_FILHIT_SHIFT	5
+#define CAN_OBJ_FLAGS_FILHIT_MASK				      \
+	GENMASK(CAN_FLAGS_FILHIT_SHIFT + CAN_FLAGS_FILHIT_BITS - 1, \
+		CAN_FLAGS_FILHIT_SHIFT)
+
+#define CAN_OBJ_FLAGS_CUSTOM_ISTEF	BIT(31)
+
+#ifdef CONFIG_SPI_IMX
+#define MCP2517_CMD_LEN		2	//See 4.0 SPI Interface, Figure 4-1;
+
+//ky_note: Structure that kept spi_transfer's original data;
+#define SPITX_BUFSZ			128
+typedef struct _spitx {
+	u16 magic;//0xABCD;
+	u16 DummyOnTop;
+	u16 DummyOnBottom;
+	u16 len;//unsigned,
+	u16	bits_per_word;//u8,
+	u16	delay_usecs;
+	u16 Reserved[2];
+	const void *tx_buf;
+	u8 TxBuf[4+SPITX_BUFSZ+4];//Dummy on Top/Bottom;
+} spitx;
+
+#define MAX_ECSPI_BURST_LEN			512		//ky_add: this value must less than following one; see ECSPIx_CONREG.BURST_LENGTH;
+#endif
+
+#define MCP2517FD_BUFFER_TXRX_SIZE 	2048
+
+static const char * const mcp2517fd_mode_names[] = {
+	[CAN_CON_MODE_MIXED] = "can2.0+canfd",
+	[CAN_CON_MODE_SLEEP] = "sleep",
+	[CAN_CON_MODE_INTERNAL_LOOPBACK] = "internal loopback",
+	[CAN_CON_MODE_LISTENONLY] = "listen only",
+	[CAN_CON_MODE_CONFIG] = "config",
+	[CAN_CON_MODE_EXTERNAL_LOOPBACK] = "external loopback",
+	[CAN_CON_MODE_CAN2_0] = "can2.0",
+	[CAN_CON_MODE_RESTRICTED] = "restricted"
+};
+
+struct mcp2517fd_obj {
+	u32 id;
+	u32 flags;
+};
+
+struct mcp2517fd_obj_tx {
+	struct mcp2517fd_obj header;
+	u32 data[];
+};
+
+static void mcp2517fd_obj_to_le(struct mcp2517fd_obj *obj)
+{
+	obj->id = cpu_to_le32(obj->id);
+	obj->flags = cpu_to_le32(obj->flags);
+}
+
+struct mcp2517fd_obj_ts {
+	u32 id;
+	u32 flags;
+	u32 ts;
+};
+
+struct mcp2517fd_obj_tef {
+	struct mcp2517fd_obj_ts header;
+};
+
+struct mcp2517fd_obj_rx {
+	struct mcp2517fd_obj_ts header;
+	u8 data[];
+};
+
+static void mcp2517fd_obj_ts_from_le(struct mcp2517fd_obj_ts *obj)
+{
+	obj->id = le32_to_cpu(obj->id);
+	obj->flags = le32_to_cpu(obj->flags);
+	obj->ts = le32_to_cpu(obj->ts);
+}
+
+#define FIFO_DATA(x)			(0x400 + (x))
+#define FIFO_DATA_SIZE			0x800
+
+static const struct can_bittiming_const mcp2517fd_nominal_bittiming_const = {
+	.name		= DEVICE_NAME,
+	.tseg1_min	= 2,
+	.tseg1_max	= BIT(CAN_NBTCFG_TSEG1_BITS),
+	.tseg2_min	= 1,
+	.tseg2_max	= BIT(CAN_NBTCFG_TSEG2_BITS),
+	.sjw_max	= BIT(CAN_NBTCFG_SJW_BITS),
+	.brp_min	= 1,
+	.brp_max	= BIT(CAN_NBTCFG_BRP_BITS),
+	.brp_inc	= 1,
+};
+
+static const struct can_bittiming_const mcp2517fd_data_bittiming_const = {
+	.name		= DEVICE_NAME,
+	.tseg1_min	= 1,
+	.tseg1_max	= BIT(CAN_DBTCFG_TSEG1_BITS),
+	.tseg2_min	= 1,
+	.tseg2_max	= BIT(CAN_DBTCFG_TSEG2_BITS),
+	.sjw_max	= BIT(CAN_DBTCFG_SJW_BITS),
+	.brp_min	= 1,
+	.brp_max	= BIT(CAN_DBTCFG_BRP_BITS),
+	.brp_inc	= 1,
+};
+
+enum mcp2517fd_model {
+	CAN_MCP2517FD	= 0x2517,
+};
+
+enum mcp2517fd_gpio_mode {
+	gpio_mode_int		= 0,
+	gpio_mode_standby	= MCP2517FD_IOCON_XSTBYEN,
+	gpio_mode_out_low	= MCP2517FD_IOCON_PM0,
+	gpio_mode_out_high	= MCP2517FD_IOCON_PM0 | MCP2517FD_IOCON_LAT0,
+	gpio_mode_in		= MCP2517FD_IOCON_PM0 | MCP2517FD_IOCON_TRIS0
+};
+
+struct mcp2517fd_trigger_tx_message {
+	struct spi_message msg;
+	struct spi_transfer fill_xfer;
+	struct spi_transfer trigger_xfer;
+	int fifo;
+	char fill_cmd[2];
+	char fill_obj[sizeof(struct mcp2517fd_obj_tx)];
+	char fill_data[64];
+	char trigger_cmd[2];
+	char trigger_data;
+};
+
+struct mcp2517fd_read_fifo_info {
+	struct mcp2517fd_obj_ts *rxb[32];
+	int rx_count;
+	u32 tsmin;
+	u32 tsmax;
+};
+
+struct mcp2517fd_priv {
+	struct can_priv	   can;
+	struct net_device *net;
+	struct spi_device *spi;
+	struct regulator *power;
+	struct regulator *transceiver;
+	struct clk *clk;
+
+	struct dentry *debugfs_dir;
+
+	/* the actual model of the mcp2517fd */
+	enum mcp2517fd_model model;
+
+	struct {
+		/* clock configuration */
+		bool clock_pll;
+		bool clock_div2;
+		int  clock_odiv;
+
+		/* GPIO configuration */
+		enum mcp2517fd_gpio_mode  gpio0_mode;
+		enum mcp2517fd_gpio_mode  gpio1_mode;
+		bool gpio_opendrain;
+		bool txcan_opendrain;
+		bool int_opendrain;
+	} config;
+
+	/* the distinct spi_speeds to use for spi communication */
+	u32 spi_setup_speed_hz;
+	u32 spi_speed_hz;
+
+	/* fifo info */
+	struct {
+		/* define payload size and mode */
+		int payload_size;
+		u32 payload_mode;
+
+		/* TEF addresses - start, end and current */
+		u32 tef_address_start;
+		u32 tef_address_end;
+		u32 tef_address;
+
+		/* address in mcp2517fd-Fifo RAM of each fifo */
+		u32 fifo_address[32];
+
+		/* infos on tx-fifos */
+		u32 tx_fifos;
+		u32 tx_fifo_start;
+		u32 tx_fifo_mask; /* bitmask of which fifo is a tx fifo */
+		u32 tx_submitted_mask;
+		u32 tx_pending_mask;
+		u32 tx_processed_mask;
+
+		/* info on rx_fifos */
+		u32 rx_fifos;
+		u32 rx_fifo_depth;
+		u32 rx_fifo_start;
+		u32 rx_fifo_mask;  /* bitmask of which fifo is a rx fifo */
+
+		/* memory image of FIFO RAM on mcp2517fd */
+		u8 fifo_data[MCP2517FD_BUFFER_TXRX_SIZE];
+
+	} fifos;
+
+	/* structure with active fifos that need to get fed to the system */
+	struct mcp2517fd_read_fifo_info queued_fifos;
+
+	/* statistics */
+	struct {
+		/* number of calls to the irq handler */
+		u64 irq_calls;
+		/* number of loops inside the irq handler */
+		u64 irq_loops;
+
+		/* interrupt handler state and statistics */
+		u32 irq_state;
+#define IRQ_STATE_NEVER_RUN 0
+#define IRQ_STATE_RUNNING 1
+#define IRQ_STATE_HANDLED 2
+		/* stats on number of rx overflows */
+		u64 rx_overflow;
+		/* statistics of FIFO usage */
+		u64 fifo_usage[32];
+	} stats;
+
+	/* the current status of the mcp2517fd */
+	struct {
+		u32 intf;
+		/* ASSERT(CAN_INT + 4 == CAN_RXIF) */
+		u32 rxif;
+		/* ASSERT(CAN_RXIF + 4 == CAN_TXIF) */
+		u32 txif;
+		/* ASSERT(CAN_TXIF + 4 == CAN_RXOVIF) */
+		u32 rxovif;
+		/* ASSERT(CAN_RXOVIF + 4 == CAN_TXATIF) */
+		u32 txatif;
+		/* ASSERT(CAN_TXATIF + 4 == CAN_TXREQ) */
+		u32 txreq;
+		/* ASSERT(CAN_TXREQ + 4 == CAN_TREC) */
+		u32 trec;
+		/* ASSERT(CAN_TREC + 4 == CAN_BDIAG0) */
+		u32 bdiag0;
+		/* ASSERT(CAN_BDIAG0 + 4 == CAN_BDIAG1) */
+		u32 bdiag1;
+	} status;
+
+	/* configuration registers */
+	struct {
+		u32 osc;
+		u32 ecccon;
+		u32 con;
+		u32 iocon;
+		u32 tdc;
+		u32 tscon;
+		u32 tefcon;
+		u32 nbtcfg;
+		u32 dbtcfg;
+	} regs;
+
+	/* interrupt handler signaling */
+	int force_quit;
+	int after_suspend;
+#define AFTER_SUSPEND_UP 1
+#define AFTER_SUSPEND_DOWN 2
+#define AFTER_SUSPEND_POWER 4
+#define AFTER_SUSPEND_RESTART 8
+	int restart_tx;
+
+	/* interrupt flags during irq handling */
+	u32 int_clear_mask;
+	u32 int_clear_value;
+	u32 bdiag1_clear_mask;
+	u32 bdiag1_clear_value;
+
+	/* composit error id and dataduring irq handling */
+	u32 can_err_id;
+	u32 can_err_data[8];
+
+	/* the current mode */
+	u32 active_can_mode;
+	u32 new_state;
+
+	/* status of the tx_queue enabled/disabled */
+	u32 tx_queue_status;
+
+	/* spi-tx/rx buffers for efficient transfers
+	 * used during setup and irq
+	 */
+	u8 spi_tx[MCP2517FD_BUFFER_TXRX_SIZE];
+	u8 spi_rx[MCP2517FD_BUFFER_TXRX_SIZE];
+
+#ifdef CONFIG_SPI_IMX
+	spitx 	SpiTxA[4];
+	u16 	SpiIdx;
+#endif
+	
+#ifdef ADLINK_DEBUG_DUMP_CUREENT_FIFO
+	u16 asyncFifoAddr;
+#endif
+
+
+	/* structure for transmit fifo spi_messages */
+	struct mcp2517fd_trigger_tx_message *spi_transmit_fifos;
+};
+
+/* module parameters */
+bool use_bulk_release_fifos;
+module_param(use_bulk_release_fifos, bool, 0664);
+MODULE_PARM_DESC(use_bulk_release_fifos,
+		 "Use code that favours longer spi transfers over multiple transfers");
+bool use_complete_fdfifo_read;
+module_param(use_complete_fdfifo_read, bool, 0664);
+MODULE_PARM_DESC(use_complete_fdfifo_read,
+		 "Use code that favours longer spi transfers over multiple transfers for fd can");
+unsigned int tx_fifos;
+module_param(tx_fifos, uint, 0664);
+MODULE_PARM_DESC(tx_fifos,
+		 "Number of tx-fifos to configure\n");
+unsigned int bw_sharing_log2bits;
+module_param(bw_sharing_log2bits, uint, 0664);
+MODULE_PARM_DESC(bw_sharing_log2bits,
+		 "Delay between 2 transmissions in number of arbitration bit times\n");
+
+
+#ifdef CONFIG_SPI_IMX
+//const int ky_test_bypass=0;
+//ky_note: This function will make sure the tx_buf in u8* type, can send out from [0] to [n-1] in the correct bytes sequence;
+//We need to swap the contain of the data only if it was packing by u8* but send as u16/u32 type;
+//More specific said: If we packing data by u32 then send as u32, in this case, it will fine;
+static void pre_job_for_imx_ecspi (struct mcp2517fd_priv *priv,struct spi_transfer *t)
+{
+	int i,len=t->len;
+	//if(ky_test_bypass) return;
+	
+	if(!len || !t->tx_buf) {
+		dev_info(&priv->spi->dev,"%s(): Empty buffer?\n",__func__);
+	}
+	else if(MAX_ECSPI_BURST_LEN<=len) {//Refer: 10.1.7.3, ECSPIx_CONREG[31:20],
+		dev_err(&priv->spi->dev,"error! %s() un-support length=%d\n",__func__,len);
+	}
+	else {
+		int dummy=0;
+		spitx *SpiTx=&priv->SpiTxA[priv->SpiIdx];
+		u8 *TxBuf=SpiTx->TxBuf;
+		if(ARRAY_SIZE(priv->SpiTxA)==++priv->SpiIdx) priv->SpiIdx=0;
+		ASSERT(SpiTx->magic||MCP2517_CMD_LEN+SPITX_BUFSZ<len);
+		//Kept current data:
+		SpiTx->magic=0xABCD;
+		SpiTx->len=(u16)t->len;
+		SpiTx->bits_per_word=t->bits_per_word;
+		SpiTx->delay_usecs=t->delay_usecs;
+		SpiTx->tx_buf=t->tx_buf;
+		
+		//ky_note: We copy data to another buffer becasue tx_buf is const type;
+		//ky_note: __spi_validate() ask for 1x/2x/4x of bytes, means "(len*8)%bits_per_word" must be 0;
+		if(len<4) {
+			t->bits_per_word=len*8;//8,16, or 24;
+			if(3==len) {//24 bits, : Refer iMX8 10.1.7.2 ECSPIx_TXDATA, should shift the contain;
+				//Padding on top...
+				dummy=1;
+				TxBuf[0]=0xAD;
+				memcpy(&TxBuf[dummy],t->tx_buf,len);
+				t->len+=dummy;
+				*(u32 *)TxBuf=cpu_to_be32(*(u32 *)TxBuf);
+				//ky_note: bits_per_word=24, len=4(32bits);
+			}
+			else if(2==len) {//16 bits command;
+				*(u16 *)TxBuf=cpu_to_be16(*(u16 *)t->tx_buf);
+			}
+			else {//ky_note: u8 size is OK;
+				TxBuf[0]=*(u8 *)t->tx_buf;
+			}
+		}
+		else {
+			//ky_note: delay_usecs will be checked only if bits_per_word=32;
+			t->bits_per_word=32;
+			if(0<(i=len%4)) {//we muts append dummy data to fit u32 alignment;
+				dummy=4-i;
+				//Shift contains, dummy bytes should on first DWORD, and on msB side; see 10.1.7.2 ECSPIx_TXDATA;
+				//Padding on top:
+				memset(TxBuf,0xAD,dummy);
+				memcpy(&TxBuf[dummy],t->tx_buf,len);
+				t->len+=dummy;
+				t->delay_usecs=dummy;//ky_add: Special setting for size check; The side effect will happen if user need some delays;
+			} //ky_note: delay_usecs will affect only if(32==bits_per_word && 0<delay_usecs<4);
+			else {
+				i=t->delay_usecs; Link2(spi_imx_setupxfer);
+				if(0<i && i<4) t->delay_usecs=4;//Keep user's delay time plus a little more; delay_usecs<4 will trigger ADLINK_ENABLE_BURST_LENGTH;
+				memcpy(TxBuf,t->tx_buf,len);
+			}
+			
+			//From little-endian(x86) to big-endian:
+			for(i=0;i<t->len;i+=4) {
+				*(u32 *)&TxBuf[i]=cpu_to_be32(*(u32 *)&TxBuf[i]);
+			}
+		}
+		t->tx_buf=TxBuf;	
+		SpiTx->DummyOnTop=dummy;
+	}
+}
+
+//ky_note: This function will transfer the rx_buf in the correct receiving sequence in u8* type;
+//The contain of rx_buf will be the same byte-sequences that we see from scope;
+static void post_job_for_imx_ecspi (struct mcp2517fd_priv *priv,struct spi_transfer *t)
+{
+	spitx *SpiTx;
+	//ky_note: spi_transfer did not distinguish tx_len/rx_len. For mcp2517fd case, the two command bytes always exist.
+	//if(ky_test_bypass) return;
+
+	SpiTx=container_of(t->tx_buf,spitx,TxBuf);
+	ASSERT(0xABCD!=SpiTx->magic);
+	SpiTx->magic=0;
+	
+	if(t->rx_buf) {
+		u32 *p;
+		int i,len=t->len;//ky_note: This length including dummy data;
+		for(p=t->rx_buf,i=0;i<len;i+=4,++p) {
+			*p=cpu_to_be32(*p);
+		}
+		i=SpiTx->DummyOnTop+MCP2517_CMD_LEN;
+		memcpy(t->rx_buf,&((u8 *)t->rx_buf)[i],len-i);
+	}
+
+	//Restore data:
+	t->len=SpiTx->len;
+	t->bits_per_word=(u8)SpiTx->bits_per_word;
+	t->delay_usecs=SpiTx->delay_usecs;
+	t->tx_buf=SpiTx->tx_buf;		
+}
+
+#else
+#define pre_job_for_imx_ecspi(p,t) ;
+#define post_job_for_imx_ecspi(p,t) ;
+#endif
+
+/* spi sync helper */
+
+/* wrapper arround spi_sync, that sets speed_hz */
+static int mcp2517fd_sync_transfer (struct spi_device *spi,
+				   struct spi_transfer *xfer,unsigned int xfers,int speed_hz)
+{
+	int i;
+#ifdef CONFIG_SPI_IMX
+	struct mcp2517fd_priv *priv=spi_get_drvdata(spi);
+	for(i=0;i<xfers;++i) {
+		int ret;
+		struct spi_message m;
+		struct spi_transfer *t=&xfer[i];
+		
+		t->speed_hz=speed_hz;
+		spi_message_init(&m);
+		spi_message_add_tail(t,&m);
+		
+		pre_job_for_imx_ecspi(priv,t);
+		if((ret=spi_sync(spi,&m))<0) {
+			dev_err(&spi->dev,"error! %d=spi_sync()\n",ret);	
+		}
+		post_job_for_imx_ecspi(priv,t);
+	}
+	return 0;
+#else
+	for (i = 0; i < xfers; i++)
+		xfer[i].speed_hz = speed_hz;
+
+	return spi_sync_transfer(spi, xfer, xfers);
+#endif	
+}
+
+/* an optimization of spi_write_then_read that merges the transfers */
+static int mcp2517fd_write_then_read(struct spi_device *spi,
+				     const void *tx_buf,
+				     unsigned int tx_len,
+				     void *rx_buf,
+				     unsigned int rx_len,
+				     int speed_hz)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct spi_transfer xfer[2];
+	int ret;
+	
+	memset(xfer, 0, sizeof(xfer));
+	
+	/* when using a halfduplex controller or to big for buffer */
+	if ((spi->master->flags & SPI_MASTER_HALF_DUPLEX) ||
+	    (tx_len + rx_len > sizeof(priv->spi_tx))) {
+efl_	xfer[0].tx_buf = tx_buf;
+		xfer[0].len = tx_len;
+
+		xfer[1].rx_buf = rx_buf;
+		xfer[1].len = rx_len;
+
+		return mcp2517fd_sync_transfer(spi, xfer, 2, speed_hz);
+	}
+
+	/* full duplex optimization */
+	xfer[0].tx_buf = priv->spi_tx;
+	xfer[0].rx_buf = priv->spi_rx;
+	xfer[0].len = tx_len + rx_len;
+
+	/* copy and clean */
+	memcpy(priv->spi_tx, tx_buf, tx_len);
+	memset(priv->spi_tx + tx_len, 0, rx_len);
+
+	ret = mcp2517fd_sync_transfer(spi, xfer, 1, speed_hz);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_SPI_IMX
+	memcpy(rx_buf,priv->spi_rx,rx_len);
+#else
+	memcpy(rx_buf, priv->spi_rx + tx_len, rx_len);
+#endif
+
+	return 0;
+}
+
+/* simple spi_write wrapper with speed_hz */
+static int mcp2517fd_write(struct spi_device *spi,
+			   const void *tx_buf,
+			   unsigned int tx_len,
+			   int speed_hz)
+{
+	struct spi_transfer xfer;
+
+	memset(&xfer, 0, sizeof(xfer));
+	xfer.tx_buf = tx_buf;
+	xfer.len = tx_len;
+
+	return mcp2517fd_sync_transfer(spi, &xfer, 1, speed_hz);
+}
+
+/* spi_sync wrapper similar to spi_write_then_read that optimizes transfers */
+static int mcp2517fd_write_then_write(struct spi_device *spi,
+				      const void *tx_buf,
+				      unsigned int tx_len,
+				      const void *tx2_buf,
+				      unsigned int tx2_len,
+				      int speed_hz)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct spi_transfer xfer;
+
+	if (tx_len + tx2_len > MCP2517FD_BUFFER_TXRX_SIZE)
+		return -EINVAL;
+
+	memset(&xfer, 0, sizeof(xfer));
+	xfer.len = tx_len + tx2_len;
+	xfer.tx_buf = priv->spi_tx;
+
+	memcpy(priv->spi_tx, tx_buf, tx_len);
+	memcpy(priv->spi_tx + tx_len, tx2_buf, tx2_len);
+
+	return mcp2517fd_sync_transfer(spi, &xfer, 1, speed_hz);
+}
+
+/* mcp2517fd spi command/protocol helper */
+
+static void mcp2517fd_calc_cmd_addr(u16 cmd, u16 addr, u8 *data)
+{
+	cmd = cmd | (addr & ADDRESS_MASK);
+
+	data[0] = (cmd >> 8) & 0xff;
+	data[1] = (cmd >> 0) & 0xff;
+}
+
+static int mcp2517fd_cmd_reset(struct spi_device *spi, u32 speed_hz)
+{
+	u8 cmd[2];
+
+	mcp2517fd_calc_cmd_addr(INSTRUCTION_RESET, 0, cmd);
+
+	/* write the reset command */
+	return mcp2517fd_write(spi, cmd, 2, speed_hz);
+}
+
+/* read multiple bytes, transform some registers */
+static int mcp2517fd_cmd_readn(struct spi_device *spi, u32 reg,
+			       void *data, int n, u32 speed_hz)
+{
+	u8 cmd[2];
+	int ret;
+
+	mcp2517fd_calc_cmd_addr(INSTRUCTION_READ, reg, cmd);
+
+	ret = mcp2517fd_write_then_read(spi, &cmd, 2, data, n, speed_hz);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+#define MCP_READ_CMD	(3<<12)
+#define MCP_WRITE_CMD	(2<<12)
+
+#define MCP_RAM_BEGIN	0x400
+#define MCP_RAM_END		0xC00
+
+#ifdef ADLINK_DEBUG
+static void DumpBufA (u8 *buf,int cnt,int LF,int addr) {
+	u8 BufA[1024];
+	int i,s;
+	if(addr<0) addr=0;
+	s=sprintf(BufA,"Dump%03X:\t",addr);
+	for(i=0;i<cnt;++i,++addr) {
+		if(i && !(i%LF)) s+=sprintf(&BufA[s],"\n    %03X:\t",addr);
+		s+=sprintf(&BufA[s],"0x%02X ",buf[i]);
+	}
+	printk(KERN_NOTICE "%s\n",BufA);
+}
+
+static void PackMcpCommand (u8 *TxBuf,int ShiftCmd,int addr) {
+	u16 cmd=ShiftCmd|addr;//Two bytes Write Command;
+	TxBuf[0]=(u8)(cmd>>8);
+	TxBuf[1]=(u8)(cmd>>0);
+}
+static void SpiQuickDump (struct mcp2517fd_priv *priv,u16 addr,u16 len) {
+	u16 cmd;
+	u8 TxBuf[MCP2517_CMD_LEN],RxBuf[256];
+	ASSERT(sizeof(RxBuf)<len);
+	cmd=MCP_READ_CMD|(0xFFF & addr);
+	TxBuf[0]=(u8)(cmd>>8);
+	TxBuf[1]=(u8)(cmd>>0);
+	if(0x400<=addr && addr<0xC00) {//Should be DWORD alignment;
+		len=(len+3)&~3;
+	}
+	mcp2517fd_write_then_read(priv->spi,TxBuf,MCP2517_CMD_LEN,RxBuf,len,priv->spi_speed_hz);
+	DumpBufA(RxBuf,len,16,addr);
+}
+
+#define DUMP_TEFCON		101
+#define DUMP_C1CON		110
+#define DUMP_C1VEC		120
+#define DUMP_FIFO		200
+#define DUMP_FSR		310
+void McpReadWriteTest (struct spi_device *spi,int TestCase) {
+	struct mcp2517fd_priv *priv=spi_get_drvdata(spi);
+	u32 speed=priv->spi_speed_hz;
+	u8 TxBuf[520],RxBuf[520];
+	int cmd,i,j,addr,len;
+	int RamAddr=MCP_RAM_BEGIN+0x500;
+	//Clear buffer before tests:
+	memset(TxBuf,0x00,sizeof(TxBuf));
+	memset(RxBuf,0xCC,sizeof(RxBuf));
+	if(1==TestCase) {//Write '0' -'9' to Ram Top;
+		cmd=MCP_WRITE_CMD|RamAddr;//Two bytes Write Command;
+		TxBuf[0]=(u8)(cmd>>8);
+		TxBuf[1]=(u8)(cmd>>0);
+		for(i=MCP2517_CMD_LEN,j=0;j<128;++j,++i) {
+			TxBuf[i]=j;
+		}
+		j=128;//May change this to any 4*N;
+		mcp2517fd_write(spi,TxBuf,MCP2517_CMD_LEN+j,speed);
+	}
+	else if(2==TestCase) {//Read from Ram Top;
+		cmd=MCP_READ_CMD|RamAddr;//Two bytes Write Command;
+		TxBuf[0]=(u8)(cmd>>8);
+		TxBuf[1]=(u8)(cmd>>0);
+		j=132;
+		mcp2517fd_write_then_read(spi,TxBuf,MCP2517_CMD_LEN,RxBuf,j,speed);
+		DumpBufA(RxBuf,j,16,RamAddr);
+	}
+	else if(3==TestCase) {//Read from addr ;04=0F,0F,3E,00,
+		addr=0x004;
+		PackMcpCommand(TxBuf,MCP_READ_CMD,addr);
+		len=4;//Could be 0~N
+		mcp2517fd_write_then_read(spi,TxBuf,MCP2517_CMD_LEN,RxBuf,len,speed);
+		DumpBufA(priv->spi_rx,14,16,addr);
+		DumpBufA(RxBuf,len,16,addr);
+	}
+	else if(10==TestCase) {//Write 'A'=0x41 - 'Z'=0x5A to Ram Top+0x100; 
+		cmd=MCP_WRITE_CMD|(MCP_RAM_BEGIN+0x100);//Two bytes Write Command;
+		TxBuf[0]=(u8)(cmd>>8);
+		TxBuf[1]=(u8)(cmd>>0);
+		for(i=2,j='A';j<='Z';++j,++i) {
+			TxBuf[i]=(u8)j;
+		}
+		mcp2517fd_write(spi,TxBuf,i,speed);
+	}
+	else if(100==TestCase) {
+		cmd=MCP_READ_CMD|0x1C;//Two bytes Write Command;
+		TxBuf[0]=(u8)(cmd>>8);
+		TxBuf[1]=(u8)(cmd>>0);
+		j=48;
+		mcp2517fd_write_then_read(spi,TxBuf,MCP2517_CMD_LEN,RxBuf,j,speed);
+		DumpBufA(RxBuf,j,16,0x1C);
+	}
+	else if(DUMP_TEFCON==TestCase) {
+		addr=0x40;
+		len=12;
+		cmd=MCP_READ_CMD|addr;
+		TxBuf[0]=(u8)(cmd>>8);
+		TxBuf[1]=(u8)(cmd>>0);
+		mcp2517fd_write_then_read(spi,TxBuf,MCP2517_CMD_LEN,RxBuf,len,speed);
+		DumpBufA(RxBuf,len,16,addr);
+	}
+	else if(DUMP_C1CON==TestCase) {
+		SpiQuickDump(priv,CAN_CON,32);		
+	}
+	else if(DUMP_C1VEC==TestCase) {
+		SpiQuickDump(priv,CAN_VEC,4);		
+	}
+	else if(DUMP_FIFO<=TestCase && TestCase<=DUMP_FIFO+31) {//Read FIFO Regs, index=0-31;
+		int fifo=TestCase-DUMP_FIFO;
+		SpiQuickDump(priv,CAN_FIFOCON(fifo),12);		
+	}
+	else if(DUMP_FSR==TestCase) {
+		SpiQuickDump(priv,0xE00,20);		
+		SpiQuickDump(priv,0x000,128);		
+		SpiQuickDump(priv,0x080,128);		
+		SpiQuickDump(priv,0x100,128);		
+		SpiQuickDump(priv,0x180,128);		
+	}
+	else if(0==TestCase) {
+	}
+	
+}
+#endif
+
+
+static int mcp2517fd_convert_to_cpu(u32 *data, int n)
+{
+	int i;
+
+	for (i = 0; i < n; i++)
+		data[i] = le32_to_cpu(data[i]);
+
+	return 0;
+}
+
+/* read a register, but we are only interrested in a few bytes */
+static int mcp2517fd_cmd_read_mask(struct spi_device *spi, u32 reg,
+				   u32 *data, u32 mask, u32 speed_hz)
+{
+	int first_byte, last_byte, len_byte;
+	int ret;
+
+	/* check that at least one bit is set */
+	if (!mask)
+		return -EINVAL;
+
+	/* calculate first and last byte used */
+	first_byte = (ffs(mask) - 1) >> 3;
+	last_byte = (fls(mask) - 1) >> 3;
+	len_byte = last_byte - first_byte + 1;
+
+	/* do a partial read */
+	*data = 0;
+	ret = mcp2517fd_cmd_readn(spi, reg,
+				  ((void *)data + first_byte), len_byte,
+				  speed_hz);
+	if (ret)
+		return ret;
+
+	return mcp2517fd_convert_to_cpu(data, 1);
+}
+
+static int mcp2517fd_cmd_read(struct spi_device *spi, u32 reg, u32 *data,
+			      u32 speed_hz)
+{
+	return mcp2517fd_cmd_read_mask(spi, reg, data, -1, speed_hz);
+}
+
+/* read a register, but we are only interrested in a few bytes */
+static int mcp2517fd_cmd_write_mask(struct spi_device *spi, u32 reg,
+				    u32 data, u32 mask, u32 speed_hz)
+{
+	int first_byte, last_byte, len_byte;
+	u8 cmd[2];
+
+	/* check that at least one bit is set */
+	if (!mask)
+		return -EINVAL;
+
+	/* calculate first and last byte used */
+	first_byte = (ffs(mask) - 1)  >> 3;
+	last_byte = (fls(mask) - 1)  >> 3;
+	len_byte = last_byte - first_byte + 1;
+
+	/* prepare buffer */
+	mcp2517fd_calc_cmd_addr(INSTRUCTION_WRITE, reg + first_byte, cmd);
+	data = cpu_to_le32(data);
+
+	return mcp2517fd_write_then_write(spi,
+					  cmd, sizeof(cmd),
+					  ((void *)&data + first_byte),
+					  len_byte,
+					  speed_hz);
+}
+
+static int mcp2517fd_cmd_write(struct spi_device *spi, u32 reg, u32 data,
+			       u32 speed_hz)
+{
+	return mcp2517fd_cmd_write_mask(spi, reg, data, -1, speed_hz);
+}
+
+static int mcp2517fd_cmd_writen(struct spi_device *spi, u32 reg,
+				void *data, int n, u32 speed_hz)
+{
+	u8 cmd[2];
+	int ret;
+
+	mcp2517fd_calc_cmd_addr(INSTRUCTION_WRITE, reg, cmd);
+
+	ret = mcp2517fd_write_then_write(spi, &cmd, 2, data, n, speed_hz);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/* ideally these would be defined in uapi/linux/can.h */
+#define CAN_EFF_SID_SHIFT		(CAN_EFF_ID_BITS - CAN_SFF_ID_BITS)
+#define CAN_EFF_SID_BITS		CAN_SFF_ID_BITS
+#define CAN_EFF_SID_MASK				      \
+	GENMASK(CAN_EFF_SID_SHIFT + CAN_EFF_SID_BITS - 1,     \
+		CAN_EFF_SID_SHIFT)
+#define CAN_EFF_EID_SHIFT		0
+#define CAN_EFF_EID_BITS		CAN_EFF_SID_SHIFT
+#define CAN_EFF_EID_MASK				      \
+	GENMASK(CAN_EFF_EID_SHIFT + CAN_EFF_EID_BITS - 1,     \
+		CAN_EFF_EID_SHIFT)
+
+static void mcp2517fd_canid_to_mcpid(u32 can_id, u32 *id, u32 *flags)
+{
+	if (can_id & CAN_EFF_FLAG) {
+		int sid = (can_id & CAN_EFF_SID_MASK) >> CAN_EFF_SID_SHIFT;
+		int eid = (can_id & CAN_EFF_EID_MASK) >> CAN_EFF_EID_SHIFT;
+		*id = (eid << CAN_OBJ_ID_EID_SHIFT) |
+			(sid << CAN_OBJ_ID_SID_SHIFT);
+		*flags = CAN_OBJ_FLAGS_IDE;
+	} else {
+		*id = can_id & CAN_SFF_MASK;
+		*flags = 0;
+	}
+
+	*flags |= (can_id & CAN_RTR_FLAG) ? CAN_OBJ_FLAGS_RTR : 0;
+}
+
+static void mcp2517fd_mcpid_to_canid(u32 mcpid, u32 mcpflags, u32 *id)
+{
+	u32 sid = (mcpid & CAN_OBJ_ID_SID_MASK) >> CAN_OBJ_ID_SID_SHIFT;
+	u32 eid = (mcpid & CAN_OBJ_ID_EID_MASK) >> CAN_OBJ_ID_EID_SHIFT;
+
+	if (mcpflags & CAN_OBJ_FLAGS_IDE) {
+		*id = (eid << CAN_EFF_EID_SHIFT) |
+			(sid << CAN_EFF_SID_SHIFT) |
+			CAN_EFF_FLAG;
+	} else {
+		*id = sid;
+	}
+
+	*id |= (mcpflags & CAN_OBJ_FLAGS_RTR) ? CAN_RTR_FLAG : 0;
+}
+
+/* CAN transmit related*/
+
+static void mcp2517fd_mark_tx_pending(void *context)
+{
+	struct mcp2517fd_trigger_tx_message *txm = context;
+	struct spi_device *spi = txm->msg.spi;
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	
+	/* only here or in the irq handler this value is changed,
+	 * so there is no race condition and it does not require locking
+	 * serialization happens via spi_pump_message
+	 */
+	priv->fifos.tx_pending_mask |= BIT(txm->fifo);
+
+#ifdef CONFIG_SPI_IMX
+	post_job_for_imx_ecspi(priv,&txm->fill_xfer);
+	post_job_for_imx_ecspi(priv,&txm->trigger_xfer);
+	
+	//ky_note: Restore the pointer here. Do the post_job;
+//	txm->fill_xfer.tx_buf 	 = txm->fill_cmd;
+//	txm->trigger_xfer.tx_buf = txm->trigger_cmd;
+#endif	
+	
+//am_((PDD "spi_async.complete: fifo=%d, tx_pending=0x%08X\n",txm->fifo,priv->fifos.tx_pending_mask));
+}
+
+static int mcp2517fd_fill_spi_transmit_fifos(struct mcp2517fd_priv *priv)
+{
+	struct mcp2517fd_trigger_tx_message *txm;
+	int i, fifo;
+	const u32 trigger = CAN_FIFOCON_TXREQ | CAN_FIFOCON_UINC;
+	const int first_byte = (ffs(trigger) - 1)  >> 3;
+
+	priv->spi_transmit_fifos = kcalloc(
+		priv->fifos.tx_fifos,
+		sizeof(*priv->spi_transmit_fifos),
+		GFP_KERNEL | GFP_DMA);
+	if (!priv->spi_transmit_fifos)
+		return -ENOMEM;
+
+	for (i = 0; i < priv->fifos.tx_fifos; i++) {
+		fifo = priv->fifos.tx_fifo_start + i;
+		txm = &priv->spi_transmit_fifos[i];
+		/* prepare the message */
+		spi_message_init(&txm->msg);
+		txm->msg.complete = mcp2517fd_mark_tx_pending;
+		txm->msg.context = txm;
+		txm->fifo = fifo;
+		/* the payload itself */
+		txm->fill_xfer.speed_hz = priv->spi_speed_hz;
+		txm->fill_xfer.tx_buf = txm->fill_cmd;
+		txm->fill_xfer.len = 2;
+		txm->fill_xfer.cs_change = true;
+		mcp2517fd_calc_cmd_addr(
+			INSTRUCTION_WRITE,
+			FIFO_DATA(priv->fifos.fifo_address[fifo]),
+			txm->fill_cmd);
+		spi_message_add_tail(&txm->fill_xfer, &txm->msg);
+		/* the trigger command */
+		txm->trigger_xfer.speed_hz = priv->spi_speed_hz;
+		txm->trigger_xfer.tx_buf = txm->trigger_cmd;
+		txm->trigger_xfer.len = 3;
+		mcp2517fd_calc_cmd_addr(INSTRUCTION_WRITE,
+					CAN_FIFOCON(fifo) + first_byte,
+					txm->trigger_cmd);
+		txm->trigger_data = trigger >> (8 * first_byte);
+		spi_message_add_tail(&txm->trigger_xfer, &txm->msg);
+	}
+
+	return 0;
+}
+
+static int mcp2517fd_transmit_message_common(
+	struct spi_device *spi, int fifo,
+	struct mcp2517fd_obj_tx *obj, int len, u8 *data)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct mcp2517fd_trigger_tx_message *txm =
+		&priv->spi_transmit_fifos[fifo - priv->fifos.tx_fifo_start];
+	int ret;
+
+	/* add fifo as seq */
+	obj->header.flags |= fifo << CAN_OBJ_FLAGS_SEQ_SHIFT;
+
+	/* transform to le32 */
+	mcp2517fd_obj_to_le(&obj->header);
+
+	/* fill in details */
+	memcpy(txm->fill_obj, obj, sizeof(struct mcp2517fd_obj_tx));
+	memset(txm->fill_data, 0, priv->fifos.payload_size);
+	memcpy(txm->fill_data, data, len);
+
+#ifdef ADLINK_PATCH_FIFO_WRITE_PLSIZE
+	//ky_note: After POR, MCP2517fd might trigger irq error (0x9008) if the data length less than 4 bytes;
+	//WORD boundary (4B) is not enough? This error only happen on first wirte.
+	if(len<8) {
+		txm->fill_xfer.len=MCP2517_CMD_LEN+sizeof(struct mcp2517fd_obj_tx)+8;
+	}
+	else {
+		txm->fill_xfer.len=MCP2517_CMD_LEN+sizeof(struct mcp2517fd_obj_tx)+ALIGN(len,4);
+	}
+#else
+	/* transfers to FIFO RAM has to be multiple of 4 */
+	txm->fill_xfer.len =
+		2 + sizeof(struct mcp2517fd_obj_tx) + ALIGN(len, 4);	
+#endif
+	
+#ifdef ADLINK_DEBUG_DUMP_CUREENT_FIFO
+	{	u8 *pb=(u8 *)txm->fill_cmd;
+		WARN_ON(0x02!=(pb[0]>>4));
+		priv->asyncFifoAddr=((0x0F&pb[0])<<8)|pb[1];
+//		DumpBufA(pb+2,16,16,priv->asyncFifoAddr);
+	}
+#endif
+
+#ifdef CONFIG_SPI_IMX
+//am_((PDD "%s(): xfer.len=%u\n",__func__,txm->fill_xfer.len));//sizeof(mcp2517fd_obj_tx)==8;
+
+	pre_job_for_imx_ecspi(priv,&txm->trigger_xfer);
+	pre_job_for_imx_ecspi(priv,&txm->fill_xfer);
+	if((ret=spi_async(spi,&txm->msg))<0) {
+		dev_err(&spi->dev,"error! %d=spi_async()\n",ret); 
+	}
+	//ky_note: async can not call post_job_for_imx_ecspi() immediately, becase it is not done yet!
+	Link2(mcp2517fd_mark_tx_pending);
+	
+//am_((PDD "%s(): %d=spi_async()\n",__func__,ret));
+
+#else
+	/* and transmit asyncroniously */
+	ret = spi_async(spi, &txm->msg);
+	if (ret)
+		return NETDEV_TX_BUSY;
+#endif
+	return NETDEV_TX_OK;
+}
+
+static int mcp2517fd_transmit_fdmessage(struct spi_device *spi, int fifo,
+					struct canfd_frame *frame)
+{
+	struct mcp2517fd_obj_tx obj;
+	int dlc = can_len2dlc(frame->len);
+	u32 flags;
+	
+//am_(("  @ CAN_FD: id=0x%03X, len=%d, flags=0x%02X, data=%X,%X\n",
+//frame->can_id,frame->len,frame->flags,frame->data[0],frame->data[1]));
+
+	frame->len = can_dlc2len(dlc);
+
+	mcp2517fd_canid_to_mcpid(frame->can_id, &obj.header.id, &flags);
+
+	flags |= dlc << CAN_OBJ_FLAGS_DLC_SHIFT;
+	flags |= (frame->can_id & CAN_EFF_FLAG) ? CAN_OBJ_FLAGS_IDE : 0;
+	flags |= (frame->can_id & CAN_RTR_FLAG) ? CAN_OBJ_FLAGS_RTR : 0;
+	flags |= (frame->flags & CANFD_BRS) ? CAN_OBJ_FLAGS_BRS : 0;
+	flags |= (frame->flags & CANFD_ESI) ? CAN_OBJ_FLAGS_ESI : 0;
+	flags |= CAN_OBJ_FLAGS_FDF;
+
+	obj.header.flags = flags;
+
+	return mcp2517fd_transmit_message_common(
+		spi, fifo, &obj, frame->len, frame->data);
+}
+
+static int mcp2517fd_transmit_message(struct spi_device *spi, int fifo,
+				      struct can_frame *frame)
+{
+	struct mcp2517fd_obj_tx obj;
+	u32 flags;
+	
+//am_(("  @ CAN_2.0: id=0x%03X, dlc=%d, data=%X,%X\n",frame->can_id,frame->can_dlc,frame->data[0],frame->data[1]));
+	
+	if (frame->can_dlc > 8)
+		frame->can_dlc = 8;
+
+	mcp2517fd_canid_to_mcpid(frame->can_id, &obj.header.id, &flags);
+
+	flags |= frame->can_dlc << CAN_OBJ_FLAGS_DLC_SHIFT;
+	flags |= (frame->can_id & CAN_EFF_FLAG) ? CAN_OBJ_FLAGS_IDE : 0;
+	flags |= (frame->can_id & CAN_RTR_FLAG) ? CAN_OBJ_FLAGS_RTR : 0;
+
+	obj.header.flags = flags;
+
+//am_((PDD "CanTx.frame: id=0x%03X, dlc=%d, pad=0x%02X, obj.id=0x%03X, obj.flags=0x%02X\n",frame->can_id,frame->can_dlc,frame->__pad,obj.header.id,flags));
+//@@ CanTx.frame: id=0x555, dlc=1, pad=0x00, obj.id=0x555, obj.flags=0x01
+
+	return mcp2517fd_transmit_message_common(
+		spi, fifo, &obj, frame->can_dlc, frame->data);
+}
+
+static netdev_tx_t mcp2517fd_start_xmit(struct sk_buff *skb,
+					struct net_device *net)
+{
+	struct mcp2517fd_priv *priv = netdev_priv(net);
+	struct spi_device *spi = priv->spi;
+	u32 pending_mask;
+	int fifo;
+	int ret;
+
+//am_((PDD "%s(): skb->len=%d\n",__func__,skb->len));	
+//@@ mcp2517fd_start_xmit(): skb->len=16 # cansend can0 555#AA;
+//@@ mcp2517fd_start_xmit(): skb->len=72 # cansend can0 555##3AA;
+
+	if (can_dropped_invalid_skb(net, skb)) {
+efl_	return NETDEV_TX_OK; }
+
+	if (priv->can.state == CAN_STATE_BUS_OFF) {
+		priv->tx_queue_status = 0;
+efl_	netif_stop_queue(priv->net);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* get effective mask */
+	pending_mask = priv->fifos.tx_pending_mask |
+		priv->fifos.tx_submitted_mask;
+
+	/* decide on fifo to assign */
+	if (pending_mask)
+		fifo = ffs(pending_mask) - 2;
+	else
+		fifo = priv->fifos.tx_fifo_start + priv->fifos.tx_fifos - 1;
+	
+//am_((PDD "%s(): fifo=%d, txf_start=%d, txf=%d, txf_mask=0x%08X\n",__func__,
+//fifo,priv->fifos.tx_fifo_start,priv->fifos.tx_fifos,priv->fifos.tx_fifo_mask));
+//@@ mcp2517fd_start_xmit(): fifo=31, txf_start=25, txf=7, txf_mask=0xFE000000
+
+//am_((" t@ submitted_mask=0x%08X, pending_mask=0x%08X, processed_mask=0x%08X\n",
+//priv->fifos.tx_submitted_mask,priv->fifos.tx_pending_mask,priv->fifos.tx_processed_mask));
+//@ submitted_mask=0x00000000, pending_mask=0x00000000, processed_mask=0x00000000
+
+	/* handle error - this should not happen... */
+	if (fifo < priv->fifos.tx_fifo_start) {
+		dev_err(&spi->dev,
+			"reached tx-fifo %i, which is not valid\n",
+			fifo);
+efl_	return NETDEV_TX_BUSY;
+	}
+
+	/* if we are the last one, then stop the queue */
+	if (fifo == priv->fifos.tx_fifo_start) {
+		priv->tx_queue_status = 0;
+		netif_stop_queue(priv->net);
+	}
+
+	/* mark as submitted */
+	priv->fifos.tx_submitted_mask |= BIT(fifo);
+	priv->stats.fifo_usage[fifo]++;
+
+#ifdef ADLINK_DEBUG_CHECK_TFNRFNIF
+//ky_note: Here we try to dump the C1FIFOSTA1.TFNRFNIF bit, but we can not call spi_sync() that will block the calling thread(network).
+//For this reason, this driver can not check this flag before loading data to FIFO. The spec has warn us that should not push data to 
+//a FIFO unless it has free zoom. To solve this, we could create a workqueue. 
+
+//am_((PDD "%s(): fifo=%d\n",__func__,fifo));
+//SpiQuickDump(priv,CAN_FIFOCON(fifo),12);
+#endif
+
+#ifdef ADLINK_PATCH_ECHO_SKB
+	//ky_note: The original location might hit racing issue;
+	can_put_echo_skb(skb, priv->net, fifo);
+//am_((" t@ can_put_echo_skb(fifo=%d), Occupy?\n",fifo));		
+#endif
+
+	/* now process it for real */
+	if (can_is_canfd_skb(skb))
+		ret = mcp2517fd_transmit_fdmessage(
+			spi, fifo, (struct canfd_frame *)skb->data);
+	else
+		ret = mcp2517fd_transmit_message(
+			spi, fifo, (struct can_frame *)skb->data);
+
+
+#ifndef ADLINK_PATCH_ECHO_SKB
+	/* keep it for reference until the message really got transmitted */
+	if (ret == NETDEV_TX_OK) {
+		can_put_echo_skb(skb, priv->net, fifo); 
+//am_((" t@ can_put_echo_skb(fifo=%d), Occupy?\n",fifo)); 	
+	}
+#endif
+
+	return ret;
+}
+
+/* CAN RX Related */
+
+static int mcp2517fd_can_transform_rx_fd(struct spi_device *spi,
+					 struct mcp2517fd_obj_rx *rx)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct canfd_frame *frame;
+	struct sk_buff *skb;
+	u32 flags = rx->header.flags;
+
+	/* allocate the skb buffer */
+	skb = alloc_canfd_skb(priv->net, &frame);
+	if (!skb) {
+		dev_err(&spi->dev, "cannot allocate RX skb\n");
+		priv->net->stats.rx_dropped++;
+		return -ENOMEM;
+	}
+
+	mcp2517fd_mcpid_to_canid(rx->header.id, flags, &frame->can_id);
+	frame->flags |= (flags & CAN_OBJ_FLAGS_BRS) ? CANFD_BRS : 0;
+	frame->flags |= (flags & CAN_OBJ_FLAGS_ESI) ? CANFD_ESI : 0;
+
+	frame->len = can_dlc2len((flags & CAN_OBJ_FLAGS_DLC_MASK)
+				 >> CAN_OBJ_FLAGS_DLC_SHIFT);
+
+	memcpy(frame->data, rx->data, frame->len);
+
+	priv->net->stats.rx_packets++;
+	priv->net->stats.rx_bytes += frame->len;
+
+	can_led_event(priv->net, CAN_LED_EVENT_RX);
+//fl_
+	netif_rx_ni(skb);
+
+	return 0;
+}
+
+static int mcp2517fd_can_transform_rx_normal(struct spi_device *spi,
+					     struct mcp2517fd_obj_rx *rx)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	u32 flags = rx->header.flags;
+	int len;
+
+	/* allocate the skb buffer */
+	skb = alloc_can_skb(priv->net, &frame);
+	if (!skb) {
+		dev_err(&spi->dev, "cannot allocate RX skb\n");
+		priv->net->stats.rx_dropped++;
+		return -ENOMEM;
+	}
+
+	mcp2517fd_mcpid_to_canid(rx->header.id, flags, &frame->can_id);
+
+	frame->can_dlc = (flags & CAN_OBJ_FLAGS_DLC_MASK)
+		>> CAN_OBJ_FLAGS_DLC_SHIFT;
+
+	len = can_dlc2len(frame->can_dlc);
+
+	memcpy(frame->data, rx->data, len);
+
+	priv->net->stats.rx_packets++;
+	priv->net->stats.rx_bytes += len;
+
+	can_led_event(priv->net, CAN_LED_EVENT_RX);
+//fl_
+	netif_rx_ni(skb);
+
+	return 0;
+}
+
+static int mcp2517fd_process_queued_rx(struct spi_device *spi,
+				       struct mcp2517fd_obj_ts *obj)
+{
+	struct mcp2517fd_obj_rx *rx = container_of(
+		obj, struct mcp2517fd_obj_rx, header);
+
+	if (obj->flags & CAN_OBJ_FLAGS_FDF)
+		return mcp2517fd_can_transform_rx_fd(
+			spi, rx);
+	else
+		return mcp2517fd_can_transform_rx_normal(
+			spi, rx);
+}
+
+static int mcp2517fd_normal_release_fifos(struct spi_device *spi,
+					  int start, int end)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	int ret;
+
+	/* release each fifo in a separate transfer */
+	for (; start < end ; start++) {
+		ret = mcp2517fd_cmd_write_mask(
+			spi, CAN_FIFOCON(start),
+			CAN_FIFOCON_UINC,
+			CAN_FIFOCON_UINC,
+			priv->spi_speed_hz);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* unfortunately the CAN_FIFOCON are not directly consecutive
+ * so the optimization of "clearing all in one spi_transfer"
+ * would produce an overhead of 11 unnecessary bytes/fifo
+ * - transferring 14 (2 cmd + 12 data) bytes
+ * instead of just 3 (2 + 1).
+ * On some slower systems this may still be beneficial,
+ * but it is not good enough for the generic case.
+ * On a Raspberry Pi CM the timings for clearing 3 fifos
+ * (at 12.5MHz SPI clock speed) are:
+ * * normal:
+ *   * 3 spi transfers
+ *   * 9 bytes total
+ *   * 36.74us from first CS low to last CS high
+ *   * individual CS: 9.14us, 5.74us and 5.16us
+ *   * 77.02us from CS up of fifo transfer to last release CS up
+ * * bulk:
+ *   * 1 spi transfer
+ *   * 27 bytes total
+ *   * 29.06us CS Low
+ *   * 78.28us from CS up of fifo transfer to last release CS up
+ * this obviously varies with SPI_clock speed
+ * - the slower the clock the less efficient the optimization.
+ * similarly the faster the CPU (and bigger the code cache) the
+ * less effcient the optimization - the above case is border line.
+ */
+
+#define FIFOCON_SPACING (CAN_FIFOCON(1) - CAN_FIFOCON(0))
+#define FIFOCON_SPACINGW (FIFOCON_SPACING / sizeof(u32))
+
+static int mcp2517fd_bulk_release_fifos(struct spi_device *spi,
+					int start, int end)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	int i;
+	int ret;
+
+	/* calculate start address and length */
+	int fifos = end - start;
+	int first_byte = (ffs(CAN_FIFOCON_UINC) - 1)  >> 3;
+	int addr = CAN_FIFOCON(start);
+	int len = 1 + (fifos - 1) * FIFOCON_SPACING;
+
+	/* the worsted case buffer */
+	u32 buf[32 * FIFOCON_SPACINGW], base;
+
+	base = (priv->fifos.payload_mode << CAN_FIFOCON_PLSIZE_SHIFT) |
+		((priv->fifos.rx_fifo_depth - 1) << CAN_FIFOCON_FSIZE_SHIFT) |
+		CAN_FIFOCON_RXTSEN | /* RX timestamps */
+		CAN_FIFOCON_UINC |
+		CAN_FIFOCON_TFERFFIE | /* FIFO Full */
+		CAN_FIFOCON_TFHRFHIE | /* FIFO Half Full*/
+		CAN_FIFOCON_TFNRFNIE; /* FIFO not empty */
+
+	memset(buf, 0, sizeof(buf));
+	for (i = 0; i < end - start ; i++) {
+		if (i == priv->fifos.rx_fifos - 1)
+			base |= CAN_FIFOCON_RXOVIE;
+		buf[FIFOCON_SPACINGW * i] = cpu_to_le32(base);
+	}
+
+	ret = mcp2517fd_cmd_writen(spi, addr + first_byte,
+				   (u8 *)buf + first_byte,
+				   len,
+				   priv->spi_speed_hz);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/* queued FIFO handling for release to system */
+
+static void mcp2517fd_clear_queued_fifos(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+
+	/* prepare rfi - mostly used for sorting */
+	priv->queued_fifos.tsmin = -1;
+	priv->queued_fifos.tsmax = 0;
+	priv->queued_fifos.rx_count = 0;
+}
+
+static void mcp2517fd_addto_queued_fifos(struct spi_device *spi,
+					 struct mcp2517fd_obj_ts *obj)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct mcp2517fd_read_fifo_info *rfi = &priv->queued_fifos;
+
+	/* add pointer to queued array-list */
+	rfi->rxb[rfi->rx_count] = obj;
+	rfi->rx_count++;
+
+	/* and get tsmin/tsmax */
+	if (rfi->tsmin > obj->ts)
+		rfi->tsmin = obj->ts;
+	if (rfi->tsmax > obj->ts)
+		rfi->tsmax = obj->ts;
+}
+
+static int mcp2517fd_process_queued_tef(struct spi_device *spi,
+					struct mcp2517fd_obj_ts *obj)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct mcp2517fd_obj_tef *tef = container_of(
+		obj, struct mcp2517fd_obj_tef, header);
+	int dlc = (obj->flags & CAN_OBJ_FLAGS_DLC_MASK)
+		>> CAN_OBJ_FLAGS_DLC_SHIFT;
+	int fifo = (tef->header.flags & CAN_OBJ_FLAGS_SEQ_MASK) >>
+		CAN_OBJ_FLAGS_SEQ_SHIFT;
+
+	/* update counters */
+	priv->net->stats.tx_packets++;
+	priv->net->stats.tx_bytes += can_dlc2len(dlc);
+
+	/* release it */
+	can_get_echo_skb(priv->net, fifo);
+//am_((PDD "%s(): can_get_echo_skb(fifo=%d), Release?\n",__func__,fifo));
+	can_led_event(priv->net, CAN_LED_EVENT_TX);
+
+	return 0;
+}
+
+static int mcp2517fd_compare_obj_ts(const void *a, const void *b)
+{
+	const struct mcp2517fd_obj_ts * const *rxa = a;
+	const struct mcp2517fd_obj_ts * const *rxb = b;
+	/* using signed here to handle rollover correctly */
+	s32 ats = (*rxa)->ts;
+	s32 bts = (*rxb)->ts;
+
+	if (ats < bts)
+		return -1;
+	if (ats > bts)
+		return 1;
+	return 0;
+}
+
+static int mcp2517fd_process_queued_fifos(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct mcp2517fd_read_fifo_info *rfi = &priv->queued_fifos;
+	int i;
+	int ret;
+
+	/* sort the fifos (rx and TEF) by receive timestamp */
+	sort(rfi->rxb, rfi->rx_count, sizeof(struct mcp2517fd_obj_ts *),
+	     mcp2517fd_compare_obj_ts, NULL);
+	
+//am_((PDD "%s(): rx_count=%d\n",__func__,rfi->rx_count));
+
+	/* process the recived fifos */
+	for (i = 0; i < rfi->rx_count ; i++) {
+		if (rfi->rxb[i]->flags & CAN_OBJ_FLAGS_CUSTOM_ISTEF) {
+			ret = mcp2517fd_process_queued_tef(
+				spi, rfi->rxb[i]);
+		} else {
+			ret = mcp2517fd_process_queued_rx(
+				spi, rfi->rxb[i]);
+		}
+		if (ret)
+			return ret;
+	}
+
+	/* clear queued fifos */
+	mcp2517fd_clear_queued_fifos(spi);
+
+	return 0;
+}
+
+static int mcp2517fd_transform_rx(struct spi_device *spi,
+				  struct mcp2517fd_obj_rx *rx)
+{
+	int dlc;
+
+	/* transform the data to system byte order */
+	mcp2517fd_obj_ts_from_le(&rx->header);
+
+	/* add the object to the list */
+	mcp2517fd_addto_queued_fifos(spi, &rx->header);
+
+	/* calc length and return it */
+	dlc = (rx->header.flags & CAN_OBJ_FLAGS_DLC_MASK)
+		>> CAN_OBJ_FLAGS_DLC_SHIFT;
+	return can_dlc2len(dlc);
+}
+
+/* read_fifo implementations
+ *
+ * read_fifos is a simple implementation, that:
+ *   * loops all fifos
+ *     * read header + some data-bytes (8)
+ *     * read rest of data-bytes bytes
+ *     * release fifo
+ *   for 3 can frames dlc<=8 to read here we have:
+ *     * 6 spi transfers
+ *     * 75 bytes (= 3 * (2 + 12 + 8) bytes + 3 * 3 bytes)
+ *   for 3 canfd frames dlc>8 to read here we have:
+ *     * 9 spi transfers
+ *     * 81 (= 3 * (2 + 12 + 8 + 2) bytes + 3 * 3 bytes) + 3 * extra payload
+ *     this only transfers the required size of bytes on the spi bus.
+ *
+ * bulk_read_fifos is an optimization that is most practical for
+ * Can2.0 busses, but may also be practical for CanFD busses that
+ * have a high average payload data size.
+ *
+ * It will read all of the fifo data in a single spi_transfer:
+ *   * read all fifos in one go (as long as these are ajacent to each other)
+ *   * loop all fifos
+ *     * release fifo
+ *   for 3 can2.0 frames to read here we have:
+ *     * 4 spi transfers
+ *     * 71 bytes (= 2 + 3 * (12 + 8) bytes + 3 * 3 bytes)
+ *   for 3 canfd frames to read here we have:
+ *     * 4 spi transfers
+ *     * 230 bytes (= 2 + 3 * (12 + 64) bytes)
+ *     obviously this reads way too many bytes for framesizes <=32 bytes,
+ *     but it avoids the overhead on the CPU side and may even trigger
+ *     DMA transfers due to the high byte count, which release CPU cycles.
+ *
+ * This optimization will also be efficient for cases where a high
+ * percentage of canFD frames has a dlc-size > 8.
+ * This mode is used for Can2.0 configured busses.
+ *
+ * For now this option can get forced for CanFD via a module parameter.
+ * In the future there may be some heuristics that could trigger a usage
+ * of this mode as well in some circumstances.
+ *
+ * Note: there is a second optimization for release fifo as well,
+ *       but it is not as efficient as this optimization for the
+ *       non-CanFD case - see mcp2517fd_bulk_release_fifos
+ */
+
+static int mcp2517fd_read_fifos(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	int fifo_header_size = sizeof(struct mcp2517fd_obj_rx);
+	int fifo_min_payload_size = 8;
+	int fifo_min_size = fifo_header_size + fifo_min_payload_size;
+	int fifo_max_payload_size =
+		((priv->can.ctrlmode & CAN_CTRLMODE_FD) ? 64 : 8);
+	u32 mask = priv->status.rxif;
+	struct mcp2517fd_obj_rx *rx;
+	int i, len;
+	int ret;
+
+	/* read all the "open" segments in big chunks */
+	for (i = priv->fifos.rx_fifo_start;
+	     i < priv->fifos.rx_fifo_start + priv->fifos.rx_fifos;
+	     i++) {
+		if (!(mask & BIT(i)))
+			continue;
+		/* the fifo to fill */
+		rx = (struct mcp2517fd_obj_rx *)
+			(priv->fifos.fifo_data + priv->fifos.fifo_address[i]);
+		/* read the minimal payload */
+		ret = mcp2517fd_cmd_readn(
+			spi, FIFO_DATA(priv->fifos.fifo_address[i]),
+			rx,
+			fifo_min_size,
+			priv->spi_speed_hz);
+		if (ret)
+			return ret;
+		/* process fifo stats and get length */
+		len = min_t(int, mcp2517fd_transform_rx(spi, rx),
+			    fifo_max_payload_size);
+
+		/* read extra payload if needed */
+		if (len > fifo_min_payload_size) {
+			ret = mcp2517fd_cmd_readn(
+				spi,
+				FIFO_DATA(priv->fifos.fifo_address[i] +
+					  fifo_min_size),
+				&rx->data[fifo_min_payload_size],
+				len - fifo_min_payload_size,
+				priv->spi_speed_hz);
+			if (ret)
+				return ret;
+		}
+		/* release fifo */
+		ret = mcp2517fd_normal_release_fifos(spi, i, i + 1);
+		if (ret)
+			return ret;
+		/* increment fifo_usage */
+		priv->stats.fifo_usage[i]++;
+	}
+
+	return 0;
+}
+
+static int mcp2517fd_bulk_read_fifos(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	int fifo_header_size = sizeof(struct mcp2517fd_obj_rx);
+	int fifo_max_payload_size = priv->fifos.payload_size;
+	int fifo_max_size = fifo_header_size + fifo_max_payload_size;
+	u32 mask = priv->status.rxif;
+	u32 rx_fifo_end = priv->fifos.rx_fifo_start +
+		priv->fifos.rx_fifos;
+	struct mcp2517fd_obj_rx *rx;
+	int i, j;
+	int ret;
+
+	/* read all the "open" segments in big chunks */
+	for (i = priv->fifos.rx_fifo_start; i < rx_fifo_end; i++) {
+		if (mask & BIT(i)) {
+			/* find the last set bit in sequence */
+			for (j = i;
+			     (j < rx_fifo_end) && (mask & BIT(j));
+			     j++) {
+				/* clear the mask */
+				mask &= ~BIT(j);
+			}
+
+			/* now we got start and end, so read the range */
+			ret = mcp2517fd_cmd_readn(
+				spi,
+				FIFO_DATA(priv->fifos.fifo_address[i]),
+				priv->fifos.fifo_data +
+				priv->fifos.fifo_address[i],
+				(j - i) * fifo_max_size,
+				priv->spi_speed_hz);
+			if (ret)
+				return ret;
+
+			/* clear all the fifos in range */
+			if (use_bulk_release_fifos)
+				ret = mcp2517fd_bulk_release_fifos(spi,
+								   i, j);
+			else
+				ret = mcp2517fd_normal_release_fifos(spi,
+								     i, j);
+			if (ret)
+				return ret;
+
+			/* preprocess data */
+			for (; i < j ; i++) {
+				/* store the fifo to process */
+				rx = (struct mcp2517fd_obj_rx *)(
+					priv->fifos.fifo_data +
+					priv->fifos.fifo_address[i]);
+				/* process fifo stats */
+				mcp2517fd_transform_rx(spi, rx);
+				/* increment usage */
+				priv->stats.fifo_usage[i]++;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int mcp2517fd_can_ist_handle_rxif(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	u32 mask = priv->status.rxif;
+	int ret;
+	
+//am_((PDD "%s(): C1RXIF=0x%X\n",__func__,mask));
+//@@ mcp2517fd_can_ist_handle_rxif(): C1RXIF=0x2
+
+	if (!mask) 
+		return 0; 
+
+	/* read all the fifos - for non-fd case use bulk read optimization */
+	if (((priv->can.ctrlmode & CAN_CTRLMODE_FD) == 0) ||
+	    use_complete_fdfifo_read)
+		ret = mcp2517fd_bulk_read_fifos(spi);
+	else
+		ret = mcp2517fd_read_fifos(spi);
+
+	return 0;
+}
+
+static int mcp2517fd_can_ist_handle_tefif(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct mcp2517fd_obj_tef *tef;
+	u32 pending = priv->fifos.tx_pending_mask &
+		(~priv->fifos.tx_processed_mask);
+	int i, count, fifo;
+	int ret;
+
+	/* calculate the number of fifos that have been processed */
+	count = hweight_long(pending);
+	count -= hweight_long(priv->status.txreq);
+	if (count <= 0) {
+		dev_err(&spi->dev,
+			"handle_tefif: unexpected count = %i\n",
+			count);
+		return -EINVAL;
+	}
+	
+//am_((PDD "%s(): pending=0x%X, TXREQ=0x%X, count=%d\n",__func__,pending,priv->status.txreq,count));
+
+	/* now clear TEF for each */
+	/* TODO: optimize for BULK reads, as we (hopefully) know COUNT */
+	for (i = 0; i < count; i++) {
+		/* calc address in address space */
+		tef = (struct mcp2517fd_obj_tef *)(priv->fifos.fifo_data +
+						   priv->fifos.tef_address);
+		/* read all the object data */
+		ret = mcp2517fd_cmd_readn(spi,
+					  FIFO_DATA(priv->fifos.tef_address),
+					  tef, sizeof(*tef),
+					  priv->spi_speed_hz);
+
+		/* increment the counter to read next */
+		ret = mcp2517fd_cmd_write_mask(spi,
+					       CAN_TEFCON,
+					       CAN_TEFCON_UINC,
+					       CAN_TEFCON_UINC,
+					       priv->spi_speed_hz);
+
+		/* transform the data to system byte order */
+		mcp2517fd_obj_ts_from_le(&tef->header);
+
+		fifo = (tef->header.flags & CAN_OBJ_FLAGS_SEQ_MASK) >>
+			CAN_OBJ_FLAGS_SEQ_SHIFT;
+
+//am_(("  @ fifo=%d, tef_address=0x%X\n",fifo,priv->fifos.tef_address));
+
+		/* submit to queue */
+		tef->header.flags |= CAN_OBJ_FLAGS_CUSTOM_ISTEF;
+		mcp2517fd_addto_queued_fifos(spi, &tef->header);
+
+		/* increment tef */
+		priv->fifos.tef_address += sizeof(*tef);
+		if (priv->fifos.tef_address > priv->fifos.tef_address_end)
+			priv->fifos.tef_address = priv->fifos.tef_address_start;
+
+		/* and set mask */
+		priv->fifos.tx_processed_mask |= BIT(fifo);
+
+		if (fifo == priv->fifos.tx_fifo_start) {
+			priv->tx_queue_status = 2;
+		}
+
+	}
+
+	return 0;
+}
+
+static void mcp2517fd_error_skb(struct net_device *net)
+{
+	struct mcp2517fd_priv *priv = netdev_priv(net);
+	struct sk_buff *skb;
+	struct can_frame *frame;
+
+	skb = alloc_can_err_skb(net, &frame);
+	if (skb) {
+		frame->can_id = priv->can_err_id;
+		memcpy(frame->data, priv->can_err_data, 8);
+fl_		netif_rx_ni(skb);
+	} 
+	else {
+		netdev_err(net, "cannot allocate error skb\n");
+	}
+}
+
+static int mcp2517fd_can_ist_handle_rxovif(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	u32 mask = priv->status.rxovif;
+	int i;
+	int ret;
+
+	/* clear all fifos that have an overflow bit set */
+	for (i = 0; i < 32; i++) {
+		if (mask & BIT(i)) {
+			ret = mcp2517fd_cmd_write_mask(spi,
+						       CAN_FIFOSTA(i),
+						       0,
+						       CAN_FIFOSTA_RXOVIF,
+						       priv->spi_speed_hz);
+			if (ret)
+				return ret;
+			/* update statistics */
+			priv->net->stats.rx_over_errors++;
+			priv->net->stats.rx_errors++;
+			priv->stats.rx_overflow++;
+			priv->can_err_id |= CAN_ERR_CRTL;
+			priv->can_err_data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
+		}
+	}
+
+	return 0;
+}
+
+static int mcp2517fd_can_ist_handle_modif(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	int mode;
+	int ret;
+
+	/* mask interrupt for clearing */
+	priv->int_clear_mask |= CAN_INT_MODIF;
+
+	/* read the mode bit */
+	ret = mcp2517fd_cmd_read_mask(spi,
+				      CAN_CON,
+				      &priv->regs.con,
+				      CAN_CON_OPMOD_MASK,
+				      priv->spi_speed_hz);
+	if (ret)
+		return ret;
+
+	mode = (priv->regs.con & CAN_CON_OPMOD_MASK) >>
+		CAN_CON_OPMOD_SHIFT;
+
+	/* this mostly happens on initialization */
+	if (mode == priv->active_can_mode) {
+		dev_err(&spi->dev,
+			"Controller switched to already active mode: %s(%u)\n",
+			mcp2517fd_mode_names[mode], mode);
+		return 0;
+	}
+
+	/* these we need to handle correctly */
+	dev_err(&spi->dev,
+		"Controller switched from mode %s(%u) to %s(%u)\n",
+		mcp2517fd_mode_names[priv->active_can_mode],
+		priv->active_can_mode,
+		mcp2517fd_mode_names[mode], mode);
+
+	/* finally assign the mode as currently active */
+	priv->active_can_mode = mode;
+	return 0;
+}
+
+static int mcp2517fd_can_ist_handle_cerrif(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+
+	/* in principle we could also delay reading bdiag registers
+	 * until we get here - it would add some extra delay in the
+	 * error case, but be slightly faster in the "normal" case.
+	 * slightly faster would be saving 8 bytes of spi transfer.
+	 */
+
+	dev_err_ratelimited(&spi->dev, "CAN Bus error\n");
+	priv->can_err_id |= CAN_ERR_BUSERROR;
+	priv->int_clear_mask |= CAN_INT_CERRIF;
+
+	if (priv->status.bdiag1 &
+	    (CAN_BDIAG1_DBIT0ERR | CAN_BDIAG1_NBIT0ERR)) {
+		priv->can_err_id |= CAN_ERR_BUSERROR;
+		priv->can_err_data[2] |= CAN_ERR_PROT_BIT0;
+		priv->bdiag1_clear_mask |= CAN_BDIAG1_DBIT0ERR |
+			CAN_BDIAG1_NBIT0ERR;
+	}
+	if (priv->status.bdiag1 &
+	    (CAN_BDIAG1_DBIT1ERR | CAN_BDIAG1_NBIT1ERR)) {
+		priv->can_err_id |= CAN_ERR_BUSERROR;
+		priv->can_err_data[2] |= CAN_ERR_PROT_BIT1;
+		priv->bdiag1_clear_mask |= CAN_BDIAG1_DBIT1ERR |
+			CAN_BDIAG1_NBIT1ERR;
+	}
+	if (priv->status.bdiag1 &
+	    (CAN_BDIAG1_DSTUFERR | CAN_BDIAG1_NSTUFERR)) {
+		priv->can_err_id |= CAN_ERR_BUSERROR;
+		priv->can_err_data[2] |= CAN_ERR_PROT_STUFF;
+		priv->bdiag1_clear_mask |= CAN_BDIAG1_DSTUFERR |
+			CAN_BDIAG1_NSTUFERR;
+	}
+	if (priv->status.bdiag1 &
+	    (CAN_BDIAG1_DFORMERR | CAN_BDIAG1_NFORMERR)) {
+		priv->can_err_id |= CAN_ERR_BUSERROR;
+		priv->can_err_data[2] |= CAN_ERR_PROT_FORM;
+		priv->bdiag1_clear_mask |= CAN_BDIAG1_DFORMERR |
+			CAN_BDIAG1_NFORMERR;
+	}
+	if (priv->status.bdiag1 & CAN_BDIAG1_NACKERR) {
+		priv->can_err_id |= CAN_ERR_ACK;
+		priv->bdiag1_clear_mask |= CAN_BDIAG1_NACKERR;
+	}
+
+	return 0;
+}
+
+static int mcp2517fd_can_ist_handle_eccif(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	int ret;
+	u32 val;
+	u32 addr;
+
+	priv->can_err_id |= CAN_ERR_CRTL;
+	priv->can_err_data[1] |= CAN_ERR_CRTL_UNSPEC;
+	priv->int_clear_mask |= CAN_INT_ECCIF;
+
+	/* read ECC status register */
+	ret = mcp2517fd_cmd_read(spi, MCP2517FD_ECCSTAT, &val,
+				 priv->spi_speed_hz);
+	if (ret)
+		return ret;
+
+	addr = (val & MCP2517FD_ECCSTAT_ERRADDR_MASK) >>
+		MCP2517FD_ECCSTAT_ERRADDR_SHIFT;
+
+	dev_err_ratelimited(&spi->dev,
+			    "ECC %s bit error at %03x\n",
+			    (val & MCP2517FD_ECCSTAT_DEDIF) ?
+			    "double" : "single",
+			    addr);
+
+	return mcp2517fd_cmd_write(spi, MCP2517FD_ECCSTAT, 0,
+				 priv->spi_speed_hz);
+}
+
+static int mcp2517fd_can_ist_handle_serrif(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+
+	/* Errors here are:
+	 * * Bus Bandwidth Error: when a RX Message Assembly Buffer
+	 *   is still full when the next message has already arrived
+	 *   the recived message shall be ignored
+	 * * TX MAB Underflow: when a TX Message is invalid
+	 *   due to ECC errors or TXMAB underflow
+	 *   in this situatioon the system will transition to
+	 *   Restricted or Listen Only mode
+	 */
+
+	priv->can_err_id |= CAN_ERR_CRTL;
+	priv->can_err_data[1] |= CAN_ERR_CRTL_UNSPEC;
+	priv->int_clear_mask |= CAN_INT_SERRIF;
+
+	/* a mode change or ecc error would indicate TX MAB Undeflow */
+	if (priv->status.intf & (CAN_INT_MODIF | CAN_INT_ECCIF)) {
+		dev_warn_ratelimited(&spi->dev, "TX MAB underflow\n");
+		priv->net->stats.tx_fifo_errors++;
+		priv->net->stats.tx_errors++;
+	} else {
+		dev_warn_ratelimited(&spi->dev, "RX MAB overflow\n");
+		priv->net->stats.rx_dropped++;
+		priv->net->stats.rx_errors++;
+	}
+	return 0;
+}
+
+static int mcp2517fd_disable_interrupts(struct spi_device *spi,
+					u32 speed_hz)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+fl_
+	priv->status.intf = 0;
+	return mcp2517fd_cmd_write(spi, CAN_INT, 0, speed_hz);
+}
+
+static int mcp2517fd_enable_interrupts(struct spi_device *spi,
+				       u32 speed_hz)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+fl_
+	priv->status.intf = CAN_INT_TEFIE |
+		CAN_INT_RXIE |
+		CAN_INT_MODIE |
+		CAN_INT_SERRIE |
+		CAN_INT_IVMIE |
+		CAN_INT_CERRIE |
+		CAN_INT_ECCIE;
+	return mcp2517fd_cmd_write(spi, CAN_INT,
+				   priv->status.intf,
+				   speed_hz);
+}
+
+static int mcp2517fd_hw_wake(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	u32 waitfor = MCP2517FD_OSC_OSCRDY;
+	u32 mask = waitfor | MCP2517FD_OSC_OSCDIS;
+	unsigned long timeout;
+	int ret;
+
+	if (priv->active_can_mode != CAN_CON_MODE_SLEEP)
+		return 0;
+
+	/* write clock */
+	ret = mcp2517fd_cmd_write(
+		spi, MCP2517FD_OSC, priv->regs.osc,
+		priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* wait for synced pll/osc/sclk */
+	timeout = jiffies + MCP2517FD_OSC_POLLING_JIFFIES;
+	while (time_before_eq(jiffies, timeout)) {
+		ret = mcp2517fd_cmd_read(spi, MCP2517FD_OSC,
+					 &priv->regs.osc,
+					 priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+		if ((priv->regs.osc & mask) == waitfor) {
+			priv->active_can_mode = CAN_CON_MODE_CONFIG;
+			return 0;
+		}
+	}
+
+	dev_err(&spi->dev,
+		"Clock did not enable within the timeout period\n");
+	return -ETIMEDOUT;
+}
+
+static void mcp2517fd_hw_sleep(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+fl_
+	/* disable interrupts */
+	mcp2517fd_disable_interrupts(spi, priv->spi_setup_speed_hz);
+
+	priv->active_can_mode = CAN_CON_MODE_SLEEP;
+	priv->regs.con = (priv->regs.con & ~CAN_CON_REQOP_MASK) |
+		(priv->active_can_mode << CAN_CON_REQOP_SHIFT);
+	mcp2517fd_cmd_write(spi, CAN_CON,
+			    priv->regs.con,
+			    priv->spi_setup_speed_hz);
+}
+
+static int mcp2517fd_can_ist_handle_status(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	int ret;
+
+	/* interrupt clearing info */
+	priv->int_clear_value = 0;
+	priv->int_clear_mask = 0;
+	priv->bdiag1_clear_value = 0;
+	priv->bdiag1_clear_mask = 0;
+	priv->can_err_id = 0;
+	memset(priv->can_err_data, 0, 8);
+
+	/* state changes */
+	priv->new_state = priv->can.state;
+
+	/* clear queued fifos */
+	mcp2517fd_clear_queued_fifos(spi);
+
+	/* handle the rx */
+	if (priv->status.intf & CAN_INT_RXIF) {
+		ret = mcp2517fd_can_ist_handle_rxif(spi);
+		if (ret)
+			return ret;
+	}
+
+	/* handle the tef */
+	if (priv->status.intf & CAN_INT_TEFIF) {
+		ret = mcp2517fd_can_ist_handle_tefif(spi);
+		if (ret)
+			return ret;
+	}
+
+	/* process the queued fifos */
+	ret = mcp2517fd_process_queued_fifos(spi);
+
+	/* restart the tx queue if needed */
+	if (priv->tx_queue_status == 2) {
+		/* nothing should be left pending /in flight now... */
+		priv->fifos.tx_pending_mask = 0;
+		priv->fifos.tx_submitted_mask = 0;
+		priv->fifos.tx_processed_mask = 0;
+		priv->tx_queue_status = 1;
+		/* wake queue now */
+		netif_wake_queue(priv->net);
+	}
+
+	/* handle error interrupt flags */
+	if (priv->status.rxovif) {
+		ret = mcp2517fd_can_ist_handle_rxovif(spi);
+		if (ret)
+			return ret;
+	}
+
+	/* mode change erros */
+	if (priv->status.intf & CAN_INT_MODIF) {
+		ret = mcp2517fd_can_ist_handle_modif(spi);
+		if (ret)
+			return ret;
+	}
+
+	/* sram ECC error interrupt */
+	if (priv->status.intf & CAN_INT_ECCIF) {
+		ret = mcp2517fd_can_ist_handle_eccif(spi);
+		if (ret)
+			return ret;
+	}
+
+	/* system error interrupt*/
+	if (priv->status.intf & CAN_INT_SERRIF) {
+		ret = mcp2517fd_can_ist_handle_serrif(spi);
+		if (ret)
+			return ret;
+	}
+
+	/* message format interrupt */
+	if (priv->status.intf & CAN_INT_IVMIF) {
+		priv->can_err_id |= CAN_ERR_PROT;
+		priv->can_err_data[2] |= CAN_ERR_PROT_FORM;
+		priv->int_clear_mask |= CAN_INT_IVMIF;
+		priv->net->stats.rx_frame_errors++;
+		priv->net->stats.rx_errors++;
+	}
+
+	/* handle bus errors in more detail */
+	if (priv->status.intf & CAN_INT_CERRIF) {
+		ret = mcp2517fd_can_ist_handle_cerrif(spi);
+		if (ret)
+			return ret;
+	}
+
+	/* Error counter handling */
+	if (priv->status.trec & CAN_TREC_TXWARN) {
+		priv->new_state = CAN_STATE_ERROR_WARNING;
+		priv->can_err_id |= CAN_ERR_CRTL;
+		priv->can_err_data[1] |= CAN_ERR_CRTL_TX_WARNING;
+	}
+	if (priv->status.trec & CAN_TREC_RXWARN) {
+		priv->new_state = CAN_STATE_ERROR_WARNING;
+		priv->can_err_id |= CAN_ERR_CRTL;
+		priv->can_err_data[1] |= CAN_ERR_CRTL_RX_WARNING;
+	}
+	if (priv->status.trec & CAN_TREC_TXBP) {
+		priv->new_state = CAN_STATE_ERROR_PASSIVE;
+		priv->can_err_id |= CAN_ERR_CRTL;
+		priv->can_err_data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
+	}
+	if (priv->status.trec & CAN_TREC_RXBP) {
+		priv->new_state = CAN_STATE_ERROR_PASSIVE;
+		priv->can_err_id |= CAN_ERR_CRTL;
+		priv->can_err_data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+	}
+	if (priv->status.trec & CAN_TREC_TXBO) {
+		priv->new_state = CAN_STATE_BUS_OFF;
+		priv->can_err_id |= CAN_ERR_BUSOFF;
+	}
+
+	/* based on the last state state check the new state */
+	switch (priv->can.state) {
+	case CAN_STATE_ERROR_ACTIVE:
+		if (priv->new_state >= CAN_STATE_ERROR_WARNING &&
+		    priv->new_state <= CAN_STATE_BUS_OFF)
+			priv->can.can_stats.error_warning++;
+		/* fallthrough */
+	case CAN_STATE_ERROR_WARNING:
+		if (priv->new_state >= CAN_STATE_ERROR_PASSIVE &&
+		    priv->new_state <= CAN_STATE_BUS_OFF)
+			priv->can.can_stats.error_passive++;
+		break;
+	default:
+		break;
+	}
+	priv->can.state = priv->new_state;
+
+	/* and send error packet */
+	if (priv->can_err_id)
+		mcp2517fd_error_skb(priv->net);
+
+	/* handle BUS OFF */
+	if (priv->can.state == CAN_STATE_BUS_OFF) {
+		if (priv->can.restart_ms == 0) {
+efl_		netif_stop_queue(priv->net);
+			priv->force_quit = 1;
+			priv->can.can_stats.bus_off++;
+			can_bus_off(priv->net);
+			mcp2517fd_hw_sleep(spi);
+		}
+	}
+
+	/* clear int flags */
+	if (priv->int_clear_mask) {
+		ret = mcp2517fd_cmd_write_mask(spi,
+					       CAN_INT,
+					       priv->int_clear_value,
+					       priv->int_clear_mask,
+					       priv->spi_speed_hz);
+		if (ret)
+			return ret;
+	}
+	if (priv->bdiag1_clear_mask) {
+		ret = mcp2517fd_cmd_write_mask(spi,
+					       CAN_BDIAG1,
+					       priv->bdiag1_clear_value,
+					       priv->bdiag1_clear_mask,
+					       priv->spi_speed_hz);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static irqreturn_t mcp2517fd_can_ist(int irq, void *dev_id)
+{
+	struct mcp2517fd_priv *priv = dev_id;
+	struct spi_device *spi = priv->spi;
+	int ret;
+
+	priv->stats.irq_calls++;
+	priv->stats.irq_state = IRQ_STATE_RUNNING;
+//am_((PDD "ISR: %s(irq=%d)\n",__func__,irq));
+	while (!priv->force_quit) {
+		/* count irq loops */
+		priv->stats.irq_loops++;
+
+		/* read interrupt status flags */
+		ret = mcp2517fd_cmd_readn(spi, CAN_INT,
+					  &priv->status,
+					  sizeof(priv->status),
+					  priv->spi_speed_hz);
+		if (ret) {
+efl_		return ret; }
+
+#ifdef ADLINK_DEBUG
+{	u32 intf=priv->status.intf;
+	u32 act=(0xFFFF&intf)&(intf>>16);
+	u32 IgnoreFlag=CAN_INT_TEFIF|CAN_INT_RXIF;
+	if(~IgnoreFlag & act) { //~(TEFIF+RXIF+TXIF)
+		am_((" I@ C1INT=0x%08X, ACT=0x%04X\n",intf,act));
+		SpiQuickDump(priv,CAN_VEC,4);
+		// I@ C1INT=0xB11A9008, ACT=0x9008
+		//Dump018: 0x48 0x00 0x40 0x40 # ICODE[6:0]=0x48="Invalid Message Occurred (IVMIF/IE)"
+		DumpBufA((u8 *)&priv->status,sizeof(priv->status),16,CAN_INT);
+		
+	}
+#ifdef ADLINK_DEBUG_DUMP_CUREENT_FIFO
+	if(priv->asyncFifoAddr && (~IgnoreFlag & act)) {
+		SpiQuickDump(priv,priv->asyncFifoAddr,16);
+	}
+	priv->asyncFifoAddr=0;
+#endif
+}
+#endif
+
+		/* only act if the mask is applied */
+		if ((priv->status.intf &
+		     (priv->status.intf >> CAN_INT_IE_SHIFT)) == 0) {
+			break; }
+
+		/* handle the status */
+		ret = mcp2517fd_can_ist_handle_status(spi);
+		if (ret) {
+efl_		return ret; }
+	}
+
+	priv->stats.irq_state = IRQ_STATE_HANDLED;
+
+//am_((PDD "submitted_mask=0x%08X, pending_mask=0x%08X, processed_mask=0x%08X\n",
+//priv->fifos.tx_submitted_mask,priv->fifos.tx_pending_mask,priv->fifos.tx_processed_mask));
+
+	return IRQ_HANDLED;
+}
+
+static int mcp2517fd_get_berr_counter(const struct net_device *net,
+				      struct can_berr_counter *bec)
+{
+	struct mcp2517fd_priv *priv = netdev_priv(net);
+
+	bec->txerr = (priv->status.trec & CAN_TREC_TEC_MASK) >>
+		CAN_TREC_TEC_SHIFT;
+	bec->rxerr = (priv->status.trec & CAN_TREC_REC_MASK) >>
+		CAN_TREC_REC_SHIFT;
+
+	return 0;
+}
+
+static int mcp2517fd_power_enable(struct regulator *reg, int enable)
+{
+	if (IS_ERR_OR_NULL(reg))
+		return 0;
+
+	if (enable)
+		return regulator_enable(reg);
+	else
+		return regulator_disable(reg);
+}
+
+static int mcp2517fd_do_set_mode(struct net_device *net, enum can_mode mode)
+{
+	switch (mode) {
+	case CAN_MODE_START:
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+#ifdef ADLINK_DEBUG
+const char *szBR (u32 bitrate) {
+	static char idx,BufA[64];
+	u32 xhz,TenX;
+	char *szBR=&BufA[(int)idx]; ((sizeof(BufA)-16)<=(idx+=16))?(idx=0):0;
+	if(bitrate<(1*1000*1000)) {
+		xhz=bitrate/1000;//To KHz;
+		TenX=10*1000/xhz;//To 10x us;
+		if(TenX%10) {
+			sprintf(szBR,"%dK(%d.%dus)",xhz,TenX/10,TenX%10);
+		}
+		else {
+			sprintf(szBR,"%dK(%dus)",xhz,TenX/10);
+		}
+	}
+	else {
+		xhz=bitrate/1000000;//To MHz;
+		TenX=10*1000/xhz;//To 10x ns;
+		if(TenX%10) {
+			sprintf(szBR,"%dM(%d.%dns)",xhz,TenX/10,TenX%10);
+		}
+		else {
+			sprintf(szBR,"%dM(%dns)",xhz,TenX/10);
+		}
+	}
+	return szBR;
+}
+#endif
+
+static int mcp2517fd_do_set_nominal_bittiming(struct net_device *net)
+{
+	struct mcp2517fd_priv *priv = netdev_priv(net);
+	struct can_bittiming *bt = &priv->can.bittiming;
+	struct spi_device *spi = priv->spi;
+
+	int sjw = bt->sjw;
+	int pseg2 = bt->phase_seg2;
+	int pseg1 = bt->phase_seg1;
+	int propseg = bt->prop_seg;
+	int brp = bt->brp;
+
+	int tseg1 = propseg + pseg1;
+	int tseg2 = pseg2;
+am_((PDD "%s(): bitrate=%s, brp=%d, sample_point=%d\n",__func__,szBR(bt->bitrate),bt->brp,bt->sample_point));
+am_(("  @ TQ=%dns, PRSEG=%d, PHSEG1=%d, PHSEG2=%d, SJW=%d\n",bt->tq,bt->prop_seg,bt->phase_seg1,bt->phase_seg2,bt->sjw));
+
+#ifdef ADLINK_PATCH_ADJUST_SJW
+	sjw=min(bt->phase_seg1,bt->phase_seg2); 
+	if(bt->sjw!=sjw) {
+		bt->sjw=sjw;
+am_(("	@ Modify SJW=%d\n",bt->sjw));
+	}
+#endif
+
+	/* calculate nominal bit timing */
+	priv->regs.nbtcfg = ((sjw - 1) << CAN_NBTCFG_SJW_SHIFT) |
+		((tseg2 - 1) << CAN_NBTCFG_TSEG2_SHIFT) |
+		((tseg1 - 1) << CAN_NBTCFG_TSEG1_SHIFT) |
+		((brp - 1) << CAN_NBTCFG_BRP_SHIFT);
+
+	return mcp2517fd_cmd_write(spi, CAN_NBTCFG,
+				   priv->regs.nbtcfg,
+				   priv->spi_setup_speed_hz);
+}
+
+static int mcp2517fd_do_set_data_bittiming(struct net_device *net)
+{
+	struct mcp2517fd_priv *priv = netdev_priv(net);
+	struct can_bittiming *bt = &priv->can.data_bittiming;
+	struct spi_device *spi = priv->spi;
+
+	int sjw = bt->sjw;
+	int pseg2 = bt->phase_seg2;
+	int pseg1 = bt->phase_seg1;
+	int propseg = bt->prop_seg;
+	int brp = bt->brp;
+
+	int tseg1 = propseg + pseg1;
+	int tseg2 = pseg2;
+am_((PDD "%s(): bitrate=%s, brp=%d, sample_point=%d\n",__func__,szBR(bt->bitrate),bt->brp,bt->sample_point));
+am_(("  @ TQ=%dns, PRSEG=%d, PHSEG1=%d, PHSEG2=%d, SJW=%d\n",bt->tq,bt->prop_seg,bt->phase_seg1,bt->phase_seg2,bt->sjw));
+
+#ifdef ADLINK_PATCH_ADJUST_SJW
+	sjw=min(bt->phase_seg1,bt->phase_seg2); 
+	if(bt->sjw!=sjw) {
+		bt->sjw=sjw;
+am_(("	@ Modify SJW=%d\n",bt->sjw));
+	}
+#endif
+
+	/* calculate nominal bit timing */
+	priv->regs.dbtcfg = ((sjw - 1) << CAN_DBTCFG_SJW_SHIFT) |
+		((tseg2 - 1) << CAN_DBTCFG_TSEG2_SHIFT) |
+		((tseg1 - 1) << CAN_DBTCFG_TSEG1_SHIFT) |
+		((brp - 1) << CAN_DBTCFG_BRP_SHIFT);
+
+	return mcp2517fd_cmd_write(spi, CAN_DBTCFG,
+				   priv->regs.dbtcfg,
+				   priv->spi_setup_speed_hz);
+}
+
+static int mcp2517fd_hw_probe (struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	u32 val;
+	int ret;
+
+	/* Wait for oscillator startup timer after power up */
+	mdelay(MCP2517FD_OST_DELAY_MS);
+
+	/* send a "blind" reset, hoping we are in Config mode */
+	mcp2517fd_cmd_reset(spi, priv->spi_setup_speed_hz);
+
+	/* Wait for oscillator startup again */
+	mdelay(MCP2517FD_OST_DELAY_MS);
+
+	/* check clock register that the clock is ready or disabled */
+	ret = mcp2517fd_cmd_read(spi, MCP2517FD_OSC, &val,
+				 priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* there can only be one... */
+	switch (val & (MCP2517FD_OSC_OSCRDY | MCP2517FD_OSC_OSCDIS)) {
+	case MCP2517FD_OSC_OSCRDY: /* either the clock is ready */
+fl_		break;
+	case MCP2517FD_OSC_OSCDIS: /* or the clock is disabled */
+		/* wakeup sleeping system */
+fl_		ret = mcp2517fd_hw_wake(spi);
+		if (ret)
+			return ret;
+		/* send a reset, hoping we are now in Config mode */
+		mcp2517fd_cmd_reset(spi, priv->spi_setup_speed_hz);
+
+		/* Wait for oscillator startup again */
+		mdelay(MCP2517FD_OST_DELAY_MS);
+		break;
+	default:
+		/* otherwise there is no valid device (or in strange state)
+		 *
+		 * if PLL is enabled but not ready, then there may be
+		 * something "fishy"
+		 * this happened during driver development
+		 * (enabling pll, when when on wrong clock), so best warn
+		 * about such a possibility
+		 */
+fl_		if ((val & (MCP2517FD_OSC_PLLEN | MCP2517FD_OSC_PLLRDY))
+		    == MCP2517FD_OSC_PLLEN)
+			dev_err(&spi->dev,
+				"mcp2517fd may be in a strange state - a power disconnect may be required\n");
+
+		return -ENODEV;
+	}
+
+	/* check if we are in config mode already*/
+
+	/* read CON register and match */
+	ret = mcp2517fd_cmd_read(spi, CAN_CON, &val,
+				 priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* apply mask and check */
+	if ((val & CAN_CON_DEFAULT_MASK) == CAN_CON_DEFAULT)
+		return 0;
+
+	/* as per datasheet a reset only works in Config Mode
+	 * so as we have in principle no knowledge of the current
+	 * mode that the controller is in we have no safe way
+	 * to detect the device correctly
+	 * hence we need to "blindly" put the controller into
+	 * config mode.
+	 * on the "save" side, the OSC reg has to be valid already,
+	 * so there is a chance we got the controller...
+	 */
+
+	/* blindly force it into config mode */
+	ret = mcp2517fd_cmd_write(spi, CAN_CON, CAN_CON_DEFAULT,
+				  priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* delay some time */
+	mdelay(MCP2517FD_OST_DELAY_MS);
+
+	/* reset can controller */
+	mcp2517fd_cmd_reset(spi, priv->spi_setup_speed_hz);
+
+	/* delay some time */
+	mdelay(MCP2517FD_OST_DELAY_MS);
+
+	/* read CON register and match a final time */
+	ret = mcp2517fd_cmd_read(spi, CAN_CON, &val,
+				 priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* just allow dumping the register if we ever get here */
+	dev_dbg(&spi->dev, "read CAN_CON = 0x%08x\n", val);
+
+	/* apply mask and check */
+	if ((val & CAN_CON_DEFAULT_MASK) != CAN_CON_DEFAULT)
+		return -ENODEV;
+
+	/* just in case: disable interrupts on controller */
+	return mcp2517fd_disable_interrupts(spi,
+					    priv->spi_setup_speed_hz);
+}
+
+static int mcp2517fd_set_normal_mode(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	int ret;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)
+		priv->active_can_mode = CAN_CON_MODE_EXTERNAL_LOOPBACK;
+	else if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)
+		priv->active_can_mode = CAN_CON_MODE_LISTENONLY;
+	else if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
+		priv->active_can_mode = CAN_CON_MODE_MIXED;
+	else
+		priv->active_can_mode = CAN_CON_MODE_CAN2_0;
+
+	/* set mode to normal */
+	priv->regs.con = (priv->regs.con & ~CAN_CON_REQOP_MASK) |
+		(priv->active_can_mode << CAN_CON_REQOP_SHIFT);
+
+	ret = mcp2517fd_cmd_write(spi, CAN_CON,
+				  priv->regs.con,
+				  priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	return 0;
+}
+
+static int mcp2517fd_setup_osc(struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	int val = ((priv->config.clock_pll) ? MCP2517FD_OSC_PLLEN : 0)
+		| ((priv->config.clock_div2) ? MCP2517FD_OSC_SCLKDIV : 0);
+	int waitfor = ((priv->config.clock_pll) ? MCP2517FD_OSC_PLLRDY : 0)
+		| ((priv->config.clock_div2) ? MCP2517FD_OSC_SCLKRDY : 0)
+		| MCP2517FD_OSC_OSCRDY;
+	int ret;
+	unsigned long timeout;
+
+	/* manage clock_out divider */
+	switch (priv->config.clock_odiv) {
+	case 10:
+		val |= (MCP2517FD_OSC_CLKODIV_10)
+			<< MCP2517FD_OSC_CLKODIV_SHIFT;
+		break;
+	case 4:
+		val |= (MCP2517FD_OSC_CLKODIV_4)
+			<< MCP2517FD_OSC_CLKODIV_SHIFT;
+		break;
+	case 2:
+		val |= (MCP2517FD_OSC_CLKODIV_2)
+			<< MCP2517FD_OSC_CLKODIV_SHIFT;
+		break;
+	case 1:
+		val |= (MCP2517FD_OSC_CLKODIV_1)
+			<< MCP2517FD_OSC_CLKODIV_SHIFT;
+		break;
+	case 0:
+		/* this means implicitly SOF output */
+		val |= (MCP2517FD_OSC_CLKODIV_10)
+			<< MCP2517FD_OSC_CLKODIV_SHIFT;
+		break;
+	default:
+		dev_err(&spi->dev,
+			"Unsupported output clock divider %i\n",
+			priv->config.clock_odiv);
+		return -EINVAL;
+	}
+
+	/* write clock */
+	ret = mcp2517fd_cmd_write(spi, MCP2517FD_OSC, val,
+				  priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* wait for synced pll/osc/sclk */
+	timeout = jiffies + MCP2517FD_OSC_POLLING_JIFFIES;
+	while (time_before_eq(jiffies, timeout)) {
+		ret = mcp2517fd_cmd_read(spi, MCP2517FD_OSC,
+					 &priv->regs.osc,
+					 priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+		if ((priv->regs.osc & waitfor) == waitfor)
+			return 0;
+	}
+
+	dev_err(&spi->dev,
+		"Clock did not lock within the timeout period\n");
+
+	/* we timed out */
+	return -ENODEV;
+}
+
+static int mcp2517fd_setup_fifo(struct net_device *net,
+				struct mcp2517fd_priv *priv,
+				struct spi_device *spi)
+{
+	u32 con_val = priv->regs.con & (~CAN_CON_REQOP_MASK);
+	u32 val, available_memory, tx_memory_used;
+	int ret;
+	int i, fifo;
+
+	/* clear all filter */
+	for (i = 0; i < 32; i++) {
+		ret = mcp2517fd_cmd_write(spi, CAN_FLTOBJ(i), 0,
+					  priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+		ret = mcp2517fd_cmd_write(spi, CAN_FLTMASK(i), 0,
+					  priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+		ret = mcp2517fd_cmd_write_mask(
+			spi, CAN_FLTCON(i), 0,
+			CAN_FILCON_MASK(i),
+			priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+	}
+
+	/* decide on TEF, tx and rx FIFOS */
+	switch (net->mtu) {
+	case CAN_MTU:
+		/* note: if we have INT1 connected to a GPIO
+		 * then we could handle this differently and more
+		 * efficiently
+		 */
+
+		/* mtu is 8 */
+		priv->fifos.payload_size = 8;
+		priv->fifos.payload_mode = CAN_TXQCON_PLSIZE_8;
+
+		/* 7 tx fifos starting at fifo 1 */
+		priv->fifos.tx_fifos = 7;
+
+		/* 24 rx fifos with 1 buffers/fifo */
+		priv->fifos.rx_fifo_depth = 1;
+
+		break;
+	case CANFD_MTU:
+		/* wish there was a way to have hw filters
+		 * that can separate based on length ...
+		 */
+		/* MTU is 64 */
+		priv->fifos.payload_size = 64;
+		priv->fifos.payload_mode = CAN_TXQCON_PLSIZE_64;
+
+		/* 7 tx fifos */
+		priv->fifos.tx_fifos = 7;
+
+		/* 19 rx fifos with 1 buffer/fifo */
+		priv->fifos.rx_fifo_depth = 1;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* if defined as a module modify the number of tx_fifos */
+	if (tx_fifos) {
+		dev_info(&spi->dev,
+			 "Using %i tx-fifos as per module parameter\n",
+			 tx_fifos);
+		priv->fifos.tx_fifos = tx_fifos;
+	}
+
+	/* check range - we need 1 RX-fifo and one tef-fifo, hence 30 */
+	if (priv->fifos.tx_fifos > 30) {
+		dev_err(&spi->dev,
+			"There is an absolute maximum of 30 tx-fifos\n");
+		return -EINVAL;
+	}
+
+	tx_memory_used = priv->fifos.tx_fifos * (
+		sizeof(struct mcp2517fd_obj_tef) +
+		sizeof(struct mcp2517fd_obj_tx) +
+		priv->fifos.payload_size
+		);
+	/* check that we are not exceeding memory limits with 1 RX buffer */
+	if (tx_memory_used + (sizeof(struct mcp2517fd_obj_rx) +
+		   priv->fifos.payload_size) > MCP2517FD_BUFFER_TXRX_SIZE) {
+		dev_err(&spi->dev,
+			"Configured %i tx-fifos exceeds available memory already\n",
+			priv->fifos.tx_fifos);
+		return -EINVAL;
+	}
+
+	/* calculate possible amount of RX fifos */
+	available_memory = MCP2517FD_BUFFER_TXRX_SIZE - tx_memory_used;
+
+	priv->fifos.rx_fifos = available_memory /
+		(sizeof(struct mcp2517fd_obj_rx) +
+		 priv->fifos.payload_size) /
+		priv->fifos.rx_fifo_depth;
+
+	/* we only support 31 FIFOS in total (TEF = FIFO0),
+	 * so modify rx accordingly
+	 */
+	if (priv->fifos.tx_fifos + priv->fifos.rx_fifos > 31)
+		priv->fifos.rx_fifos = 31 - priv->fifos.tx_fifos;
+
+	/* calculate rx/tx fifo start */
+	priv->fifos.rx_fifo_start = 1;
+	priv->fifos.tx_fifo_start =
+		priv->fifos.rx_fifo_start + priv->fifos.rx_fifos;
+
+	/* set up TEF SIZE to the number of tx_fifos and IRQ */
+	priv->regs.tefcon = CAN_TEFCON_FRESET |
+		CAN_TEFCON_TEFNEIE |
+		CAN_TEFCON_TEFTSEN |
+		((priv->fifos.tx_fifos - 1) << CAN_TEFCON_FSIZE_SHIFT),
+
+	ret = mcp2517fd_cmd_write(
+		spi, CAN_TEFCON,
+		priv->regs.tefcon,
+		priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* set up tx fifos */
+	val = CAN_FIFOCON_TXEN |
+		CAN_FIFOCON_FRESET | /* reset FIFO */
+		(priv->fifos.payload_mode << CAN_FIFOCON_PLSIZE_SHIFT) |
+		(0 << CAN_FIFOCON_FSIZE_SHIFT); /* 1 FIFO only */
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
+		val |= CAN_FIFOCON_TXAT_ONE_SHOT <<
+			CAN_FIFOCON_TXAT_SHIFT;
+	else
+		val |= CAN_FIFOCON_TXAT_UNLIMITED <<
+			CAN_FIFOCON_TXAT_SHIFT;
+
+	for (i = 0; i < priv->fifos.tx_fifos; i++) {
+		fifo = priv->fifos.tx_fifo_start + i;
+		ret = mcp2517fd_cmd_write(
+			spi, CAN_FIFOCON(fifo),
+			val | (fifo << CAN_FIFOCON_TXPRI_SHIFT),
+			priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+		priv->fifos.tx_fifo_mask |= BIT(fifo);
+	}
+
+	/* now set up RX FIFO */
+	for (i = 0; i < priv->fifos.rx_fifos; i++) {
+		fifo = priv->fifos.rx_fifo_start + i;
+		/* prepare the fifo itself */
+		ret = mcp2517fd_cmd_write(
+			spi, CAN_FIFOCON(fifo),
+			(priv->fifos.payload_mode <<
+			 CAN_FIFOCON_PLSIZE_SHIFT) |
+			((priv->fifos.rx_fifo_depth - 1) <<
+			 CAN_FIFOCON_FSIZE_SHIFT) |
+			CAN_FIFOCON_RXTSEN | /* RX timestamps */
+			CAN_FIFOCON_FRESET | /* reset FIFO */
+			CAN_FIFOCON_TFERFFIE | /* FIFO Full */
+			CAN_FIFOCON_TFHRFHIE | /* FIFO Half Full*/
+			CAN_FIFOCON_TFNRFNIE | /* FIFO not empty */
+			/* on the last fifo add overflow flag */
+			((i == priv->fifos.rx_fifos - 1) ?
+			 CAN_FIFOCON_RXOVIE : 0),
+			priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+		/* prepare the rx filter config: filter i directs to fifo
+		 * FLTMSK and FLTOBJ are 0 already, so they match everything
+		 */
+		ret = mcp2517fd_cmd_write_mask(
+			spi, CAN_FLTCON(i),
+			CAN_FIFOCON_FLTEN(i) | (fifo << CAN_FILCON_SHIFT(i)),
+			CAN_FIFOCON_FLTEN(i) | CAN_FILCON_MASK(i),
+			priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+
+		priv->fifos.rx_fifo_mask |= BIT(fifo);
+	}
+
+	/* we need to move out of CONFIG mode shortly to get the addresses */
+	ret = mcp2517fd_cmd_write(
+		spi, CAN_CON, con_val |
+		(CAN_CON_MODE_INTERNAL_LOOPBACK << CAN_CON_REQOP_SHIFT),
+		priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* for the TEF fifo */
+	ret = mcp2517fd_cmd_read(spi, CAN_TEFUA, &val,
+				 priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+	priv->fifos.tef_address = val;
+	priv->fifos.tef_address_start = val;
+	priv->fifos.tef_address_end = priv->fifos.tef_address_start +
+		(priv->fifos.tx_fifos) * sizeof(struct mcp2517fd_obj_tef) -
+		1;
+
+	/* get all the relevant addresses for the transmit fifos */
+	for (i = 0; i < priv->fifos.tx_fifos; i++) {
+		fifo = priv->fifos.tx_fifo_start + i;
+		ret = mcp2517fd_cmd_read(spi, CAN_FIFOUA(fifo),
+					 &val, priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+		priv->fifos.fifo_address[fifo] = val;
+	}
+
+	/* and prepare the spi_messages */
+	ret = mcp2517fd_fill_spi_transmit_fifos(priv);
+	if (ret)
+		return ret;
+
+	/* get all the relevant addresses for the rx fifos */
+	for (i = 0; i < priv->fifos.rx_fifos; i++) {
+		fifo = priv->fifos.rx_fifo_start + i;
+		ret = mcp2517fd_cmd_read(spi, CAN_FIFOUA(fifo),
+					 &val, priv->spi_setup_speed_hz);
+		if (ret)
+			return ret;
+	       priv->fifos.fifo_address[fifo] = val;
+	}
+
+	/* now get back into config mode */
+	ret = mcp2517fd_cmd_write(
+		spi, CAN_CON, con_val |
+		(CAN_CON_MODE_CONFIG << CAN_CON_REQOP_SHIFT),
+		priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+am_((PDD "%s(): rx_fifo_start=%d,sz=%d(0x%X)\n",__func__,
+priv->fifos.rx_fifo_start,priv->fifos.rx_fifos,priv->fifos.fifo_address[priv->fifos.rx_fifo_start]));
+am_(("  @ tx_fifo_start=%d,sz=%d(0x%X), tef_address_start=0x%X\n",priv->fifos.tx_fifo_start,priv->fifos.tx_fifos,
+priv->fifos.fifo_address[priv->fifos.tx_fifo_start],priv->fifos.tef_address_start));
+//@@ mcp2517fd_setup_fifo(): rx_fifo_start=1,sz=24(0x54), tx_fifo_start=25,sz=7(0x234), tef_address_start=0x0
+
+	return 0;
+}
+
+static int mcp2517fd_setup(struct net_device *net,
+			   struct mcp2517fd_priv *priv,
+			   struct spi_device *spi)
+{
+	u32 val;
+	int ret;
+
+	/* set up pll/clock if required */
+	ret = mcp2517fd_setup_osc(spi);
+	if (ret)
+		return ret;
+
+	/* set up RAM ECC (but for now without interrupts) */
+	priv->regs.ecccon = MCP2517FD_ECCCON_ECCEN;
+	ret = mcp2517fd_cmd_write(spi, MCP2517FD_ECCCON,
+				  priv->regs.ecccon,
+				  priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* GPIO handling - could expose this as gpios*/
+	val = 0; /* PUSHPULL INT , TXCAN PUSH/PULL, no Standby */
+
+	/* SOF/CLOCKOUT pin 3 */
+	if (priv->config.clock_odiv < 0)
+		val |= MCP2517FD_IOCON_SOF;
+	/* GPIO0 - pin 9 */
+	switch (priv->config.gpio0_mode) {
+	case gpio_mode_standby:
+	case gpio_mode_int: /* asserted low on TXIF */
+	case gpio_mode_out_low:
+	case gpio_mode_out_high:
+	case gpio_mode_in:
+		val |= priv->config.gpio0_mode;
+		break;
+	default: /* GPIO IN */
+		dev_err(&spi->dev,
+			"GPIO1 does not support mode %08x\n",
+			priv->config.gpio0_mode);
+		return -EINVAL;
+	}
+	/* GPIO1 - pin 8 */
+	switch (priv->config.gpio1_mode) {
+	case gpio_mode_standby:
+		dev_err(&spi->dev,
+			"GPIO1 does not support transceiver standby\n");
+		return -EINVAL;
+	case gpio_mode_int: /* asserted low on RXIF */
+	case gpio_mode_out_low:
+	case gpio_mode_out_high:
+	case gpio_mode_in:
+		val |= priv->config.gpio1_mode << 1;
+		break;
+	default:
+		dev_err(&spi->dev,
+			"GPIO1 does not support mode %08x\n",
+			priv->config.gpio0_mode);
+		return -EINVAL;
+	}
+	/* INT/GPIO pins as open drain */
+	if (priv->config.gpio_opendrain)
+		val |= MCP2517FD_IOCON_INTOD;
+	if (priv->config.txcan_opendrain)
+		val |= MCP2517FD_IOCON_TXCANOD; /* OpenDrain TXCAN */
+	if (priv->config.int_opendrain)
+		val |= MCP2517FD_IOCON_INTOD; /* OpenDrain INT pins */
+
+	priv->regs.iocon = val;
+	ret = mcp2517fd_cmd_write(spi, MCP2517FD_IOCON, val,
+				  priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* set up Transmitter Delay compensation */
+	priv->regs.tdc = CAN_TDC_EDGFLTEN;
+	
+#ifdef ADLINK_PATCH_ENABLE_TDCMOD//DS200005678B-3.4.3 - Transmitter Delay Compensation (TDC).
+	if(CAN_CTRLMODE_FD & priv->can.ctrlmode) {
+		struct can_bittiming *bt = &priv->can.data_bittiming;
+		u8 bTDCO=(CAN_TDC_TDCV_MASK&((1000000000/bt->bitrate/bt->tq)-bt->phase_seg2-1));
+		bTDCO*=bt->brp;//refer: 3.4.8-bit time configuration example;
+		priv->regs.tdc |= (CAN_TDC_TDCO_MASK & (bTDCO<<CAN_TDC_TDCO_SHIFT));
+		priv->regs.tdc |= (0x02<<CAN_TDC_TDCMOD_SHIFT);
+am_(("  @ Enable TDCMOD, TDCO=%d (DataPhase:PRSEG+PHSEG1), C1TDC=0x%08X\n",bTDCO,priv->regs.tdc));
+	}
+#endif
+	
+	ret = mcp2517fd_cmd_write(spi, CAN_TDC, priv->regs.tdc,
+				  priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* time stamp control register - 1ns resolution, but disabled */
+	ret = mcp2517fd_cmd_write(spi, CAN_TBC, 0,
+				  priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+	priv->regs.tscon = CAN_TSCON_TBCEN |
+		((priv->can.clock.freq / 1000000)
+		 << CAN_TSCON_TBCPRE_SHIFT);
+	ret = mcp2517fd_cmd_write(spi, CAN_TSCON,
+				  priv->regs.tscon,
+				  priv->spi_setup_speed_hz);
+	if (ret)
+		return ret;
+
+	/* setup value of con_register */
+	priv->regs.con = CAN_CON_STEF /* enable TEF */;
+	/* transmissin bandwidth sharing bits */
+	if (bw_sharing_log2bits < 12)
+		bw_sharing_log2bits = 12;
+	priv->regs.con |= bw_sharing_log2bits << CAN_CON_TXBWS_SHIFT;
+	/* non iso FD mode */
+	if (!(priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))
+		priv->regs.con |= CAN_CON_ISOCRCEN;
+	/* one shot */
+	if (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
+		priv->regs.con |= CAN_CON_RTXAT;
+
+#ifdef ADLINK_DEBUG_ENABLE_PXEDIS
+	priv->regs.con |= CAN_CON_PXEDIS;
+#endif
+
+	/* setup fifos - this also puts the system into sleep mode */
+	return mcp2517fd_setup_fifo(net, priv, spi);
+}
+
+static int mcp2517fd_open(struct net_device *net)
+{
+	struct mcp2517fd_priv *priv = netdev_priv(net);
+	struct spi_device *spi = priv->spi;
+	int ret;
+fl_
+	ret = open_candev(net);
+	if (ret) {
+		dev_err(&spi->dev, "unable to set initial baudrate!\n");
+		return ret;
+	}
+
+#ifdef ADLINK_DEBUG_ONE_SHOT
+	priv->can.ctrlmode|=CAN_CTRLMODE_ONE_SHOT; 
+#endif
+
+	mcp2517fd_power_enable(priv->transceiver, 1);
+
+	priv->force_quit = 0;
+
+	priv->stats.irq_state = 0;
+	priv->stats.irq_calls = 0;
+	priv->stats.irq_loops = 0;
+
+	priv->force_quit = 0;
+	ret = request_threaded_irq(spi->irq, NULL,
+				   mcp2517fd_can_ist,
+				   IRQF_ONESHOT | IRQF_TRIGGER_LOW,
+				   DEVICE_NAME, priv);
+	if (ret) {
+		dev_err(&spi->dev, "failed to acquire irq %d - %i\n",
+			spi->irq, ret);
+		mcp2517fd_power_enable(priv->transceiver, 0);
+		close_candev(net);
+		return ret;
+	}
+
+	/* wake from sleep if necessary */
+	ret = mcp2517fd_hw_wake(spi);
+	if (ret)
+		goto open_clean;
+
+	ret = mcp2517fd_hw_probe(spi);
+	if (ret) {
+		dev_err(&spi->dev,
+			"HW Probe failed, but was working earlier!\n");
+		goto open_clean;
+	}
+
+	ret = mcp2517fd_setup(net, priv, spi);
+	if (ret)
+		goto open_clean;
+
+#ifdef CONFIG_SPI_IMX
+	priv->SpiIdx=0;
+	memset(priv->SpiTxA,0,sizeof(priv->SpiTxA));
+#endif
+#ifdef ADLINK_DEBUG_DUMP_CUREENT_FIFO
+	priv->asyncFifoAddr=0;
+#endif
+
+	mcp2517fd_do_set_nominal_bittiming(net);
+	mcp2517fd_do_set_data_bittiming(net);
+
+	ret = mcp2517fd_set_normal_mode(spi);
+	if (ret)
+		goto open_clean;
+
+	/* only now enable the interrupt on the controller */
+	ret =  mcp2517fd_enable_interrupts(spi,
+					   priv->spi_setup_speed_hz);
+	if (ret)
+		goto open_clean;
+
+	can_led_event(net, CAN_LED_EVENT_OPEN);
+
+	priv->tx_queue_status = 1;
+	netif_wake_queue(net);
+
+#if defined(ADLINK_DEBUG_ONE_SHOT)||defined(ADLINK_DEBUG_LOOPBACK)
+am_((PDD "%s(): can.ctrlmode=0x%02X; #FD=20h, OneShot=8h, LOOPBACK=1h, NonISO=80h\n",__func__,priv->can.ctrlmode));
+//CAN_CTRLMODE_FD_NON_ISO=0x80, CAN_CTRLMODE_FD=0x20, CAN_CTRLMODE_LOOPBACK=0x01
+#endif
+
+#ifdef ADLINK_DEBUG_DUMP_FSR
+	McpReadWriteTest(spi,DUMP_FSR);
+#endif
+
+	return 0;
+
+open_clean:
+	mcp2517fd_disable_interrupts(spi, priv->spi_setup_speed_hz);
+	free_irq(spi->irq, priv);
+	mcp2517fd_hw_sleep(spi);
+	mcp2517fd_power_enable(priv->transceiver, 0);
+	close_candev(net);
+
+	return ret;
+}
+
+static void mcp2517fd_clean(struct net_device *net)
+{
+	struct mcp2517fd_priv *priv = netdev_priv(net);
+	int i;
+fl_
+	for (i = 0; i < priv->fifos.tx_fifos; i++) {
+		if (priv->fifos.tx_pending_mask & BIT(i)) {
+			can_free_echo_skb(priv->net, 0);
+			priv->net->stats.tx_errors++;
+		}
+	}
+
+	priv->fifos.tx_pending_mask = 0;
+}
+
+static int mcp2517fd_stop(struct net_device *net)
+{
+	struct mcp2517fd_priv *priv = netdev_priv(net);
+	struct spi_device *spi = priv->spi;
+fl_
+	close_candev(net);
+
+	kfree(priv->spi_transmit_fifos);
+	priv->spi_transmit_fifos = NULL;
+
+	priv->force_quit = 1;
+
+#ifdef ADLINK_PATCH_OF_IRQ	
+	//ky_note: Disable hardware first;
+	mcp2517fd_disable_interrupts(spi, priv->spi_setup_speed_hz);
+	free_irq(spi->irq, priv);
+	
+#else	
+	free_irq(spi->irq, priv);
+	/* Disable and clear pending interrupts */
+	mcp2517fd_disable_interrupts(spi, priv->spi_setup_speed_hz);
+#endif
+
+	mcp2517fd_clean(net);
+
+	mcp2517fd_hw_sleep(spi);
+
+	mcp2517fd_power_enable(priv->transceiver, 0);
+
+	priv->can.state = CAN_STATE_STOPPED;
+
+	can_led_event(net, CAN_LED_EVENT_STOP);
+
+	return 0;
+}
+
+static const struct net_device_ops mcp2517fd_netdev_ops = {
+	.ndo_open = mcp2517fd_open,
+	.ndo_stop = mcp2517fd_stop,
+	.ndo_start_xmit = mcp2517fd_start_xmit,
+	.ndo_change_mtu = can_change_mtu,
+};
+
+static const struct of_device_id of_mcp2517fd_id_table[] = {
+	{
+		.compatible	= "microchip,mcp2517fd",
+		.data		= (void *)CAN_MCP2517FD,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of,of_mcp2517fd_id_table);
+
+static const struct spi_device_id spi_mcp2517fd_id_table[] = {
+	{
+		.name		= "mcp2517fd",
+		.driver_data	= (kernel_ulong_t)CAN_MCP2517FD,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(spi,spi_mcp2517fd_id_table);
+
+static void mcp2517fd_debugfs_add(struct mcp2517fd_priv *priv)
+{
+#if defined(CONFIG_DEBUG_FS)
+	struct dentry *root, *fifousage, *fifoaddr, *rx, *tx, *status, *regs;
+	char name[32];
+	int i;
+
+	/* create the net device name */
+	snprintf(name, sizeof(name), DEVICE_NAME "-%s", priv->net->name);
+	priv->debugfs_dir = debugfs_create_dir(name, NULL);
+	root = priv->debugfs_dir;
+
+	rx = debugfs_create_dir("rx", root);
+	tx = debugfs_create_dir("tx", root);
+	fifousage = debugfs_create_dir("fifo_usage", root);
+	fifoaddr = debugfs_create_dir("fifo_address", root);
+	status = debugfs_create_dir("status", root);
+	regs = debugfs_create_dir("regs", root);
+
+	/* add spi speed info */
+	debugfs_create_u32("spi_setup_speed_hz", 0444, root,
+			   &priv->spi_setup_speed_hz);
+	debugfs_create_u32("spi_speed_hz", 0444, root,
+			   &priv->spi_speed_hz);
+
+	/* add irq state info */
+	debugfs_create_u64("irq_calls", 0444, root, &priv->stats.irq_calls);
+	debugfs_create_u64("irq_loops", 0444, root, &priv->stats.irq_loops);
+	debugfs_create_u32("irq_state", 0444, root, &priv->stats.irq_state);
+
+	/* export the status structure */
+	debugfs_create_x32("intf", 0444, status, &priv->status.intf);
+	debugfs_create_x32("rx_if", 0444, status, &priv->status.rxif);
+	debugfs_create_x32("tx_if", 0444, status, &priv->status.txif);
+	debugfs_create_x32("rx_ovif", 0444, status, &priv->status.rxovif);
+	debugfs_create_x32("tx_atif", 0444, status, &priv->status.txatif);
+	debugfs_create_x32("tx_req", 0444, status, &priv->status.txreq);
+	debugfs_create_x32("trec", 0444, status, &priv->status.trec);
+	debugfs_create_x32("bdiag0", 0444, status, &priv->status.bdiag0);
+	debugfs_create_x32("bdiag1", 0444, status, &priv->status.bdiag1);
+
+	/* some configuration registers */
+	debugfs_create_x32("con", 0444, regs, &priv->regs.con);
+	debugfs_create_x32("ecccon", 0444, regs, &priv->regs.ecccon);
+	debugfs_create_x32("osc", 0444, regs, &priv->regs.osc);
+	debugfs_create_x32("iocon", 0444, regs, &priv->regs.iocon);
+	debugfs_create_x32("tdc", 0444, regs, &priv->regs.tdc);
+	debugfs_create_x32("tscon", 0444, regs, &priv->regs.tscon);
+	debugfs_create_x32("nbtcfg", 0444, regs, &priv->regs.nbtcfg);
+	debugfs_create_x32("dbtcfg", 0444, regs, &priv->regs.dbtcfg);
+
+	/* information on fifos */
+	debugfs_create_u32("fifo_start", 0444, rx,
+			   &priv->fifos.rx_fifo_start);
+	debugfs_create_u32("fifo_count", 0444, rx,
+			   &priv->fifos.rx_fifos);
+	debugfs_create_x32("fifo_mask", 0444, rx,
+			   &priv->fifos.rx_fifo_mask);
+	debugfs_create_u64("rx_overflow", 0444, rx,
+			   &priv->stats.rx_overflow);
+
+	debugfs_create_u32("fifo_start", 0444, tx,
+			   &priv->fifos.tx_fifo_start);
+	debugfs_create_u32("fifo_count", 0444, tx,
+			   &priv->fifos.tx_fifos);
+	debugfs_create_x32("fifo_mask", 0444, tx,
+			   &priv->fifos.tx_fifo_mask);
+	debugfs_create_x32("fifo_pending", 0444, tx,
+			   &priv->fifos.tx_pending_mask);
+	debugfs_create_x32("fifo_submitted", 0444, tx,
+			   &priv->fifos.tx_submitted_mask);
+	debugfs_create_x32("fifo_processed", 0444, tx,
+			   &priv->fifos.tx_processed_mask);
+	debugfs_create_u32("queue_status", 0444, tx,
+			   &priv->tx_queue_status);
+
+	debugfs_create_u32("fifo_max_payload_size", 0444, root,
+			   &priv->fifos.payload_size);
+
+	/* statistics on fifo buffer usage */
+	for (i = 1; i < 32; i++) {
+		snprintf(name, sizeof(name), "%02i", i);
+		debugfs_create_u64(name, 0444, fifousage,
+				   &priv->stats.fifo_usage[i]);
+		debugfs_create_u32(name, 0444, fifoaddr,
+				   &priv->fifos.fifo_address[i]);
+	}
+
+#endif
+}
+
+static void mcp2517fd_debugfs_remove(struct mcp2517fd_priv *priv)
+{
+#if defined(CONFIG_DEBUG_FS)
+	debugfs_remove_recursive(priv->debugfs_dir);
+#endif
+}
+
+int mcp2517fd_of_parse(struct mcp2517fd_priv *priv)
+{
+#ifdef CONFIG_OF_DYNAMIC
+	struct spi_device *spi = priv->spi;
+	const struct device_node *np = spi->dev.of_node;
+	u32 val;
+	int ret;
+
+	ret = of_property_read_u32_index(np, "microchip,clock_div",
+					 0, &val);
+	if (!ret) {
+		switch (val) {
+		case 1:
+			priv->config.clock_div2 = false;
+			break;
+		case 2:
+			priv->config.clock_div2 = true;
+			break;
+		default:
+			dev_err(&spi->dev,
+				"Invalid value in device tree for microchip,clock_div: %u - valid_values: 1, 2\n",
+				val);
+			return -EINVAL;
+		}
+	}
+
+	ret = of_property_read_u32_index(np, "microchip,clock_out_div",
+					 0, &val);
+	if (!ret) {
+		switch (val) {
+		case 0:
+		case 1:
+		case 2:
+		case 4:
+		case 10:
+			priv->config.clock_odiv = val;
+			break;
+		default:
+			dev_err(&spi->dev,
+				"Invalid value in device tree for microchip,clock_out_div: %u - valid values: 0, 1, 2, 4, 10\n",
+				val);
+			return -EINVAL;
+		}
+	}
+
+	ret = of_property_read_u32_index(np, "microchip,gpio0_mode",
+					 0, &val);
+	if (!ret) {
+		switch (val) {
+		case 0:
+			priv->config.gpio0_mode = gpio_mode_in;
+			break;
+		case 1:
+			priv->config.gpio0_mode = gpio_mode_int;
+			break;
+		case 2:
+			priv->config.gpio0_mode = gpio_mode_out_low;
+			break;
+		case 3:
+			priv->config.gpio0_mode = gpio_mode_out_high;
+			break;
+		case 4:
+			priv->config.gpio0_mode = gpio_mode_standby;
+			break;
+		default:
+			dev_err(&spi->dev,
+				"Invalid value in device tree for microchip,gpio0_mode: %u - valid values: 0, 1, 2, 3, 4\n",
+				val);
+			return -EINVAL;
+		}
+	} else {
+		priv->config.gpio0_mode = gpio_mode_in;
+	}
+
+	ret = of_property_read_u32_index(np, "microchip,gpio1_mode",
+					 0, &val);
+	if (!ret) {
+		switch (val) {
+		case 0:
+			priv->config.gpio1_mode = gpio_mode_in;
+			break;
+		case 1:
+			priv->config.gpio1_mode = gpio_mode_int;
+			break;
+		case 2:
+			priv->config.gpio1_mode = gpio_mode_out_low;
+			break;
+		case 3:
+			priv->config.gpio1_mode = gpio_mode_out_high;
+			break;
+		default:
+			dev_err(&spi->dev,
+				"Invalid value in device tree for microchip,gpio1_mode: %u - valif_values: 0, 1, 2, 3, 4\n",
+				val);
+			return -EINVAL;
+		}
+	} else {
+		priv->config.gpio1_mode = gpio_mode_in;
+	}
+
+	priv->config.gpio_opendrain = of_property_read_bool(
+		np, "microchip,gpio_opendrain");
+
+	priv->config.txcan_opendrain = of_property_read_bool(
+		np, "microchip,txcan_opendrain");
+
+	priv->config.int_opendrain = of_property_read_bool(
+		np, "microchip,int_opendrain");
+#endif
+	return 0;
+}
+
+static int mcp2517fd_can_probe_spi (struct spi_device *spi)
+{
+	struct device *dev=&spi->dev;
+	struct device_node *np=dev->of_node; 
+	const struct of_device_id *of_id = of_match_node(of_mcp2517fd_id_table,np);
+	struct net_device *net;
+	struct mcp2517fd_priv *priv;
+	struct clk *clk;
+	unsigned long freq;
+	int ret;
+	
+am_((PDD "%s(%s,irq=%d): spi-master=%s, of.compatible='%s'\n",__func__,dev_name(dev),spi->irq,dev_name(&spi->master->dev),of_id->compatible));
+// @@ mcp2517fd_can_probe_spi(spi1.0): spi-master=spi1, of.compatible='microchip,mcp2517fd'
+
+//am_((PDD "spi_device(%s): chip_select=%d, max_speed_hz=%u, bits_per_word=%d, mode=%03X, irq=%d, cs_gpio=%d\n",
+//dev_name(&spi->dev),spi->chip_select,spi->max_speed_hz,spi->bits_per_word,spi->mode,spi->irq,spi->cs_gpio));
+//@@ spi_device(spi1.0): chip_select=0, max_speed_hz=40000000, bits_per_word=8, mode=000, irq=165, cs_gpio=-2
+
+	/* as irq_create_fwspec_mapping() can return 0, check for it */
+	if(spi->irq <= 0) {
+		dev_err(dev, "no valid irq line defined: irq = %i\n",spi->irq);
+		return -EINVAL;
+	}
+
+	clk = devm_clk_get(dev, NULL);
+	if(IS_ERR(clk)) {
+		dev_err(dev,"error! fail on devm_clk_get()\n");
+		return PTR_ERR(clk);
+	}
+	freq = clk_get_rate(clk);
+
+	if (freq < MCP2517FD_MIN_CLOCK_FREQUENCY || freq > MCP2517FD_MAX_CLOCK_FREQUENCY) {
+		dev_err(dev,"Clock frequency %lu is not in range\n", freq);
+		return -ERANGE;
+	}
+am_(("  @ clk_get_rate()=%lu MHz\n",freq/1000000));
+
+	/* Allocate can/net device */
+	net = alloc_candev(sizeof(*priv), TX_ECHO_SKB_MAX);
+	if(!net) {
+		dev_err(dev,"error! fail on alloc_candev()\n");
+		return -ENOMEM;
+	}
+
+	ret = clk_prepare_enable(clk);
+	if (ret)
+		goto out_free;
+
+	net->netdev_ops = &mcp2517fd_netdev_ops;
+	net->flags |= IFF_ECHO;
+
+	priv = netdev_priv(net);
+	priv->can.bittiming_const = &mcp2517fd_nominal_bittiming_const;
+	priv->can.do_set_bittiming = &mcp2517fd_do_set_nominal_bittiming;
+	priv->can.data_bittiming_const = &mcp2517fd_data_bittiming_const;
+	priv->can.do_set_data_bittiming = &mcp2517fd_do_set_data_bittiming;
+	priv->can.do_set_mode = mcp2517fd_do_set_mode;
+	priv->can.do_get_berr_counter = mcp2517fd_get_berr_counter;
+
+	priv->can.ctrlmode_supported =
+		CAN_CTRLMODE_FD |
+		CAN_CTRLMODE_LOOPBACK |
+		CAN_CTRLMODE_LISTENONLY |
+		CAN_CTRLMODE_BERR_REPORTING |
+		CAN_CTRLMODE_FD_NON_ISO |
+		CAN_CTRLMODE_ONE_SHOT;
+
+	if (of_id)
+		priv->model = (enum mcp2517fd_model)of_id->data;
+	else
+		priv->model = spi_get_device_id(spi)->driver_data;
+
+	priv->spi = spi;
+	priv->net = net;
+	priv->clk = clk;
+
+	spi_set_drvdata(spi, priv);
+
+	/* set up gpio modes as GPIO INT */
+	priv->config.gpio0_mode = gpio_mode_int;
+	priv->config.gpio1_mode = gpio_mode_int;
+	/* all by default as push/pull */
+	priv->config.gpio_opendrain = false;
+	priv->config.txcan_opendrain = false;
+	priv->config.int_opendrain = false;
+	/* do not use the SCK clock divider of 2 */
+	priv->config.clock_div2 = false;
+	/* clock output is divided by 10 */
+	priv->config.clock_odiv = 10;
+
+	/* as a first guess we assume we are in CAN_CON_MODE_SLEEP
+	 * this is how we leave the controller when removing ourselves
+	 */
+	priv->active_can_mode = CAN_CON_MODE_SLEEP;
+
+	/* if we have a clock that is smaller then 4MHz, then enable the pll */
+	priv->config.clock_pll =
+		(freq <= MCP2517FD_AUTO_PLL_MAX_CLOCK_FREQUENCY);
+
+	/* check in device tree for overrrides */
+	ret = mcp2517fd_of_parse(priv);
+	if (ret)
+		goto out_clk;
+
+	/* decide on real can clock rate */
+	priv->can.clock.freq = freq;
+	if(priv->config.clock_pll) {
+fl_		priv->can.clock.freq *= MCP2517FD_PLL_MULTIPLIER;
+		if (priv->can.clock.freq > MCP2517FD_MAX_CLOCK_FREQUENCY) {
+			dev_err(dev,"PLL clock frequency %i would exceed limit\n",priv->can.clock.freq);
+			return -EINVAL;
+		}
+	}
+
+#if 0//ky_test: Did not work, cansend still fail;
+	priv->config.clock_div2=true;
+#endif
+	
+	if(priv->config.clock_div2) {
+fl_		priv->can.clock.freq /= MCP2517FD_SCLK_DIVIDER;
+	}
+
+	/* calclculate the clock frequencies to use */
+#ifdef CONFIG_SPI_IMX
+	//ky_note: Table7-6.Note3: FSCK must be less than or equal to FSYSCLK/2. 
+	//The SPI speed(SCK) did not distinguish from setup or FIFO access.
+	priv->spi_setup_speed_hz 	= priv->can.clock.freq/2;
+	priv->spi_speed_hz 			= priv->can.clock.freq/2;
+am_(("  @ SYSCLK=%u MHz, SPI_SCK=%u MHz\n",priv->can.clock.freq/1000000,priv->spi_speed_hz/1000000));
+#else
+	priv->spi_setup_speed_hz = freq / 2;
+	priv->spi_speed_hz = priv->can.clock.freq / 2;
+#endif
+	if(priv->config.clock_div2) {
+		priv->spi_setup_speed_hz /= MCP2517FD_SCLK_DIVIDER;
+		priv->spi_speed_hz /= MCP2517FD_SCLK_DIVIDER;
+	}
+
+	if (spi->max_speed_hz) {
+		priv->spi_setup_speed_hz = min_t(int,
+						 priv->spi_setup_speed_hz,
+						 spi->max_speed_hz);
+		priv->spi_speed_hz = min_t(int,
+					   priv->spi_speed_hz,
+					   spi->max_speed_hz);
+	}
+//am_(("  @ spi->max=%u, spi_setup=%u, spi_speed=%u \n",spi->max_speed_hz,priv->spi_setup_speed_hz,priv->spi_speed_hz));
+
+	/* Configure the SPI bus */
+	spi->bits_per_word = 8;
+	spi->mode=SPI_MODE_0;
+	ret = spi_setup(spi);
+	if (ret)
+		goto out_clk;
+
+	priv->power = devm_regulator_get_optional(dev, "vdd");
+	priv->transceiver = devm_regulator_get_optional(dev, "xceiver");
+	if ((PTR_ERR(priv->power) == -EPROBE_DEFER) ||
+	    (PTR_ERR(priv->transceiver) == -EPROBE_DEFER)) {
+		ret = -EPROBE_DEFER;
+		goto out_clk;
+	}
+
+	ret = mcp2517fd_power_enable(priv->power, 1);
+	if (ret)
+		goto out_clk;
+
+	SET_NETDEV_DEV(net, dev);
+
+#ifdef xADLINK_DEBUG//ky_test;
+	memset(priv->spi_tx,0x00,sizeof(priv->spi_tx));
+	memset(priv->spi_rx,0xCC,sizeof(priv->spi_rx));
+	
+	McpReadWriteTest(spi,1);
+	McpReadWriteTest(spi,2);
+	return -EPERM;
+#endif
+
+	ret = mcp2517fd_hw_probe(spi);
+	/* on error retry a second time */
+	if(ret == -ENODEV) {
+		ret = mcp2517fd_hw_probe(spi);
+		if(!ret)
+			dev_info(dev,"found device only during retry\n");
+	}
+	if(ret) {
+		if(ret == -ENODEV)
+			dev_err(dev,"Cannot initialize MCP%x. Wrong wiring?\n",priv->model);
+		goto error_probe;
+	}
+
+	mcp2517fd_hw_sleep(spi);
+
+	ret = register_candev(net);
+	if (ret)
+		goto error_probe;
+
+	/* register debugfs */
+	mcp2517fd_debugfs_add(priv);
+
+	devm_can_led_init(net);
+
+	netdev_info(net, "MCP%x successfully initialized.\n", priv->model);
+	return 0;
+
+error_probe:
+	mcp2517fd_power_enable(priv->power, 0);
+
+out_clk:
+	if (!IS_ERR(clk))
+		clk_disable_unprepare(clk);
+
+out_free:
+	free_candev(net);
+	dev_err(dev, "Probe failed, err=%d\n", -ret);
+	return ret;
+}
+
+static int mcp2517fd_can_remove_spi (struct spi_device *spi)
+{
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct net_device *net = priv->net;
+
+#ifdef ADLINK_PATCH_OF_IRQ	
+	//ky_note: Solve the error of "irq: type mismatch, failed to map hwirq-1 for /gpio@30230000!"
+	//ky_wait: insmod will success after can-up/down, but can not pass interrupt_request while open;
+//	irq_dispose_mapping(priv->spi->irq); Link2(spi_drv_probe); Link2(of_irq_get);
+#endif
+
+	mcp2517fd_debugfs_remove(priv);
+
+	unregister_candev(net);
+
+	mcp2517fd_power_enable(priv->power, 0);
+
+	if (!IS_ERR(priv->clk))
+		clk_disable_unprepare(priv->clk);
+
+	free_candev(net);
+fl_
+	return 0;
+}
+
+static int __maybe_unused mcp2517fd_can_suspend(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+	struct net_device *net = priv->net;
+fl_
+	priv->force_quit = 1;
+	disable_irq(spi->irq);
+
+	if (netif_running(net)) {
+		netif_device_detach(net);
+
+		mcp2517fd_hw_sleep(spi);
+		mcp2517fd_power_enable(priv->transceiver, 0);
+		priv->after_suspend = AFTER_SUSPEND_UP;
+	} else {
+		priv->after_suspend = AFTER_SUSPEND_DOWN;
+	}
+
+	if (!IS_ERR_OR_NULL(priv->power)) {
+		regulator_disable(priv->power);
+		priv->after_suspend |= AFTER_SUSPEND_POWER;
+	}
+
+	return 0;
+}
+
+static int __maybe_unused mcp2517fd_can_resume(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct mcp2517fd_priv *priv = spi_get_drvdata(spi);
+fl_
+	if (priv->after_suspend & AFTER_SUSPEND_POWER)
+		mcp2517fd_power_enable(priv->power, 1);
+
+	if (priv->after_suspend & AFTER_SUSPEND_UP)
+		mcp2517fd_power_enable(priv->transceiver, 1);
+	else
+		priv->after_suspend = 0;
+
+	priv->force_quit = 0;
+
+	enable_irq(spi->irq);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(mcp2517fd_can_pm_ops, mcp2517fd_can_suspend,mcp2517fd_can_resume);
+
+static struct spi_driver mcp2517fd_can_driver = {
+	.driver = {
+		.name 			= DEVICE_NAME,
+		.owner 			= THIS_MODULE,
+		.pm 			= &mcp2517fd_can_pm_ops,
+		.of_match_table = of_mcp2517fd_id_table,
+	},
+	.id_table 			= spi_mcp2517fd_id_table,
+	.probe 				= mcp2517fd_can_probe_spi,
+	.remove 			= mcp2517fd_can_remove_spi,
+};
+module_spi_driver(mcp2517fd_can_driver);
+
+MODULE_AUTHOR("Martin Sperl <kernel@xxxxxxxxxxxxxxxx>");
+MODULE_DESCRIPTION("Microchip 2517FD CAN driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/net/can/spi/mcp251x.c b/drivers/net/can/spi/mcp251x.c
index f2e0632..f3f05fe 100644
--- a/drivers/net/can/spi/mcp251x.c
+++ b/drivers/net/can/spi/mcp251x.c
@@ -54,12 +54,6 @@
  *
  */
 
-//#define ADLINK_DEBUG
-
-#ifdef ADLINK_DEBUG
-static int DebugFlag=1;
-#endif
-
 #include <linux/can/core.h>
 #include <linux/can/dev.h>
 #include <linux/can/led.h>
@@ -323,46 +317,14 @@ static int mcp251x_spi_trans(struct spi_device *spi, int len)
 		.rx_buf = priv->spi_rx_buf,
 		.len = len,
 		.cs_change = 0,
-		.delay_usecs = 0,//ky_add: store the padding bytes;
 	};
 	struct spi_message m;
-	int i,ret;
-
-	//ky_add: re-arrange tx buffer...
-	if(!len) return 0;
-	else if(len<4) {
-		t.bits_per_word=len*8;
-		if(3==len) {//24 bits, : Refer iMX8 10.1.7.2 ECSPIx_TXDATA, should shift the contain;
-			for(i=3;0<i;--i) priv->spi_tx_buf[i]=priv->spi_tx_buf[i-1];
-			priv->spi_tx_buf[0]=0xAD;//No meaning; ADlink;
-			t.len=4;//Real length is 3, but we must set t.len=4 to pass checked by __spi_validate()@spi.c
-		}
-	}
-	else {
-		t.bits_per_word=32;
-		i=len%4;//Check size;
-		if(i) {//we muts append dummy data to fit u32 alignment;
-			int dummy=4-i;
-			int j,NewEnd=len+dummy-1;
-			//Shift contains, dummy should on first DWORD, and on MSB(Left) side; see 10.1.7.2 ECSPIx_TXDATA;
-			for(j=len-1;0<=j;--j,--NewEnd) {
-				priv->spi_tx_buf[NewEnd]=priv->spi_tx_buf[j];
-			}
-			for(j=0;j<dummy;++j) priv->spi_tx_buf[j]=0xAD;
-			t.delay_usecs=dummy;//ky_add: Special setting for size check; The side effect will happen if user set this value on range 1~3;
-			t.len+=dummy;
-		}
-	}
-
-#ifdef ADLINK_DEBUG
-if(DebugFlag)
-am_((PDD "%s(0x%08X,%2d); t->len=%d\n",__func__,*(int *)priv->spi_tx_buf,len,t.len));
-#endif
+	int ret;
 
 	spi_message_init(&m);
 
 	if (mcp251x_enable_dma) {
-efl_	t.tx_dma = priv->spi_tx_dma;
+		t.tx_dma = priv->spi_tx_dma;
 		t.rx_dma = priv->spi_rx_dma;
 		m.is_dma_mapped = 1;
 	}
@@ -372,13 +334,6 @@ efl_	t.tx_dma = priv->spi_tx_dma;
 	ret = spi_sync(spi, &m);
 	if (ret)
 		dev_err(&spi->dev, "spi transfer failed: ret = %d\n", ret);
-
-	//ky_add: re-arrange rx buffer...
-	if(3==len) {
-		for(i=0;i<3;++i) priv->spi_rx_buf[i]=priv->spi_rx_buf[i+1];
-	}
-
-
 	return ret;
 }
 
@@ -391,14 +346,8 @@ static u8 mcp251x_read_reg(struct spi_device *spi, uint8_t reg)
 	priv->spi_tx_buf[1] = reg;
 
 	mcp251x_spi_trans(spi, 3);
-
-//ky_test;
-//am_((PDD "spi_rx[0-7]= 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
-//priv->spi_rx_buf[0],priv->spi_rx_buf[1],priv->spi_rx_buf[2],priv->spi_rx_buf[3],
-//priv->spi_rx_buf[4],priv->spi_rx_buf[5],priv->spi_rx_buf[6],priv->spi_rx_buf[7]));
-
 	val = priv->spi_rx_buf[2];
-am_((PDD "Read Reg %02Xh = 0x%02X\n",reg,val));
+
 	return val;
 }
 
@@ -414,7 +363,6 @@ static void mcp251x_read_2regs(struct spi_device *spi, uint8_t reg,
 
 	*v1 = priv->spi_rx_buf[2];
 	*v2 = priv->spi_rx_buf[3];
-am_((PDD "Read Reg %02Xh = 0x%02X, 0x%02X\n",reg,*v1,*v2));
 }
 
 static void mcp251x_write_reg(struct spi_device *spi, u8 reg, uint8_t val)
@@ -505,7 +453,7 @@ static void mcp251x_hw_rx_frame(struct spi_device *spi, u8 *buf,
 			buf[i] = mcp251x_read_reg(spi, RXBCTRL(buf_idx) + i);
 	} else {
 		priv->spi_tx_buf[RXBCTRL_OFF] = INSTRUCTION_READ_RXB(buf_idx);
-		mcp251x_spi_trans(spi, SPI_TRANSFER_BUF_LEN + 2);
+		mcp251x_spi_trans(spi, SPI_TRANSFER_BUF_LEN);
 		memcpy(buf, priv->spi_rx_buf, SPI_TRANSFER_BUF_LEN);
 	}
 }
@@ -858,9 +806,6 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
 	struct spi_device *spi = priv->spi;
 	struct net_device *net = priv->net;
 
-am_((PDD "%s(irq=%d): \n",__func__,irq));
-//@@ mcp251x_can_ist(irq=163):
-
 	mutex_lock(&priv->mcp_lock);
 	while (!priv->force_quit) {
 		enum can_state new_state;
@@ -983,13 +928,6 @@ am_((PDD "%s(irq=%d): \n",__func__,irq));
 		}
 
 	}
-
-#ifdef ADLINK_DEBUG
-	DebugFlag=0;
-	mcp251x_read_2regs(spi, TEC,(char *)&irq+0,(char *)&irq+1);
-	mcp251x_read_reg(spi, TXBCTRL(0));
-	DebugFlag=1;
-#endif
 	mutex_unlock(&priv->mcp_lock);
 	return IRQ_HANDLED;
 }
@@ -1003,7 +941,7 @@ static int mcp251x_open(struct net_device *net)
 
 	ret = open_candev(net);
 	if (ret) {
-efl_	dev_err(&spi->dev, "unable to set initial baudrate!\n");
+		dev_err(&spi->dev, "unable to set initial baudrate!\n");
 		return ret;
 	}
 
@@ -1017,12 +955,11 @@ efl_	dev_err(&spi->dev, "unable to set initial baudrate!\n");
 	ret = request_threaded_irq(spi->irq, NULL, mcp251x_can_ist,
 				   flags | IRQF_ONESHOT, DEVICE_NAME, priv);
 	if (ret) {
-efl_	dev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);
+		dev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);
 		mcp251x_power_enable(priv->transceiver, 0);
 		close_candev(net);
 		goto open_unlock;
 	}
-am_((PDD "%s(irq=%d)\n",__func__,spi->irq));//@@ mcp251x_open(irq=163)
 
 	priv->wq = alloc_workqueue("mcp251x_wq", WQ_FREEZABLE | WQ_MEM_RECLAIM,
 				   0);
@@ -1031,17 +968,17 @@ am_((PDD "%s(irq=%d)\n",__func__,spi->irq));//@@ mcp251x_open(irq=163)
 
 	ret = mcp251x_hw_reset(spi);
 	if (ret) {
-efl_	mcp251x_open_clean(net);
+		mcp251x_open_clean(net);
 		goto open_unlock;
 	}
 	ret = mcp251x_setup(net, priv, spi);
 	if (ret) {
-efl_	mcp251x_open_clean(net);
+		mcp251x_open_clean(net);
 		goto open_unlock;
 	}
 	ret = mcp251x_set_normal_mode(spi);
 	if (ret) {
-efl_	mcp251x_open_clean(net);
+		mcp251x_open_clean(net);
 		goto open_unlock;
 	}
 
@@ -1190,13 +1127,13 @@ static int mcp251x_can_probe(struct spi_device *spi)
 
 	/* Allocate non-DMA buffers */
 	if (!mcp251x_enable_dma) {
-		priv->spi_tx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN + 4,
+		priv->spi_tx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,
 						GFP_KERNEL);
 		if (!priv->spi_tx_buf) {
 			ret = -ENOMEM;
 			goto error_probe;
 		}
-		priv->spi_rx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN + 4,
+		priv->spi_rx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,
 						GFP_KERNEL);
 		if (!priv->spi_rx_buf) {
 			ret = -ENOMEM;
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index c51dd7a..eb0c392 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -55,7 +55,6 @@ comment "SPI Master Controller Drivers"
 
 config SPI_ALTERA
 	tristate "Altera SPI Controller"
-	select SPI_BITBANG
 	help
 	  This is the driver for the Altera SPI Controller.
 
@@ -67,6 +66,13 @@ config SPI_ATH79
 	  This enables support for the SPI controller present on the
 	  Atheros AR71XX/AR724X/AR913X SoCs.
 
+config SPI_ARMADA_3700
+	tristate "Marvell Armada 3700 SPI Controller"
+	depends on (ARCH_MVEBU && OF) || COMPILE_TEST
+	help
+	  This enables support for the SPI controller present on the
+	  Marvell Armada 3700 SoCs.
+
 config SPI_ATMEL
 	tristate "Atmel SPI Controller"
 	depends on HAS_DMA
@@ -155,8 +161,7 @@ config SPI_BCM63XX_HSSPI
 
 config SPI_BCM_QSPI
 	tristate "Broadcom BSPI and MSPI controller support"
-	depends on ARCH_BRCMSTB || ARCH_BCM || ARCH_BCM_IPROC || COMPILE_TEST
-	depends on MTD_NORFLASH
+	depends on ARCH_BRCMSTB || ARCH_BCM || ARCH_BCM_IPROC || BMIPS_GENERIC || COMPILE_TEST
 	default ARCH_BCM_IPROC
 	help
 	  Enables support for the Broadcom SPI flash and MSPI controller.
@@ -257,7 +262,7 @@ config SPI_EP93XX
 	  mode.
 
 config SPI_FALCON
-	tristate "Falcon SPI controller support"
+	bool "Falcon SPI controller support"
 	depends on SOC_FALCON
 	help
 	  The external bus unit (EBU) found on the FALC-ON SoC has SPI
@@ -265,6 +270,12 @@ config SPI_FALCON
 	  has only been tested with m25p80 type chips. The hardware has no
 	  support for other types of SPI peripherals.
 
+config SPI_FSL_LPSPI
+	tristate "Freescale i.MX LPSPI controller"
+	depends on ARCH_MXC || ARCH_MXC_ARM64 || COMPILE_TEST
+	help
+	  This enables Freescale i.MX LPSPI controllers in master mode.
+
 config SPI_GPIO
 	tristate "GPIO-based bitbanging SPI Master"
 	depends on GPIOLIB || COMPILE_TEST
@@ -366,6 +377,7 @@ config SPI_FSL_SPI
 config SPI_FSL_DSPI
 	tristate "Freescale DSPI controller"
 	select REGMAP_MMIO
+	depends on HAS_DMA
 	depends on SOC_VF610 || SOC_LS1021A || ARCH_LAYERSCAPE || COMPILE_TEST
 	help
 	  This enables support for the Freescale DSPI controller in master
@@ -374,18 +386,18 @@ config SPI_FSL_DSPI
 config SPI_FSL_ESPI
 	tristate "Freescale eSPI controller"
 	depends on FSL_SOC
-	select SPI_FSL_LIB
 	help
 	  This enables using the Freescale eSPI controllers in master mode.
 	  From MPC8536, 85xx platform uses the controller, and all P10xx,
 	  P20xx, P30xx,P40xx, P50xx uses this controller.
 
-config SPI_FSL_LPSPI
-	tristate "Freescale i.MX LPSPI controller"
-	depends on ARCH_MXC || ARCH_MXC_ARM64 || COMPILE_TEST
+config SPI_MESON_SPICC
+	tristate "Amlogic Meson SPICC controller"
+	depends on ARCH_MESON || COMPILE_TEST
 	select SPI_BITBANG
 	help
-	  This enables Freescale i.MX LPSPI controllers in master mode.
+	  This enables master mode support for the SPICC (SPI communication
+	  controller) available in Amlogic Meson SoCs.
 
 config SPI_MESON_SPIFC
 	tristate "Amlogic Meson SPIFC controller"
@@ -411,6 +423,14 @@ config SPI_NUC900
 	help
 	  SPI driver for Nuvoton NUC900 series ARM SoCs
 
+config SPI_LANTIQ_SSC
+	tristate "Lantiq SSC SPI controller"
+	depends on LANTIQ || COMPILE_TEST
+	help
+	  This driver supports the Lantiq SSC SPI controller in master
+	  mode. This controller is found on Intel (former Lantiq) SoCs like
+	  the Danube, Falcon, xRX200, xRX300.
+
 config SPI_OC_TINY
 	tristate "OpenCores tiny SPI"
 	depends on GPIOLIB || COMPILE_TEST
@@ -443,6 +463,7 @@ config SPI_OMAP24XX
 
 config SPI_TI_QSPI
 	tristate "DRA7xxx QSPI controller support"
+	depends on HAS_DMA
 	depends on ARCH_OMAP2PLUS || COMPILE_TEST
 	help
 	  QSPI master controller for DRA7xxx used for flash devices.
@@ -459,7 +480,7 @@ config SPI_ORION
 	tristate "Orion SPI master"
 	depends on PLAT_ORION || ARCH_MVEBU || COMPILE_TEST
 	help
-	  This enables using the SPI master controller on the Orion chips.
+	  This enables using the SPI master controller on the Orion and MVEBU chips.
 
 config SPI_PIC32
 	tristate "Microchip PIC32 series SPI"
@@ -495,8 +516,8 @@ config SPI_PPC4xx
 
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
-	depends on (ARCH_PXA || PCI || ACPI)
-	select PXA_SSP if ARCH_PXA
+	depends on (ARCH_PXA || ARCH_MMP || PCI || ACPI)
+	select PXA_SSP if ARCH_PXA || ARCH_MMP
 	help
 	  This enables using a PXA2xx or Sodaville SSP port as a SPI master
 	  controller. The driver can be configured to use any SSP port and
@@ -561,7 +582,7 @@ config SPI_S3C24XX_FIQ
 
 config SPI_S3C64XX
 	tristate "Samsung S3C64XX series type SPI"
-	depends on (PLAT_SAMSUNG || ARCH_EXYNOS)
+	depends on (PLAT_SAMSUNG || ARCH_EXYNOS || COMPILE_TEST)
 	help
 	  SPI driver for Samsung S3C64XX and newer SoCs.
 
@@ -604,6 +625,16 @@ config SPI_SIRF
 	help
 	  SPI driver for CSR SiRFprimaII SoCs
 
+config SPI_STM32
+	tristate "STMicroelectronics STM32 SPI controller"
+	depends on ARCH_STM32 || COMPILE_TEST
+	help
+	  SPI driver for STMicroelectonics STM32 SoCs.
+
+	  STM32 SPI controller supports DMA and PIO modes. When DMA
+	  is not available, the driver automatically falls back to
+	  PIO mode.
+
 config SPI_ST_SSC4
 	tristate "STMicroelectronics SPI SSC-based driver"
 	depends on ARCH_STI || COMPILE_TEST
@@ -700,7 +731,7 @@ config SPI_XILINX
 
 config SPI_XLP
 	tristate "Netlogic XLP SPI controller driver"
-	depends on CPU_XLP || ARCH_VULCAN || COMPILE_TEST
+	depends on CPU_XLP || ARCH_THUNDER2 || COMPILE_TEST
 	help
 	  Enable support for the SPI controller on the Netlogic XLP SoCs.
 	  Currently supported XLP variants are XLP8XX, XLP3XX, XLP2XX, XLP9XX
@@ -769,6 +800,30 @@ config SPI_TLE62X0
 
 endif # SPI_MASTER
 
-# (slave support would go here)
+#
+# SLAVE side ... listening to other SPI masters
+#
+
+config SPI_SLAVE
+	bool "SPI slave protocol handlers"
+	help
+	  If your system has a slave-capable SPI controller, you can enable
+	  slave protocol handlers.
+
+if SPI_SLAVE
+
+config SPI_SLAVE_TIME
+	tristate "SPI slave handler reporting boot up time"
+	help
+	  SPI slave handler responding with the time of reception of the last
+	  SPI message.
+
+config SPI_SLAVE_SYSTEM_CONTROL
+	tristate "SPI slave handler controlling system state"
+	help
+	  SPI slave handler to allow remote control of system reboot, power
+	  off, halt, and suspend.
+
+endif # SPI_SLAVE
 
 endif # SPI
diff --git a/drivers/spi/spi-imx.c b/drivers/spi/spi-imx.c
index a90f6a4..ff22d01 100644
--- a/drivers/spi/spi-imx.c
+++ b/drivers/spi/spi-imx.c
@@ -1,3 +1,10 @@
+#define ADLINK_ECSPI_PATCH
+#define ADLINK_SHORT_PATH
+#define ADLINK_ENABLE_BURST_LENGTH//Refer ECSPIx_CONREG[31:20] ;
+
+//#define ADLINK_DEBUG
+//#define ADLINK_DEBUG_ADD500us_DELAY
+
 /*
  * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright (C) 2008 Juergen Beisert
@@ -17,17 +24,13 @@
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301, USA.
  */
-
-#define ADLINK_ENABLE_BURST_LENGTH//Refer ECSPIx_CONREG[31:20] ;
-
-//#define ADLINK_DEBUG//ky_add: see linux/err.h
 #include <linux/err.h>
-
 #include <linux/clk.h>
 #include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
+#include <linux/err.h>
 #include <linux/gpio.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
@@ -46,7 +49,6 @@
 #include <linux/platform_data/dma-imx.h>
 #include <linux/platform_data/spi-imx.h>
 
-
 #define DRIVER_NAME "spi_imx"
 
 #define MXC_CSPIRXDATA		0x00
@@ -58,13 +60,13 @@
 /* generic defines to abstract from the different register layouts */
 #define MXC_INT_RR	(1 << 0) /* Receive data ready interrupt */
 #define MXC_INT_TE	(1 << 1) /* Transmit FIFO empty interrupt */
+#define MXC_INT_RDR	BIT(4) /* Receive date threshold interrupt */
 
 /* The maximum  bytes that a sdma BD can transfer.*/
 #define MAX_SDMA_BD_BYTES  (1 << 15)
-struct spi_imx_config {
-	unsigned int speed_hz;
-	unsigned int bpw;
-};
+#define MX51_ECSPI_CTRL_MAX_BURST	512
+/* The maximum bytes that IMX53_ECSPI can transfer in slave mode.*/
+#define MX53_MAX_TRANSFER_BYTES		512
 
 enum spi_imx_devtype {
 	IMX1_CSPI,
@@ -72,7 +74,8 @@ enum spi_imx_devtype {
 	IMX27_CSPI,
 	IMX31_CSPI,
 	IMX35_CSPI,	/* CSPI on all i.mx except above */
-	IMX51_ECSPI,	/* ECSPI on i.mx51 and later */
+	IMX51_ECSPI,	/* ECSPI on i.mx51 */
+	IMX53_ECSPI,	/* ECSPI on i.mx53 and later */
 	IMX6UL_ECSPI,
 };
 
@@ -80,10 +83,16 @@ struct spi_imx_data;
 
 struct spi_imx_devtype_data {
 	void (*intctrl)(struct spi_imx_data *, int);
-	int (*config)(struct spi_device *, struct spi_imx_config *);
+	int (*config)(struct spi_device *);
 	void (*trigger)(struct spi_imx_data *);
 	int (*rx_available)(struct spi_imx_data *);
 	void (*reset)(struct spi_imx_data *);
+	void (*setup_wml)(struct spi_imx_data *);
+	void (*disable)(struct spi_imx_data *);
+	bool has_dmamode;
+	bool has_slavemode;
+	unsigned int fifo_size;
+	bool dynamic_burst;
 	enum spi_imx_devtype devtype;
 };
 
@@ -100,14 +109,27 @@ struct spi_imx_data {
 	unsigned long spi_clk;
 	unsigned int spi_bus_clk;
 
-	unsigned int bytes_per_word;
+	unsigned int speed_hz;
+	unsigned int bits_per_word;
+	unsigned int spi_drctl;
+	
+#ifdef ADLINK_ENABLE_BURST_LENGTH	
+	unsigned int burst_length; //ECSPIx_CONREG[31:20];
+#endif
 
-	unsigned int count;
+	unsigned int count, remainder;
 	void (*tx)(struct spi_imx_data *);
 	void (*rx)(struct spi_imx_data *);
 	void *rx_buf;
 	const void *tx_buf;
 	unsigned int txfifo; /* number of words pushed in tx FIFO */
+	unsigned int dynamic_burst, read_u32;
+	unsigned int word_mask;
+
+	/* Slave mode */
+	bool slave_mode;
+	bool slave_aborted;
+	unsigned int slave_burst;
 
 	/* DMA */
 	bool usedma;
@@ -134,26 +156,22 @@ static inline int is_imx51_ecspi(struct spi_imx_data *d)
 	       d->devtype_data->devtype == IMX6UL_ECSPI;
 }
 
-static inline unsigned spi_imx_get_fifosize(struct spi_imx_data *d)
+static inline int is_imx53_ecspi(struct spi_imx_data *d)
 {
-	return is_imx51_ecspi(d) ? 64 : 8;
+	return d->devtype_data->devtype == IMX53_ECSPI;
 }
 
-//ky_add: some transfer might use length=1, we must swap the contain for 16,32 bits_per_word transfer;
-#define ToBE(type,va) (1==sizeof(type))?(va):(2==sizeof(type))?(cpu_to_be16(va)):(cpu_to_be32(va))
 
 #define MXC_SPI_BUF_RX(type)						\
 static void spi_imx_buf_rx_##type(struct spi_imx_data *spi_imx)		\
 {									\
 	unsigned int val = readl(spi_imx->base + MXC_CSPIRXDATA);	\
-	val = ToBE(type,val);						\
 	if (spi_imx->rx_buf) {						\
 		*(type *)spi_imx->rx_buf = val;				\
 		spi_imx->rx_buf += sizeof(type);			\
 	}								\
 }
 
-
 #define MXC_SPI_BUF_TX(type)						\
 static void spi_imx_buf_tx_##type(struct spi_imx_data *spi_imx)		\
 {									\
@@ -161,7 +179,6 @@ static void spi_imx_buf_tx_##type(struct spi_imx_data *spi_imx)		\
 									\
 	if (spi_imx->tx_buf) {						\
 		val = *(type *)spi_imx->tx_buf;				\
-		val = ToBE(type,val); \
 		spi_imx->tx_buf += sizeof(type);			\
 	}								\
 									\
@@ -185,15 +202,16 @@ static int mxc_clkdivs[] = {0, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192,
 
 /* MX21, MX27 */
 static unsigned int spi_imx_clkdiv_1(unsigned int fin,
-		unsigned int fspi, unsigned int max)
+		unsigned int fspi, unsigned int max, unsigned int *fres)
 {
 	int i;
 
 	for (i = 2; i < max; i++)
 		if (fspi * mxc_clkdivs[i] >= fin)
-			return i;
+			break;
 
-	return max;
+	*fres = fin / mxc_clkdivs[i];
+	return i;
 }
 
 /* MX1, MX31, MX35, MX51 CSPI */
@@ -213,37 +231,32 @@ static unsigned int spi_imx_clkdiv_2(unsigned int fin,
 	return i;
 }
 
-static int spi_imx_bytes_per_word(const int bpw)
+static int spi_imx_bytes_per_word(const int bits_per_word)
 {
-	return DIV_ROUND_UP(bpw, BITS_PER_BYTE);
+	return DIV_ROUND_UP(bits_per_word, BITS_PER_BYTE);
 }
 
 static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 			 struct spi_transfer *transfer)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
-	unsigned int bpw;
+	unsigned int bytes_per_word;
 
 	if (!master->dma_rx)
 		return false;
 
-	if (!transfer)
+	if (spi_imx->slave_mode)
 		return false;
 
-	bpw = transfer->bits_per_word;
-	if (!bpw)
-		bpw = spi->bits_per_word;
-
-	bpw = spi_imx_bytes_per_word(bpw);
+	bytes_per_word = spi_imx_bytes_per_word(transfer->bits_per_word);
 
-	if (bpw != 1 && bpw != 2 && bpw != 4)
+	if (bytes_per_word != 1 && bytes_per_word != 2 && bytes_per_word != 4)
 		return false;
 
-	if (transfer->len < spi_imx->wml * bpw)
+	if (transfer->len < spi_imx->devtype_data->fifo_size / 2)
 		return false;
 
-	if (transfer->len % (spi_imx->wml * bpw))
-		return false;
+	spi_imx->dynamic_burst = 0;
 
 	return true;
 }
@@ -253,10 +266,12 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 #define MX51_ECSPI_CTRL_XCH		(1 <<  2)
 #define MX51_ECSPI_CTRL_SMC		(1 << 3)
 #define MX51_ECSPI_CTRL_MODE_MASK	(0xf << 4)
+#define MX51_ECSPI_CTRL_DRCTL(drctl)	((drctl) << 16)
 #define MX51_ECSPI_CTRL_POSTDIV_OFFSET	8
 #define MX51_ECSPI_CTRL_PREDIV_OFFSET	12
 #define MX51_ECSPI_CTRL_CS(cs)		((cs) << 18)
 #define MX51_ECSPI_CTRL_BL_OFFSET	20
+#define MX51_ECSPI_CTRL_BL_MASK		(0xfff << 20)
 
 #define MX51_ECSPI_CONFIG	0x0c
 #define MX51_ECSPI_CONFIG_SCLKPHA(cs)	(1 << ((cs) +  0))
@@ -268,6 +283,7 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 #define MX51_ECSPI_INT		0x10
 #define MX51_ECSPI_INT_TEEN		(1 <<  0)
 #define MX51_ECSPI_INT_RREN		(1 <<  3)
+#define MX51_ECSPI_INT_RDREN		(1 <<  4)
 
 #define MX51_ECSPI_DMA      0x14
 #define MX51_ECSPI_DMA_TX_WML(wml)	((wml) & 0x3f)
@@ -284,6 +300,144 @@ static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,
 #define MX51_ECSPI_TESTREG	0x20
 #define MX51_ECSPI_TESTREG_LBC	BIT(31)
 
+static void spi_imx_buf_rx_swap_u32(struct spi_imx_data *spi_imx)
+{
+	unsigned int val = readl(spi_imx->base + MXC_CSPIRXDATA);
+#ifdef __LITTLE_ENDIAN
+	unsigned int bytes_per_word;
+#endif
+
+	if (spi_imx->rx_buf) {
+#ifdef __LITTLE_ENDIAN
+		bytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);
+		if (bytes_per_word == 1)
+			val = cpu_to_be32(val);
+		else if (bytes_per_word == 2)
+			val = (val << 16) | (val >> 16);
+#endif
+		val &= spi_imx->word_mask;
+		*(u32 *)spi_imx->rx_buf = val;
+		spi_imx->rx_buf += sizeof(u32);
+	}
+}
+
+static void spi_imx_buf_rx_swap(struct spi_imx_data *spi_imx)
+{
+	unsigned int bytes_per_word;
+
+	bytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);
+	if (spi_imx->read_u32) {
+		spi_imx_buf_rx_swap_u32(spi_imx);
+		return;
+	}
+
+	if (bytes_per_word == 1)
+		spi_imx_buf_rx_u8(spi_imx);
+	else if (bytes_per_word == 2)
+		spi_imx_buf_rx_u16(spi_imx);
+}
+
+static void spi_imx_buf_tx_swap_u32(struct spi_imx_data *spi_imx)
+{
+	u32 val = 0;
+#ifdef __LITTLE_ENDIAN
+	unsigned int bytes_per_word;
+#endif
+
+	if (spi_imx->tx_buf) {
+		val = *(u32 *)spi_imx->tx_buf;
+		val &= spi_imx->word_mask;
+		spi_imx->tx_buf += sizeof(u32);
+	}
+
+	spi_imx->count -= sizeof(u32);
+#ifdef __LITTLE_ENDIAN
+	bytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);
+
+	if (bytes_per_word == 1)
+		val = cpu_to_be32(val);
+	else if (bytes_per_word == 2)
+		val = (val << 16) | (val >> 16);
+#endif
+	writel(val, spi_imx->base + MXC_CSPITXDATA);
+}
+
+static void spi_imx_buf_tx_swap(struct spi_imx_data *spi_imx)
+{
+	u32 ctrl, val;
+	unsigned int bytes_per_word;
+
+	if (spi_imx->count == spi_imx->remainder) {
+		ctrl = readl(spi_imx->base + MX51_ECSPI_CTRL);
+		ctrl &= ~MX51_ECSPI_CTRL_BL_MASK;
+		if (spi_imx->count > MX51_ECSPI_CTRL_MAX_BURST) {
+			spi_imx->remainder = spi_imx->count %
+					     MX51_ECSPI_CTRL_MAX_BURST;
+			val = MX51_ECSPI_CTRL_MAX_BURST * 8 - 1;
+		} else if (spi_imx->count >= sizeof(u32)) {
+			spi_imx->remainder = spi_imx->count % sizeof(u32);
+			val = (spi_imx->count - spi_imx->remainder) * 8 - 1;
+		} else {
+			spi_imx->remainder = 0;
+			val = spi_imx->bits_per_word - 1;
+			spi_imx->read_u32 = 0;
+		}
+
+		ctrl |= (val << MX51_ECSPI_CTRL_BL_OFFSET);
+		writel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);
+	}
+
+	if (spi_imx->count >= sizeof(u32)) {
+		spi_imx_buf_tx_swap_u32(spi_imx);
+		return;
+	}
+
+	bytes_per_word = spi_imx_bytes_per_word(spi_imx->bits_per_word);
+
+	if (bytes_per_word == 1)
+		spi_imx_buf_tx_u8(spi_imx);
+	else if (bytes_per_word == 2)
+		spi_imx_buf_tx_u16(spi_imx);
+}
+
+static void mx53_ecspi_rx_slave(struct spi_imx_data *spi_imx)
+{
+	u32 val = be32_to_cpu(readl(spi_imx->base + MXC_CSPIRXDATA));
+
+	if (spi_imx->rx_buf) {
+		int n_bytes = spi_imx->slave_burst % sizeof(val);
+
+		if (!n_bytes)
+			n_bytes = sizeof(val);
+
+		memcpy(spi_imx->rx_buf,
+		       ((u8 *)&val) + sizeof(val) - n_bytes, n_bytes);
+
+		spi_imx->rx_buf += n_bytes;
+		spi_imx->slave_burst -= n_bytes;
+	}
+}
+
+static void mx53_ecspi_tx_slave(struct spi_imx_data *spi_imx)
+{
+	u32 val = 0;
+	int n_bytes = spi_imx->count % sizeof(val);
+
+	if (!n_bytes)
+		n_bytes = sizeof(val);
+
+	if (spi_imx->tx_buf) {
+		memcpy(((u8 *)&val) + sizeof(val) - n_bytes,
+		       spi_imx->tx_buf, n_bytes);
+		val = cpu_to_be32(val);
+		spi_imx->tx_buf += n_bytes;
+	}
+
+	spi_imx->count -= n_bytes;
+
+	writel(val, spi_imx->base + MXC_CSPITXDATA);
+}
+
 /* MX51 eCSPI */
 static unsigned int mx51_ecspi_clkdiv(struct spi_imx_data *spi_imx,
 				      unsigned int fspi, unsigned int *fres)
@@ -333,6 +487,9 @@ static void mx51_ecspi_intctrl(struct spi_imx_data *spi_imx, int enable)
 	if (enable & MXC_INT_RR)
 		val |= MX51_ECSPI_INT_RREN;
 
+	if (enable & MXC_INT_RDR)
+		val |= MX51_ECSPI_INT_RDREN;
+
 	writel(val, spi_imx->base + MX51_ECSPI_INT);
 }
 
@@ -352,34 +509,61 @@ static void mx51_ecspi_trigger(struct spi_imx_data *spi_imx)
 	writel(reg, spi_imx->base + MX51_ECSPI_CTRL);
 }
 
-static int mx51_ecspi_config(struct spi_device *spi,
-			     struct spi_imx_config *config)
+static void mx51_ecspi_disable(struct spi_imx_data *spi_imx)
+{
+	u32 ctrl;
+
+	ctrl = readl(spi_imx->base + MX51_ECSPI_CTRL);
+	ctrl &= ~MX51_ECSPI_CTRL_ENABLE;
+	writel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);
+}
+
+static int mx51_ecspi_config(struct spi_device *spi)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	u32 ctrl = MX51_ECSPI_CTRL_ENABLE;
-	u32 clk = config->speed_hz, delay, reg;
+	u32 clk = spi_imx->speed_hz, delay, reg;
 	u32 cfg = readl(spi_imx->base + MX51_ECSPI_CONFIG);
-	int tx_wml = 0;
+
+	/* set Master or Slave mode */
+	if (spi_imx->slave_mode)
+		ctrl &= ~MX51_ECSPI_CTRL_MODE_MASK;
+	else
+		ctrl |= MX51_ECSPI_CTRL_MODE_MASK;
 
 	/*
-	 * The hardware seems to have a race condition when changing modes. The
-	 * current assumption is that the selection of the channel arrives
-	 * earlier in the hardware than the mode bits when they are written at
-	 * the same time.
-	 * So set master mode for all channels as we do not support slave mode.
+	 * Enable SPI_RDY handling (falling edge/level triggered).
 	 */
-	ctrl |= MX51_ECSPI_CTRL_MODE_MASK;
+	if (spi->mode & SPI_READY)
+		ctrl |= MX51_ECSPI_CTRL_DRCTL(spi_imx->spi_drctl);
 
 	/* set clock speed */
-	ctrl |= mx51_ecspi_clkdiv(spi_imx, config->speed_hz, &clk);
+	ctrl |= mx51_ecspi_clkdiv(spi_imx, spi_imx->speed_hz, &clk);
 	spi_imx->spi_bus_clk = clk;
 
 	/* set chip select to use */
 	ctrl |= MX51_ECSPI_CTRL_CS(spi->chip_select);
 
-	ctrl |= (config->bpw - 1) << MX51_ECSPI_CTRL_BL_OFFSET;
+#ifdef ADLINK_ENABLE_BURST_LENGTH
+	ctrl|=(spi_imx->burst_length-1)<<MX51_ECSPI_CTRL_BL_OFFSET;
+#else
+	if (spi_imx->slave_mode)
+		ctrl |= (spi_imx->slave_burst * 8 - 1)
+			<< MX51_ECSPI_CTRL_BL_OFFSET;
+	else
+		ctrl |= (spi_imx->bits_per_word - 1)
+			<< MX51_ECSPI_CTRL_BL_OFFSET;
+#endif
 
-	cfg |= MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
+	/*
+	 * eCSPI burst completion by Chip Select signal in Slave mode
+	 * is not functional for imx53 Soc, config SPI burst completed when
+	 * BURST_LENGTH + 1 bits are received
+	 */
+	if (spi_imx->slave_mode && is_imx53_ecspi(spi_imx))
+		cfg &= ~MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
+	else
+		cfg |= MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
 
 	if (spi->mode & SPI_CPHA)
 		cfg |= MX51_ECSPI_CONFIG_SCLKPHA(spi->chip_select);
@@ -430,20 +614,26 @@ static int mx51_ecspi_config(struct spi_device *spi,
 	else			/* SCLK is _very_ slow */
 		usleep_range(delay, delay + 10);
 
+	return 0;
+}
+
+static void mx51_setup_wml(struct spi_imx_data *spi_imx)
+{
+	int tx_wml = 0;
+
 	/*
 	 * Configure the DMA register: setup the watermark
 	 * and enable DMA request.
 	 */
 	if (spi_imx->devtype_data->devtype == IMX6UL_ECSPI)
-		tx_wml = spi_imx->wml / 2;
-
-	writel(MX51_ECSPI_DMA_RX_WML(spi_imx->wml) |
-		MX51_ECSPI_DMA_TX_WML(tx_wml) |
-		MX51_ECSPI_DMA_RXT_WML(spi_imx->wml) |
-		MX51_ECSPI_DMA_TEDEN | MX51_ECSPI_DMA_RXDEN |
-		MX51_ECSPI_DMA_RXTDEN, spi_imx->base + MX51_ECSPI_DMA);
+		tx_wml = spi_imx->wml;
 
-	return 0;
+	if (spi_imx->usedma)
+		writel(MX51_ECSPI_DMA_RX_WML(spi_imx->wml - 1) |
+			MX51_ECSPI_DMA_TX_WML(tx_wml) |
+			MX51_ECSPI_DMA_RXT_WML(spi_imx->wml) |
+			MX51_ECSPI_DMA_TEDEN | MX51_ECSPI_DMA_RXDEN |
+			MX51_ECSPI_DMA_RXTDEN, spi_imx->base + MX51_ECSPI_DMA);
 }
 
 static int mx51_ecspi_rx_available(struct spi_imx_data *spi_imx)
@@ -464,6 +654,7 @@ static void mx51_ecspi_reset(struct spi_imx_data *spi_imx)
 #define MX31_CSPICTRL_ENABLE	(1 << 0)
 #define MX31_CSPICTRL_MASTER	(1 << 1)
 #define MX31_CSPICTRL_XCH	(1 << 2)
+#define MX31_CSPICTRL_SMC	(1 << 3)
 #define MX31_CSPICTRL_POL	(1 << 4)
 #define MX31_CSPICTRL_PHA	(1 << 5)
 #define MX31_CSPICTRL_SSCTL	(1 << 6)
@@ -474,6 +665,10 @@ static void mx51_ecspi_reset(struct spi_imx_data *spi_imx)
 #define MX35_CSPICTRL_CS_SHIFT	12
 #define MX31_CSPICTRL_DR_SHIFT	16
 
+#define MX31_CSPI_DMAREG	0x10
+#define MX31_DMAREG_RH_DEN	(1<<4)
+#define MX31_DMAREG_TH_DEN	(1<<1)
+
 #define MX31_CSPISTATUS		0x14
 #define MX31_STATUS_RR		(1 << 3)
 
@@ -505,21 +700,21 @@ static void mx31_trigger(struct spi_imx_data *spi_imx)
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 }
 
-static int mx31_config(struct spi_device *spi, struct spi_imx_config *config)
+static int mx31_config(struct spi_device *spi)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	unsigned int reg = MX31_CSPICTRL_ENABLE | MX31_CSPICTRL_MASTER;
 	unsigned int clk;
 
-	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz, &clk) <<
+	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->speed_hz, &clk) <<
 		MX31_CSPICTRL_DR_SHIFT;
 	spi_imx->spi_bus_clk = clk;
 
 	if (is_imx35_cspi(spi_imx)) {
-		reg |= (config->bpw - 1) << MX35_CSPICTRL_BL_SHIFT;
+		reg |= (spi_imx->bits_per_word - 1) << MX35_CSPICTRL_BL_SHIFT;
 		reg |= MX31_CSPICTRL_SSCTL;
 	} else {
-		reg |= (config->bpw - 1) << MX31_CSPICTRL_BC_SHIFT;
+		reg |= (spi_imx->bits_per_word - 1) << MX31_CSPICTRL_BC_SHIFT;
 	}
 
 	if (spi->mode & SPI_CPHA)
@@ -528,11 +723,14 @@ static int mx31_config(struct spi_device *spi, struct spi_imx_config *config)
 		reg |= MX31_CSPICTRL_POL;
 	if (spi->mode & SPI_CS_HIGH)
 		reg |= MX31_CSPICTRL_SSPOL;
-	if (spi->cs_gpio < 0)
-		reg |= (spi->cs_gpio + 32) <<
+	if (!gpio_is_valid(spi->cs_gpio))
+		reg |= (spi->chip_select) <<
 			(is_imx35_cspi(spi_imx) ? MX35_CSPICTRL_CS_SHIFT :
 						  MX31_CSPICTRL_CS_SHIFT);
 
+	if (spi_imx->usedma)
+		reg |= MX31_CSPICTRL_SMC;
+
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 
 	reg = readl(spi_imx->base + MX31_CSPI_TESTREG);
@@ -542,6 +740,13 @@ static int mx31_config(struct spi_device *spi, struct spi_imx_config *config)
 		reg &= ~MX31_TEST_LBC;
 	writel(reg, spi_imx->base + MX31_CSPI_TESTREG);
 
+	if (spi_imx->usedma) {
+		/* configure DMA requests when RXFIFO is half full and
+		   when TXFIFO is half empty */
+		writel(MX31_DMAREG_RH_DEN | MX31_DMAREG_TH_DEN,
+			spi_imx->base + MX31_CSPI_DMAREG);
+	}
+
 	return 0;
 }
 
@@ -591,15 +796,18 @@ static void mx21_trigger(struct spi_imx_data *spi_imx)
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 }
 
-static int mx21_config(struct spi_device *spi, struct spi_imx_config *config)
+static int mx21_config(struct spi_device *spi)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	unsigned int reg = MX21_CSPICTRL_ENABLE | MX21_CSPICTRL_MASTER;
 	unsigned int max = is_imx27_cspi(spi_imx) ? 16 : 18;
+	unsigned int clk;
 
-	reg |= spi_imx_clkdiv_1(spi_imx->spi_clk, config->speed_hz, max) <<
-		MX21_CSPICTRL_DR_SHIFT;
-	reg |= config->bpw - 1;
+	reg |= spi_imx_clkdiv_1(spi_imx->spi_clk, spi_imx->speed_hz, max, &clk)
+		<< MX21_CSPICTRL_DR_SHIFT;
+	spi_imx->spi_bus_clk = clk;
+
+	reg |= spi_imx->bits_per_word - 1;
 
 	if (spi->mode & SPI_CPHA)
 		reg |= MX21_CSPICTRL_PHA;
@@ -607,8 +815,8 @@ static int mx21_config(struct spi_device *spi, struct spi_imx_config *config)
 		reg |= MX21_CSPICTRL_POL;
 	if (spi->mode & SPI_CS_HIGH)
 		reg |= MX21_CSPICTRL_SSPOL;
-	if (spi->cs_gpio < 0)
-		reg |= (spi->cs_gpio + 32) << MX21_CSPICTRL_CS_SHIFT;
+	if (!gpio_is_valid(spi->cs_gpio))
+		reg |= spi->chip_select << MX21_CSPICTRL_CS_SHIFT;
 
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 
@@ -657,17 +865,17 @@ static void mx1_trigger(struct spi_imx_data *spi_imx)
 	writel(reg, spi_imx->base + MXC_CSPICTRL);
 }
 
-static int mx1_config(struct spi_device *spi, struct spi_imx_config *config)
+static int mx1_config(struct spi_device *spi)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	unsigned int reg = MX1_CSPICTRL_ENABLE | MX1_CSPICTRL_MASTER;
 	unsigned int clk;
 
-	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz, &clk) <<
+	reg |= spi_imx_clkdiv_2(spi_imx->spi_clk, spi_imx->speed_hz, &clk) <<
 		MX1_CSPICTRL_DR_SHIFT;
 	spi_imx->spi_bus_clk = clk;
 
-	reg |= config->bpw - 1;
+	reg |= spi_imx->bits_per_word - 1;
 
 	if (spi->mode & SPI_CPHA)
 		reg |= MX1_CSPICTRL_PHA;
@@ -695,6 +903,10 @@ static struct spi_imx_devtype_data imx1_cspi_devtype_data = {
 	.trigger = mx1_trigger,
 	.rx_available = mx1_rx_available,
 	.reset = mx1_reset,
+	.fifo_size = 8,
+	.has_dmamode = false,
+	.dynamic_burst = false,
+	.has_slavemode = false,
 	.devtype = IMX1_CSPI,
 };
 
@@ -704,6 +916,10 @@ static struct spi_imx_devtype_data imx21_cspi_devtype_data = {
 	.trigger = mx21_trigger,
 	.rx_available = mx21_rx_available,
 	.reset = mx21_reset,
+	.fifo_size = 8,
+	.has_dmamode = false,
+	.dynamic_burst = false,
+	.has_slavemode = false,
 	.devtype = IMX21_CSPI,
 };
 
@@ -714,6 +930,10 @@ static struct spi_imx_devtype_data imx27_cspi_devtype_data = {
 	.trigger = mx21_trigger,
 	.rx_available = mx21_rx_available,
 	.reset = mx21_reset,
+	.fifo_size = 8,
+	.has_dmamode = false,
+	.dynamic_burst = false,
+	.has_slavemode = false,
 	.devtype = IMX27_CSPI,
 };
 
@@ -723,6 +943,10 @@ static struct spi_imx_devtype_data imx31_cspi_devtype_data = {
 	.trigger = mx31_trigger,
 	.rx_available = mx31_rx_available,
 	.reset = mx31_reset,
+	.fifo_size = 8,
+	.has_dmamode = false,
+	.dynamic_burst = false,
+	.has_slavemode = false,
 	.devtype = IMX31_CSPI,
 };
 
@@ -733,6 +957,10 @@ static struct spi_imx_devtype_data imx35_cspi_devtype_data = {
 	.trigger = mx31_trigger,
 	.rx_available = mx31_rx_available,
 	.reset = mx31_reset,
+	.fifo_size = 8,
+	.has_dmamode = true,
+	.dynamic_burst = false,
+	.has_slavemode = false,
 	.devtype = IMX35_CSPI,
 };
 
@@ -742,15 +970,45 @@ static struct spi_imx_devtype_data imx51_ecspi_devtype_data = {
 	.trigger = mx51_ecspi_trigger,
 	.rx_available = mx51_ecspi_rx_available,
 	.reset = mx51_ecspi_reset,
+	.setup_wml = mx51_setup_wml,
+	.fifo_size = 64,
+#ifdef ADLINK_SHORT_PATH
+	.has_dmamode = false,
+	.dynamic_burst = false,
+#else
+	.has_dmamode = true,
+	.dynamic_burst = true,
+#endif
+	.has_slavemode = true,
+	.disable = mx51_ecspi_disable,
 	.devtype = IMX51_ECSPI,
 };
 
+static struct spi_imx_devtype_data imx53_ecspi_devtype_data = {
+	.intctrl = mx51_ecspi_intctrl,
+	.config = mx51_ecspi_config,
+	.trigger = mx51_ecspi_trigger,
+	.rx_available = mx51_ecspi_rx_available,
+	.reset = mx51_ecspi_reset,
+	.fifo_size = 64,
+	.has_dmamode = true,
+	.has_slavemode = true,
+	.disable = mx51_ecspi_disable,
+	.devtype = IMX53_ECSPI,
+};
+
 static struct spi_imx_devtype_data imx6ul_ecspi_devtype_data = {
 	.intctrl = mx51_ecspi_intctrl,
 	.config = mx51_ecspi_config,
 	.trigger = mx51_ecspi_trigger,
 	.rx_available = mx51_ecspi_rx_available,
 	.reset = mx51_ecspi_reset,
+	.setup_wml = mx51_setup_wml,
+	.fifo_size = 64,
+	.has_dmamode = true,
+	.dynamic_burst = true,
+	.has_slavemode = true,
+	.disable = mx51_ecspi_disable,
 	.devtype = IMX6UL_ECSPI,
 };
 
@@ -774,6 +1032,9 @@ static struct platform_device_id spi_imx_devtype[] = {
 		.name = "imx51-ecspi",
 		.driver_data = (kernel_ulong_t) &imx51_ecspi_devtype_data,
 	}, {
+		.name = "imx53-ecspi",
+		.driver_data = (kernel_ulong_t) &imx53_ecspi_devtype_data,
+	}, {
 		.name = "imx6ul-ecspi",
 		.driver_data = (kernel_ulong_t) &imx6ul_ecspi_devtype_data,
 	}, {
@@ -788,6 +1049,7 @@ static const struct of_device_id spi_imx_dt_ids[] = {
 	{ .compatible = "fsl,imx31-cspi", .data = &imx31_cspi_devtype_data, },
 	{ .compatible = "fsl,imx35-cspi", .data = &imx35_cspi_devtype_data, },
 	{ .compatible = "fsl,imx51-ecspi", .data = &imx51_ecspi_devtype_data, },
+	{ .compatible = "fsl,imx53-ecspi", .data = &imx53_ecspi_devtype_data, },
 	{ .compatible = "fsl,imx6ul-ecspi", .data = &imx6ul_ecspi_devtype_data, },
 	{ /* sentinel */ }
 };
@@ -798,6 +1060,9 @@ static void spi_imx_chipselect(struct spi_device *spi, int is_active)
 	int active = is_active != BITBANG_CS_INACTIVE;
 	int dev_is_lowactive = !(spi->mode & SPI_CS_HIGH);
 
+	if (spi->mode & SPI_NO_CS)
+		return;
+
 	if (!gpio_is_valid(spi->cs_gpio))
 		return;
 
@@ -806,22 +1071,26 @@ static void spi_imx_chipselect(struct spi_device *spi, int is_active)
 
 static void spi_imx_push(struct spi_imx_data *spi_imx)
 {
-	while (spi_imx->txfifo < spi_imx_get_fifosize(spi_imx)) {
+	while (spi_imx->txfifo < spi_imx->devtype_data->fifo_size) {
 		if (!spi_imx->count)
 			break;
-		spi_imx->tx(spi_imx); Link2(MXC_SPI_BUF_TX);
+		if (spi_imx->txfifo && (spi_imx->count == spi_imx->remainder))
+			break;
+		spi_imx->tx(spi_imx);
 		spi_imx->txfifo++;
 	}
 
-	spi_imx->devtype_data->trigger(spi_imx); Link2(mx51_ecspi_trigger);
+	if (!spi_imx->slave_mode)
+		spi_imx->devtype_data->trigger(spi_imx);
 }
 
 static irqreturn_t spi_imx_isr(int irq, void *dev_id)
 {
 	struct spi_imx_data *spi_imx = dev_id;
 
-	while (spi_imx->devtype_data->rx_available(spi_imx)) { Link2(mx51_ecspi_rx_available);
-		spi_imx->rx(spi_imx);  Link2(MXC_SPI_BUF_RX);
+	while (spi_imx->txfifo &&
+	       spi_imx->devtype_data->rx_available(spi_imx)) {
+		spi_imx->rx(spi_imx);
 		spi_imx->txfifo--;
 	}
 
@@ -845,19 +1114,14 @@ static irqreturn_t spi_imx_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int spi_imx_dma_configure(struct spi_master *master,
-				 int bytes_per_word)
+static int spi_imx_dma_configure(struct spi_master *master)
 {
 	int ret;
 	enum dma_slave_buswidth buswidth;
 	struct dma_slave_config rx = {}, tx = {};
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
 
-	if (bytes_per_word == spi_imx->bytes_per_word)
-		/* Same as last time */
-		return 0;
-
-	switch (bytes_per_word) {
+	switch (spi_imx_bytes_per_word(spi_imx->bits_per_word)) {
 	case 4:
 		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
 		break;
@@ -874,7 +1138,7 @@ static int spi_imx_dma_configure(struct spi_master *master,
 	tx.direction = DMA_MEM_TO_DEV;
 	tx.dst_addr = spi_imx->base_phys + MXC_CSPITXDATA;
 	tx.dst_addr_width = buswidth;
-	tx.dst_maxburst = spi_imx->wml / 2;
+	tx.dst_maxburst = spi_imx->wml;
 	ret = dmaengine_slave_config(master->dma_tx, &tx);
 	if (ret) {
 		dev_err(spi_imx->dev, "TX dma configuration failed with %d\n", ret);
@@ -891,8 +1155,6 @@ static int spi_imx_dma_configure(struct spi_master *master,
 		return ret;
 	}
 
-	spi_imx->bytes_per_word = bytes_per_word;
-
 	return 0;
 }
 
@@ -900,54 +1162,72 @@ static int spi_imx_setupxfer(struct spi_device *spi,
 				 struct spi_transfer *t)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
-	struct spi_imx_config config;
-	int ret;
 
-	config.bpw = t ? t->bits_per_word : spi->bits_per_word;
-	config.speed_hz  = t ? t->speed_hz : spi->max_speed_hz;
+	if (!t)
+		return 0;
 
-	if (!config.speed_hz)
-		config.speed_hz = spi->max_speed_hz;
-	if (!config.bpw)
-		config.bpw = spi->bits_per_word;
+	spi_imx->bits_per_word = t->bits_per_word;
+	spi_imx->speed_hz  = t->speed_hz;
 
 	/* Initialize the functions for transfer */
-	if (config.bpw <= 8) {
-		spi_imx->rx = spi_imx_buf_rx_u8;
-		spi_imx->tx = spi_imx_buf_tx_u8;
-	} else if (config.bpw <= 16) {
-		spi_imx->rx = spi_imx_buf_rx_u16;
-		spi_imx->tx = spi_imx_buf_tx_u16;
+	if (spi_imx->devtype_data->dynamic_burst && !spi_imx->slave_mode) {
+		u32 mask;
+
+		spi_imx->dynamic_burst = 0;
+		spi_imx->remainder = 0;
+		spi_imx->read_u32  = 1;
+
+		mask = (1 << spi_imx->bits_per_word) - 1;
+		spi_imx->rx = spi_imx_buf_rx_swap;
+		spi_imx->tx = spi_imx_buf_tx_swap;
+		spi_imx->dynamic_burst = 1;
+		spi_imx->remainder = t->len;
+
+		if (spi_imx->bits_per_word <= 8)
+			spi_imx->word_mask = mask << 24 | mask << 16
+					     | mask << 8 | mask;
+		else if (spi_imx->bits_per_word <= 16)
+			spi_imx->word_mask = mask << 16 | mask;
+		else
+			spi_imx->word_mask = mask;
 	} else {
-		spi_imx->rx = spi_imx_buf_rx_u32; Link2(MXC_SPI_BUF_RX);
-		spi_imx->tx = spi_imx_buf_tx_u32; Link2(MXC_SPI_BUF_TX);
+		if (spi_imx->bits_per_word <= 8) {
+			spi_imx->rx = spi_imx_buf_rx_u8;
+			spi_imx->tx = spi_imx_buf_tx_u8;
+		} else if (spi_imx->bits_per_word <= 16) {
+			spi_imx->rx = spi_imx_buf_rx_u16;
+			spi_imx->tx = spi_imx_buf_tx_u16;
+		} else {
+			spi_imx->rx = spi_imx_buf_rx_u32;
+			spi_imx->tx = spi_imx_buf_tx_u32;
+		}
 	}
 
-	if (spi_imx_can_dma(spi_imx->bitbang.master, spi, t))
-		spi_imx->usedma = 1;
-	else
-		spi_imx->usedma = 0;
+	if (spi_imx_can_dma(spi_imx->bitbang.master, spi, t)) {
+		spi_imx->usedma = 1; }
+	else {
+		spi_imx->usedma = 0; }
 
+	if (spi_imx->slave_mode) {
+		spi_imx->rx = mx53_ecspi_rx_slave;
+		spi_imx->tx = mx53_ecspi_tx_slave;
+		spi_imx->slave_burst = t->len;
+	}
 #ifdef ADLINK_ENABLE_BURST_LENGTH
+	spi_imx->burst_length=t->bits_per_word;	
+
 	//ky_changed: Long burst only acceptable on 32 bits wide;
-	if(32==config.bpw && t->len<=512) {
-		config.bpw=t->len*8;
-		if(0<t->delay_usecs && t->delay_usecs<4) { Link2(mcp251x_spi_trans);
-am_((PDD "%s(): Modify config.bpw form %d to %d\n",__func__,config.bpw,config.bpw-8*t->delay_usecs));
-			config.bpw-=t->delay_usecs*8;
+	if(32==spi_imx->burst_length && t->len<=512) {
+		spi_imx->burst_length=t->len*8;
+		if(0<t->delay_usecs && t->delay_usecs<4) { Link2(pre_job_for_imx_ecspi);
+am_((PDD "%s(): Modify spi_imx->burst_length form %d to %d\n",__func__,spi_imx->burst_length,spi_imx->burst_length-8*t->delay_usecs));
+			spi_imx->burst_length-=t->delay_usecs*8;
 			t->delay_usecs=0;
 		}
 	}
 #endif
 
-	if (spi_imx->usedma) {
-		ret = spi_imx_dma_configure(spi->master,
-					    spi_imx_bytes_per_word(config.bpw));
-		if (ret)
-			return ret;
-	}
-
-	spi_imx->devtype_data->config(spi, &config); Link2(mx51_ecspi_config);
+	spi_imx->devtype_data->config(spi); Link2(mx51_ecspi_config);
 
 	return 0;
 }
@@ -972,7 +1252,7 @@ static int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,
 {
 	int ret;
 
-	spi_imx->wml = spi_imx_get_fifosize(spi_imx) / 2;
+	spi_imx->wml = spi_imx->devtype_data->fifo_size / 2;
 
 	/* Prepare for TX DMA: */
 	master->dma_tx = dma_request_slave_channel_reason(dev, "tx");
@@ -992,8 +1272,6 @@ static int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,
 		goto err;
 	}
 
-	spi_imx_dma_configure(master, 1);
-
 	init_completion(&spi_imx->dma_rx_completion);
 	init_completion(&spi_imx->dma_tx_completion);
 	master->can_dma = spi_imx_can_dma;
@@ -1043,6 +1321,31 @@ static int spi_imx_dma_transfer(struct spi_imx_data *spi_imx,
 	unsigned long timeout;
 	struct spi_master *master = spi_imx->bitbang.master;
 	struct sg_table *tx = &transfer->tx_sg, *rx = &transfer->rx_sg;
+	struct scatterlist *last_sg = sg_last(rx->sgl, rx->nents);
+	unsigned int bytes_per_word, i;
+	int ret;
+fl_
+	/* Get the right burst length from the last sg to ensure no tail data */
+	bytes_per_word = spi_imx_bytes_per_word(transfer->bits_per_word);
+	for (i = spi_imx->devtype_data->fifo_size / 2; i > 0; i--) {
+		if (!(sg_dma_len(last_sg) % (i * bytes_per_word)))
+			break;
+	}
+	/* Use 1 as wml in case no available burst length got */
+	if (i == 0)
+		i = 1;
+	spi_imx->wml =  i;
+
+	ret = spi_imx_dma_configure(master);
+	if (ret)
+		return ret;
+
+	if (!spi_imx->devtype_data->setup_wml) {
+		dev_err(spi_imx->dev, "No setup_wml()?\n");
+		return -EINVAL;
+	}
+
+	spi_imx->devtype_data->setup_wml(spi_imx);
 
 	/*
 	 * The TX DMA setup starts the transfer, so make sure RX is configured
@@ -1106,7 +1409,7 @@ static int spi_imx_pio_transfer(struct spi_device *spi,
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 	unsigned long transfer_timeout;
 	unsigned long timeout;
-
+fl_
 	spi_imx->tx_buf = transfer->tx_buf;
 	spi_imx->rx_buf = transfer->rx_buf;
 	spi_imx->count = transfer->len;
@@ -1128,14 +1431,70 @@ static int spi_imx_pio_transfer(struct spi_device *spi,
 		return -ETIMEDOUT;
 	}
 
+#ifdef ADLINK_DEBUG_ADD500us_DELAY
+{	int i; for(i=0;i<50;++i) 
+	udelay(9);
+}	
+#endif
+
 	return transfer->len;
 }
 
+static int spi_imx_pio_transfer_slave(struct spi_device *spi,
+				      struct spi_transfer *transfer)
+{
+	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
+	int ret = transfer->len;
+fl_
+	if ((is_imx51_ecspi(spi_imx) || is_imx53_ecspi(spi_imx)) &&
+	    transfer->len > MX53_MAX_TRANSFER_BYTES) {
+		dev_err(&spi->dev, "Transaction too big, max size is %d bytes\n",
+			MX53_MAX_TRANSFER_BYTES);
+		return -EMSGSIZE;
+	}
+
+	spi_imx->tx_buf = transfer->tx_buf;
+	spi_imx->rx_buf = transfer->rx_buf;
+	spi_imx->count = transfer->len;
+	spi_imx->txfifo = 0;
+
+	reinit_completion(&spi_imx->xfer_done);
+	spi_imx->slave_aborted = false;
+
+	spi_imx_push(spi_imx);
+
+	spi_imx->devtype_data->intctrl(spi_imx, MXC_INT_TE | MXC_INT_RDR);
+
+	if (wait_for_completion_interruptible(&spi_imx->xfer_done) ||
+	    spi_imx->slave_aborted) {
+		dev_dbg(&spi->dev, "interrupted\n");
+		ret = -EINTR;
+	}
+
+	/* ecspi has a HW issue when works in Slave mode,
+	 * after 64 words writtern to TXFIFO, even TXFIFO becomes empty,
+	 * ECSPI_TXDATA keeps shift out the last word data,
+	 * so we have to disable ECSPI when in slave mode after the
+	 * transfer completes
+	 */
+	if (spi_imx->devtype_data->disable)
+		spi_imx->devtype_data->disable(spi_imx);
+
+	return ret;
+}
+
 static int spi_imx_transfer(struct spi_device *spi,
 				struct spi_transfer *transfer)
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
 
+	/* flush rxfifo before transfer */
+	while (spi_imx->devtype_data->rx_available(spi_imx))
+		spi_imx->rx(spi_imx);
+
+	if (spi_imx->slave_mode)
+		return spi_imx_pio_transfer_slave(spi, transfer);
+
 	if (spi_imx->usedma)
 		return spi_imx_dma_transfer(spi_imx, transfer);
 	else
@@ -1147,6 +1506,9 @@ static int spi_imx_setup(struct spi_device *spi)
 	dev_dbg(&spi->dev, "%s: mode %d, %u bpw, %d hz\n", __func__,
 		 spi->mode, spi->bits_per_word, spi->max_speed_hz);
 
+	if (spi->mode & SPI_NO_CS)
+		return 0;
+
 	if (gpio_is_valid(spi->cs_gpio))
 		gpio_direction_output(spi->cs_gpio,
 				      spi->mode & SPI_CS_HIGH ? 0 : 1);
@@ -1189,6 +1551,16 @@ spi_imx_unprepare_message(struct spi_master *master, struct spi_message *msg)
 	return 0;
 }
 
+static int spi_imx_slave_abort(struct spi_master *master)
+{
+	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
+
+	spi_imx->slave_aborted = true;
+	complete(&spi_imx->xfer_done);
+
+	return 0;
+}
+
 static int spi_imx_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -1199,51 +1571,90 @@ static int spi_imx_probe(struct platform_device *pdev)
 	struct spi_master *master;
 	struct spi_imx_data *spi_imx;
 	struct resource *res;
-	int i, ret, irq;
+	int i, ret, irq, spi_drctl, num_cs;
+	const struct spi_imx_devtype_data *devtype_data = of_id ? of_id->data :
+		(struct spi_imx_devtype_data *)pdev->id_entry->driver_data;
+	bool slave_mode;
 
 	if (!np && !mxc_platform_info) {
 		dev_err(&pdev->dev, "can't get the platform data\n");
 		return -EINVAL;
 	}
 
-	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_imx_data));
+	slave_mode = devtype_data->has_slavemode &&
+			of_property_read_bool(np, "spi-slave");
+	if (slave_mode)
+		master = spi_alloc_slave(&pdev->dev,
+					 sizeof(struct spi_imx_data));
+	else
+		master = spi_alloc_master(&pdev->dev,
+					  sizeof(struct spi_imx_data));
 	if (!master)
 		return -ENOMEM;
 
+	ret = of_property_read_u32(np, "fsl,spi-rdy-drctl", &spi_drctl);
+	if ((ret < 0) || (spi_drctl >= 0x3)) {
+		/* '11' is reserved */
+		spi_drctl = 0;
+	}
+
 	platform_set_drvdata(pdev, master);
 
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);
 	master->bus_num = np ? -1 : pdev->id;
 
+#ifndef ADLINK_ECSPI_PATCH//ky_note: Use default value=1 will be fine;
+	ret = of_property_read_u32(np, "fsl,spi-num-chipselects", &num_cs);
+	if (ret < 0) {
+		if (mxc_platform_info) {
+			num_cs = mxc_platform_info->num_chipselect;
+			master->num_chipselect = num_cs;
+		}
+	} else {
+		master->num_chipselect = num_cs;
+	}
+#endif
+
 	spi_imx = spi_master_get_devdata(master);
 	spi_imx->bitbang.master = master;
 	spi_imx->dev = &pdev->dev;
+	spi_imx->slave_mode = slave_mode;
 
-	spi_imx->devtype_data = of_id ? of_id->data :
-		(struct spi_imx_devtype_data *)pdev->id_entry->driver_data;
+	spi_imx->devtype_data = devtype_data;
 
-	if (mxc_platform_info) {//ky_NO;
-efl_	master->num_chipselect = mxc_platform_info->num_chipselect;
-		master->cs_gpios = devm_kzalloc(&master->dev,
+#ifdef ADLINK_ECSPI_PATCH
+	//ky_note: of_spi_register_master() will handle "cs-gpios", but it did not request gpio.
+	for(i=num_cs=0;i<0;);//Prevent warnings.
+#else
+	master->cs_gpios = devm_kzalloc(&master->dev,
 			sizeof(int) * master->num_chipselect, GFP_KERNEL);
-		if (!master->cs_gpios)
-			return -ENOMEM;
-
-		for (i = 0; i < master->num_chipselect; i++)
-			master->cs_gpios[i] = mxc_platform_info->chipselect[i];
- 	}
-	// master->cs_gpios can not be NULL. write dummy value on dts is not a good idea.
-	// Here we accept this situation and assign dummy on driver site;
-	else if(-ENOENT==of_gpio_named_count(np,"cs-gpios")) {//ky_add: Solve cs-gpios property
-		master->cs_gpios=devm_kzalloc(&master->dev,sizeof(int)*master->num_chipselect,GFP_KERNEL);
+
+	if (!spi_imx->slave_mode) {
 		if (!master->cs_gpios) {
-			ret=-ENOMEM;
+			dev_err(&pdev->dev, "No CS GPIOs available\n");
+			ret = -EINVAL;
 			goto out_master_put;
 		}
-		for(i=0;i<master->num_chipselect;i++) {
-			master->cs_gpios[i]=-1;
+
+		for (i = 0; i < master->num_chipselect; i++) {
+			int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
+			if (!gpio_is_valid(cs_gpio) && mxc_platform_info)
+				cs_gpio = mxc_platform_info->chipselect[i];
+
+			master->cs_gpios[i] = cs_gpio;
+			if (!gpio_is_valid(cs_gpio))
+				continue;
+
+			ret = devm_gpio_request(&pdev->dev, master->cs_gpios[i],
+						DRIVER_NAME);
+			if (ret) {
+				dev_err(&pdev->dev, "Can't get CS GPIO %i\n",
+					master->cs_gpios[i]);
+				goto out_master_put;
+			}
 		}
 	}
+#endif
 
 	spi_imx->bitbang.chipselect = spi_imx_chipselect;
 	spi_imx->bitbang.setup_transfer = spi_imx_setupxfer;
@@ -1252,9 +1663,14 @@ efl_	master->num_chipselect = mxc_platform_info->num_chipselect;
 	spi_imx->bitbang.master->cleanup = spi_imx_cleanup;
 	spi_imx->bitbang.master->prepare_message = spi_imx_prepare_message;
 	spi_imx->bitbang.master->unprepare_message = spi_imx_unprepare_message;
-	spi_imx->bitbang.master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
-	if (is_imx35_cspi(spi_imx) || is_imx51_ecspi(spi_imx))
-		spi_imx->bitbang.master->mode_bits |= SPI_LOOP;
+	spi_imx->bitbang.master->slave_abort = spi_imx_slave_abort;
+	spi_imx->bitbang.master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH \
+					     | SPI_NO_CS;
+	if (is_imx35_cspi(spi_imx) || is_imx51_ecspi(spi_imx) ||
+	    is_imx53_ecspi(spi_imx))
+		spi_imx->bitbang.master->mode_bits |= SPI_LOOP | SPI_READY;
+
+	spi_imx->spi_drctl = spi_drctl;
 
 	init_completion(&spi_imx->xfer_done);
 
@@ -1300,16 +1716,11 @@ efl_	master->num_chipselect = mxc_platform_info->num_chipselect;
 		goto out_put_per;
 
 	spi_imx->spi_clk = clk_get_rate(spi_imx->clk_per);
-
-am_((PDD "PA=0x%08lX, VA=%p, Irq=%d, clk=%lu KHz\n",spi_imx->base_phys,spi_imx->base,irq,spi_imx->spi_clk/1000));
-//PA=0x30830000, VA=ffff00000adb0000, Irq=38, clk=200000 KHz
-//ky_note: A53-IRQ is 32 for ecspi2, see Table 7-1;
-
 	/*
-	 * Only validated on i.mx6 now, can remove the constrain if validated on
-	 * other chips.
+	 * Only validated on i.mx35 and i.mx6 now, can remove the constraint
+	 * if validated on other chips.
 	 */
-	if (is_imx51_ecspi(spi_imx)) {
+	if (spi_imx->devtype_data->has_dmamode) {
 		ret = spi_imx_sdma_init(&pdev->dev, spi_imx, master);
 		if (ret == -EPROBE_DEFER)
 			goto out_clk_put;
@@ -1319,9 +1730,9 @@ am_((PDD "PA=0x%08lX, VA=%p, Irq=%d, clk=%lu KHz\n",spi_imx->base_phys,spi_imx->
 				ret);
 	}
 
-	spi_imx->devtype_data->reset(spi_imx); Link2(mx51_ecspi_reset);
+	spi_imx->devtype_data->reset(spi_imx);
 
-	spi_imx->devtype_data->intctrl(spi_imx, 0); Link2(mx51_ecspi_intctrl);
+	spi_imx->devtype_data->intctrl(spi_imx, 0);
 
 	master->dev.of_node = pdev->dev.of_node;
 	ret = spi_bitbang_start(&spi_imx->bitbang);
@@ -1330,26 +1741,6 @@ am_((PDD "PA=0x%08lX, VA=%p, Irq=%d, clk=%lu KHz\n",spi_imx->base_phys,spi_imx->
 		goto out_clk_put;
 	}
 
-	if (!master->cs_gpios) {
-		dev_err(&pdev->dev, "No CS GPIOs available\n");
-		ret = -EINVAL;
-		goto out_clk_put;
-	}
-
-	for (i = 0; i < master->num_chipselect; i++) {
-		if (!gpio_is_valid(master->cs_gpios[i]))
-			continue;
-
-		ret = devm_gpio_request(&pdev->dev, master->cs_gpios[i],
-					DRIVER_NAME);
-		if (ret) {
-			dev_err(&pdev->dev, "Can't get CS GPIO %i\n",
-				master->cs_gpios[i]);
-			goto out_clk_put;
-		}
-	}
-am_((PDD "Probed Success: %s, BusNum=%d\n",dev_name(&master->dev),master->bus_num));
-
 	dev_info(&pdev->dev, "probed\n");
 
 	clk_disable_unprepare(spi_imx->clk_ipg);
-- 
2.7.4

