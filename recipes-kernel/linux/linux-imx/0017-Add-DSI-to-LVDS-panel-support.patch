From fc51b5bbbed717c0377e225f26fc4d92ce1089ce Mon Sep 17 00:00:00 2001
From: Antony <antonyabee.prakashxv@adlinktech.com>
Date: Mon, 15 Jul 2019 14:18:34 +0530
Subject: [PATCH 2/2] Add-DSI-to-LVDS-panel-support

---
 arch/arm64/boot/dts/adlink/Makefile                |    8 +-
 .../adlink/adlink-imx8mq-evk-lcdif-g104x1l03.dts   |  184 ++
 .../adlink/adlink-imx8mq-evk-lcdif-g185xw01.dts    |  183 ++
 .../adlink/adlink-imx8mq-evk-lcdif-hv150ux2.dts    |  181 ++
 .../adlink/adlink-imx8mq-evk-lcdif-lm215wf3.dts    |  181 ++
 .../dts/adlink/adlink-imx8mq-evk-lcdif-n101bge.dts |  196 ++
 drivers/gpu/drm/bridge/Kconfig                     |    8 +
 drivers/gpu/drm/bridge/Makefile                    |    1 +
 drivers/gpu/drm/bridge/sn65dsi84-dsi2lvds.c        |  218 ++
 drivers/gpu/drm/panel/Kconfig                      |   11 +
 drivers/gpu/drm/panel/Makefile                     |    1 +
 drivers/gpu/drm/panel/panel-lecimx8.c              | 2720 ++++++++++++++++++++
 drivers/gpu/drm/panel/panel-simple.c               |  170 ++
 13 files changed, 4060 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-g104x1l03.dts
 create mode 100644 arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-g185xw01.dts
 create mode 100644 arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-hv150ux2.dts
 create mode 100644 arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-lm215wf3.dts
 create mode 100755 arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-n101bge.dts
 create mode 100644 drivers/gpu/drm/bridge/sn65dsi84-dsi2lvds.c
 create mode 100755 drivers/gpu/drm/panel/panel-lecimx8.c

diff --git a/arch/arm64/boot/dts/adlink/Makefile b/arch/arm64/boot/dts/adlink/Makefile
index 4153157..1ae0066 100644
--- a/arch/arm64/boot/dts/adlink/Makefile
+++ b/arch/arm64/boot/dts/adlink/Makefile
@@ -3,8 +3,12 @@ dtb-$(CONFIG_ARCH_LEC_IMX8M) += adlink-lec-imx8m.dtb \
                                 adlink-2gb-canfd-40M.dtb \
                                 adlink-4gb-canfd.dtb \
                                 adlink-4gb-canfd-40M.dtb \
-				adlink-lec-imx8m-usb-otg-master.dtb
-
+				adlink-lec-imx8m-usb-otg-master.dtb \
+				adlink-imx8mq-evk-lcdif-g104x1l03.dtb \
+				adlink-imx8mq-evk-lcdif-g185xw01.dtb \
+				adlink-imx8mq-evk-lcdif-hv150ux2.dtb \
+				adlink-imx8mq-evk-lcdif-lm215wf3.dtb \
+				adlink-imx8mq-evk-lcdif-n101bge.dtb
 always		:= $(dtb-y)
 subdir-y	:= $(dts-dirs)
 clean-files	:= *.dtb
diff --git a/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-g104x1l03.dts b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-g104x1l03.dts
new file mode 100644
index 0000000..9d231f2
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-g104x1l03.dts
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-lec-imx8m.dts"
+#define useReg 0
+/ {
+	display-subsystem {
+		status = "disabled";
+	};
+#if useReg		
+	regulators {
+		reg_gpio_lvds: regulator-gpio {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vdd>;
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "gpio_lvds";
+			regulator-type = "voltage";
+			gpios = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+			//states = <900000 0x1 1000000 0x0>;
+		};
+	};
+#endif	
+	backlight: backlight {
+  	compatible = "pwm-backlight";
+		pwms = <&pwm1 0 1000000 0>;
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+				     10 11 12 13 14 15 16 17 18 19
+				     20 21 22 23 24 25 26 27 28 29
+				     30 31 32 33 34 35 36 37 38 39
+				     40 41 42 43 44 45 46 47 48 49
+				     50 51 52 53 54 55 56 57 58 59
+				     60 61 62 63 64 65 66 67 68 69
+				     70 71 72 73 74 75 76 77 78 79
+				     80 81 82 83 84 85 86 87 88 89
+				     90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+    status = "okay";
+	};
+};
+
+&irqsteer_dcss {
+	status = "disabled";
+};
+
+&dcss {
+	status = "disabled";
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&lcdif {
+	status = "okay";
+	max-res = <1024>, <768>;
+	port@0 {
+		lcdif_mipi_dsi: mipi-dsi-endpoint {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&iomuxc {
+	imx8mq-evk {
+		pinctrl_bridge: typecgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+			>;
+		};
+	#if useReg	
+		pinctrl_panel: panelgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO00_GPIO1_IO0	0x16					// LVDS_BKLT_EN					
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+			>;
+		};
+	
+		pinctrl_vdd: vddgrp {
+			fsl,pins = <				
+				MX8MQ_IOMUXC_SPDIF_TX_GPIO5_IO3		0x16					// LVDS_VDD_EN
+			>;
+		};
+	#else
+		pinctrl_panel: panelgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO00_GPIO1_IO0	0x16					// LVDS_BKLT_EN					
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+				MX8MQ_IOMUXC_SPDIF_TX_GPIO5_IO3		0x16					// LVDS_VDD_EN
+			>;
+		};
+	#endif
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO01_PWM1_OUT 		0x06				// LVDS_BKLTCTL
+			>;
+		};
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+	assigned-clocks = <&clk IMX8MQ_CLK_DSI_PHY_REF>,
+			  <&clk IMX8MQ_CLK_DSI_CORE>,
+			  <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1>;
+	assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+				 <&clk IMX8MQ_SYS1_PLL_266M>,
+				 <&clk IMX8MQ_CLK_25M>;
+	assigned-clock-rates = <24000000>,
+			       <266000000>,
+			       <0>,
+			       <599999999>;
+	as_bridge;
+	sync-pol = <1>;
+	pwr-delay = <10>;
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&lcdif_mipi_dsi>;
+		};
+	};
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+	
+	panel@0 {
+		reg = <0>;
+    status = "okay";
+    compatible = "inno,g104x1l03";
+    pinctrl-0 = <&pinctrl_panel>;
+    backlight = <&backlight>;
+    bridge-i2c-bus = <&i2c4>;
+    bridge-info = <1>;
+    bridge-gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+    enable-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;   
+   #if useReg 
+    power-supply = <&reg_gpio_lvds>;
+   #else
+   	power-gpios = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+   #endif
+		dsi-lanes = <4>;
+
+		panel-width-mm  = <210>;
+		panel-height-mm = <158>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_out>;
+			};
+		};
+	};
+
+	port@1 {
+		mipi_dsi_bridge_out: endpoint {
+			remote-endpoint = <&panel_in>;
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-g185xw01.dts b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-g185xw01.dts
new file mode 100644
index 0000000..4e73874
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-g185xw01.dts
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-lec-imx8m.dts"
+#define useReg 0
+/ {
+	display-subsystem {
+		status = "disabled";
+	};
+#if useReg		
+	regulators {
+		reg_gpio_lvds: regulator-gpio {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vdd>;
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "gpio_lvds";
+			regulator-type = "voltage";
+			gpios = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+			//states = <900000 0x1 1000000 0x0>;
+		};
+	};
+#endif	
+	backlight: backlight {
+  	compatible = "pwm-backlight";
+		pwms = <&pwm1 0 1000000 0>;
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+				     10 11 12 13 14 15 16 17 18 19
+				     20 21 22 23 24 25 26 27 28 29
+				     30 31 32 33 34 35 36 37 38 39
+				     40 41 42 43 44 45 46 47 48 49
+				     50 51 52 53 54 55 56 57 58 59
+				     60 61 62 63 64 65 66 67 68 69
+				     70 71 72 73 74 75 76 77 78 79
+				     80 81 82 83 84 85 86 87 88 89
+				     90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+    status = "okay";
+	};
+};
+
+&irqsteer_dcss {
+	status = "disabled";
+};
+
+&dcss {
+	status = "disabled";
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&lcdif {
+	status = "okay";
+	max-res = <1600>, <1200>;
+	port@0 {
+		lcdif_mipi_dsi: mipi-dsi-endpoint {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&iomuxc {
+	imx8mq-evk {
+		pinctrl_bridge: typecgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+			>;
+		};
+	#if useReg	
+		pinctrl_panel: panelgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO00_GPIO1_IO0	0x16					// LVDS_BKLT_EN					
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+			>;
+		};
+	
+		pinctrl_vdd: vddgrp {
+			fsl,pins = <				
+				MX8MQ_IOMUXC_SPDIF_TX_GPIO5_IO3		0x16					// LVDS_VDD_EN
+			>;
+		};
+	#else
+		pinctrl_panel: panelgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO00_GPIO1_IO0	0x16					// LVDS_BKLT_EN					
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+				MX8MQ_IOMUXC_SPDIF_TX_GPIO5_IO3		0x16					// LVDS_VDD_EN
+			>;
+		};
+	#endif
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO01_PWM1_OUT 		0x06				// LVDS_BKLTCTL
+			>;
+		};
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+	assigned-clocks = <&clk IMX8MQ_CLK_DSI_PHY_REF>,
+			  <&clk IMX8MQ_CLK_DSI_CORE>,
+			  <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1>;
+	assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+				 <&clk IMX8MQ_SYS1_PLL_266M>,
+				 <&clk IMX8MQ_CLK_25M>;
+	assigned-clock-rates = <24000000>,
+			       <266000000>,
+			       <0>,
+			       <599999999>;
+	as_bridge;
+	sync-pol = <1>;
+	pwr-delay = <10>;
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&lcdif_mipi_dsi>;
+		};
+	};
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+	
+	panel@0 {
+		reg = <0>;
+    status = "okay";
+    compatible = "auo,g185xw01";
+    pinctrl-0 = <&pinctrl_panel>;
+    backlight = <&backlight>;
+    bridge-i2c-bus = <&i2c4>;
+    bridge-info = <2>;
+    bridge-gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+    enable-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;   
+   #if useReg 
+    power-supply = <&reg_gpio_lvds>;
+   #else
+   	power-gpios = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+   #endif
+		dsi-lanes = <4>;
+		panel-width-mm  = <409>;
+		panel-height-mm = <230>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_out>;
+			};
+		};
+	};
+
+	port@1 {
+		mipi_dsi_bridge_out: endpoint {
+			remote-endpoint = <&panel_in>;
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-hv150ux2.dts b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-hv150ux2.dts
new file mode 100644
index 0000000..bf52d9b
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-hv150ux2.dts
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-lec-imx8m.dts"
+
+/ {
+	display-subsystem {
+		status = "disabled";
+	};
+	
+	regulators {
+		reg_gpio_lvds: regulator-gpio {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vdd>;
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "gpio_lvds";
+			regulator-type = "voltage";
+			gpios = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+			states = <900000 0x1 1000000 0x0>;
+		};
+	};
+	
+	backlight: backlight {
+  	compatible = "pwm-backlight";
+		pwms = <&pwm1 0 1000000 0>;
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+				     10 11 12 13 14 15 16 17 18 19
+				     20 21 22 23 24 25 26 27 28 29
+				     30 31 32 33 34 35 36 37 38 39
+				     40 41 42 43 44 45 46 47 48 49
+				     50 51 52 53 54 55 56 57 58 59
+				     60 61 62 63 64 65 66 67 68 69
+				     70 71 72 73 74 75 76 77 78 79
+				     80 81 82 83 84 85 86 87 88 89
+				     90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+    status = "okay";
+	};
+};
+
+&irqsteer_dcss {
+	status = "disabled";
+};
+
+&dcss {
+	status = "disabled";
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&lcdif {
+	status = "okay";
+	max-res = <1600>, <1200>;
+	port@0 {
+		lcdif_mipi_dsi: mipi-dsi-endpoint {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&iomuxc {
+	imx8mq-evk {
+		pinctrl_bridge: typecgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+			>;
+		};
+		
+		pinctrl_panel: panelgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO00_GPIO1_IO0	0x16					// LVDS_BKLT_EN					
+			>;
+		};
+		
+		pinctrl_vdd: vddgrp {
+			fsl,pins = <				
+				MX8MQ_IOMUXC_SPDIF_TX_GPIO5_IO3		0x16					// LVDS_VDD_EN
+			>;
+		};
+		
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO01_PWM1_OUT 		0x06				// LVDS_BKLTCTL
+			>;
+		};
+	};
+};
+
+&i2c4 {
+	status = "okay";
+	dsi_lvds_bridge: sn65dsi84@2c {
+		reg = <0x2c>;
+		status = "okay";
+		compatible = "ti,sn65dsi84";
+		pinctrl-0 = <&pinctrl_bridge>;
+		enable-gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+
+		sn65dsi84,addresses = <	0x09 0x0A 0x0B 0x0D 0x10 0x11 0x12 0x13
+					0x18 0x19 0x1A 0x1B 0x20 0x21 0x22 0x23
+					0x24 0x25 0x26 0x27 0x28 0x29 0x2A 0x2B
+					0x2C 0x2D 0x2E 0x2F 0x30 0x31 0x32 0x33
+					0x34 0x35 0x36 0x37 0x38 0x39 0x3A 0x3B
+					0x3C 0x3D 0x3E 0x0D>;
+
+		sn65dsi84,values =    <	0x00 0x05 0x10 0x00 0x26 0x00 0x31 0x00
+					0x60 0x00 0x03 0x00 0x40 0x06 0x00 0x00
+					0x00 0x00 0x00 0x00 0xa6 0x03 0x00 0x00
+					0x32 0x00 0x00 0x00 0x0a 0x00 0x00 0x00
+					0x32 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+					0x00 0x00 0x00 0x01>;
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+	as_bridge;
+	sync-pol = <1>;
+	pwr-delay = <10>;
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&lcdif_mipi_dsi>;
+		};
+	};
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+	
+	panel@0 {
+		reg = <0>;
+    status = "okay";
+    compatible = "hydis,hv150ux2";
+    pinctrl-0 = <&pinctrl_panel>;
+    backlight = <&backlight>;
+    enable-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+    power-supply = <&reg_gpio_lvds>;
+		dsi-lanes = <4>;
+		panel-width-mm  = <305>;
+		panel-height-mm = <229>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_out>;
+			};
+		};
+	};
+
+	port@1 {
+		mipi_dsi_bridge_out: endpoint {
+			remote-endpoint = <&panel_in>;
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-lm215wf3.dts b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-lm215wf3.dts
new file mode 100644
index 0000000..2c9ffd9
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-lm215wf3.dts
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-lec-imx8m.dts"
+
+/ {
+	display-subsystem {
+		status = "disabled";
+	};
+	
+	regulators {
+		reg_gpio_lvds: regulator-gpio {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vdd>;
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "gpio_lvds";
+			regulator-type = "voltage";
+			gpios = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+			states = <900000 0x1 1000000 0x0>;
+		};
+	};
+	
+	backlight: backlight {
+  	compatible = "pwm-backlight";
+		pwms = <&pwm1 0 1000000 0>;
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+				     10 11 12 13 14 15 16 17 18 19
+				     20 21 22 23 24 25 26 27 28 29
+				     30 31 32 33 34 35 36 37 38 39
+				     40 41 42 43 44 45 46 47 48 49
+				     50 51 52 53 54 55 56 57 58 59
+				     60 61 62 63 64 65 66 67 68 69
+				     70 71 72 73 74 75 76 77 78 79
+				     80 81 82 83 84 85 86 87 88 89
+				     90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+    status = "okay";
+	};
+};
+
+&irqsteer_dcss {
+	status = "disabled";
+};
+
+&dcss {
+	status = "disabled";
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&lcdif {
+	status = "okay";
+	max-res = <1920>, <1080>;
+	port@0 {
+		lcdif_mipi_dsi: mipi-dsi-endpoint {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&iomuxc {
+	imx8mq-evk {
+		pinctrl_bridge: typecgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+			>;
+		};
+		
+		pinctrl_panel: panelgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO00_GPIO1_IO0	0x16					// LVDS_BKLT_EN					
+			>;
+		};
+		
+		pinctrl_vdd: vddgrp {
+			fsl,pins = <				
+				MX8MQ_IOMUXC_SPDIF_TX_GPIO5_IO3		0x16					// LVDS_VDD_EN
+			>;
+		};
+		
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO01_PWM1_OUT 		0x06				// LVDS_BKLTCTL
+			>;
+		};
+	};
+};
+
+&i2c4 {
+	status = "okay";
+	dsi_lvds_bridge: sn65dsi84@2c {
+		reg = <0x2c>;
+		status = "okay";
+		compatible = "ti,sn65dsi84";
+		pinctrl-0 = <&pinctrl_bridge>;
+		enable-gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+
+		sn65dsi84,addresses = <	0x09 0x0A 0x0B 0x0D 0x10 0x11 0x12 0x13
+					0x18 0x19 0x1A 0x1B 0x20 0x21 0x22 0x23
+					0x24 0x25 0x26 0x27 0x28 0x29 0x2A 0x2B
+					0x2C 0x2D 0x2E 0x2F 0x30 0x31 0x32 0x33
+					0x34 0x35 0x36 0x37 0x38 0x39 0x3A 0x3B
+					0x3C 0x3D 0x3E 0x0D>;
+
+		sn65dsi84,values =    <	0x00 0x05 0x10 0x00 0x26 0x00 0x2b 0x00
+					0x6d 0x00 0x03 0x00 0x80 0x07 0x00 0x00
+					0x00 0x00 0x00 0x00 0x13 0x04 0x00 0x00
+					0x19 0x00 0x00 0x00 0x08 0x00 0x00 0x00
+					0x19 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+					0x00 0x00 0x00 0x01>;
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+	as_bridge;
+	sync-pol = <1>;
+	pwr-delay = <10>;
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&lcdif_mipi_dsi>;
+		};
+	};
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+	
+	panel@0 {
+		reg = <0>;
+    status = "okay";
+    compatible = "lg,lm215wf3";
+    pinctrl-0 = <&pinctrl_panel>;
+    backlight = <&backlight>;
+    enable-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+    power-supply = <&reg_gpio_lvds>;
+		dsi-lanes = <4>;
+		panel-width-mm  = <475>;
+		panel-height-mm = <267>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_out>;
+			};
+		};
+	};
+
+	port@1 {
+		mipi_dsi_bridge_out: endpoint {
+			remote-endpoint = <&panel_in>;
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-n101bge.dts b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-n101bge.dts
new file mode 100755
index 0000000..b353726
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/adlink-imx8mq-evk-lcdif-n101bge.dts
@@ -0,0 +1,196 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "adlink-lec-imx8m.dts"
+#define useReg 0
+/ {
+	display-subsystem {
+		status = "disabled";
+	};
+	
+	sound-hdmi {
+		status = "disabled";
+	};
+	
+#if useReg		
+	regulators {
+		reg_gpio_lvds: regulator-gpio {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vdd>;
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "gpio_lvds";
+			regulator-type = "voltage";
+			gpios = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+			//states = <900000 0x1 1000000 0x0>;
+		};
+	};
+#endif	
+	backlight: backlight {
+  	compatible = "pwm-backlight";
+		pwms = <&pwm1 0 1000000 0>;
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+				     10 11 12 13 14 15 16 17 18 19
+				     20 21 22 23 24 25 26 27 28 29
+				     30 31 32 33 34 35 36 37 38 39
+				     40 41 42 43 44 45 46 47 48 49
+				     50 51 52 53 54 55 56 57 58 59
+				     60 61 62 63 64 65 66 67 68 69
+				     70 71 72 73 74 75 76 77 78 79
+				     80 81 82 83 84 85 86 87 88 89
+				     90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+    status = "okay";
+	};
+};
+
+&irqsteer_dcss {
+	status = "disabled";
+};
+
+&dcss {
+	status = "disabled";
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&lcdif {
+	status = "okay";
+	max-res = <1600>, <1200>;
+	assigned-clocks = <&clk IMX8MQ_CLK_LCDIF_PIXEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1>;
+	assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+				 <&clk IMX8MQ_CLK_25M>;
+	assigned-clock-rate = <120000000>,
+			      <0>,
+			      <599999999>;
+	port@0 {
+		lcdif_mipi_dsi: mipi-dsi-endpoint {
+			remote-endpoint = <&mipi_dsi_in>;
+		};
+	};
+};
+
+&iomuxc {
+	imx8mq-evk {
+		pinctrl_bridge: typecgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+			>;
+		};
+	#if useReg	
+		pinctrl_panel: panelgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO00_GPIO1_IO0	0x16					// LVDS_BKLT_EN					
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+			>;
+		};
+	
+		pinctrl_vdd: vddgrp {
+			fsl,pins = <				
+				MX8MQ_IOMUXC_SPDIF_TX_GPIO5_IO3		0x16					// LVDS_VDD_EN
+			>;
+		};
+	#else
+		pinctrl_panel: panelgrp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO00_GPIO1_IO0	0x16					// LVDS_BKLT_EN					
+				MX8MQ_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x16			// LCD_BRI_EN	
+				MX8MQ_IOMUXC_SPDIF_TX_GPIO5_IO3		0x16					// LVDS_VDD_EN
+			>;
+		};
+	#endif
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX8MQ_IOMUXC_GPIO1_IO01_PWM1_OUT 		0x06				// LVDS_BKLTCTL
+			>;
+		};
+	};
+};
+
+&mipi_dsi_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+	assigned-clocks = <&clk IMX8MQ_CLK_DSI_PHY_REF>,
+			  <&clk IMX8MQ_CLK_DSI_CORE>,
+			  <&clk IMX8MQ_VIDEO_PLL1_REF_SEL>,
+			  <&clk IMX8MQ_VIDEO_PLL1>;
+	assigned-clock-parents = <&clk IMX8MQ_VIDEO_PLL1_OUT>,
+				 <&clk IMX8MQ_SYS1_PLL_266M>,
+				 <&clk IMX8MQ_CLK_25M>;
+	assigned-clock-rates = <24000000>,
+			       <266000000>,
+			       <0>,
+			       <599999999>;
+	as_bridge;
+	sync-pol = <1>;
+	pwr-delay = <10>;
+
+	port@1 {
+		mipi_dsi_in: endpoint {
+			remote-endpoint = <&lcdif_mipi_dsi>;
+		};
+	};
+};
+
+&mipi_dsi_bridge {
+	status = "okay";
+	
+	panel@0 {
+		reg = <0>;
+    status = "okay";
+    compatible = "inno,n101bge";
+    pinctrl-0 = <&pinctrl_panel>;
+    backlight = <&backlight>;
+    bridge-i2c-bus = <&i2c4>;
+    bridge-info = <3>;
+    bridge-gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+    enable-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;   
+   #if useReg 
+    power-supply = <&reg_gpio_lvds>;
+   #else
+   	power-gpios = <&gpio5 3 GPIO_ACTIVE_HIGH>;
+   #endif
+		dsi-lanes = <4>;
+		panel-width-mm  = <223>;
+		panel-height-mm = <126>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mipi_dsi_bridge_out>;
+			};
+		};
+	};
+
+	port@1 {
+		mipi_dsi_bridge_out: endpoint {
+			remote-endpoint = <&panel_in>;
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 593e9a4..212fbb8 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -89,6 +89,14 @@ config DRM_PARADE_PS8622
 	---help---
 	  Parade eDP-LVDS bridge chip driver.
 
+config DRM_TI_SN65DSI84
+	tristate "TI SN65DSI84 DSI/LVDS bridge"
+	depends on OF
+	select DRM_KMS_HELPER
+	select DRM_PANEL
+	---help---
+	  TI SN65DSI84 DSI-LVDS bridge chip driver.
+
 config DRM_SIL_SII8620
 	tristate "Silicon Image SII8620 HDMI/MHL bridge"
 	depends on OF
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index d684dce..fcfa46c 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_DRM_ITE_IT6263) += it6263.o
 obj-$(CONFIG_DRM_NWL_DSI) += nwl-dsi.o
 obj-$(CONFIG_DRM_SEC_MIPI_DSIM) += sec-dsim.o
 obj-$(CONFIG_DRM_NXP_SEIKO_43WVFIG) += nxp-seiko-43wvfig.o
+obj-$(CONFIG_DRM_TI_SN65DSI84) += sn65dsi84-dsi2lvds.o
diff --git a/drivers/gpu/drm/bridge/sn65dsi84-dsi2lvds.c b/drivers/gpu/drm/bridge/sn65dsi84-dsi2lvds.c
new file mode 100644
index 0000000..5dc66b4
--- /dev/null
+++ b/drivers/gpu/drm/bridge/sn65dsi84-dsi2lvds.c
@@ -0,0 +1,218 @@
+/*
+ * Texas Instruments sn65dsi84 DSI to LVDS bridge driver.
+ *
+ * Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+
+static int sn65dsi84_i2c_read(struct i2c_client *client, char *writebuf,
+			   int writelen, char *readbuf, int readlen)
+{
+	int ret;
+
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+				.addr = client->addr,
+				.flags = 0,
+				.len = writelen,
+				.buf = writebuf,
+			},
+			{
+				.addr = client->addr,
+				.flags = I2C_M_RD,
+				.len = readlen,
+				.buf = readbuf,
+			},
+		};
+
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret < 0)
+			dev_err(&client->dev, "%s: i2c read error.\n", __func__);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+				.addr = client->addr,
+				.flags = I2C_M_RD,
+				.len = readlen,
+				.buf = readbuf,
+			},
+		};
+
+		ret = i2c_transfer(client->adapter, msgs, 1);
+		if (ret < 0)
+			dev_err(&client->dev, "%s:i2c read error.\n", __func__);
+	}
+
+	return ret;
+}
+
+static int sn65dsi84_i2c_write(struct i2c_client *client, char *writebuf,
+			    int writelen)
+{
+	int ret;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = writelen,
+			.buf = writebuf,
+		},
+	};
+	ret = i2c_transfer(client->adapter, msgs, 1);
+	if (ret < 0)
+		dev_err(&client->dev, "%s: i2c write error.\n", __func__);
+
+	return ret;
+}
+
+static int sn65dsi84_write_reg(struct i2c_client *client, u8 addr, const u8 val)
+{
+	u8 buf[2] = {0};
+
+	buf[0] = addr;
+	buf[1] = val;
+
+	return sn65dsi84_i2c_write(client, buf, sizeof(buf));
+}
+
+static int sn65dsi84_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)
+{
+	struct property *prop;
+	int err;
+	int i, size;
+	struct device_node *np = client->dev.of_node;
+	int addresses[100];
+	int values[100];
+	int chipid[] = {0x35, 0x38, 0x49, 0x53, 0x44, 0x20, 0x20, 0x20, 0x01};
+	char address, value;
+	struct gpio_desc *enable_gpio;
+
+	enable_gpio = devm_gpiod_get_optional(&client->dev, "enable", GPIOD_OUT_HIGH);
+	if (enable_gpio)
+		gpiod_set_value_cansleep(enable_gpio, 1);
+
+	for (i = 0; i < sizeof(chipid) / sizeof(int); i++) {
+		address = (char)i;
+		err = sn65dsi84_i2c_read(client, &address, 1, &value, 1);
+		if (err < 0) {
+			dev_err(&client->dev, "failed to read chip id\n");
+			return err;
+		}
+		if (value != chipid[i]) {
+			dev_err(&client->dev, "chip id is not correct\n");
+			return err;
+		}
+	}
+
+	prop = of_find_property(np, "sn65dsi84,addresses", NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	size = prop->length / sizeof(int);
+
+	err = of_property_read_u32_array(np, "sn65dsi84,addresses", addresses, size);
+	if (err && (err != -EINVAL)) {
+		dev_err(&client->dev, "Unable to read 'sn65dsi84,addresses'\n");
+		return err;
+	}
+
+	prop = of_find_property(np, "sn65dsi84,values", NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	i = prop->length / sizeof(u32);
+	if (i != size) {
+		dev_err(&client->dev, "invalid 'sn65dsi84,values' length should be same as addresses\n");
+		return -EINVAL;
+	}
+
+	err = of_property_read_u32_array(np, "sn65dsi84,values", values, i);
+	if (err && (err != -EINVAL)) {
+		dev_err(&client->dev, "Unable to read 'sn65dsi84,values'\n");
+		return err;
+	}
+
+	for (i = 0; i < size; i++) {
+		sn65dsi84_write_reg(client, addresses[i], values[i]);
+		if (err < 0) {
+			dev_err(&client->dev, "failed to write data to the chip\n");
+			return err;
+		}
+	}
+
+
+	return 0;
+}
+
+static int sn65dsi84_remove(struct i2c_client *client)
+{
+	struct gpio_desc *enable_gpio;
+
+	enable_gpio = devm_gpiod_get_optional(&client->dev, "enable", GPIOD_OUT_LOW);
+	if (enable_gpio)
+		gpiod_set_value_cansleep(enable_gpio, 0);
+
+	return 0;
+}
+
+static const struct i2c_device_id sn65dsi84_id[] = {
+	{"sn65dsi84", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, sn65dsi84_id);
+
+static struct of_device_id sn65dsi84_match_table[] = {
+	{ .compatible = "ti,sn65dsi84",},
+	{ },
+};
+
+static struct i2c_driver sn65dsi84_i2c_driver = {
+	.probe = sn65dsi84_probe,
+	.remove = sn65dsi84_remove,
+	.driver = {
+		.name = "sn65dsi84",
+		.owner = THIS_MODULE,
+		.of_match_table = sn65dsi84_match_table,
+	},
+	.id_table = sn65dsi84_id,
+};
+
+static int __init sn65dsi84_init(void)
+{
+	return i2c_add_driver(&sn65dsi84_i2c_driver);
+}
+
+static void __exit sn65dsi84_exit(void)
+{
+	i2c_del_driver(&sn65dsi84_i2c_driver);
+}
+
+module_init(sn65dsi84_init);
+module_exit(sn65dsi84_exit);
+
+MODULE_DESCRIPTION("TI SN65DSI84 DSI to LVDS bridge driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index eb2a746..6584baa 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -38,6 +38,17 @@ config DRM_PANEL_INNOLUX_P079ZCA
 	  TFT-LCD modules. The panel has a 1024x768 resolution and uses
 	  24 bit RGB per pixel. It provides a MIPI DSI interface to
 	  the host and has a built-in LED backlight.
+	  
+config DRM_PANEL_LECIMX8
+	tristate "support for lecimx8 panels"
+	depends on OF
+	depends on BACKLIGHT_CLASS_DEVICE
+	select VIDEOMODE_HELPERS
+	help
+	  DRM panel driver for dumb panels that need at most a regulator and
+	  a GPIO to be powered up. Optionally a backlight can be attached so
+	  that it can be automatically turned off when the panel goes into a
+	  low power state.	  
 
 config DRM_PANEL_JDI_LT070ME05000
 	tristate "JDI LT070ME05000 WUXGA DSI panel"
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 68a80b1..f1ac49b 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_DRM_PANEL_LVDS) += panel-lvds.o
 obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
+obj-$(CONFIG_DRM_PANEL_LECIMX8) += panel-lecimx8.o
 obj-$(CONFIG_DRM_PANEL_INNOLUX_P079ZCA) += panel-innolux-p079zca.o
 obj-$(CONFIG_DRM_PANEL_JDI_LT070ME05000) += panel-jdi-lt070me05000.o
 obj-$(CONFIG_DRM_PANEL_LG_LG4573) += panel-lg-lg4573.o
diff --git a/drivers/gpu/drm/panel/panel-lecimx8.c b/drivers/gpu/drm/panel/panel-lecimx8.c
new file mode 100755
index 0000000..0610e85
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-lecimx8.c
@@ -0,0 +1,2720 @@
+/*
+ * Copyright (C) 2013, NVIDIA Corporation.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/backlight.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+
+#include <video/display_timing.h>
+#include <video/videomode.h>
+
+#define useTiming 0
+#define BridgeAddr	0x2c
+#define useblk	1
+#define useReg	0
+#define jdebug 0
+static int sn65dsi84_i2c_read(struct i2c_adapter *bridge, char *writebuf,
+			   int writelen, char *readbuf, int readlen)
+{
+	int ret;
+
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+				.addr = BridgeAddr,
+				.flags = 0,
+				.len = writelen,
+				.buf = writebuf,
+			},
+			{
+				.addr = BridgeAddr,
+				.flags = I2C_M_RD,
+				.len = readlen,
+				.buf = readbuf,
+			},
+		};
+
+		ret = i2c_transfer(bridge, msgs, 2);
+		if (ret < 0)
+			printk("%s: i2c read error.\n", __func__);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+				.addr = BridgeAddr,
+				.flags = I2C_M_RD,
+				.len = readlen,
+				.buf = readbuf,
+			},
+		};
+
+		ret = i2c_transfer(bridge, msgs, 1);
+		if (ret < 0)
+			printk("%s:i2c read error.\n", __func__);
+	}
+
+	return ret;
+}
+
+static int sn65dsi84_i2c_write(struct i2c_adapter *bridge, char *writebuf,
+			    int writelen)
+{
+	int ret;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr = BridgeAddr,
+			.flags = 0,
+			.len = writelen,
+			.buf = writebuf,
+		},
+	};
+	ret = i2c_transfer(bridge, msgs, 1);
+	if (ret < 0)
+		printk("%s: i2c write error.\n", __func__);
+
+	return ret;
+}
+
+static int sn65dsi84_write_reg(struct i2c_adapter *bridge, u8 addr, const u8 val)
+{
+	u8 buf[2] = {0};
+
+	buf[0] = addr;
+	buf[1] = val;
+
+	return sn65dsi84_i2c_write(bridge, buf, sizeof(buf));
+}
+// end of added
+
+struct panel_desc {
+	const struct drm_display_mode *modes;
+	unsigned int num_modes;
+	const struct display_timing *timings;
+	unsigned int num_timings;
+
+	unsigned int bpc;
+
+	/**
+	 * @width: width (in millimeters) of the panel's active display area
+	 * @height: height (in millimeters) of the panel's active display area
+	 */
+	struct {
+		unsigned int width;
+		unsigned int height;
+	} size;
+
+	/**
+	 * @prepare: the time (in milliseconds) that it takes for the panel to
+	 *           become ready and start receiving video data
+	 * @enable: the time (in milliseconds) that it takes for the panel to
+	 *          display the first valid frame after starting to receive
+	 *          video data
+	 * @disable: the time (in milliseconds) that it takes for the panel to
+	 *           turn the display off (no content is visible)
+	 * @unprepare: the time (in milliseconds) that it takes for the panel
+	 *             to power itself down completely
+	 */
+	struct {
+		unsigned int prepare;
+		unsigned int enable;
+		unsigned int disable;
+		unsigned int unprepare;
+	} delay;
+
+	u32 bus_format;
+	u32 bus_flags;
+};
+
+struct panel_simple {
+	struct drm_panel base;
+	bool prepared;
+	bool enabled;
+
+	const struct panel_desc *desc;
+
+	struct backlight_device *backlight;
+	struct regulator *supply;
+	struct i2c_adapter *ddc;	
+	struct i2c_adapter *bridge;
+	struct gpio_desc *bridge_gpio;		
+	int bridge_info;
+	struct gpio_desc *power_gpio;
+	
+	struct gpio_desc *enable_gpio;
+};
+
+static inline struct panel_simple *to_panel_simple(struct drm_panel *panel)
+{
+	return container_of(panel, struct panel_simple, base);
+}
+
+static int panel_simple_get_fixed_modes(struct panel_simple *panel)
+{
+	struct drm_connector *connector = panel->base.connector;
+	struct drm_device *drm = panel->base.drm;
+	struct drm_display_mode *mode;
+	unsigned int i, num = 0;
+
+	if (!panel->desc)
+		return 0;
+
+	for (i = 0; i < panel->desc->num_timings; i++) {
+		const struct display_timing *dt = &panel->desc->timings[i];
+		struct videomode vm;
+
+		videomode_from_timing(dt, &vm);
+		mode = drm_mode_create(drm);
+		if (!mode) {
+			dev_err(drm->dev, "failed to add mode %ux%u\n",
+				dt->hactive.typ, dt->vactive.typ);
+			continue;
+		}
+
+		drm_display_mode_from_videomode(&vm, mode);
+
+		mode->type |= DRM_MODE_TYPE_DRIVER;
+
+		if (panel->desc->num_timings == 1)
+			mode->type |= DRM_MODE_TYPE_PREFERRED;
+
+		drm_mode_probed_add(connector, mode);
+		num++;
+	}
+
+	for (i = 0; i < panel->desc->num_modes; i++) {
+		const struct drm_display_mode *m = &panel->desc->modes[i];
+
+		mode = drm_mode_duplicate(drm, m);
+		if (!mode) {
+			dev_err(drm->dev, "failed to add mode %ux%u@%u\n",
+				m->hdisplay, m->vdisplay, m->vrefresh);
+			continue;
+		}
+
+		mode->type |= DRM_MODE_TYPE_DRIVER;
+
+		if (panel->desc->num_modes == 1)
+			mode->type |= DRM_MODE_TYPE_PREFERRED;
+
+		drm_mode_set_name(mode);
+
+		drm_mode_probed_add(connector, mode);
+		num++;
+	}
+
+	connector->display_info.bpc = panel->desc->bpc;
+	connector->display_info.width_mm = panel->desc->size.width;
+	connector->display_info.height_mm = panel->desc->size.height;
+	if (panel->desc->bus_format)
+		drm_display_info_set_bus_formats(&connector->display_info,
+						 &panel->desc->bus_format, 1);
+	connector->display_info.bus_flags = panel->desc->bus_flags;
+
+	return num;
+}
+
+static int panel_simple_disable(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_disable start \r\n");
+	#endif
+	// end of added
+	if (!p->enabled)
+		return 0;
+#if useblk
+	if (p->backlight) {
+		p->backlight->props.power = FB_BLANK_POWERDOWN;
+		p->backlight->props.state |= BL_CORE_FBBLANK;
+		backlight_update_status(p->backlight);
+	}
+#endif
+	if (p->desc->delay.disable)
+		msleep(p->desc->delay.disable);
+
+	p->enabled = false;
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_disable end \r\n");
+	#endif
+	// end of added
+	return 0;
+}
+
+static int panel_simple_unprepare(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_unprepare start \r\n");
+	#endif
+	// end of added
+	if (!p->prepared)
+		return 0;
+
+	if (p->enable_gpio)
+		gpiod_set_value_cansleep(p->enable_gpio, 0);
+
+	#if useReg	
+	regulator_disable(p->supply);	
+	#endif
+	if (p->desc->delay.unprepare)
+		msleep(p->desc->delay.unprepare);
+
+	p->prepared = false;
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_unprepare end \r\n");
+	#endif
+	// end of added
+	return 0;
+}
+
+static int panel_simple_prepare(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_prepare start \r\n");
+	#endif
+	// end of added
+	if (p->prepared)
+		return 0;
+	#if useReg	
+	err = regulator_enable(p->supply);
+	if (err < 0) {
+		dev_err(panel->dev, "failed to enable supply: %d\n", err);
+		return err;
+	}	
+	#endif
+	// added by johnson to test
+	#if jdebug
+	printk("johnson set enable_gpio H \r\n");
+	#endif
+	// end of added
+	if (p->enable_gpio)
+		gpiod_set_value_cansleep(p->enable_gpio, 1);
+
+	if (p->desc->delay.prepare)
+		msleep(p->desc->delay.prepare);
+
+	p->prepared = true;
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_prepare end \r\n");
+	#endif
+	// end of added
+	return 0;
+}
+
+static int bridge_sn65dsi84_write_values(struct panel_simple *p, char *addresses, char *values, int size1, int size2)
+{
+	int i=0;
+	int err=0;
+	if( size1!=size2)
+		return -1;
+	for (i = 0; i < size1; i++) {
+				err = sn65dsi84_write_reg(p->bridge, addresses[i], values[i]);
+				if (err < 0) {
+					printk("failed to write data to the chip\n");
+					return err;
+				}
+			}
+	return err;
+}
+#define testpattern 0
+
+#define ttt 39	// ok, this is for inno_g104x1l03 200/2
+
+static int bridge_sn65dsi84_config(struct panel_simple *p)
+{
+	int i=0, size=0, err=0;
+	
+	switch(p->bridge_info)
+	{
+	case 1:	// for inno_g104x1l03
+		{
+			char addresses[] = {
+											0x09, 0x0A, 0x0B, 0x0D, 0x10, 0x11, 0x12, 0x13,
+											0x18, 0x19, 0x1A, 0x1B, 0x20, 0x21, 0x22, 0x23,
+											0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B,
+											0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
+											0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,
+											0x3C, 0x3D, 0x3E, 0x0D
+											};
+			
+			char values[] = {
+										#if testpattern
+											0x00, 0x05, 0x10, 0x00, 0x26, 0x00, 0x27, 0x00,
+											0x78, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00,
+											0x00, 0x03, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
+											0x64, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
+											0x64, 0x00, 0x0a, 0x00, 0x78, 0x00, 0x12, 0x00,
+											0x10, 0x00, 0x00, 0x01
+										#else										
+											0x00, 0x07, 0x08, 0x00, 0x26, 0x00, 0x28, 0x00, 
+											0x78, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 
+											0x00, 0x00, 0x00, 0x00, 0xc2, 0x02, 0x00, 0x00, 
+											0x64, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
+											0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+											0x00, 0x00, 0x00, 0x01
+										#endif
+											};			
+			i = sizeof(addresses);
+			size = sizeof(values);
+			err = bridge_sn65dsi84_write_values(p, addresses, values, i, size);			
+		}
+		break;
+	case 2:
+		{
+			char addresses[] = {
+											0x09, 0x0A, 0x0B, 0x0D, 0x10, 0x11, 0x12, 0x13,
+											0x18, 0x19, 0x1A, 0x1B, 0x20, 0x21, 0x22, 0x23,
+											0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B,
+											0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
+											0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,
+											0x3C, 0x3D, 0x3E, 0x0D
+											};
+			
+			char values[] = {																														
+											0x00, 0x05, 0x10, 0x00, 0x26, 0x00, 0x2f, 0x00, 
+											0x78, 0x00, 0x03, 0x00, 0x56, 0x05, 0x00, 0x00, 
+											0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 
+											0x78, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
+											0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+											0x00, 0x00, 0x00, 0x01																				
+											};
+			i = sizeof(addresses);
+			size = sizeof(values);
+			err = bridge_sn65dsi84_write_values(p, addresses, values, i, size);			
+		}
+		break;
+	case 3:
+		{
+			char addresses[] = {
+											0x09, 0x0A, 0x0B, 0x0D, 0x10, 0x11, 0x12, 0x13,
+											0x18, 0x19, 0x1A, 0x1B, 0x20, 0x21, 0x22, 0x23,
+											0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B,
+											0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
+											0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,
+											0x3C, 0x3D, 0x3E, 0x0D
+											};
+			
+			char values[] = {																														
+											0x00, 0x05, 0x10, 0x00, 0x26, 0x00, 0x31, 0x00, 
+											0x7a, 0x00, 0x03, 0x00, 0x56, 0x05, 0x00, 0x00, 
+											0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 
+											0x78, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
+											0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+											0x00, 0x00, 0x00, 0x01																				
+											};
+			i = sizeof(addresses);
+			size = sizeof(values);
+			err = bridge_sn65dsi84_write_values(p, addresses, values, i, size);			
+		}
+		break;
+				
+	default:
+		break;
+	}
+	return err;
+}
+static int bridge_sn65dsi84_enable(struct panel_simple *p)
+{	
+	int i, err=0;	
+	int chipid[] = {0x35, 0x38, 0x49, 0x53, 0x44, 0x20, 0x20, 0x20, 0x01};
+	char address, value;
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa bridge_sn65dsi84_enable start \r\n");
+	#endif
+	// end of added
+	if (p->bridge_gpio) 
+	{
+		#if jdebug
+		printk("johnson start to enable bridge \r\n");
+		#endif
+		gpiod_set_value_cansleep(p->bridge_gpio, 0);
+		msleep(10);
+		gpiod_set_value_cansleep(p->bridge_gpio, 1);
+		msleep(10);
+	}
+	for (i = 0; i < sizeof(chipid) / sizeof(int); i++) {
+		address = (char)i;
+		err = sn65dsi84_i2c_read(p->bridge, &address, 1, &value, 1);
+		if (err < 0) {
+			printk("failed to read chip id\n");
+			return err;
+		}
+		if (value != chipid[i]) {
+			printk("chip id is not correct\n");
+			return err;
+		}
+	}
+	err = bridge_sn65dsi84_config(p);
+	if( err < 0)
+		return err;
+	
+	msleep(50);
+	err = sn65dsi84_write_reg(p->bridge, 0x09, 0x01);
+	if (err < 0) {
+		printk("failed to write data to the chip\n");
+		return err;
+	}
+	msleep(50);
+	address = 0xe5;
+	err = sn65dsi84_i2c_read(p->bridge, &address, 1, &value, 1);
+	if (err < 0) {
+		printk("failed to read chip id\n");
+		return err;
+	}	
+	
+	msleep(500);
+	#if jdebug
+	printk("johnson aaa bridge_sn65dsi84_enable end value: 0x%x \r\n", value);
+	#endif
+	return 0;
+}
+// end of added
+static int panel_simple_enable(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_enable start \r\n");
+	#endif
+	// end of added
+	if (p->enabled)
+		return 0;
+
+	if (p->desc->delay.enable)
+		msleep(p->desc->delay.enable);
+#if useblk
+	if (p->backlight) {
+		p->backlight->props.state &= ~BL_CORE_FBBLANK;
+		p->backlight->props.power = FB_BLANK_UNBLANK;
+		backlight_update_status(p->backlight);
+	}
+#endif
+	p->enabled = true;
+	// added by johnson to test
+	#if jdebug	
+	printk("johnson aaa panel_simple_enable end \r\n");
+	#endif
+	// end of added
+	return 0;
+}
+
+static int panel_simple_get_modes(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	int num = 0;
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_get_modes start \r\n");
+	#endif
+	// end of added
+	/* probe EDID if a DDC bus is available */
+	if (p->ddc) {
+		struct edid *edid = drm_get_edid(panel->connector, p->ddc);
+		drm_mode_connector_update_edid_property(panel->connector, edid);
+		if (edid) {
+			num += drm_add_edid_modes(panel->connector, edid);
+			kfree(edid);
+		}
+	}
+
+	/* add hard-coded panel modes */
+	num += panel_simple_get_fixed_modes(p);
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_get_modes end \r\n");
+	#endif
+	// end of added
+	return num;
+}
+
+static int panel_simple_get_timings(struct drm_panel *panel,
+				    unsigned int num_timings,
+				    struct display_timing *timings)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	unsigned int i;
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_get_timings start \r\n");
+	#endif
+	// end of added
+	if (p->desc->num_timings < num_timings)
+		num_timings = p->desc->num_timings;
+
+	if (timings)
+		for (i = 0; i < num_timings; i++)
+			timings[i] = p->desc->timings[i];
+	// added by johnson to test
+	#if jdebug
+	printk("johnson aaa panel_simple_get_timings end \r\n");
+	#endif
+	// end of added
+	return p->desc->num_timings;
+}
+
+static const struct drm_panel_funcs panel_simple_funcs = {
+	.disable = panel_simple_disable,
+	.unprepare = panel_simple_unprepare,
+	.prepare = panel_simple_prepare,
+	.enable = panel_simple_enable,
+	.get_modes = panel_simple_get_modes,
+	.get_timings = panel_simple_get_timings,
+};
+
+static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
+{
+	struct device_node *backlight, *ddc, *bridge;
+	struct panel_simple *panel;
+	int err;	
+	struct device_node *np = dev->of_node;
+	// added by johnson to test		
+	#if jdebug
+	printk("johnson set panel_simple_probe start \r\n");
+	#endif
+	// end of added
+	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
+	if (!panel)
+		return -ENOMEM;
+
+	panel->enabled = false;
+	panel->prepared = false;
+	panel->desc = desc;
+
+	#if useReg
+	// added by johnson to test
+	#if jdebug
+	printk("johnson use regulator 111 \r\n");
+	#endif
+	// end of added
+	panel->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(panel->supply))
+		return PTR_ERR(panel->supply);
+	// added by johnson to test
+	#if jdebug
+	printk("johnson use regulator 222 \r\n");
+	#endif
+	// end of added
+	#else
+	panel->power_gpio = devm_gpiod_get_optional(dev, "power",
+						     GPIOD_OUT_HIGH);
+	if (IS_ERR(panel->power_gpio)) {
+		err = PTR_ERR(panel->power_gpio);
+		dev_err(dev, "failed to request power GPIO: %d\n", err);
+		return err;
+	}
+	gpiod_set_value_cansleep(panel->power_gpio, 1);
+	#if jdebug
+	printk("johnson use power gpio \r\n");
+	#endif
+	
+	#endif
+	
+	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable",
+						     GPIOD_OUT_LOW);
+	if (IS_ERR(panel->enable_gpio)) {
+		err = PTR_ERR(panel->enable_gpio);
+		dev_err(dev, "failed to request GPIO: %d\n", err);
+		return err;
+	}
+#if useblk
+	backlight = of_parse_phandle(dev->of_node, "backlight", 0);
+	if (backlight) {
+		panel->backlight = of_find_backlight_by_node(backlight);
+		of_node_put(backlight);
+
+		if (!panel->backlight)
+			return -EPROBE_DEFER;
+	}
+#endif
+	ddc = of_parse_phandle(dev->of_node, "ddc-i2c-bus", 0);
+	if (ddc) {
+		panel->ddc = of_find_i2c_adapter_by_node(ddc);
+		of_node_put(ddc);
+
+		if (!panel->ddc) {
+			err = -EPROBE_DEFER;
+			goto free_backlight;
+		}
+	}
+	
+	panel->bridge_info = 0;
+	err = of_property_read_u32(np, "bridge-info", &(panel->bridge_info));
+		
+	panel->bridge_gpio = devm_gpiod_get_optional(dev, "bridge",
+						     GPIOD_OUT_HIGH);
+	if (IS_ERR(panel->bridge_gpio)) {
+		err = PTR_ERR(panel->bridge_gpio);
+		dev_err(dev, "failed to request bridge GPIO: %d\n", err);
+		return err;
+	}
+	gpiod_set_value_cansleep(panel->bridge_gpio, 1);
+		
+	bridge = of_parse_phandle(dev->of_node, "bridge-i2c-bus", 0);
+	if (bridge) {
+		panel->bridge = of_find_i2c_adapter_by_node(bridge);
+		of_node_put(bridge);
+
+		if (!panel->bridge) {
+			err = -EPROBE_DEFER;
+			goto free_backlight;
+		}
+	}
+	bridge_sn65dsi84_enable(panel);
+	#if jdebug
+	printk("johnson get bridge control and gpio control type: %d \r\n", panel->bridge_info);	
+	#endif
+	drm_panel_init(&panel->base);
+	panel->base.dev = dev;
+	panel->base.funcs = &panel_simple_funcs;
+
+	err = drm_panel_add(&panel->base);
+	if (err < 0)
+		goto free_ddc;
+
+	dev_set_drvdata(dev, panel);
+	// added by johnson to test
+	#if jdebug
+	printk("johnson set panel_simple_probe end \r\n");
+	#endif
+	// end of added
+	return 0;
+
+free_ddc:
+	if (panel->ddc)
+		put_device(&panel->ddc->dev);
+free_backlight:
+	if (panel->backlight)
+		put_device(&panel->backlight->dev);
+
+	return err;
+}
+
+static int panel_simple_remove(struct device *dev)
+{
+	struct panel_simple *panel = dev_get_drvdata(dev);
+
+	drm_panel_detach(&panel->base);
+	drm_panel_remove(&panel->base);
+
+	panel_simple_disable(&panel->base);
+	panel_simple_unprepare(&panel->base);
+
+	if (panel->ddc)
+		put_device(&panel->ddc->dev);
+
+	if (panel->backlight)
+		put_device(&panel->backlight->dev);
+
+	return 0;
+}
+
+static void panel_simple_shutdown(struct device *dev)
+{
+	struct panel_simple *panel = dev_get_drvdata(dev);
+
+	panel_simple_disable(&panel->base);
+	panel_simple_unprepare(&panel->base);
+}
+
+static const struct drm_display_mode ampire_am800480r3tmqwa1h_mode = {
+	.clock = 33333,
+	.hdisplay = 800,
+	.hsync_start = 800 + 0,
+	.hsync_end = 800 + 0 + 255,
+	.htotal = 800 + 0 + 255 + 0,
+	.vdisplay = 480,
+	.vsync_start = 480 + 2,
+	.vsync_end = 480 + 2 + 45,
+	.vtotal = 480 + 2 + 45 + 0,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,
+};
+
+static const struct panel_desc ampire_am800480r3tmqwa1h = {
+	.modes = &ampire_am800480r3tmqwa1h_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode auo_b101aw03_mode = {
+	.clock = 51450,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 156,
+	.hsync_end = 1024 + 156 + 8,
+	.htotal = 1024 + 156 + 8 + 156,
+	.vdisplay = 600,
+	.vsync_start = 600 + 16,
+	.vsync_end = 600 + 16 + 6,
+	.vtotal = 600 + 16 + 6 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b101aw03 = {
+	.modes = &auo_b101aw03_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 223,
+		.height = 125,
+	},
+};
+
+static const struct drm_display_mode auo_b101ean01_mode = {
+	.clock = 72500,
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 119,
+	.hsync_end = 1280 + 119 + 32,
+	.htotal = 1280 + 119 + 32 + 21,
+	.vdisplay = 800,
+	.vsync_start = 800 + 4,
+	.vsync_end = 800 + 4 + 20,
+	.vtotal = 800 + 4 + 20 + 8,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b101ean01 = {
+	.modes = &auo_b101ean01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 217,
+		.height = 136,
+	},
+};
+
+static const struct drm_display_mode auo_b101xtn01_mode = {
+	.clock = 72000,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 20,
+	.hsync_end = 1366 + 20 + 70,
+	.htotal = 1366 + 20 + 70,
+	.vdisplay = 768,
+	.vsync_start = 768 + 14,
+	.vsync_end = 768 + 14 + 42,
+	.vtotal = 768 + 14 + 42,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc auo_b101xtn01 = {
+	.modes = &auo_b101xtn01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 223,
+		.height = 125,
+	},
+};
+
+static const struct drm_display_mode auo_b116xw03_mode = {
+	.clock = 70589,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 40,
+	.hsync_end = 1366 + 40 + 40,
+	.htotal = 1366 + 40 + 40 + 32,
+	.vdisplay = 768,
+	.vsync_start = 768 + 10,
+	.vsync_end = 768 + 10 + 12,
+	.vtotal = 768 + 10 + 12 + 6,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b116xw03 = {
+	.modes = &auo_b116xw03_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 256,
+		.height = 144,
+	},
+};
+
+static const struct drm_display_mode auo_b133xtn01_mode = {
+	.clock = 69500,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 48,
+	.hsync_end = 1366 + 48 + 32,
+	.htotal = 1366 + 48 + 32 + 20,
+	.vdisplay = 768,
+	.vsync_start = 768 + 3,
+	.vsync_end = 768 + 3 + 6,
+	.vtotal = 768 + 3 + 6 + 13,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b133xtn01 = {
+	.modes = &auo_b133xtn01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 293,
+		.height = 165,
+	},
+};
+
+static const struct drm_display_mode auo_b133htn01_mode = {
+	.clock = 150660,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 172,
+	.hsync_end = 1920 + 172 + 80,
+	.htotal = 1920 + 172 + 80 + 60,
+	.vdisplay = 1080,
+	.vsync_start = 1080 + 25,
+	.vsync_end = 1080 + 25 + 10,
+	.vtotal = 1080 + 25 + 10 + 10,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b133htn01 = {
+	.modes = &auo_b133htn01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 293,
+		.height = 165,
+	},
+	.delay = {
+		.prepare = 105,
+		.enable = 20,
+		.unprepare = 50,
+	},
+};
+
+static const struct drm_display_mode avic_tm070ddh03_mode = {
+	.clock = 51200,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 160,
+	.hsync_end = 1024 + 160 + 4,
+	.htotal = 1024 + 160 + 4 + 156,
+	.vdisplay = 600,
+	.vsync_start = 600 + 17,
+	.vsync_end = 600 + 17 + 1,
+	.vtotal = 600 + 17 + 1 + 17,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc avic_tm070ddh03 = {
+	.modes = &avic_tm070ddh03_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 154,
+		.height = 90,
+	},
+	.delay = {
+		.prepare = 20,
+		.enable = 200,
+		.disable = 200,
+	},
+};
+
+static const struct drm_display_mode chunghwa_claa101wa01a_mode = {
+	.clock = 72070,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 58,
+	.hsync_end = 1366 + 58 + 58,
+	.htotal = 1366 + 58 + 58 + 58,
+	.vdisplay = 768,
+	.vsync_start = 768 + 4,
+	.vsync_end = 768 + 4 + 4,
+	.vtotal = 768 + 4 + 4 + 4,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc chunghwa_claa101wa01a = {
+	.modes = &chunghwa_claa101wa01a_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 220,
+		.height = 120,
+	},
+};
+
+static const struct drm_display_mode chunghwa_claa101wb01_mode = {
+	.clock = 69300,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 48,
+	.hsync_end = 1366 + 48 + 32,
+	.htotal = 1366 + 48 + 32 + 20,
+	.vdisplay = 768,
+	.vsync_start = 768 + 16,
+	.vsync_end = 768 + 16 + 8,
+	.vtotal = 768 + 16 + 8 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc chunghwa_claa101wb01 = {
+	.modes = &chunghwa_claa101wb01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 223,
+		.height = 125,
+	},
+};
+
+static const struct drm_display_mode edt_et057090dhu_mode = {
+	.clock = 25175,
+	.hdisplay = 640,
+	.hsync_start = 640 + 16,
+	.hsync_end = 640 + 16 + 30,
+	.htotal = 640 + 16 + 30 + 114,
+	.vdisplay = 480,
+	.vsync_start = 480 + 10,
+	.vsync_end = 480 + 10 + 3,
+	.vtotal = 480 + 10 + 3 + 32,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc edt_et057090dhu = {
+	.modes = &edt_et057090dhu_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 115,
+		.height = 86,
+	},
+};
+
+static const struct drm_display_mode edt_etm0700g0dh6_mode = {
+	.clock = 33260,
+	.hdisplay = 800,
+	.hsync_start = 800 + 40,
+	.hsync_end = 800 + 40 + 128,
+	.htotal = 800 + 40 + 128 + 88,
+	.vdisplay = 480,
+	.vsync_start = 480 + 10,
+	.vsync_end = 480 + 10 + 2,
+	.vtotal = 480 + 10 + 2 + 33,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc edt_etm0700g0dh6 = {
+	.modes = &edt_etm0700g0dh6_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+};
+
+static const struct drm_display_mode foxlink_fl500wvr00_a0t_mode = {
+	.clock = 32260,
+	.hdisplay = 800,
+	.hsync_start = 800 + 168,
+	.hsync_end = 800 + 168 + 64,
+	.htotal = 800 + 168 + 64 + 88,
+	.vdisplay = 480,
+	.vsync_start = 480 + 37,
+	.vsync_end = 480 + 37 + 2,
+	.vtotal = 480 + 37 + 2 + 8,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc foxlink_fl500wvr00_a0t = {
+	.modes = &foxlink_fl500wvr00_a0t_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 108,
+		.height = 65,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct drm_display_mode giantplus_gpg482739qs5_mode = {
+	.clock = 9000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 5,
+	.hsync_end = 480 + 5 + 1,
+	.htotal = 480 + 5 + 1 + 40,
+	.vdisplay = 272,
+	.vsync_start = 272 + 8,
+	.vsync_end = 272 + 8 + 1,
+	.vtotal = 272 + 8 + 1 + 8,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc giantplus_gpg482739qs5 = {
+	.modes = &giantplus_gpg482739qs5_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 95,
+		.height = 54,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct display_timing hannstar_hsd070pww1_timing = {
+	.pixelclock = { 64300000, 71100000, 82000000 },
+	.hactive = { 1280, 1280, 1280 },
+	.hfront_porch = { 1, 1, 10 },
+	.hback_porch = { 1, 1, 10 },
+	/*
+	 * According to the data sheet, the minimum horizontal blanking interval
+	 * is 54 clocks (1 + 52 + 1), but tests with a Nitrogen6X have shown the
+	 * minimum working horizontal blanking interval to be 60 clocks.
+	 */
+	.hsync_len = { 58, 158, 661 },
+	.vactive = { 800, 800, 800 },
+	.vfront_porch = { 1, 1, 10 },
+	.vback_porch = { 1, 1, 10 },
+	.vsync_len = { 1, 21, 203 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc hannstar_hsd070pww1 = {
+	.timings = &hannstar_hsd070pww1_timing,
+	.num_timings = 1,
+	.bpc = 6,
+	.size = {
+		.width = 151,
+		.height = 94,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
+};
+
+static const struct display_timing hannstar_hsd100pxn1_timing = {
+	.pixelclock = { 55000000, 65000000, 75000000 },
+	.hactive = { 1024, 1024, 1024 },
+	.hfront_porch = { 40, 40, 40 },
+	.hback_porch = { 220, 220, 220 },
+	.hsync_len = { 20, 60, 100 },
+	.vactive = { 768, 768, 768 },
+	.vfront_porch = { 7, 7, 7 },
+	.vback_porch = { 21, 21, 21 },
+	.vsync_len = { 10, 10, 10 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc hannstar_hsd100pxn1 = {
+	.timings = &hannstar_hsd100pxn1_timing,
+	.num_timings = 1,
+	.bpc = 6,
+	.size = {
+		.width = 203,
+		.height = 152,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
+};
+
+static const struct drm_display_mode hitachi_tx23d38vm0caa_mode = {
+	.clock = 33333,
+	.hdisplay = 800,
+	.hsync_start = 800 + 85,
+	.hsync_end = 800 + 85 + 86,
+	.htotal = 800 + 85 + 86 + 85,
+	.vdisplay = 480,
+	.vsync_start = 480 + 16,
+	.vsync_end = 480 + 16 + 13,
+	.vtotal = 480 + 16 + 13 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc hitachi_tx23d38vm0caa = {
+	.modes = &hitachi_tx23d38vm0caa_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 195,
+		.height = 117,
+	},
+};
+
+static const struct drm_display_mode innolux_at043tn24_mode = {
+	.clock = 9000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 2,
+	.hsync_end = 480 + 2 + 41,
+	.htotal = 480 + 2 + 41 + 2,
+	.vdisplay = 272,
+	.vsync_start = 272 + 2,
+	.vsync_end = 272 + 2 + 11,
+	.vtotal = 272 + 2 + 11 + 2,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc innolux_at043tn24 = {
+	.modes = &innolux_at043tn24_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 95,
+		.height = 54,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct drm_display_mode innolux_at070tn92_mode = {
+	.clock = 33333,
+	.hdisplay = 800,
+	.hsync_start = 800 + 210,
+	.hsync_end = 800 + 210 + 20,
+	.htotal = 800 + 210 + 20 + 46,
+	.vdisplay = 480,
+	.vsync_start = 480 + 22,
+	.vsync_end = 480 + 22 + 10,
+	.vtotal = 480 + 22 + 23 + 10,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc innolux_at070tn92 = {
+	.modes = &innolux_at070tn92_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 154,
+		.height = 86,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct display_timing innolux_g101ice_l01_timing = {
+	.pixelclock = { 60400000, 71100000, 74700000 },
+	.hactive = { 1280, 1280, 1280 },
+	.hfront_porch = { 41, 80, 100 },
+	.hback_porch = { 40, 79, 99 },
+	.hsync_len = { 1, 1, 1 },
+	.vactive = { 800, 800, 800 },
+	.vfront_porch = { 5, 11, 14 },
+	.vback_porch = { 4, 11, 14 },
+	.vsync_len = { 1, 1, 1 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc innolux_g101ice_l01 = {
+	.timings = &innolux_g101ice_l01_timing,
+	.num_timings = 1,
+	.bpc = 8,
+	.size = {
+		.width = 217,
+		.height = 135,
+	},
+	.delay = {
+		.enable = 200,
+		.disable = 200,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
+};
+
+static const struct drm_display_mode innolux_g121i1_l01_mode = {
+	.clock = 71000,
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 64,
+	.hsync_end = 1280 + 64 + 32,
+	.htotal = 1280 + 64 + 32 + 64,
+	.vdisplay = 800,
+	.vsync_start = 800 + 9,
+	.vsync_end = 800 + 9 + 6,
+	.vtotal = 800 + 9 + 6 + 9,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc innolux_g121i1_l01 = {
+	.modes = &innolux_g121i1_l01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 261,
+		.height = 163,
+	},
+};
+
+static const struct drm_display_mode innolux_g121x1_l03_mode = {
+	.clock = 65000,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 0,
+	.hsync_end = 1024 + 1,
+	.htotal = 1024 + 0 + 1 + 320,
+	.vdisplay = 768,
+	.vsync_start = 768 + 38,
+	.vsync_end = 768 + 38 + 1,
+	.vtotal = 768 + 38 + 1 + 0,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc innolux_g121x1_l03 = {
+	.modes = &innolux_g121x1_l03_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 246,
+		.height = 185,
+	},
+	.delay = {
+		.enable = 200,
+		.unprepare = 200,
+		.disable = 400,
+	},
+};
+
+static const struct drm_display_mode innolux_n116bge_mode = {
+	.clock = 76420,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 136,
+	.hsync_end = 1366 + 136 + 30,
+	.htotal = 1366 + 136 + 30 + 60,
+	.vdisplay = 768,
+	.vsync_start = 768 + 8,
+	.vsync_end = 768 + 8 + 12,
+	.vtotal = 768 + 8 + 12 + 12,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc innolux_n116bge = {
+	.modes = &innolux_n116bge_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 256,
+		.height = 144,
+	},
+};
+
+static const struct drm_display_mode innolux_n156bge_l21_mode = {
+	.clock = 69300,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 16,
+	.hsync_end = 1366 + 16 + 34,
+	.htotal = 1366 + 16 + 34 + 50,
+	.vdisplay = 768,
+	.vsync_start = 768 + 2,
+	.vsync_end = 768 + 2 + 6,
+	.vtotal = 768 + 2 + 6 + 12,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc innolux_n156bge_l21 = {
+	.modes = &innolux_n156bge_l21_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 344,
+		.height = 193,
+	},
+};
+
+static const struct drm_display_mode innolux_zj070na_01p_mode = {
+	.clock = 51501,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 128,
+	.hsync_end = 1024 + 128 + 64,
+	.htotal = 1024 + 128 + 64 + 128,
+	.vdisplay = 600,
+	.vsync_start = 600 + 16,
+	.vsync_end = 600 + 16 + 4,
+	.vtotal = 600 + 16 + 4 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc innolux_zj070na_01p = {
+	.modes = &innolux_zj070na_01p_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 154,
+		.height = 90,
+	},
+};
+
+static const struct display_timing jdi_tx26d202vm0bwa_timing = {
+	.pixelclock = { 151820000, 156720000, 159780000 },
+	.hactive = { 1920, 1920, 1920 },
+	.hfront_porch = { 76, 100, 112 },
+	.hback_porch = { 74, 100, 112 },
+	.hsync_len = { 30, 30, 30 },
+	.vactive = { 1200, 1200, 1200},
+	.vfront_porch = { 3, 5, 10 },
+	.vback_porch = { 2, 5, 10 },
+	.vsync_len = { 5, 5, 5 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc jdi_tx26d202vm0bwa = {
+	.timings = &jdi_tx26d202vm0bwa_timing,
+	.num_timings = 1,
+	.bpc = 8,
+	.size = {
+		.width = 217,
+		.height = 136,
+	},
+	.delay = {
+		/*
+		 * The panel spec recommends one second delay
+		 * to the below items.  However, it's a bit too
+		 * long in pratical.  Based on tests, it turns
+		 * out 100 milliseconds is fine.
+		 */
+		.prepare = 100,
+		.enable = 100,
+		.unprepare = 100,
+		.disable = 100,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
+};
+
+static const struct display_timing kyo_tcg121xglp_timing = {
+	.pixelclock = { 52000000, 65000000, 71000000 },
+	.hactive = { 1024, 1024, 1024 },
+	.hfront_porch = { 2, 2, 2 },
+	.hback_porch = { 2, 2, 2 },
+	.hsync_len = { 86, 124, 244 },
+	.vactive = { 768, 768, 768 },
+	.vfront_porch = { 2, 2, 2 },
+	.vback_porch = { 2, 2, 2 },
+	.vsync_len = { 6, 34, 73 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc kyo_tcg121xglp = {
+	.timings = &kyo_tcg121xglp_timing,
+	.num_timings = 1,
+	.bpc = 8,
+	.size = {
+		.width = 246,
+		.height = 184,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
+};
+
+static const struct drm_display_mode lg_lb070wv8_mode = {
+	.clock = 33246,
+	.hdisplay = 800,
+	.hsync_start = 800 + 88,
+	.hsync_end = 800 + 88 + 80,
+	.htotal = 800 + 88 + 80 + 88,
+	.vdisplay = 480,
+	.vsync_start = 480 + 10,
+	.vsync_end = 480 + 10 + 25,
+	.vtotal = 480 + 10 + 25 + 10,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc lg_lb070wv8 = {
+	.modes = &lg_lb070wv8_mode,
+	.num_modes = 1,
+	.bpc = 16,
+	.size = {
+		.width = 151,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
+};
+
+static const struct drm_display_mode lg_lp079qx1_sp0v_mode = {
+	.clock = 200000,
+	.hdisplay = 1536,
+	.hsync_start = 1536 + 12,
+	.hsync_end = 1536 + 12 + 16,
+	.htotal = 1536 + 12 + 16 + 48,
+	.vdisplay = 2048,
+	.vsync_start = 2048 + 8,
+	.vsync_end = 2048 + 8 + 4,
+	.vtotal = 2048 + 8 + 4 + 8,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc lg_lp079qx1_sp0v = {
+	.modes = &lg_lp079qx1_sp0v_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 129,
+		.height = 171,
+	},
+};
+
+static const struct drm_display_mode lg_lp097qx1_spa1_mode = {
+	.clock = 205210,
+	.hdisplay = 2048,
+	.hsync_start = 2048 + 150,
+	.hsync_end = 2048 + 150 + 5,
+	.htotal = 2048 + 150 + 5 + 5,
+	.vdisplay = 1536,
+	.vsync_start = 1536 + 3,
+	.vsync_end = 1536 + 3 + 1,
+	.vtotal = 1536 + 3 + 1 + 9,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc lg_lp097qx1_spa1 = {
+	.modes = &lg_lp097qx1_spa1_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 208,
+		.height = 147,
+	},
+};
+
+static const struct drm_display_mode lg_lp120up1_mode = {
+	.clock = 162300,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 40,
+	.hsync_end = 1920 + 40 + 40,
+	.htotal = 1920 + 40 + 40+ 80,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 4,
+	.vsync_end = 1280 + 4 + 4,
+	.vtotal = 1280 + 4 + 4 + 12,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc lg_lp120up1 = {
+	.modes = &lg_lp120up1_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 267,
+		.height = 183,
+	},
+};
+
+static const struct drm_display_mode lg_lp129qe_mode = {
+	.clock = 285250,
+	.hdisplay = 2560,
+	.hsync_start = 2560 + 48,
+	.hsync_end = 2560 + 48 + 32,
+	.htotal = 2560 + 48 + 32 + 80,
+	.vdisplay = 1700,
+	.vsync_start = 1700 + 3,
+	.vsync_end = 1700 + 3 + 10,
+	.vtotal = 1700 + 3 + 10 + 36,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc lg_lp129qe = {
+	.modes = &lg_lp129qe_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 272,
+		.height = 181,
+	},
+};
+
+static const struct drm_display_mode nec_nl4827hc19_05b_mode = {
+	.clock = 10870,
+	.hdisplay = 480,
+	.hsync_start = 480 + 2,
+	.hsync_end = 480 + 2 + 41,
+	.htotal = 480 + 2 + 41 + 2,
+	.vdisplay = 272,
+	.vsync_start = 272 + 2,
+	.vsync_end = 272 + 2 + 4,
+	.vtotal = 272 + 2 + 4 + 2,
+	.vrefresh = 74,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc nec_nl4827hc19_05b = {
+	.modes = &nec_nl4827hc19_05b_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 95,
+		.height = 54,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+	.bus_flags = DRM_BUS_FLAG_PIXDATA_POSEDGE,
+};
+
+static const struct display_timing okaya_rs800480t_7x0gp_timing = {
+	.pixelclock = { 30000000, 30000000, 40000000 },
+	.hactive = { 800, 800, 800 },
+	.hfront_porch = { 40, 40, 40 },
+	.hback_porch = { 40, 40, 40 },
+	.hsync_len = { 1, 48, 48 },
+	.vactive = { 480, 480, 480 },
+	.vfront_porch = { 13, 13, 13 },
+	.vback_porch = { 29, 29, 29 },
+	.vsync_len = { 3, 3, 3 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc okaya_rs800480t_7x0gp = {
+	.timings = &okaya_rs800480t_7x0gp_timing,
+	.num_timings = 1,
+	.bpc = 6,
+	.size = {
+		.width = 154,
+		.height = 87,
+	},
+	.delay = {
+		.prepare = 41,
+		.enable = 50,
+		.unprepare = 41,
+		.disable = 50,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode olimex_lcd_olinuxino_43ts_mode = {
+	.clock = 9000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 5,
+	.hsync_end = 480 + 5 + 30,
+	.htotal = 480 + 5 + 30 + 10,
+	.vdisplay = 272,
+	.vsync_start = 272 + 8,
+	.vsync_end = 272 + 8 + 5,
+	.vtotal = 272 + 8 + 5 + 3,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc olimex_lcd_olinuxino_43ts = {
+	.modes = &olimex_lcd_olinuxino_43ts_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 105,
+		.height = 67,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+/*
+ * 800x480 CVT. The panel appears to be quite accepting, at least as far as
+ * pixel clocks, but this is the timing that was being used in the Adafruit
+ * installation instructions.
+ */
+static const struct drm_display_mode ontat_yx700wv03_mode = {
+	.clock = 29500,
+	.hdisplay = 800,
+	.hsync_start = 824,
+	.hsync_end = 896,
+	.htotal = 992,
+	.vdisplay = 480,
+	.vsync_start = 483,
+	.vsync_end = 493,
+	.vtotal = 500,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+/*
+ * Specification at:
+ * https://www.adafruit.com/images/product-files/2406/c3163.pdf
+ */
+static const struct panel_desc ontat_yx700wv03 = {
+	.modes = &ontat_yx700wv03_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 154,
+		.height = 83,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct drm_display_mode ortustech_com43h4m85ulc_mode  = {
+	.clock = 25000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 10,
+	.hsync_end = 480 + 10 + 10,
+	.htotal = 480 + 10 + 10 + 15,
+	.vdisplay = 800,
+	.vsync_start = 800 + 3,
+	.vsync_end = 800 + 3 + 3,
+	.vtotal = 800 + 3 + 3 + 3,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc ortustech_com43h4m85ulc = {
+	.modes = &ortustech_com43h4m85ulc_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 56,
+		.height = 93,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_POSEDGE,
+};
+
+static const struct drm_display_mode qd43003c0_40_mode = {
+	.clock = 9000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 8,
+	.hsync_end = 480 + 8 + 4,
+	.htotal = 480 + 8 + 4 + 39,
+	.vdisplay = 272,
+	.vsync_start = 272 + 4,
+	.vsync_end = 272 + 4 + 10,
+	.vtotal = 272 + 4 + 10 + 2,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc qd43003c0_40 = {
+	.modes = &qd43003c0_40_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 95,
+		.height = 53,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct drm_display_mode samsung_lsn122dl01_c01_mode = {
+	.clock = 271560,
+	.hdisplay = 2560,
+	.hsync_start = 2560 + 48,
+	.hsync_end = 2560 + 48 + 32,
+	.htotal = 2560 + 48 + 32 + 80,
+	.vdisplay = 1600,
+	.vsync_start = 1600 + 2,
+	.vsync_end = 1600 + 2 + 5,
+	.vtotal = 1600 + 2 + 5 + 57,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc samsung_lsn122dl01_c01 = {
+	.modes = &samsung_lsn122dl01_c01_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 263,
+		.height = 164,
+	},
+};
+
+static const struct drm_display_mode samsung_ltn101nt05_mode = {
+	.clock = 54030,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 24,
+	.hsync_end = 1024 + 24 + 136,
+	.htotal = 1024 + 24 + 136 + 160,
+	.vdisplay = 600,
+	.vsync_start = 600 + 3,
+	.vsync_end = 600 + 3 + 6,
+	.vtotal = 600 + 3 + 6 + 61,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc samsung_ltn101nt05 = {
+	.modes = &samsung_ltn101nt05_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 223,
+		.height = 125,
+	},
+};
+
+static const struct drm_display_mode samsung_ltn140at29_301_mode = {
+	.clock = 76300,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 64,
+	.hsync_end = 1366 + 64 + 48,
+	.htotal = 1366 + 64 + 48 + 128,
+	.vdisplay = 768,
+	.vsync_start = 768 + 2,
+	.vsync_end = 768 + 2 + 5,
+	.vtotal = 768 + 2 + 5 + 17,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc samsung_ltn140at29_301 = {
+	.modes = &samsung_ltn140at29_301_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 320,
+		.height = 187,
+	},
+};
+
+static const struct display_timing sharp_lq101k1ly04_timing = {
+	.pixelclock = { 60000000, 65000000, 80000000 },
+	.hactive = { 1280, 1280, 1280 },
+	.hfront_porch = { 20, 20, 20 },
+	.hback_porch = { 20, 20, 20 },
+	.hsync_len = { 10, 10, 10 },
+	.vactive = { 800, 800, 800 },
+	.vfront_porch = { 4, 4, 4 },
+	.vback_porch = { 4, 4, 4 },
+	.vsync_len = { 4, 4, 4 },
+	.flags = DISPLAY_FLAGS_PIXDATA_POSEDGE,
+};
+
+static const struct panel_desc sharp_lq101k1ly04 = {
+	.timings = &sharp_lq101k1ly04_timing,
+	.num_timings = 1,
+	.bpc = 8,
+	.size = {
+		.width = 217,
+		.height = 136,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA,
+};
+
+static const struct drm_display_mode sharp_lq123p1jx31_mode = {
+	.clock = 252750,
+	.hdisplay = 2400,
+	.hsync_start = 2400 + 48,
+	.hsync_end = 2400 + 48 + 32,
+	.htotal = 2400 + 48 + 32 + 80,
+	.vdisplay = 1600,
+	.vsync_start = 1600 + 3,
+	.vsync_end = 1600 + 3 + 10,
+	.vtotal = 1600 + 3 + 10 + 33,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc sharp_lq123p1jx31 = {
+	.modes = &sharp_lq123p1jx31_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 259,
+		.height = 173,
+	},
+	.delay = {
+		.prepare = 110,
+		.enable = 50,
+		.unprepare = 550,
+	},
+};
+
+static const struct drm_display_mode shelly_sca07010_bfn_lnn_mode = {
+	.clock = 33300,
+	.hdisplay = 800,
+	.hsync_start = 800 + 1,
+	.hsync_end = 800 + 1 + 64,
+	.htotal = 800 + 1 + 64 + 64,
+	.vdisplay = 480,
+	.vsync_start = 480 + 1,
+	.vsync_end = 480 + 1 + 23,
+	.vtotal = 480 + 1 + 23 + 22,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc shelly_sca07010_bfn_lnn = {
+	.modes = &shelly_sca07010_bfn_lnn_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode starry_kr122ea0sra_mode = {
+	.clock = 147000,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 16,
+	.hsync_end = 1920 + 16 + 16,
+	.htotal = 1920 + 16 + 16 + 32,
+	.vdisplay = 1200,
+	.vsync_start = 1200 + 15,
+	.vsync_end = 1200 + 15 + 2,
+	.vtotal = 1200 + 15 + 2 + 18,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc starry_kr122ea0sra = {
+	.modes = &starry_kr122ea0sra_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 263,
+		.height = 164,
+	},
+	.delay = {
+		.prepare = 10 + 200,
+		.enable = 50,
+		.unprepare = 10 + 500,
+	},
+};
+
+static const struct drm_display_mode tpk_f07a_0102_mode = {
+	.clock = 33260,
+	.hdisplay = 800,
+	.hsync_start = 800 + 40,
+	.hsync_end = 800 + 40 + 128,
+	.htotal = 800 + 40 + 128 + 88,
+	.vdisplay = 480,
+	.vsync_start = 480 + 10,
+	.vsync_end = 480 + 10 + 2,
+	.vtotal = 480 + 10 + 2 + 33,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc tpk_f07a_0102 = {
+	.modes = &tpk_f07a_0102_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+	.bus_flags = DRM_BUS_FLAG_PIXDATA_POSEDGE,
+};
+
+static const struct drm_display_mode tpk_f10a_0102_mode = {
+	.clock = 45000,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 176,
+	.hsync_end = 1024 + 176 + 5,
+	.htotal = 1024 + 176 + 5 + 88,
+	.vdisplay = 600,
+	.vsync_start = 600 + 20,
+	.vsync_end = 600 + 20 + 5,
+	.vtotal = 600 + 20 + 5 + 25,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc tpk_f10a_0102 = {
+	.modes = &tpk_f10a_0102_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 223,
+		.height = 125,
+	},
+};
+
+static const struct display_timing urt_umsh_8596md_timing = {
+	.pixelclock = { 33260000, 33260000, 33260000 },
+	.hactive = { 800, 800, 800 },
+	.hfront_porch = { 41, 41, 41 },
+	.hback_porch = { 216 - 128, 216 - 128, 216 - 128 },
+	.hsync_len = { 71, 128, 128 },
+	.vactive = { 480, 480, 480 },
+	.vfront_porch = { 10, 10, 10 },
+	.vback_porch = { 35 - 2, 35 - 2, 35 - 2 },
+	.vsync_len = { 2, 2, 2 },
+	.flags = DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_PIXDATA_NEGEDGE |
+		DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
+};
+
+static const struct panel_desc urt_umsh_8596md_lvds = {
+	.timings = &urt_umsh_8596md_timing,
+	.num_timings = 1,
+	.bpc = 6,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
+};
+
+static const struct panel_desc urt_umsh_8596md_parallel = {
+	.timings = &urt_umsh_8596md_timing,
+	.num_timings = 1,
+	.bpc = 6,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct of_device_id platform_of_match[] = {
+	{
+		.compatible = "ampire,am800480r3tmqwa1h",
+		.data = &ampire_am800480r3tmqwa1h,
+	}, {
+		.compatible = "auo,b101aw03",
+		.data = &auo_b101aw03,
+	}, {
+		.compatible = "auo,b101ean01",
+		.data = &auo_b101ean01,
+	}, {
+		.compatible = "auo,b101xtn01",
+		.data = &auo_b101xtn01,
+	}, {
+		.compatible = "auo,b116xw03",
+		.data = &auo_b116xw03,
+	}, {
+		.compatible = "auo,b133htn01",
+		.data = &auo_b133htn01,
+	}, {
+		.compatible = "auo,b133xtn01",
+		.data = &auo_b133xtn01,
+	}, {
+		.compatible = "avic,tm070ddh03",
+		.data = &avic_tm070ddh03,
+	}, {
+		.compatible = "chunghwa,claa101wa01a",
+		.data = &chunghwa_claa101wa01a
+	}, {
+		.compatible = "chunghwa,claa101wb01",
+		.data = &chunghwa_claa101wb01
+	}, {
+		.compatible = "edt,et057090dhu",
+		.data = &edt_et057090dhu,
+	}, {
+		.compatible = "edt,et070080dh6",
+		.data = &edt_etm0700g0dh6,
+	}, {
+		.compatible = "edt,etm0700g0dh6",
+		.data = &edt_etm0700g0dh6,
+	}, {
+		.compatible = "foxlink,fl500wvr00-a0t",
+		.data = &foxlink_fl500wvr00_a0t,
+	}, {
+		.compatible = "giantplus,gpg482739qs5",
+		.data = &giantplus_gpg482739qs5
+	}, {
+		.compatible = "hannstar,hsd070pww1",
+		.data = &hannstar_hsd070pww1,
+	}, {
+		.compatible = "hannstar,hsd100pxn1",
+		.data = &hannstar_hsd100pxn1,
+	}, {
+		.compatible = "hit,tx23d38vm0caa",
+		.data = &hitachi_tx23d38vm0caa
+	}, {
+		.compatible = "innolux,at043tn24",
+		.data = &innolux_at043tn24,
+	}, {
+		.compatible = "innolux,at070tn92",
+		.data = &innolux_at070tn92,
+	}, {
+		.compatible ="innolux,g101ice-l01",
+		.data = &innolux_g101ice_l01
+	}, {
+		.compatible ="innolux,g121i1-l01",
+		.data = &innolux_g121i1_l01
+	}, {
+		.compatible = "innolux,g121x1-l03",
+		.data = &innolux_g121x1_l03,
+	}, {
+		.compatible = "innolux,n116bge",
+		.data = &innolux_n116bge,
+	}, {
+		.compatible = "innolux,n156bge-l21",
+		.data = &innolux_n156bge_l21,
+	}, {
+		.compatible = "innolux,zj070na-01p",
+		.data = &innolux_zj070na_01p,
+	}, {
+		.compatible = "jdi,tx26d202vm0bwa",
+		.data = &jdi_tx26d202vm0bwa,
+	}, {
+		.compatible = "kyo,tcg121xglp",
+		.data = &kyo_tcg121xglp,
+	}, {
+		.compatible = "lg,lb070wv8",
+		.data = &lg_lb070wv8,
+	}, {
+		.compatible = "lg,lp079qx1-sp0v",
+		.data = &lg_lp079qx1_sp0v,
+	}, {
+		.compatible = "lg,lp097qx1-spa1",
+		.data = &lg_lp097qx1_spa1,
+	}, {
+		.compatible = "lg,lp120up1",
+		.data = &lg_lp120up1,
+	}, {
+		.compatible = "lg,lp129qe",
+		.data = &lg_lp129qe,
+	}, {
+		.compatible = "nec,nl4827hc19-05b",
+		.data = &nec_nl4827hc19_05b,
+	}, {
+		.compatible = "okaya,rs800480t-7x0gp",
+		.data = &okaya_rs800480t_7x0gp,
+	}, {
+		.compatible = "olimex,lcd-olinuxino-43-ts",
+		.data = &olimex_lcd_olinuxino_43ts,
+	}, {
+		.compatible = "ontat,yx700wv03",
+		.data = &ontat_yx700wv03,
+	}, {
+		.compatible = "ortustech,com43h4m85ulc",
+		.data = &ortustech_com43h4m85ulc,
+	}, {
+		.compatible = "qiaodian,qd43003c0-40",
+		.data = &qd43003c0_40,
+	}, {
+		.compatible = "samsung,lsn122dl01-c01",
+		.data = &samsung_lsn122dl01_c01,
+	}, {
+		.compatible = "samsung,ltn101nt05",
+		.data = &samsung_ltn101nt05,
+	}, {
+		.compatible = "samsung,ltn140at29-301",
+		.data = &samsung_ltn140at29_301,
+	}, {
+		.compatible = "sharp,lq101k1ly04",
+		.data = &sharp_lq101k1ly04,
+	}, {
+		.compatible = "sharp,lq123p1jx31",
+		.data = &sharp_lq123p1jx31,
+	}, {
+		.compatible = "shelly,sca07010-bfn-lnn",
+		.data = &shelly_sca07010_bfn_lnn,
+	}, {
+		.compatible = "starry,kr122ea0sra",
+		.data = &starry_kr122ea0sra,
+	}, {
+		.compatible = "tpk,f07a-0102",
+		.data = &tpk_f07a_0102,
+	}, {
+		.compatible = "tpk,f10a-0102",
+		.data = &tpk_f10a_0102,
+	}, {
+		.compatible = "urt,umsh-8596md-t",
+		.data = &urt_umsh_8596md_parallel,
+	}, {
+		.compatible = "urt,umsh-8596md-1t",
+		.data = &urt_umsh_8596md_parallel,
+	}, {
+		.compatible = "urt,umsh-8596md-7t",
+		.data = &urt_umsh_8596md_parallel,
+	}, {
+		.compatible = "urt,umsh-8596md-11t",
+		.data = &urt_umsh_8596md_lvds,
+	}, {
+		.compatible = "urt,umsh-8596md-19t",
+		.data = &urt_umsh_8596md_lvds,
+	}, {
+		.compatible = "urt,umsh-8596md-20t",
+		.data = &urt_umsh_8596md_parallel,
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, platform_of_match);
+
+static int panel_simple_platform_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *id;
+	
+	// added by johnson to test
+	#if jdebug
+	printk("johnson set panel_simple_platform_probe start \r\n");
+	#endif
+	// end of added
+
+	id = of_match_node(platform_of_match, pdev->dev.of_node);
+	if (!id)
+		return -ENODEV;
+
+	return panel_simple_probe(&pdev->dev, id->data);
+}
+
+static int panel_simple_platform_remove(struct platform_device *pdev)
+{
+	return panel_simple_remove(&pdev->dev);
+}
+
+static void panel_simple_platform_shutdown(struct platform_device *pdev)
+{
+	panel_simple_shutdown(&pdev->dev);
+}
+
+static struct platform_driver panel_simple_platform_driver = {
+	.driver = {
+		.name = "panel-simple",
+		.of_match_table = platform_of_match,
+	},
+	.probe = panel_simple_platform_probe,
+	.remove = panel_simple_platform_remove,
+	.shutdown = panel_simple_platform_shutdown,
+};
+
+struct panel_desc_dsi {
+	struct panel_desc desc;
+
+	unsigned long flags;
+	enum mipi_dsi_pixel_format format;
+	unsigned int lanes;
+};
+
+static const struct drm_display_mode auo_b080uan01_mode = {
+	.clock = 154500,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 62,
+	.hsync_end = 1200 + 62 + 4,
+	.htotal = 1200 + 62 + 4 + 62,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 9,
+	.vsync_end = 1920 + 9 + 2,
+	.vtotal = 1920 + 9 + 2 + 8,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc_dsi auo_b080uan01 = {
+	.desc = {
+		.modes = &auo_b080uan01_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 108,
+			.height = 272,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode boe_tv080wum_nl0_mode = {
+	.clock = 160000,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 120,
+	.hsync_end = 1200 + 120 + 20,
+	.htotal = 1200 + 120 + 20 + 21,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 21,
+	.vsync_end = 1920 + 21 + 3,
+	.vtotal = 1920 + 21 + 3 + 18,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc_dsi boe_tv080wum_nl0 = {
+	.desc = {
+		.modes = &boe_tv080wum_nl0_mode,
+		.num_modes = 1,
+		.size = {
+			.width = 107,
+			.height = 172,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO |
+		 MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode lg_ld070wx3_sl01_mode = {
+	.clock = 71000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 32,
+	.hsync_end = 800 + 32 + 1,
+	.htotal = 800 + 32 + 1 + 57,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 28,
+	.vsync_end = 1280 + 28 + 1,
+	.vtotal = 1280 + 28 + 1 + 14,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc_dsi lg_ld070wx3_sl01 = {
+	.desc = {
+		.modes = &lg_ld070wx3_sl01_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 94,
+			.height = 151,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode lg_lh500wx1_sd03_mode = {
+	.clock = 67000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 12,
+	.hsync_end = 720 + 12 + 4,
+	.htotal = 720 + 12 + 4 + 112,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 8,
+	.vsync_end = 1280 + 8 + 4,
+	.vtotal = 1280 + 8 + 4 + 12,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc_dsi lg_lh500wx1_sd03 = {
+	.desc = {
+		.modes = &lg_lh500wx1_sd03_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 62,
+			.height = 110,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode panasonic_vvx10f004b00_mode = {
+	.clock = 157200,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 154,
+	.hsync_end = 1920 + 154 + 16,
+	.htotal = 1920 + 154 + 16 + 32,
+	.vdisplay = 1200,
+	.vsync_start = 1200 + 17,
+	.vsync_end = 1200 + 17 + 2,
+	.vtotal = 1200 + 17 + 2 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc_dsi panasonic_vvx10f004b00 = {
+	.desc = {
+		.modes = &panasonic_vvx10f004b00_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 217,
+			.height = 136,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+		 MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode sgd_gktw70sdae4sd_mode = {
+	.clock = 29250,
+	.hdisplay = 800,
+	.hsync_start = 800 + 40,
+	.hsync_end = 800 + 40 + 48,
+	.htotal = 800 + 40 + 48 + 40,
+	.vdisplay = 480,
+	.vsync_start = 480 + 23,
+	.vsync_end = 480 + 23 + 3,
+	.vtotal = 480 + 23 + 3 + 39,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc_dsi sgd_gktw70sdae4sd = {
+	.desc = {
+		.modes = &sgd_gktw70sdae4sd_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 154,
+			.height = 87,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_LOW,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+#if useTiming
+static const struct display_timing auo_g185xw01_timing = {
+	.pixelclock = { 78000000, 78000000, 78000000 },
+	.hactive = { 1360, 1360, 1360 },
+	
+	.hfront_porch = { 60, 60, 60 },
+	.hback_porch = { 60, 60, 60 },	
+	.hsync_len = { 120, 120, 120 },
+	
+	.vactive = { 768, 768, 768 },
+	.vfront_porch = { 10, 10, 10 },
+	.vback_porch = { 10, 10, 10 },
+	.vsync_len = { 20, 20, 20 },
+	.flags = DISPLAY_FLAGS_HSYNC_LOW |
+		 DISPLAY_FLAGS_VSYNC_LOW |
+		 DISPLAY_FLAGS_DE_LOW |
+		 DISPLAY_FLAGS_PIXDATA_NEGEDGE,
+};
+#else
+static const struct drm_display_mode auo_g185xw01_mode = {
+	.clock = 78000,
+	.hdisplay = 1360,
+	.hsync_start = 1360 + 120,
+	.hsync_end = 1360 + 120 + 60,
+	.htotal = 1360 + 120 + 60 + 60,
+	.vdisplay = 768,
+	.vsync_start = 768 + 20,
+	.vsync_end = 768 + 20 + 10,
+	.vtotal = 768 + 20 + 10 + 10,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+#endif
+
+static const struct panel_desc_dsi auo_g185xw01 = {
+	.desc = {
+	#if useTiming
+		.num_modes = 0,
+		.timings = &auo_g185xw01_timing,
+		.num_timings = 1,
+		.bpc = 8,
+		.size = {
+			.width = 409,
+			.height = 230,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_LOW | DRM_BUS_FLAG_PIXDATA_NEGEDGE,
+	#else
+		.modes = &auo_g185xw01_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 409,
+			.height = 230,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_LOW,
+	#endif
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	//.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode hydis_hv150ux2_mode = {
+	.clock = 81000,
+	.hdisplay = 1600,
+	.hsync_start = 1600 + 360,
+	.hsync_end = 1600 + 360 + 100,
+	.htotal = 1600 + 360 + 100 + 100,
+	.vdisplay = 1200,
+	.vsync_start = 1200 + 30,
+	.vsync_end = 1200 + 30 + 10,
+	.vtotal = 1200 + 30 + 10 + 10,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc_dsi hydis_hv150ux2 = {
+	.desc = {
+		.modes = &hydis_hv150ux2_mode,
+		.num_modes = 1,
+		.bpc = 6,
+		.size = {
+			.width = 305,
+			.height = 229,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_HIGH,
+	},
+	//.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB666,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode lg_lm215wf3_mode = {
+	.clock = 72000,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 156,
+	.hsync_end = 1920 + 156 + 50,
+	.htotal = 1920 + 156 + 50 + 50,
+	.vdisplay = 1080,
+	.vsync_start = 1080 + 8,
+	.vsync_end = 1080 + 8 + 6,
+	.vtotal = 1080 + 8 + 6 + 6,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc_dsi lg_lm215wf3 = {
+	.desc = {
+		.modes = &lg_lm215wf3_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 475,
+			.height = 267,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_HIGH,
+	},
+	//.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+#if useTiming
+static const struct display_timing inno_n101bge_timing = {
+	// 1360x768
+	.pixelclock = { 78000000, 78000000, 78000000 },
+	.hactive = { 1360, 1360, 1360 },
+	
+	.hfront_porch = { 60, 60, 60 },
+	.hback_porch = { 60, 60, 60 },	
+	.hsync_len = { 120, 120, 120 },
+	
+	.vactive = { 768, 768, 768 },
+	.vfront_porch = { 10, 10, 10 },
+	.vback_porch = { 10, 10, 10 },
+	.vsync_len = { 20, 20, 20 },
+	.flags = DISPLAY_FLAGS_HSYNC_LOW |
+		 DISPLAY_FLAGS_VSYNC_LOW |
+		 DISPLAY_FLAGS_DE_LOW |
+		 DISPLAY_FLAGS_PIXDATA_NEGEDGE,
+};
+#else
+static const struct drm_display_mode inno_n101bge_mode = {
+	.clock = 78000,
+	.hdisplay = 1360,
+	.hsync_start = 1360 + 126,
+	.hsync_end = 1360 + 126 + 50,
+	.htotal = 1360 + 126 + 50 + 50,
+	.vdisplay = 768,
+	.vsync_start = 768 + 12,
+	.vsync_end = 768 + 12 + 10,
+	.vtotal = 768 + 12 + 10 + 10,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+#endif
+
+static const struct panel_desc_dsi inno_n101bge = {
+	.desc = {
+	#if useTiming
+		.num_modes = 0,
+		.timings = &inno_n101bge_timing,
+		.num_timings = 1,
+		.bpc = 8,
+		.size = {
+			.width = 223,
+			.height = 126,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_LOW,
+	#else
+		.modes = &inno_n101bge_mode,
+		.num_modes = 1,
+		.bpc = 6,
+		.size = {
+			.width = 223,
+			.height = 126,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_LOW,
+	#endif
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	//.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB666,
+	.lanes = 4,
+};
+
+#if useTiming
+static const struct display_timing inno_g104x1l03_timing = {
+	.pixelclock = { 65000000, 65000000, 65000000 },
+	.hactive = { 1024, 1024, 1024 },
+	.hfront_porch = { 100, 100, 100 },
+	.hback_porch = { 100, 100, 100 },
+	.hsync_len = { 120, 120, 120 },
+	.vactive = { 768, 768, 768 },
+	.vfront_porch = { 10, 10, 10 },
+	.vback_porch = { 10, 10, 10 },
+	.vsync_len = { 18, 18, 18 },
+	.flags = DISPLAY_FLAGS_HSYNC_LOW |
+		 DISPLAY_FLAGS_VSYNC_LOW |
+		 DISPLAY_FLAGS_DE_HIGH |
+		 DISPLAY_FLAGS_PIXDATA_NEGEDGE,
+};
+#else
+static const struct drm_display_mode inno_g104x1l03_mode = {
+	.clock = 65000,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 120,
+	.hsync_end = 1024 + 120 + 100,
+	.htotal = 1024 + 120 + 100 + 100,
+	.vdisplay = 768,
+	.vsync_start = 768 + 18,
+	.vsync_end = 768 + 18 + 10,
+	.vtotal = 768 + 18 + 10 + 10,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+#endif
+
+
+static const struct panel_desc_dsi inno_g104x1l03 = {
+	.desc = {
+	#if useTiming
+		.num_modes = 0,
+		.timings = &inno_g104x1l03_timing,
+		.num_timings = 1,
+		.bpc = 8,
+		.size = {
+			.width = 210,
+			.height = 158,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_LOW,
+	#else
+		.modes = &inno_g104x1l03_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 210,
+			.height = 158,
+		},	
+		.bus_flags = DRM_BUS_FLAG_DE_LOW,
+	#endif
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	// MIPI_DSI_MODE_LPM
+	//.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct of_device_id dsi_of_match[] = {
+	{
+		.compatible = "auo,b080uan01",
+		.data = &auo_b080uan01
+	}, {
+		.compatible = "boe,tv080wum-nl0",
+		.data = &boe_tv080wum_nl0
+	}, {
+		.compatible = "lg,ld070wx3-sl01",
+		.data = &lg_ld070wx3_sl01
+	}, {
+		.compatible = "lg,lh500wx1-sd03",
+		.data = &lg_lh500wx1_sd03
+	}, {
+		.compatible = "panasonic,vvx10f004b00",
+		.data = &panasonic_vvx10f004b00
+	}, {
+		.compatible = "sgd,gktw70sdae4sd",
+		.data = &sgd_gktw70sdae4sd
+	}, {
+		.compatible = "auo,g185xw01",
+		.data = &auo_g185xw01
+	}, {
+		.compatible = "hydis,hv150ux2",
+		.data = &hydis_hv150ux2
+	}, {
+		.compatible = "inno,n101bge",
+		.data = &inno_n101bge
+	}, {
+		.compatible = "lg,lm215wf3",
+		.data = &lg_lm215wf3
+	}, {
+		.compatible = "inno,g104x1l03",
+		.data = &inno_g104x1l03
+	}
+	, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, dsi_of_match);
+
+static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	const struct panel_desc_dsi *desc;
+	const struct of_device_id *id;
+	int err;
+	// added by johnson to test	;
+	#if jdebug
+	printk("johnson panel_simple_dsi_probe \r\n");
+	#endif
+	// end of added
+	id = of_match_node(dsi_of_match, dsi->dev.of_node);
+	if (!id)
+		return -ENODEV;
+
+	desc = id->data;
+
+	err = panel_simple_probe(&dsi->dev, &desc->desc);
+	if (err < 0)
+		return err;
+
+	dsi->mode_flags = desc->flags;
+	dsi->format = desc->format;
+	dsi->lanes = desc->lanes;
+
+	return mipi_dsi_attach(dsi);
+}
+
+static int panel_simple_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	int err;
+
+	err = mipi_dsi_detach(dsi);
+	if (err < 0)
+		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", err);
+
+	return panel_simple_remove(&dsi->dev);
+}
+
+static void panel_simple_dsi_shutdown(struct mipi_dsi_device *dsi)
+{
+	panel_simple_shutdown(&dsi->dev);
+}
+
+static struct mipi_dsi_driver panel_simple_dsi_driver = {
+	.driver = {
+		.name = "panel-simple-dsi",
+		.of_match_table = dsi_of_match,
+	},
+	.probe = panel_simple_dsi_probe,
+	.remove = panel_simple_dsi_remove,
+	.shutdown = panel_simple_dsi_shutdown,
+};
+
+static int __init panel_simple_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&panel_simple_platform_driver);
+	if (err < 0)
+		return err;
+
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {
+		err = mipi_dsi_driver_register(&panel_simple_dsi_driver);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+module_init(panel_simple_init);
+
+static void __exit panel_simple_exit(void)
+{
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+		mipi_dsi_driver_unregister(&panel_simple_dsi_driver);
+
+	platform_driver_unregister(&panel_simple_platform_driver);
+}
+module_exit(panel_simple_exit);
+
+MODULE_AUTHOR("Thierry Reding <treding@nvidia.com>");
+MODULE_DESCRIPTION("DRM Driver for Simple Panels");
+MODULE_LICENSE("GPL and additional rights");
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index a764230..91cbc0f 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -2368,6 +2368,160 @@ static const struct panel_desc_dsi panasonic_vvx10f004b00 = {
 	.lanes = 4,
 };
 
+static const struct drm_display_mode sgd_gktw70sdae4sd_mode = {
+	.clock = 29250,
+	.hdisplay = 800,
+	.hsync_start = 800 + 40,
+	.hsync_end = 800 + 40 + 48,
+	.htotal = 800 + 40 + 48 + 40,
+	.vdisplay = 480,
+	.vsync_start = 480 + 23,
+	.vsync_end = 480 + 23 + 3,
+	.vtotal = 480 + 23 + 3 + 39,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc_dsi sgd_gktw70sdae4sd = {
+	.desc = {
+		.modes = &sgd_gktw70sdae4sd_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 154,
+			.height = 87,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_LOW,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode auo_g185xw01_mode = {
+	.clock = 78000,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 120,
+	.hsync_end = 1366 + 120 + 60,
+	.htotal = 1366 + 120 + 60 + 60,
+	.vdisplay = 768,
+	.vsync_start = 768 + 20,
+	.vsync_end = 768 + 20 + 10,
+	.vtotal = 768 + 20 + 10 + 10,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc_dsi auo_g185xw01 = {
+	.desc = {
+		.modes = &auo_g185xw01_mode,
+		.num_modes = 1,
+		.bpc = 6,
+		.size = {
+			.width = 409,
+			.height = 230,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_HIGH,
+	},
+	//.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB666,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode hydis_hv150ux2_mode = {
+	.clock = 81000,
+	.hdisplay = 1600,
+	.hsync_start = 1600 + 360,
+	.hsync_end = 1600 + 360 + 100,
+	.htotal = 1600 + 360 + 100 + 100,
+	.vdisplay = 1200,
+	.vsync_start = 1200 + 30,
+	.vsync_end = 1200 + 30 + 10,
+	.vtotal = 1200 + 30 + 10 + 10,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc_dsi hydis_hv150ux2 = {
+	.desc = {
+		.modes = &hydis_hv150ux2_mode,
+		.num_modes = 1,
+		.bpc = 6,
+		.size = {
+			.width = 305,
+			.height = 229,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_HIGH,
+	},
+	//.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB666,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode inno_n101bge_mode = {
+	.clock = 76420,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 126,
+	.hsync_end = 1366 + 126 + 50,
+	.htotal = 1366 + 126 + 50 + 50,
+	.vdisplay = 768,
+	.vsync_start = 768 + 12,
+	.vsync_end = 768 + 12 + 10,
+	.vtotal = 768 + 12 + 10 + 10,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc_dsi inno_n101bge = {
+	.desc = {
+		.modes = &inno_n101bge_mode,
+		.num_modes = 1,
+		.bpc = 6,
+		.size = {
+			.width = 223,
+			.height = 126,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_HIGH,
+	},
+	//.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB666,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode lg_lm215wf3_mode = {
+	.clock = 72000,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 156,
+	.hsync_end = 1920 + 156 + 50,
+	.htotal = 1920 + 156 + 50 + 50,
+	.vdisplay = 1080,
+	.vsync_start = 1080 + 8,
+	.vsync_end = 1080 + 8 + 6,
+	.vtotal = 1080 + 8 + 6 + 6,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc_dsi lg_lm215wf3 = {
+	.desc = {
+		.modes = &lg_lm215wf3_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 475,
+			.height = 267,
+		},
+		.bus_flags = DRM_BUS_FLAG_DE_HIGH,
+	},
+	//.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
 static const struct of_device_id dsi_of_match[] = {
 	{
 		.compatible = "auo,b080uan01",
@@ -2385,6 +2539,22 @@ static const struct of_device_id dsi_of_match[] = {
 		.compatible = "panasonic,vvx10f004b00",
 		.data = &panasonic_vvx10f004b00
 	}, {
+		.compatible = "sgd,gktw70sdae4sd",
+		.data = &sgd_gktw70sdae4sd
+	}, {
+		.compatible = "auo,g185xw01",
+		.data = &auo_g185xw01
+	}, {
+		.compatible = "hydis,hv150ux2",
+		.data = &hydis_hv150ux2
+	}, {
+		.compatible = "inno,n101bge",
+		.data = &inno_n101bge
+	}, {
+		.compatible = "lg,lm215wf3",
+		.data = &lg_lm215wf3
+	}
+	, {
 		/* sentinel */
 	}
 };
-- 
2.7.4

