From 8adfaa65655409d8a9defd5a2f6b1808d6e241d3 Mon Sep 17 00:00:00 2001
From: "arun.tamilselvan" <arun.tamilselvan@adlinktech.com>
Date: Fri, 28 Mar 2025 15:27:48 +0530
Subject: [PATCH] Added mipi_csis camera support

---
 drivers/staging/media/imx/imx8-isi-cap.c      | 42 +++++++++++++++++--
 drivers/staging/media/imx/imx8-isi-fmt.c      | 22 +++++++++-
 drivers/staging/media/imx/imx8-isi-hw.c       |  4 ++
 .../staging/media/imx/imx8-mipi-csi2-sam.c    | 13 ++++++
 4 files changed, 76 insertions(+), 5 deletions(-)

diff --git a/drivers/staging/media/imx/imx8-isi-cap.c b/drivers/staging/media/imx/imx8-isi-cap.c
index 6f83ba47f919..22fc0e2896f8 100644
--- a/drivers/staging/media/imx/imx8-isi-cap.c
+++ b/drivers/staging/media/imx/imx8-isi-cap.c
@@ -54,7 +54,23 @@ struct mxc_isi_fmt mxc_isi_src_formats[] = {
 		.memplanes	= 1,
 		.colplanes	= 1,
 		.align		= 2,
-	}
+	},
+	{
+		.name		= "BGGR10",
+		.fourcc		= V4L2_PIX_FMT_SBGGR10,
+		.depth		= { 16 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+	},
+	{
+		.name		= "BGGR8",
+		.fourcc		= V4L2_PIX_FMT_SBGGR8,
+		.depth		= { 8 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+	},
 };
 
 struct mxc_isi_fmt *mxc_isi_get_format(unsigned int index)
@@ -99,6 +115,10 @@ struct mxc_isi_fmt *mxc_isi_get_src_fmt(struct v4l2_subdev_format *sd_fmt)
 	    sd_fmt->format.code == MEDIA_BUS_FMT_UYVY8_2X8 ||
 	    sd_fmt->format.code == MEDIA_BUS_FMT_YUYV8_2X8)
 		index = 1;
+	else if(sd_fmt->format.code == MEDIA_BUS_FMT_SBGGR10_1X10)
+		index = 2;
+	else if(sd_fmt->format.code == MEDIA_BUS_FMT_SBGGR8_1X8)
+		index = 3;
 	else
 		index = 0;
 	return &mxc_isi_src_formats[index];
@@ -119,6 +139,7 @@ static int mxc_isi_pipeline_enable(struct mxc_isi_cap_dev *isi_cap, bool enable)
 	struct media_device *mdev = entity->graph_obj.mdev;
 	struct media_graph graph;
 	struct v4l2_subdev *subdev;
+	struct v4l2_subdev *subdev_defer = NULL;
 	int ret = 0;
 
 	mutex_lock(&mdev->graph_mutex);
@@ -147,12 +168,25 @@ static int mxc_isi_pipeline_enable(struct mxc_isi_cap_dev *isi_cap, bool enable)
 			continue;
 		}
 
-		ret = v4l2_subdev_call(subdev, video, s_stream, enable);
+		if((strstr(subdev->entity.name, "ov13850") != NULL) ||
+			(strstr(subdev->entity.name, "ov13855") != NULL)) {
+			subdev_defer = subdev;
+		} else {
+			ret = v4l2_subdev_call(subdev, video, s_stream, enable);
+			if (ret < 0 && ret != -ENOIOCTLCMD) {
+				dev_err(dev, "subdev %s s_stream failed\n", subdev->name);
+				break;
+			}
+		}
+	}
+
+	if(subdev_defer) {
+		ret = v4l2_subdev_call(subdev_defer, video, s_stream, enable);
 		if (ret < 0 && ret != -ENOIOCTLCMD) {
-			dev_err(dev, "subdev %s s_stream failed\n", subdev->name);
-			break;
+			dev_err(dev, "subdev %s s_stream failed\n", subdev_defer->name);
 		}
 	}
+
 	mutex_unlock(&mdev->graph_mutex);
 	media_graph_walk_cleanup(&graph);
 
diff --git a/drivers/staging/media/imx/imx8-isi-fmt.c b/drivers/staging/media/imx/imx8-isi-fmt.c
index db11c809a3d3..505304b7bd1f 100644
--- a/drivers/staging/media/imx/imx8-isi-fmt.c
+++ b/drivers/staging/media/imx/imx8-isi-fmt.c
@@ -97,7 +97,27 @@ struct mxc_isi_fmt mxc_isi_out_formats[] = {
 		.colplanes	= 1,
 		.align		= 2,
 		.mbus_code	= MEDIA_BUS_FMT_RGB888_1X24,
-	}
+	},
+	{
+		.name		= "BGGR10",
+		.fourcc		= V4L2_PIX_FMT_SBGGR10,
+		.depth		= { 16 },
+		.color		= MXC_ISI_OUT_FMT_RAW10,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+		.mbus_code	= MEDIA_BUS_FMT_SBGGR10_1X10,
+	},
+	{
+		.name		= "BGGR8",
+		.fourcc		= V4L2_PIX_FMT_SBGGR8,
+		.depth		= { 8 },
+		.color		= MXC_ISI_OUT_FMT_RAW8,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+		.mbus_code	= MEDIA_BUS_FMT_SBGGR8_1X8,
+	},
 };
 
 size_t mxc_isi_out_formats_size = ARRAY_SIZE(mxc_isi_out_formats);
diff --git a/drivers/staging/media/imx/imx8-isi-hw.c b/drivers/staging/media/imx/imx8-isi-hw.c
index 193ff5c5fd33..a24c76a51c1d 100644
--- a/drivers/staging/media/imx/imx8-isi-hw.c
+++ b/drivers/staging/media/imx/imx8-isi-hw.c
@@ -653,6 +653,10 @@ void mxc_isi_channel_config(struct mxc_isi_dev *mxc_isi,
 	/*  Bypass channel */
 	if (!mxc_isi->cscen && !mxc_isi->scale)
 		val |= (CHNL_CTRL_CHNL_BYPASS_ENABLE << CHNL_CTRL_CHNL_BYPASS_OFFSET);
+	if ((mxc_isi->isi_cap->pix.pixelformat == V4L2_PIX_FMT_SBGGR10) ||
+		(mxc_isi->isi_cap->pix.pixelformat == V4L2_PIX_FMT_SBGGR8)) {
+		val |= (CHNL_CTRL_CHNL_BYPASS_ENABLE << CHNL_CTRL_CHNL_BYPASS_OFFSET);
+	}
 
 	writel(val, mxc_isi->regs + CHNL_CTRL);
 }
diff --git a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
index 1d12365520a6..b685dd02baeb 100644
--- a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
+++ b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
@@ -1138,6 +1138,7 @@ static int mipi_csis_set_fmt(struct v4l2_subdev *mipi_sd,
 
 	format->pad = source_pad->index;
 	mf->code = MEDIA_BUS_FMT_UYVY8_2X8;
+
 	ret = v4l2_subdev_call(sen_sd, pad, set_fmt, NULL, format);
 	if (ret < 0) {
 		v4l2_err(&state->sd, "%s, set sensor format fail\n", __func__);
@@ -1163,6 +1164,7 @@ static int mipi_csis_get_fmt(struct v4l2_subdev *mipi_sd,
 	struct v4l2_mbus_framefmt *mf = &state->format;
 	struct media_pad *source_pad;
 	struct v4l2_subdev *sen_sd;
+	struct csis_pix_format const *csis_fmt;
 	int ret;
 
 	/* Get remote source pad */
@@ -1187,6 +1189,14 @@ static int mipi_csis_get_fmt(struct v4l2_subdev *mipi_sd,
 	}
 
 	memcpy(mf, &format->format, sizeof(struct v4l2_mbus_framefmt));
+
+	csis_fmt = find_csis_format(mf->code);
+	if (!csis_fmt) {
+		csis_fmt = &mipi_csis_formats[0];
+		mf->code = csis_fmt->code;
+	}
+	state->csis_fmt = csis_fmt;
+
 	return 0;
 }
 
@@ -1293,6 +1303,9 @@ static int csis_s_fmt(struct v4l2_subdev *sd, struct csi_sam_format *fmt)
 	struct csi_state *state = container_of(sd, struct csi_state, sd);
 
 	switch (fmt->format) {
+	case V4L2_PIX_FMT_SBGGR8:
+	    code = MEDIA_BUS_FMT_SBGGR8_1X8;
+	    break;
 	case V4L2_PIX_FMT_SBGGR10:
 	    code = MEDIA_BUS_FMT_SBGGR10_1X10;
 	    break;
-- 
2.25.1

